/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/packs/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/javascript/packs/application.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/javascript/packs/application.js":
/*!*********************************************!*\
  !*** ./app/javascript/packs/application.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint no-console:0 */
// This file is automatically compiled by Webpack, along with any other files
// present in this directory. You're encouraged to place your actual application logic in
// a relevant structure within app/javascript and only use these pack files to reference
// that code so it'll be compiled.
//
// To reference this file, add <%= javascript_pack_tag 'application' %> to the appropriate
// layout file, like app/views/layouts/application.html.erb

__webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js");
__webpack_require__(/*! jquery-ui */ "./node_modules/jquery-ui/ui/widget.js");
__webpack_require__(/*! w2ui */ "./node_modules/w2ui/w2ui.js");
__webpack_require__(/*! chart */ "./node_modules/chart.js/dist/Chart.js");
__webpack_require__(/*! msa */ "./node_modules/msa/lib/index.js");
__webpack_require__(/*! biojs-io-fasta */ "./node_modules/biojs-io-fasta/lib/index.js");
__webpack_require__(/*! jsgrid */ "./node_modules/jsgrid/dist/jsgrid.js");
__webpack_require__(/*! expose-loader?$!jquery */ "./node_modules/expose-loader/index.js?$!./node_modules/jquery/src/jquery.js-exposed");
__webpack_require__(/*! expose-loader?jsgrid!jsgrid */ "./node_modules/expose-loader/index.js?jsgrid!./node_modules/jsgrid/dist/jsgrid.js-exposed");
__webpack_require__(/*! expose-loader?msa!msa */ "./node_modules/expose-loader/index.js?msa!./node_modules/msa/lib/index.js-exposed");
__webpack_require__(/*! expose-loader?fasta!biojs-io-fasta */ "./node_modules/expose-loader/index.js?fasta!./node_modules/biojs-io-fasta/lib/index.js-exposed");

// console.log('Hello World from Webpacker')

/***/ }),

/***/ "./node_modules/backbone-childs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/backbone-childs/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
var viewType = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
var pluginator;

/**
 * Remove an element and provide a function that inserts it into its original position
 * @param element {Element} The element to be temporarily removed
 * @return {Function} A function that inserts the element into its original position
 **/
function removeToInsertLater(element) {
  var parentNode = element.parentNode;
  var nextSibling = element.nextSibling;
  parentNode.removeChild(element);
  return function () {
    if (nextSibling) {
      parentNode.insertBefore(element, nextSibling);
    } else {
      parentNode.appendChild(element);
    }
  };
}
var removeChilds = function removeChilds(node) {
  var last;
  while (last = node.lastChild) node.removeChild(last);
};
module.exports = pluginator = viewType.extend({
  renderSubviews: function renderSubviews() {
    // it is faster to remove the entire element and replace it
    // -> however this will lead to lost id,class and style props
    var oldEl = this.el;

    // it might be that the element is not on the DOM yet
    var elOnDom = oldEl.parentNode != undefined;
    if (elOnDom) {
      var insert = removeToInsertLater(oldEl);
    }
    removeChilds(oldEl);
    var frag = document.createDocumentFragment();
    var views = this._views();
    var viewsSorted = _.sortBy(views, function (el) {
      return el.ordering;
    });
    var view, node;
    for (var i = 0; i < viewsSorted.length; i++) {
      view = viewsSorted[i];
      view.render();
      node = view.el;
      if (node != null) {
        frag.appendChild(node);
      }
    }
    oldEl.appendChild(frag);
    if (elOnDom) {
      insert();
    }
    return oldEl;
  },
  addView: function addView(key, view) {
    var views = this._views();
    if (view == null) {
      throw "Invalid plugin. ";
    }
    if (view.ordering == null) {
      view.ordering = key;
    }
    return views[key] = view;
  },
  removeViews: function removeViews() {
    var el, key;
    var views = this._views();
    for (key in views) {
      el = views[key];
      el.undelegateEvents();
      el.unbind();
      if (el.removeViews != null) {
        el.removeViews();
      }
      el.remove();
    }
    return this.views = {};
  },
  removeView: function removeView(key) {
    var views = this._views();
    views[key].remove();
    return delete views[key];
  },
  getView: function getView(key) {
    var views = this._views();
    return views[key];
  },
  remove: function remove() {
    this.removeViews();
    return viewType.prototype.remove.apply(this);
  },
  _views: function _views() {
    if (this.views == null) {
      this.views = {};
    }
    return this.views;
  }
});

/***/ }),

/***/ "./node_modules/backbone-events-standalone/backbone-events-standalone.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/backbone-events-standalone/backbone-events-standalone.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function () {
  var root = this,
    nativeForEach = Array.prototype.forEach,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    slice = Array.prototype.slice,
    idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (_typeof(obj) !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key,
          keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },
      uniqueId: function uniqueId(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },
      has: function has(obj, key) {
        return hasOwnProperty.call(obj, key);
      },
      each: function each(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      },
      once: function once(func) {
        var ran = false,
          memo;
        return function () {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }
  var _ = miniscore(),
    Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function on(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({
        callback: callback,
        context: context,
        ctx: context || this
      });
      return this;
    },
    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function once(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function () {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },
    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function off(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }
      return this;
    },
    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function trigger(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },
    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function stopListening(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (_typeof(name) === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }
  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function eventsApi(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (_typeof(name) === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }
    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function triggerEvents(events, args) {
    var ev,
      i = -1,
      l = events.length,
      a1 = args[0],
      a2 = args[1],
      a3 = args[2];
    switch (args.length) {
      case 0:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx);
        return;
      case 1:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
        return;
      case 2:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
        return;
      case 3:
        while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
        return;
      default:
        while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };
  var listenMethods = {
    listenTo: 'on',
    listenToOnce: 'once'
  };

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function (implementation, method) {
    Events[method] = function (obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (_typeof(name) === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function (proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo', 'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function (name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (true) {
    if ( true && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/backbone-events-standalone/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/backbone-events-standalone/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./backbone-events-standalone */ "./node_modules/backbone-events-standalone/backbone-events-standalone.js");

/***/ }),

/***/ "./node_modules/backbone-extend-standalone/backbone-extend-standalone.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/backbone-extend-standalone/backbone-extend-standalone.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (definition) {
  if (( false ? undefined : _typeof(exports)) === "object") {
    module.exports = definition();
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function () {
  "use strict";

  // mini-underscore
  var _ = {
    has: function has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    },
    extend: function extend(obj) {
      for (var i = 1; i < arguments.length; ++i) {
        var source = arguments[i];
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      }
      return obj;
    }
  };

  /// Following code is pasted from Backbone.js ///

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function extend(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function child() {
        return parent.apply(this, arguments);
      };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function Surrogate() {
      this.constructor = child;
    };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;
    return child;
  };

  // Expose the extend function
  return extend;
});

/***/ }),

/***/ "./node_modules/backbone-thin/collection.js":
/*!**************************************************!*\
  !*** ./node_modules/backbone-thin/collection.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

var Events = __webpack_require__(/*! backbone-events-standalone */ "./node_modules/backbone-events-standalone/index.js");
var extend = __webpack_require__(/*! backbone-extend-standalone */ "./node_modules/backbone-extend-standalone/backbone-extend-standalone.js");
var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
var Model = __webpack_require__(/*! ./model */ "./node_modules/backbone-thin/model.js");

// Create local references to array methods we'll want to use later.
var array = [];
var _slice = array.slice;

// Backbone.Collection
// -------------------

// If models tend to represent a single row of data, a Backbone Collection is
// more analogous to a table full of data ... or a small slice or page of that
// table, or a collection of rows that belong together for a particular reason
// -- all of the messages in this particular folder, all of the documents
// belonging to this particular author, and so on. Collections maintain
// indexes of their models, both in order, and for lookup by `id`.

// Create a new **Collection**, perhaps to contain a specific type of `model`.
// If a `comparator` is specified, the Collection will maintain
// its models in sort order, as they're added and removed.
var Collection = function Collection(models, options) {
  options || (options = {});
  if (options.model) this.model = options.model;
  if (options.comparator !== void 0) this.comparator = options.comparator;
  this._reset();
  this.initialize.apply(this, arguments);
  if (models) this.reset(models, _.extend({
    silent: true
  }, options));
};

// Default options for `Collection#set`.
var setOptions = {
  add: true,
  remove: true,
  merge: true
};
var addOptions = {
  add: true,
  remove: false
};

// Define the Collection's inheritable methods.
_.extend(Collection.prototype, Events, {
  // The default model for a collection is just a **Backbone.Model**.
  // This should be overridden in most cases.
  model: Model,
  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function initialize() {},
  // The JSON representation of a Collection is an array of the
  // models' attributes.
  toJSON: function toJSON(options) {
    return this.map(function (model) {
      return model.toJSON(options);
    });
  },
  // Proxy `Backbone.sync` by default.
  sync: function sync() {
    return Backbone.sync.apply(this, arguments);
  },
  // Add a model, or list of models to the set.
  add: function add(models, options) {
    return this.set(models, _.extend({
      merge: false
    }, options, addOptions));
  },
  // Remove a model, or a list of models from the set.
  remove: function remove(models, options) {
    var singular = !_.isArray(models);
    models = singular ? [models] : _.clone(models);
    options || (options = {});
    for (var i = 0, length = models.length; i < length; i++) {
      var model = models[i] = this.get(models[i]);
      if (!model) continue;
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      delete this._byId[model.cid];
      var index = this.indexOf(model);
      this.models.splice(index, 1);
      this.length--;
      if (!options.silent) {
        options.index = index;
        model.trigger('remove', model, this, options);
      }
      this._removeReference(model, options);
    }
    return singular ? models[0] : models;
  },
  // Update a collection by `set`-ing a new list of models, adding new ones,
  // removing models that are no longer present, and merging models that
  // already exist in the collection, as necessary. Similar to **Model#set**,
  // the core operation for updating the data contained by the collection.
  set: function set(models, options) {
    options = _.defaults({}, options, setOptions);
    if (options.parse) models = this.parse(models, options);
    var singular = !_.isArray(models);
    models = singular ? models ? [models] : [] : models.slice();
    var id, model, attrs, existing, sort;
    var at = options.at;
    var sortable = this.comparator && at == null && options.sort !== false;
    var sortAttr = _.isString(this.comparator) ? this.comparator : null;
    var toAdd = [],
      toRemove = [],
      modelMap = {};
    var add = options.add,
      merge = options.merge,
      remove = options.remove;
    var order = !sortable && add && remove ? [] : false;

    // Turn bare objects into model references, and prevent invalid models
    // from being added.
    for (var i = 0, length = models.length; i < length; i++) {
      attrs = models[i];

      // If a duplicate is found, prevent it from being added and
      // optionally merge it into the existing model.
      if (existing = this.get(attrs)) {
        if (remove) modelMap[existing.cid] = true;
        if (merge && attrs !== existing) {
          attrs = this._isModel(attrs) ? attrs.attributes : attrs;
          if (options.parse) attrs = existing.parse(attrs, options);
          existing.set(attrs, options);
          if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
        }
        models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
      } else if (add) {
        model = models[i] = this._prepareModel(attrs, options);
        if (!model) continue;
        toAdd.push(model);
        this._addReference(model, options);
      }

      // Do not add multiple models with the same `id`.
      model = existing || model;
      if (!model) continue;
      id = this.modelId(model.attributes);
      if (order && (model.isNew() || !modelMap[id])) order.push(model);
      modelMap[id] = true;
    }

    // Remove nonexistent models if appropriate.
    if (remove) {
      for (var i = 0, length = this.length; i < length; i++) {
        if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
      }
      if (toRemove.length) this.remove(toRemove, options);
    }

    // See if sorting is needed, update `length` and splice in new models.
    if (toAdd.length || order && order.length) {
      if (sortable) sort = true;
      this.length += toAdd.length;
      if (at != null) {
        for (var i = 0, length = toAdd.length; i < length; i++) {
          this.models.splice(at + i, 0, toAdd[i]);
        }
      } else {
        if (order) this.models.length = 0;
        var orderedModels = order || toAdd;
        for (var i = 0, length = orderedModels.length; i < length; i++) {
          this.models.push(orderedModels[i]);
        }
      }
    }

    // Silently sort the collection if appropriate.
    if (sort) this.sort({
      silent: true
    });

    // Unless silenced, it's time to fire all appropriate add/sort events.
    if (!options.silent) {
      var addOpts = at != null ? _.clone(options) : options;
      for (var i = 0, length = toAdd.length; i < length; i++) {
        if (at != null) addOpts.index = at + i;
        (model = toAdd[i]).trigger('add', model, this, addOpts);
      }
      if (sort || order && order.length) this.trigger('sort', this, options);
    }

    // Return the added (or merged) model (or models).
    return singular ? models[0] : models;
  },
  // When you have more items than you want to add or remove individually,
  // you can reset the entire set with a new list of models, without firing
  // any granular `add` or `remove` events. Fires `reset` when finished.
  // Useful for bulk operations and optimizations.
  reset: function reset(models, options) {
    options || (options = {});
    for (var i = 0, length = this.models.length; i < length; i++) {
      this._removeReference(this.models[i], options);
    }
    options.previousModels = this.models;
    this._reset();
    models = this.add(models, _.extend({
      silent: true
    }, options));
    if (!options.silent) this.trigger('reset', this, options);
    return models;
  },
  // Add a model to the end of the collection.
  push: function push(model, options) {
    return this.add(model, _.extend({
      at: this.length
    }, options));
  },
  // Remove a model from the end of the collection.
  pop: function pop(options) {
    var model = this.at(this.length - 1);
    this.remove(model, options);
    return model;
  },
  // Add a model to the beginning of the collection.
  unshift: function unshift(model, options) {
    return this.add(model, _.extend({
      at: 0
    }, options));
  },
  // Remove a model from the beginning of the collection.
  shift: function shift(options) {
    var model = this.at(0);
    this.remove(model, options);
    return model;
  },
  // Slice out a sub-array of models from the collection.
  slice: function slice() {
    return _slice.apply(this.models, arguments);
  },
  // Get a model from the set by id.
  get: function get(obj) {
    if (obj == null) return void 0;
    var id = this.modelId(this._isModel(obj) ? obj.attributes : obj);
    return this._byId[obj] || this._byId[id] || this._byId[obj.cid];
  },
  // Get the model at the given index.
  at: function at(index) {
    if (index < 0) index += this.length;
    return this.models[index];
  },
  // Return models with matching attributes. Useful for simple cases of
  // `filter`.
  where: function where(attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return this[first ? 'find' : 'filter'](function (model) {
      for (var key in attrs) {
        if (attrs[key] !== model.get(key)) return false;
      }
      return true;
    });
  },
  // Return the first model with matching attributes. Useful for simple cases
  // of `find`.
  findWhere: function findWhere(attrs) {
    return this.where(attrs, true);
  },
  // Force the collection to re-sort itself. You don't need to call this under
  // normal circumstances, as the set will maintain sort order as each item
  // is added.
  sort: function sort(options) {
    if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
    options || (options = {});

    // Run sort based on type of `comparator`.
    if (_.isString(this.comparator) || this.comparator.length === 1) {
      this.models = this.sortBy(this.comparator, this);
    } else {
      this.models.sort(_.bind(this.comparator, this));
    }
    if (!options.silent) this.trigger('sort', this, options);
    return this;
  },
  // Pluck an attribute from each model in the collection.
  pluck: function pluck(attr) {
    return _.invoke(this.models, 'get', attr);
  },
  // Fetch the default set of models for this collection, resetting the
  // collection when they arrive. If `reset: true` is passed, the response
  // data will be passed through the `reset` method instead of `set`.
  fetch: function fetch(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var success = options.success;
    var collection = this;
    options.success = function (resp) {
      var method = options.reset ? 'reset' : 'set';
      collection[method](resp, options);
      if (success) success(collection, resp, options);
      collection.trigger('sync', collection, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },
  // Create a new instance of a model in this collection. Add the model to the
  // collection immediately, unless `wait: true` is passed, in which case we
  // wait for the server to agree.
  create: function create(model, options) {
    options = options ? _.clone(options) : {};
    if (!(model = this._prepareModel(model, options))) return false;
    if (!options.wait) this.add(model, options);
    var collection = this;
    var success = options.success;
    options.success = function (model, resp) {
      if (options.wait) collection.add(model, options);
      if (success) success(model, resp, options);
    };
    model.save(null, options);
    return model;
  },
  // **parse** converts a response into a list of models to be added to the
  // collection. The default implementation is just to pass it through.
  parse: function parse(resp, options) {
    return resp;
  },
  // Create a new collection with an identical list of models as this one.
  clone: function clone() {
    return new this.constructor(this.models, {
      model: this.model,
      comparator: this.comparator
    });
  },
  // Define how to uniquely identify models in the collection.
  modelId: function modelId(attrs) {
    return attrs[this.model.prototype.idAttribute || 'id'];
  },
  // Private method to reset all internal state. Called when the collection
  // is first initialized or reset.
  _reset: function _reset() {
    this.length = 0;
    this.models = [];
    this._byId = {};
  },
  // Prepare a hash of attributes (or other model) to be added to this
  // collection.
  _prepareModel: function _prepareModel(attrs, options) {
    if (this._isModel(attrs)) {
      if (!attrs.collection) attrs.collection = this;
      return attrs;
    }
    options = options ? _.clone(options) : {};
    options.collection = this;
    var model = new this.model(attrs, options);
    if (!model.validationError) return model;
    this.trigger('invalid', this, model.validationError, options);
    return false;
  },
  // Method for checking whether an object should be considered a model for
  // the purposes of adding to the collection.
  _isModel: function _isModel(model) {
    return model instanceof Model;
  },
  // Internal method to create a model's ties to a collection.
  _addReference: function _addReference(model, options) {
    this._byId[model.cid] = model;
    var id = this.modelId(model.attributes);
    if (id != null) this._byId[id] = model;
    model.on('all', this._onModelEvent, this);
  },
  // Internal method to sever a model's ties to a collection.
  _removeReference: function _removeReference(model, options) {
    if (this === model.collection) delete model.collection;
    model.off('all', this._onModelEvent, this);
  },
  // Internal method called every time a model in the set fires an event.
  // Sets need to update their indexes when models change ids. All other
  // events simply proxy through. "add" and "remove" events that originate
  // in other collections are ignored.
  _onModelEvent: function _onModelEvent(event, model, collection, options) {
    if ((event === 'add' || event === 'remove') && collection !== this) return;
    if (event === 'destroy') this.remove(model, options);
    if (event === 'change') {
      var prevId = this.modelId(model.previousAttributes());
      var id = this.modelId(model.attributes);
      if (prevId !== id) {
        if (prevId != null) delete this._byId[prevId];
        if (id != null) this._byId[id] = model;
      }
    }
    this.trigger.apply(this, arguments);
  }
});

// Underscore methods that we want to implement on the Collection.
// 90% of the core usefulness of Backbone Collections is actually implemented
// right here:
var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest', 'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain', 'sample', 'partition'];

// Mix in each Underscore method as a proxy to `Collection#models`.
_.each(methods, function (method) {
  if (!_[method]) return;
  Collection.prototype[method] = function () {
    var args = _slice.call(arguments);
    args.unshift(this.models);
    return _[method].apply(_, args);
  };
});

// Underscore methods that take a property name as an argument.
var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

// Use attributes instead of properties.
_.each(attributeMethods, function (method) {
  if (!_[method]) return;
  Collection.prototype[method] = function (value, context) {
    var iterator = _.isFunction(value) ? value : function (model) {
      return model.get(value);
    };
    return _[method](this.models, iterator, context);
  };
});

// setup inheritance
Collection.extend = extend;
module.exports = Collection;

/***/ }),

/***/ "./node_modules/backbone-thin/index.js":
/*!*********************************************!*\
  !*** ./node_modules/backbone-thin/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports.Model = __webpack_require__(/*! ./model */ "./node_modules/backbone-thin/model.js");
module.exports.Collection = __webpack_require__(/*! ./collection */ "./node_modules/backbone-thin/collection.js");
module.exports.Events = __webpack_require__(/*! backbone-events-standalone */ "./node_modules/backbone-events-standalone/index.js");
module.exports.extend = __webpack_require__(/*! backbone-extend-standalone */ "./node_modules/backbone-extend-standalone/backbone-extend-standalone.js");

/***/ }),

/***/ "./node_modules/backbone-thin/model.js":
/*!*********************************************!*\
  !*** ./node_modules/backbone-thin/model.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

var Events = __webpack_require__(/*! backbone-events-standalone */ "./node_modules/backbone-events-standalone/index.js");
var extend = __webpack_require__(/*! backbone-extend-standalone */ "./node_modules/backbone-extend-standalone/backbone-extend-standalone.js");
var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");

// Backbone.Model
// --------------

// Backbone **Models** are the basic data object in the framework --
// frequently representing a row in a table in a database on your server.
// A discrete chunk of data and a bunch of useful, related methods for
// performing computations and transformations on that data.

// Create a new model with the specified attributes. A client id (`cid`)
// is automatically generated and assigned for you.
var Model = function Model(attributes, options) {
  var attrs = attributes || {};
  options || (options = {});
  this.cid = _.uniqueId('c');
  this.attributes = {};
  if (options.collection) this.collection = options.collection;
  if (options.parse) attrs = this.parse(attrs, options) || {};
  attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
  this.set(attrs, options);
  this.changed = {};
  this.initialize.apply(this, arguments);
};

// Attach all inheritable methods to the Model prototype.
_.extend(Model.prototype, Events, {
  // A hash of attributes whose current and previous value differ.
  changed: null,
  // The value returned during the last failed validation.
  validationError: null,
  // The default name for the JSON `id` attribute is `"id"`. MongoDB and
  // CouchDB users may want to set this to `"_id"`.
  idAttribute: 'id',
  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function initialize() {},
  // Return a copy of the model's `attributes` object.
  toJSON: function toJSON(options) {
    return _.clone(this.attributes);
  },
  // Proxy `Backbone.sync` by default -- but override this if you need
  // custom syncing semantics for *this* particular model.
  sync: function sync() {
    return Backbone.sync.apply(this, arguments);
  },
  // Get the value of an attribute.
  get: function get(attr) {
    return this.attributes[attr];
  },
  // Get the HTML-escaped value of an attribute.
  escape: function escape(attr) {
    return _.escape(this.get(attr));
  },
  // Returns `true` if the attribute contains a value that is not null
  // or undefined.
  has: function has(attr) {
    return this.get(attr) != null;
  },
  // Set a hash of model attributes on the object, firing `"change"`. This is
  // the core primitive operation of a model, updating the data and notifying
  // anyone who needs to know about the change in state. The heart of the beast.
  set: function set(key, val, options) {
    var attr, attrs, unset, changes, silent, changing, prev, current;
    if (key == null) return this;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (_typeof(key) === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }
    options || (options = {});

    // Run validation.
    if (!this._validate(attrs, options)) return false;

    // Extract attributes and options.
    unset = options.unset;
    silent = options.silent;
    changes = [];
    changing = this._changing;
    this._changing = true;
    if (!changing) {
      this._previousAttributes = _.clone(this.attributes);
      this.changed = {};
    }
    current = this.attributes, prev = this._previousAttributes;

    // Check for changes of `id`.
    if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

    // For each `set` attribute, update or delete the current value.
    for (attr in attrs) {
      val = attrs[attr];
      if (!_.isEqual(current[attr], val)) changes.push(attr);
      if (!_.isEqual(prev[attr], val)) {
        this.changed[attr] = val;
      } else {
        delete this.changed[attr];
      }
      unset ? delete current[attr] : current[attr] = val;
    }

    // Trigger all relevant attribute changes.
    if (!silent) {
      if (changes.length) this._pending = options;
      for (var i = 0, length = changes.length; i < length; i++) {
        this.trigger('change:' + changes[i], this, current[changes[i]], options);
      }
    }

    // You might be wondering why there's a `while` loop here. Changes can
    // be recursively nested within `"change"` events.
    if (changing) return this;
    if (!silent) {
      while (this._pending) {
        options = this._pending;
        this._pending = false;
        this.trigger('change', this, options);
      }
    }
    this._pending = false;
    this._changing = false;
    return this;
  },
  // Remove an attribute from the model, firing `"change"`. `unset` is a noop
  // if the attribute doesn't exist.
  unset: function unset(attr, options) {
    return this.set(attr, void 0, _.extend({}, options, {
      unset: true
    }));
  },
  // Clear all attributes on the model, firing `"change"`.
  clear: function clear(options) {
    var attrs = {};
    for (var key in this.attributes) attrs[key] = void 0;
    return this.set(attrs, _.extend({}, options, {
      unset: true
    }));
  },
  // Determine if the model has changed since the last `"change"` event.
  // If you specify an attribute name, determine if that attribute has changed.
  hasChanged: function hasChanged(attr) {
    if (attr == null) return !_.isEmpty(this.changed);
    return _.has(this.changed, attr);
  },
  // Return an object containing all the attributes that have changed, or
  // false if there are no changed attributes. Useful for determining what
  // parts of a view need to be updated and/or what attributes need to be
  // persisted to the server. Unset attributes will be set to undefined.
  // You can also pass an attributes object to diff against the model,
  // determining if there *would be* a change.
  changedAttributes: function changedAttributes(diff) {
    if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
    var val,
      changed = false;
    var old = this._changing ? this._previousAttributes : this.attributes;
    for (var attr in diff) {
      if (_.isEqual(old[attr], val = diff[attr])) continue;
      (changed || (changed = {}))[attr] = val;
    }
    return changed;
  },
  // Get the previous value of an attribute, recorded at the time the last
  // `"change"` event was fired.
  previous: function previous(attr) {
    if (attr == null || !this._previousAttributes) return null;
    return this._previousAttributes[attr];
  },
  // Get all of the attributes of the model at the time of the previous
  // `"change"` event.
  previousAttributes: function previousAttributes() {
    return _.clone(this._previousAttributes);
  },
  // Fetch the model from the server. If the server's representation of the
  // model differs from its current attributes, they will be overridden,
  // triggering a `"change"` event.
  fetch: function fetch(options) {
    options = options ? _.clone(options) : {};
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function (resp) {
      if (!model.set(model.parse(resp, options), options)) return false;
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);
    return this.sync('read', this, options);
  },
  // Set a hash of model attributes, and sync the model to the server.
  // If the server returns an attributes hash that differs, the model's
  // state will be `set` again.
  save: function save(key, val, options) {
    var attrs,
      method,
      xhr,
      attributes = this.attributes;

    // Handle both `"key", value` and `{key: value}` -style arguments.
    if (key == null || _typeof(key) === 'object') {
      attrs = key;
      options = val;
    } else {
      (attrs = {})[key] = val;
    }
    options = _.extend({
      validate: true
    }, options);

    // If we're not waiting and attributes exist, save acts as
    // `set(attr).save(null, opts)` with validation. Otherwise, check if
    // the model will be valid when the attributes, if any, are set.
    if (attrs && !options.wait) {
      if (!this.set(attrs, options)) return false;
    } else {
      if (!this._validate(attrs, options)) return false;
    }

    // Set temporary attributes if `{wait: true}`.
    if (attrs && options.wait) {
      this.attributes = _.extend({}, attributes, attrs);
    }

    // After a successful server-side save, the client is (optionally)
    // updated with the server-side state.
    if (options.parse === void 0) options.parse = true;
    var model = this;
    var success = options.success;
    options.success = function (resp) {
      // Ensure attributes are restored during synchronous saves.
      model.attributes = attributes;
      var serverAttrs = model.parse(resp, options);
      if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
      if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
        return false;
      }
      if (success) success(model, resp, options);
      model.trigger('sync', model, resp, options);
    };
    wrapError(this, options);
    method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
    if (method === 'patch' && !options.attrs) options.attrs = attrs;
    xhr = this.sync(method, this, options);

    // Restore attributes.
    if (attrs && options.wait) this.attributes = attributes;
    return xhr;
  },
  // Destroy this model on the server if it was already persisted.
  // Optimistically removes the model from its collection, if it has one.
  // If `wait: true` is passed, waits for the server to respond before removal.
  destroy: function destroy(options) {
    options = options ? _.clone(options) : {};
    var model = this;
    var success = options.success;
    var destroy = function destroy() {
      model.stopListening();
      model.trigger('destroy', model, model.collection, options);
    };
    options.success = function (resp) {
      if (options.wait || model.isNew()) destroy();
      if (success) success(model, resp, options);
      if (!model.isNew()) model.trigger('sync', model, resp, options);
    };
    if (this.isNew()) {
      options.success();
      return false;
    }
    wrapError(this, options);
    var xhr = this.sync('delete', this, options);
    if (!options.wait) destroy();
    return xhr;
  },
  // Default URL for the model's representation on the server -- if you're
  // using Backbone's restful methods, override this to change the endpoint
  // that will be called.
  url: function url() {
    var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
    if (this.isNew()) return base;
    return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
  },
  // **parse** converts a response into the hash of attributes to be `set` on
  // the model. The default implementation is just to pass the response along.
  parse: function parse(resp, options) {
    return resp;
  },
  // Create a new model with identical attributes to this one.
  clone: function clone() {
    return new this.constructor(this.attributes);
  },
  // A model is new if it has never been saved to the server, and lacks an id.
  isNew: function isNew() {
    return !this.has(this.idAttribute);
  },
  // Check if the model is currently in a valid state.
  isValid: function isValid(options) {
    return this._validate({}, _.extend(options || {}, {
      validate: true
    }));
  },
  // Run validation against the next complete set of model attributes,
  // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
  _validate: function _validate(attrs, options) {
    if (!options.validate || !this.validate) return true;
    attrs = _.extend({}, this.attributes, attrs);
    var error = this.validationError = this.validate(attrs, options) || null;
    if (!error) return true;
    this.trigger('invalid', this, error, _.extend(options, {
      validationError: error
    }));
    return false;
  }
});

// Underscore methods that we want to implement on the Model.
var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit', 'chain', 'isEmpty'];

// Mix in each Underscore method as a proxy to `Model#attributes`.
_.each(modelMethods, function (method) {
  if (!_[method]) return;
  Model.prototype[method] = function () {
    var args = slice.call(arguments);
    args.unshift(this.attributes);
    return _[method].apply(_, args);
  };
});

// setup inheritance
Model.extend = extend;
module.exports = Model;

/***/ }),

/***/ "./node_modules/backbone-viewj/index.js":
/*!**********************************************!*\
  !*** ./node_modules/backbone-viewj/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this is the extracted view model from backbone
// note that we inject jbone as jquery replacment
// (and underscore directly)
//
// Views are almost more convention than they are actual code.
//  MVC pattern
// Backbone.View
// -------------

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
var Events = __webpack_require__(/*! backbone-events-standalone */ "./node_modules/backbone-events-standalone/index.js");
var extend = __webpack_require__(/*! backbone-extend-standalone */ "./node_modules/backbone-extend-standalone/backbone-extend-standalone.js");
var $ = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");

// Backbone Views are almost more convention than they are actual code. A View
// is simply a JavaScript object that represents a logical chunk of UI in the
// DOM. This might be a single item, an entire list, a sidebar or panel, or
// even the surrounding frame which wraps your whole app. Defining a chunk of
// UI as a **View** allows you to define your DOM events declaratively, without
// having to worry about render order ... and makes it easy for the view to
// react to specific changes in the state of your models.

// Creating a Backbone.View creates its initial element outside of the DOM,
// if an existing element is not provided...
var View = function View(options) {
  this.cid = _.uniqueId('view');
  options || (options = {});
  _.extend(this, _.pick(options, viewOptions));
  this._ensureElement();
  this.initialize.apply(this, arguments);
};

// Cached regex to split keys for `delegate`.
var delegateEventSplitter = /^(\S+)\s*(.*)$/;

// List of view options to be merged as properties.
var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

// Set up all inheritable **Backbone.View** properties and methods.
_.extend(View.prototype, Events, {
  // The default `tagName` of a View's element is `"div"`.
  tagName: 'div',
  // jQuery delegate for element lookup, scoped to DOM elements within the
  // current view. This should be preferred to global lookups where possible.
  $: function $(selector) {
    return this.$el.find(selector);
  },
  // Initialize is an empty function by default. Override it with your own
  // initialization logic.
  initialize: function initialize() {},
  // **render** is the core function that your view should override, in order
  // to populate its element (`this.el`), with the appropriate HTML. The
  // convention is for **render** to always return `this`.
  render: function render() {
    return this;
  },
  // Remove this view by taking the element out of the DOM, and removing any
  // applicable Backbone.Events listeners.
  remove: function remove() {
    this._removeElement();
    this.stopListening();
    return this;
  },
  // Remove this view's element from the document and all event listeners
  // attached to it. Exposed for subclasses using an alternative DOM
  // manipulation API.
  _removeElement: function _removeElement() {
    this.$el.remove();
  },
  // Change the view's element (`this.el` property) and re-delegate the
  // view's events on the new element.
  setElement: function setElement(element) {
    this.undelegateEvents();
    this._setElement(element);
    this.delegateEvents();
    return this;
  },
  // Creates the `this.el` and `this.$el` references for this view using the
  // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
  // context or an element. Subclasses can override this to utilize an
  // alternative DOM manipulation API and are only required to set the
  // `this.el` property.
  _setElement: function _setElement(el) {
    this.$el = el instanceof $ ? el : $(el);
    this.el = this.$el[0];
  },
  // Set callbacks, where `this.events` is a hash of
  //
  // *{"event selector": "callback"}*
  //
  //     {
  //       'mousedown .title':  'edit',
  //       'click .button':     'save',
  //       'click .open':       function(e) { ... }
  //     }
  //
  // pairs. Callbacks will be bound to the view, with `this` set properly.
  // Uses event delegation for efficiency.
  // Omitting the selector binds the event to `this.el`.
  delegateEvents: function delegateEvents(events) {
    if (!(events || (events = _.result(this, 'events')))) return this;
    this.undelegateEvents();
    for (var key in events) {
      var method = events[key];
      if (!_.isFunction(method)) method = this[events[key]];
      if (!method) continue;
      var match = key.match(delegateEventSplitter);
      this.delegate(match[1], match[2], _.bind(method, this));
    }
    return this;
  },
  // Add a single event listener to the view's element (or a child element
  // using `selector`). This only works for delegate-able events: not `focus`,
  // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
  delegate: function delegate(eventName, selector, listener) {
    this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
  },
  // Clears all callbacks previously bound to the view by `delegateEvents`.
  // You usually don't need to use this, but may wish to if you have multiple
  // Backbone views attached to the same DOM element.
  undelegateEvents: function undelegateEvents() {
    if (this.$el) this.$el.off('.delegateEvents' + this.cid);
    return this;
  },
  // A finer-grained `undelegateEvents` for removing a single delegated event.
  // `selector` and `listener` are both optional.
  undelegate: function undelegate(eventName, selector, listener) {
    this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
  },
  // Produces a DOM element to be assigned to your view. Exposed for
  // subclasses using an alternative DOM manipulation API.
  _createElement: function _createElement(tagName) {
    return document.createElement(tagName);
  },
  // Ensure that the View has a DOM element to render into.
  // If `this.el` is a string, pass it through `$()`, take the first
  // matching element, and re-assign it to `el`. Otherwise, create
  // an element from the `id`, `className` and `tagName` properties.
  _ensureElement: function _ensureElement() {
    if (!this.el) {
      var attrs = _.extend({}, _.result(this, 'attributes'));
      if (this.id) attrs.id = _.result(this, 'id');
      if (this.className) attrs['class'] = _.result(this, 'className');
      this.setElement(this._createElement(_.result(this, 'tagName')));
      this._setAttributes(attrs);
    } else {
      this.setElement(_.result(this, 'el'));
    }
  },
  // Set attributes from a hash on this view's element.  Exposed for
  // subclasses using an alternative DOM manipulation API.
  _setAttributes: function _setAttributes(attributes) {
    this.$el.attr(attributes);
  }
});

// setup inheritance
View.extend = extend;
module.exports = View;

/***/ }),

/***/ "./node_modules/biojs-events/index.js":
/*!********************************************!*\
  !*** ./node_modules/biojs-events/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var events = __webpack_require__(/*! backbone-events-standalone */ "./node_modules/backbone-events-standalone/index.js");
events.onAll = function (callback, context) {
  this.on("all", callback, context);
  return this;
};

// Mixin utility
events.oldMixin = events.mixin;
events.mixin = function (proto) {
  events.oldMixin(proto);
  // add custom onAll
  var exports = ['onAll'];
  for (var i = 0; i < exports.length; i++) {
    var name = exports[i];
    proto[name] = this[name];
  }
  return proto;
};
module.exports = events;

/***/ }),

/***/ "./node_modules/biojs-io-clustal/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/biojs-io-clustal/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.8.0
var Clustal, GenericReader, st;
GenericReader = __webpack_require__(/*! biojs-io-parser */ "./node_modules/biojs-io-parser/lib/index.js");
st = __webpack_require__(/*! msa-seqtools */ "./node_modules/msa-seqtools/lib/index.js");
module.exports = Clustal = {
  parse: function parse(text) {
    var blockstate, cSeq, k, keys, label, line, lines, match, obj, regex, seqCounter, seqs, sequence;
    seqs = [];
    if (Object.prototype.toString.call(text) === '[object Array]') {
      lines = text;
    } else {
      lines = text.split("\n");
    }
    if (lines[0].slice(0, 6) === !"CLUSTAL") {
      throw new Error("Invalid CLUSTAL Header");
    }
    k = 0;
    blockstate = 1;
    seqCounter = 0;
    while (k < lines.length) {
      k++;
      line = lines[k];
      if (line == null || line.length === 0) {
        blockstate = 1;
        continue;
      }
      if (line.trim().length === 0) {
        blockstate = 1;
        continue;
      } else {
        if (st.contains(line, "*")) {
          continue;
        }
        if (blockstate === 1) {
          seqCounter = 0;
          blockstate = 0;
        }
        regex = /^(?:\s*)(\S+)(?:\s+)(\S+)(?:\s*)(\d*)(?:\s*|$)/g;
        match = regex.exec(line);
        if (match != null) {
          label = match[1];
          sequence = match[2];
          if (seqCounter >= seqs.length) {
            obj = st.getMeta(label);
            label = obj.name;
            cSeq = new st.model(sequence, label, seqCounter);
            cSeq.ids = obj.ids || {};
            cSeq.details = obj.details || {};
            keys = Object.keys(cSeq.ids);
            if (keys.length > 0) {
              cSeq.id = cSeq.ids[keys[0]];
            }
            seqs.push(cSeq);
          } else {
            seqs[seqCounter].seq += sequence;
          }
          seqCounter++;
        } else {
          console.log("parse error", line);
        }
      }
    }
    return seqs;
  }
};
GenericReader.mixin(Clustal);

/***/ }),

/***/ "./node_modules/biojs-io-fasta/lib/extend.js":
/*!***************************************************!*\
  !*** ./node_modules/biojs-io-fasta/lib/extend.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.9.0
module.exports = function (out) {
  var i, key, _i, _j, _len, _ref, _ref1;
  out = out || {};
  for (i = _i = 0, _ref = arguments.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    if (!arguments[i]) {
      continue;
    }
    _ref1 = arguments[i];
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      key = _ref1[_j];
      if (arguments[i].hasOwnProperty(key)) {
        out[key] = arguments[i][key];
      }
    }
  }
  return out;
};

/***/ }),

/***/ "./node_modules/biojs-io-fasta/lib/fasta.js":
/*!**************************************************!*\
  !*** ./node_modules/biojs-io-fasta/lib/fasta.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.0
var Fasta, _extend, st;
st = __webpack_require__(/*! msa-seqtools */ "./node_modules/msa-seqtools/lib/index.js");
_extend = __webpack_require__(/*! ./extend */ "./node_modules/biojs-io-fasta/lib/extend.js");
module.exports = Fasta = {
  getMeta: st.getMeta,
  extend: function extend(metaParser) {
    var customFasta;
    customFasta = _extend(Fasta);
    Fasta.getMeta = metaParser;
    return customFasta;
  },
  parse: function parse(text) {
    var currentSeq, getMeta, id, label, line, obj, seqs, _i, _len;
    seqs = [];
    if (!text || text.length === 0) {
      return [];
    }
    if (Object.prototype.toString.call(text) !== '[object Array]') {
      text = text.split("\n");
    }
    getMeta = Fasta.getMeta;
    for (_i = 0, _len = text.length; _i < _len; _i++) {
      line = text[_i];
      if (line[0] === ">" || line[0] === ";") {
        label = line.slice(1);
        obj = getMeta(label);
        label = obj.name;
        id = obj.id || seqs.length;
        currentSeq = new st.model("", obj.name, id);
        currentSeq.ids = obj.ids || {};
        currentSeq.details = obj.details || {};
        seqs.push(currentSeq);
      } else {
        currentSeq.seq += line;
      }
    }
    return seqs;
  },
  write: function write(seqs, access) {
    var seq, text, _i, _len;
    text = "";
    for (_i = 0, _len = seqs.length; _i < _len; _i++) {
      seq = seqs[_i];
      if (access != null) {
        seq = access(seq);
      }
      text += ">" + seq.name + "\n";
      text += st.splitNChars(seq.seq, 80).join("\n");
      text += "\n";
    }
    return text;
  }
};

/***/ }),

/***/ "./node_modules/biojs-io-fasta/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/biojs-io-fasta/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.0
var Fasta, GenericReader;
GenericReader = __webpack_require__(/*! biojs-io-parser */ "./node_modules/biojs-io-parser/lib/index.js");
Fasta = __webpack_require__(/*! ./fasta */ "./node_modules/biojs-io-fasta/lib/fasta.js");
module.exports = Fasta;
GenericReader.mixin(Fasta);

/***/ }),

/***/ "./node_modules/biojs-io-gff/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/biojs-io-gff/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * biojs-io-gff
 * https://github.com/greenify/biojs-io-gff
 *
 * Copyright (c) 2014 greenify
 * Licensed under the Apache 2 license.
 */

var parser = __webpack_require__(/*! biojs-io-parser */ "./node_modules/biojs-io-parser/lib/index.js");
var gff = function gff() {};
parser.mixin(gff);
module.exports = gff;
var utils = __webpack_require__(/*! ./utils */ "./node_modules/biojs-io-gff/lib/utils.js");
var jalview = __webpack_require__(/*! ./jalview */ "./node_modules/biojs-io-gff/lib/jalview.js");

/**
 * Method responsible to parse GFF
 * @see https://www.sanger.ac.uk/resources/software/gff/spec.html#t_2
 *
 * @example
 *
 *     biojsiogff.parse('SEQ1  EMBL  atg  103  105  .  +  0');
 *
 * @method parse
 * @param {String} file GFF file
 * @return {String} Returns JSON representation
 */

gff.parseLines = function (file) {
  var lines = file.split("\n");
  var config = {};
  var arr = [];
  config.type = gff._guessType(lines);
  var offset = 0;
  if (config.type === "jalview") {
    var ret = jalview.readHeader(lines);
    //console.log(ret);
    offset = ret.offset;
    config.colors = ret.colors;
    arr = ret.features;
  }
  for (var i = offset; i < lines.length; i++) {
    // ignore comments for now
    var line = lines[i];
    if (line.length === 0 || line[0] === "#") continue;
    line = gff.parseLine(line);
    if (line !== undefined) arr.push(line);
  }
  return {
    features: arr,
    config: config
  };
};
gff._guessType = function (line) {
  if (line[0].substring(0, 15) === "##gff-version 3") {
    return "gff3";
  } else if (line[0].indexOf("#") < 0 && line[0].split("\t").length === 2) {
    // no comments and two columns. let's hope this is from jalview
    return "jalview";
  }
  // unable to read file header. lets hope this is gff3
  return "gff3";
};

/**
 * parses GFF and returns a dictionary of all seqs with their features
 * @method parseSeqs
 * @param {String} file GFF file
 * @return {String} Returns dictionary of sequences with an array of their features
 */
gff.parseSeqs = gff.parse = function (file) {
  var obj = gff.parseLines(file);
  var seqs = {};
  obj.features.forEach(function (entry) {
    var key = entry.seqname;
    if (seqs[key] === undefined) seqs[key] = [];
    delete entry.seqname;
    seqs[key].push(entry);
  });
  delete obj.features;
  obj.seqs = seqs;
  return obj;
};

/*
 * parses one GFF line and returns it
 */
gff.parseLine = function (line) {
  var tLine = {};
  var columns = line.split(/\s+/);
  // ignore empty lines
  if (columns.length === 1) return;
  tLine.seqname = columns[0];
  tLine.source = columns[1];
  tLine.feature = columns[2];
  tLine.start = parseInt(columns[3]);
  tLine.end = parseInt(columns[4]);
  tLine.score = columns[5]; // only DNA,RNA
  tLine.strand = columns[6]; // only DNA,RNA
  tLine.frame = columns[7]; // only DNA,RNA
  var attr = columns.slice(8).join(" "); // plain text comments

  // remove undefined (dot)
  Object.keys(tLine).forEach(function (key) {
    if (typeof tLine[key] === "string") {
      tLine[key] = tLine[key].trim(); // triming is important
    }
    if (tLine[key] === ".") {
      tLine[key] = undefined;
    }
  });

  // parse optional parameters
  if (tLine.score) {
    tLine.score = parseFloat(tLine.score);
  }
  if (tLine.frame) {
    tLine.frame = parseInt(tLine.frame);
  }
  tLine.attributes = utils.extractKeys(attr);
  return tLine;
};
gff.exportLine = function (line) {
  var attrs = Object.keys(line.attributes).map(function (key) {
    return key + "=" + line.attributes[key];
  }).join(";");
  var cells = [line.seqname, line.source, line.feature, line.start, line.end, line.score, line.strand, line.frame, attrs];
  cells = cells.map(function (e) {
    if (e === undefined) {
      return ".";
    }
    return e;
  });
  return cells.join("\t");
};
gff.exportLines = function (lines) {
  return "##gff-version 3\n" + lines.map(gff.exportLine).join("\n");
};
gff.exportSeqs = gff["export"] = function (seqs) {
  var lines = [];
  var pLine = function pLine(e) {
    e.seqname = key;
    lines.push(e);
  };
  for (var key in seqs) {
    seqs[key].forEach(pLine);
  }
  return gff.exportLines(lines);
};

/***/ }),

/***/ "./node_modules/biojs-io-gff/lib/jalview.js":
/*!**************************************************!*\
  !*** ./node_modules/biojs-io-gff/lib/jalview.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var jalview = {};
module.exports = jalview;
var utils = __webpack_require__(/*! ./utils */ "./node_modules/biojs-io-gff/lib/utils.js");

// http://www.jalview.org/help/html/features/featuresFormat.html
jalview.readHeader = function (lines) {
  var colors = {};
  var i = 0;
  var features = [];
  var currentGroup;
  for (; i < lines.length; i++) {
    var line = lines[i];
    if (line.indexOf("#") >= 0) {
      // no comments allowed -> stop
      break;
    }
    var columns = line.split(/\t/);
    var firstCell = columns[0].trim();
    if (firstCell === "GFF") {
      // this symbolizes the end 
      break;
    } else if (columns.length === 2) {
      if (firstCell === "startgroup") {
        currentGroup = columns[1].trim();
      } else if (firstCell === "endgroup") {
        currentGroup = "";
        continue;
      } else {
        // parse color
        colors[columns[0]] = jalview.parseColor(columns[1]);
      }
    } else if (columns.length >= 5) {
      var arr = jalview.parseLine(columns);
      if (currentGroup) {
        arr.attributes.Parent = currentGroup;
      }
      features.push(arr);
    }
  }
  return {
    offset: i,
    colors: colors,
    features: features
  };
};
jalview.parseColor = function (cell) {
  if (cell.indexOf(",") >= 0) {
    // rgb code
    return utils.rgbToHex(cell.split(",").map(function (el) {
      return parseInt(el);
    }));
  }
  // color names with length == 6
  // 'bisque,maroon,orange,orchid,purple,salmon,sienna,tomato,violet,yellow'
  if (cell.length === 6 && parseInt(cell.charAt(0), 16) <= 16 && cell !== 'bisque') {
    // hex code
    return "#" + cell;
  }
  // color name
  return cell;
};
jalview.parseLine = function (columns) {
  var obj = {
    attributes: {}
  };
  obj.attributes.Name = columns[0].trim(); //desc
  obj.seqname = columns[1].trim(); // id
  obj.start = parseInt(columns[3]);
  obj.end = parseInt(columns[4]);
  obj.feature = columns[5].trim();
  if (obj.seqname === "ID_NOT_SPECIFIED") {
    obj.seqname = columns[2].trim(); // alternative id
  }
  return obj;
};

/***/ }),

/***/ "./node_modules/biojs-io-gff/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/biojs-io-gff/lib/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var utils = {};
module.exports = utils;
utils.extractKeys = function extractKeys(attr) {
  // extract key-value definitions
  var attributes = {};
  var attrArr = attr.split(";");
  attrArr.forEach(function (el) {
    var keyArr, key, val;
    if (el.indexOf("=") > 0) {
      keyArr = el.split("=");
      key = keyArr[0];
      val = keyArr[1];
      attributes[key] = val;
    } else if (el.indexOf(" ") > 0) {
      keyArr = el.split(" ");
      key = keyArr[0];
      val = keyArr[1].replace(/"/g, '');
      attributes[key] = val;
    }
  });
  return attributes;
};
function componentToHex(c) {
  var hex = c.toString(16);
  return hex.length === 1 ? "0" + hex : hex;
}
utils.rgbToHex = function (r, g, b) {
  if (r.length === 3) {
    return utils.rgbToHex(r[0], r[1], r[2]);
  }
  return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
};

/***/ }),

/***/ "./node_modules/biojs-io-parser/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/biojs-io-parser/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var GenericReader;
var xhr = __webpack_require__(/*! request */ "./node_modules/biojs-io-parser/node_modules/xhr/index.js");
var vow = __webpack_require__(/*! vow */ "./node_modules/vow/lib/vow.js");
module.exports = GenericReader = function () {
  function GenericReader() {}

  // returns a promise if callback is undefined
  GenericReader.read = function (url, callback) {
    var onret;
    onret = function (_this) {
      return function (err, response, text) {
        return GenericReader._onRetrieval(err, text, callback, _this);
      };
    }(this);
    if (typeof callback === "undefined") {
      var prom = vow.defer();
      callback = function callback(err, res) {
        if (err) {
          prom.reject(err);
        } else {
          prom.resolve(res);
        }
      };
      xhr(url, onret);
      return prom.promise();
    } else {
      return xhr(url, onret);
    }
  };
  GenericReader._onRetrieval = function (err, text, callback, _this) {
    var rText;
    if (typeof err !== "undefined") {
      rText = _this.parse(text);
    }
    return callback.call(_this, err, rText);
  };

  // provide a convenient shortcut to inherit
  GenericReader.extend = function (obj, statics) {
    return extend(GenericReader, obj, statics);
  };
  // Mixin utility
  GenericReader.mixin = function (proto) {
    var exports = ['read'];
    if (_typeof(proto) !== "object") {
      proto = proto.prototype;
    }
    exports.forEach(function (name) {
      proto[name] = GenericReader[name];
    }, this);
    return proto;
  };
  return GenericReader;
}();

/***/ }),

/***/ "./node_modules/biojs-io-parser/node_modules/xhr/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/biojs-io-parser/node_modules/xhr/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var window = __webpack_require__(/*! global/window */ "./node_modules/global/window.js");
var isFunction = __webpack_require__(/*! is-function */ "./node_modules/is-function/index.js");
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js");
var xtend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");
module.exports = createXHR;
// Allow use of default import syntax in TypeScript
module.exports["default"] = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window.XDomainRequest;
forEachArray(["get", "put", "post", "patch", "head", "delete"], function (method) {
  createXHR[method === "delete" ? "del" : method] = function (uri, options, callback) {
    options = initParams(uri, options, callback);
    options.method = method.toUpperCase();
    return _createXHR(options);
  };
});
function forEachArray(array, iterator) {
  for (var i = 0; i < array.length; i++) {
    iterator(array[i]);
  }
}
function isEmpty(obj) {
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) return false;
  }
  return true;
}
function initParams(uri, options, callback) {
  var params = uri;
  if (isFunction(options)) {
    callback = options;
    if (typeof uri === "string") {
      params = {
        uri: uri
      };
    }
  } else {
    params = xtend(options, {
      uri: uri
    });
  }
  params.callback = callback;
  return params;
}
function createXHR(uri, options, callback) {
  options = initParams(uri, options, callback);
  return _createXHR(options);
}
function _createXHR(options) {
  if (typeof options.callback === "undefined") {
    throw new Error("callback argument missing");
  }
  var called = false;
  var callback = function cbOnce(err, response, body) {
    if (!called) {
      called = true;
      options.callback(err, response, body);
    }
  };
  function readystatechange() {
    if (xhr.readyState === 4) {
      setTimeout(loadFunc, 0);
    }
  }
  function getBody() {
    // Chrome with requestType=blob throws errors arround when even testing access to responseText
    var body = undefined;
    if (xhr.response) {
      body = xhr.response;
    } else {
      body = xhr.responseText || getXml(xhr);
    }
    if (isJson) {
      try {
        body = JSON.parse(body);
      } catch (e) {}
    }
    return body;
  }
  function errorFunc(evt) {
    clearTimeout(timeoutTimer);
    if (!(evt instanceof Error)) {
      evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
    }
    evt.statusCode = 0;
    return callback(evt, failureResponse);
  }

  // will load the data & process the response in a special response object
  function loadFunc() {
    if (aborted) return;
    var status;
    clearTimeout(timeoutTimer);
    if (options.useXDR && xhr.status === undefined) {
      //IE8 CORS GET successful response doesn't have a status field, but body is fine
      status = 200;
    } else {
      status = xhr.status === 1223 ? 204 : xhr.status;
    }
    var response = failureResponse;
    var err = null;
    if (status !== 0) {
      response = {
        body: getBody(),
        statusCode: status,
        method: method,
        headers: {},
        url: uri,
        rawRequest: xhr
      };
      if (xhr.getAllResponseHeaders) {
        //remember xhr can in fact be XDR for CORS in IE
        response.headers = parseHeaders(xhr.getAllResponseHeaders());
      }
    } else {
      err = new Error("Internal XMLHttpRequest Error");
    }
    return callback(err, response, response.body);
  }
  var xhr = options.xhr || null;
  if (!xhr) {
    if (options.cors || options.useXDR) {
      xhr = new createXHR.XDomainRequest();
    } else {
      xhr = new createXHR.XMLHttpRequest();
    }
  }
  var key;
  var aborted;
  var uri = xhr.url = options.uri || options.url;
  var method = xhr.method = options.method || "GET";
  var body = options.body || options.data;
  var headers = xhr.headers = options.headers || {};
  var sync = !!options.sync;
  var isJson = false;
  var timeoutTimer;
  var failureResponse = {
    body: undefined,
    headers: {},
    statusCode: 0,
    method: method,
    url: uri,
    rawRequest: xhr
  };
  if ("json" in options && options.json !== false) {
    isJson = true;
    headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
    if (method !== "GET" && method !== "HEAD") {
      headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
      body = JSON.stringify(options.json === true ? body : options.json);
    }
  }
  xhr.onreadystatechange = readystatechange;
  xhr.onload = loadFunc;
  xhr.onerror = errorFunc;
  // IE9 must have onprogress be set to a unique function.
  xhr.onprogress = function () {
    // IE must die
  };
  xhr.onabort = function () {
    aborted = true;
  };
  xhr.ontimeout = errorFunc;
  xhr.open(method, uri, !sync, options.username, options.password);
  //has to be after open
  if (!sync) {
    xhr.withCredentials = !!options.withCredentials;
  }
  // Cannot set timeout with sync request
  // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
  // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
  if (!sync && options.timeout > 0) {
    timeoutTimer = setTimeout(function () {
      if (aborted) return;
      aborted = true; //IE9 may still call readystatechange
      xhr.abort("timeout");
      var e = new Error("XMLHttpRequest timeout");
      e.code = "ETIMEDOUT";
      errorFunc(e);
    }, options.timeout);
  }
  if (xhr.setRequestHeader) {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (options.headers && !isEmpty(options.headers)) {
    throw new Error("Headers cannot be set on an XDomainRequest object");
  }
  if ("responseType" in options) {
    xhr.responseType = options.responseType;
  }
  if ("beforeSend" in options && typeof options.beforeSend === "function") {
    options.beforeSend(xhr);
  }

  // Microsoft Edge browser sends "undefined" when send is called with undefined value.
  // XMLHttpRequest spec says to pass null as body to indicate no body
  // See https://github.com/naugtur/xhr/issues/100.
  xhr.send(body || null);
  return xhr;
}
function getXml(xhr) {
  // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
  // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
  try {
    if (xhr.responseType === "document") {
      return xhr.responseXML;
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
      return xhr.responseXML;
    }
  } catch (e) {}
  return null;
}
function noop() {}

/***/ }),

/***/ "./node_modules/biojs-model/src/index.js":
/*!***********************************************!*\
  !*** ./node_modules/biojs-model/src/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports.seq = __webpack_require__(/*! ./seq */ "./node_modules/biojs-model/src/seq.js");

/***/ }),

/***/ "./node_modules/biojs-model/src/seq.js":
/*!*********************************************!*\
  !*** ./node_modules/biojs-model/src/seq.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (seq, name, id) {
  this.seq = seq;
  this.name = name;
  this.id = id;
  this.meta = {};
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/light.js":
/*!*************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/light.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this is a light-weight build without the scrolling module
module.exports = __webpack_require__(/*! ./src/index.js */ "./node_modules/biojs-vis-seqlogo/src/index.js");

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/axis.js":
/*!****************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/axis.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  render_x_axis_label: function render_x_axis_label() {
    var label = "Model Position";
    if (this.display_ali_map) {
      label = "Alignment Column";
    }
    this.called_on.find('.logo_xaxis').remove();
    this.called_on.prepend('<div class="logo_xaxis" class="centered" style="margin-left:40px"><p class="xaxis_text" style="width:10em;margin:1em auto">' + label + '</p></div>');
  },
  render_y_axis_label: function render_y_axis_label() {
    //attach a canvas for the y-axis
    this.dom_element.parent().before('<canvas class="logo_yaxis" height="' + this.options.height + '" width="55"></canvas>');
    var canvas = this.called_on.find('.logo_yaxis'),
      top_pix_height = 0,
      bottom_pix_height = 0,
      top_height = Math.abs(this.data.max_height),
      bottom_height = isNaN(this.data.min_height_obs) ? 0 : parseInt(this.data.min_height_obs, 10),
      context = null,
      axis_label = "Information Content (bits)";
    context = canvas[0].getContext('2d');
    //draw min/max tick marks
    context.beginPath();
    context.moveTo(55, 1);
    context.lineTo(40, 1);
    context.moveTo(55, this.info_content_height);
    context.lineTo(40, this.info_content_height);
    context.moveTo(55, this.info_content_height / 2);
    context.lineTo(40, this.info_content_height / 2);
    context.lineWidth = 1;
    context.strokeStyle = "#666666";
    context.stroke();

    //draw the label text
    context.fillStyle = "#666666";
    context.textAlign = "right";
    context.font = "bold 10px Arial";

    // draw the max label
    context.textBaseline = "top";
    context.fillText(parseFloat(this.data.max_height).toFixed(1), 38, 0);
    context.textBaseline = "middle";

    // draw the midpoint labels
    context.fillText(parseFloat(this.data.max_height / 2).toFixed(1), 38, this.info_content_height / 2);
    // draw the min label
    context.fillText('0', 38, this.info_content_height);

    // draw the axis label
    if (this.data.height_calc === 'score') {
      axis_label = "Score (bits)";
    }
    context.save();
    context.translate(5, this.height / 2 - 20);
    context.rotate(-Math.PI / 2);
    context.textAlign = "center";
    context.font = "normal 12px Arial";
    context.fillText(axis_label, 1, 0);
    context.restore();

    // draw the insert row labels
    context.fillText('occupancy', 55, this.info_content_height + 7);
    if (this.show_inserts) {
      context.fillText('ins. prob.', 50, 280);
      context.fillText('ins. len.', 46, 296);
    }
  }
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/canvasSupport.js":
/*!*************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/canvasSupport.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var canv_support = null;
module.exports = function canvasSupport() {
  if (!canv_support) {
    var elem = document.createElement('canvas');
    canv_support = !!(elem.getContext && elem.getContext('2d'));
  }
  return canv_support;
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/colors/aa.js":
/*!*********************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/colors/aa.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  'A': '#FF9966',
  'C': '#009999',
  'D': '#FF0000',
  'E': '#CC0033',
  'F': '#00FF00',
  'G': '#f2f20c',
  'H': '#660033',
  'I': '#CC9933',
  'K': '#663300',
  'L': '#FF9933',
  'M': '#CC99CC',
  'N': '#336666',
  'P': '#0099FF',
  'Q': '#6666CC',
  'R': '#990000',
  'S': '#0000FF',
  'T': '#00FFFF',
  'V': '#FFCC33',
  'W': '#66CC66',
  'Y': '#006600'
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/colors/dna.js":
/*!**********************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/colors/dna.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  'A': '#cbf751',
  'C': '#5ec0cc',
  'G': '#ffdf59',
  'T': '#b51f16',
  'U': '#b51f16'
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/eventListener.js":
/*!*************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/eventListener.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
module.exports = function ($el, logo, logo_graphic) {
  $el.find('.logo_settings_switch, .logo_settings .close').on('click', function (e) {
    e.preventDefault();
    $('.logo_settings').toggle();
  });
  $el.find('.logo_reset').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({
      'target': logo.default_zoom
    });
  });
  $el.find('.logo_change').on('click', function (e) {
    e.preventDefault();
  });
  $el.find('.logo_zoomin').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({
      'distance': 0.1,
      'direction': '+'
    });
  });
  $el.find('.logo_zoomout').on('click', function (e) {
    e.preventDefault();
    logo.changeZoom({
      'distance': 0.1,
      'direction': '-'
    });
  });
  $el.find('.logo_scale').on('change', function (e) {
    logo.toggleScale(this.value);
  });
  $el.find('.logo_color').on('change', function (e) {
    logo.toggleColorscheme(this.value);
  });
  $el.find('.logo_ali_map').on('change', function (e) {
    logo.toggleAliMap(this.value);
  });
  $el.find('.logo_position').on('change', function () {
    if (!this.value.match(/^\d+$/m)) {
      return;
    }
    logo.scrollToColumn(this.value, 1);
  });
  logo_graphic.on('dblclick', function (e) {
    // need to get coordinates of mouse click
    console.log("dblclick", logo);
    offset = logo.logo_graphic.offset(), x = parseInt(e.pageX - offset.left, 10),
    // get mouse position in the window
    window_position = e.pageX - $el.parent().offset().left,
    // get column number
    col = logo.columnFromCoordinates(x), console.log("col", col);

    // choose new zoom level and zoom in.
    current = logo.zoom;
    if (current < 1) {
      logo.changeZoom({
        'target': 1,
        offset: window_position,
        column: col
      });
    } else {
      logo.changeZoom({
        'target': 0.3,
        offset: window_position,
        column: col
      });
    }
    return;
  });
  $(document).on($el.attr('id') + ".scrolledTo", function (e, left, top, zoom) {
    logo.render({
      target: left
    });
  });
  $(document).on('keydown', function (e) {
    if (!e.ctrlKey) {
      if (e.which === 61 || e.which === 107) {
        zoom += 0.1;
        logo.changeZoom({
          'distance': 0.1,
          'direction': '+'
        });
      }
      if (e.which === 109 || e.which === 0) {
        zoom = zoom - 0.1;
        logo.changeZoom({
          'distance': 0.1,
          'direction': '-'
        });
      }
    }
  });
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");

//var ConsensusColors = require("./consensusColors.js");
var canvasSupport = __webpack_require__(/*! ./canvasSupport.js */ "./node_modules/biojs-vis-seqlogo/src/canvasSupport.js");
var _render = __webpack_require__(/*! ./render/render.js */ "./node_modules/biojs-vis-seqlogo/src/render/render.js");
var Letter = __webpack_require__(/*! ./model/letter.js */ "./node_modules/biojs-vis-seqlogo/src/model/letter.js");
var view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
var axis = __webpack_require__(/*! ./axis */ "./node_modules/biojs-vis-seqlogo/src/axis.js");
var eventListener = __webpack_require__(/*! ./eventListener.js */ "./node_modules/biojs-vis-seqlogo/src/eventListener.js");
var settings = __webpack_require__(/*! ./info/settings.js */ "./node_modules/biojs-vis-seqlogo/src/info/settings.js");
var jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
module.exports = view.extend({
  options: {
    xaxis: true,
    yaxis: true,
    height: 300,
    column_width: 34,
    debug: true,
    scale_height_enabled: true,
    scaled_max: true,
    zoom_buttons: true,
    colorscheme: 'default',
    data: undefined,
    start: 1,
    end: undefined,
    zoom: 0.4,
    colors: undefined,
    divider: false,
    show_probs: false,
    divider_step: 5,
    show_divider: false,
    border: false,
    settings: false,
    scroller: true,
    positionMarker: true
  },
  loadDefault: function loadDefault(options) {
    this.data = options.data;

    // never show the alignment coordinates by default as that would get
    // really confusing.
    this.display_ali_map = 0;
    this.alphabet = options.data.alphabet || 'dna';
    this.start = options.start;
    //this.end = options.end || this.data.heightArr.length;
    this.zoom = parseFloat(options.zoom) || 0.4;
    this.default_zoom = this.zoom;
    this.column_width = options.column_width;
    this.height = options.height;
    this.canvas_width = 5000;
    this.scale_height_enabled = options.scale_height_enabled;

    // this needs to be set to null here so that we can initialise it after
    // the render function has fired and the width determined.
    this.scrollme = null;
    this.previous_target = 0;
    // keeps track of which canvas elements have been drawn and which ones haven't.
    this.rendered = [];
    this.previous_zoom = 0;
    if (this.data.max_height == undefined) {
      this.data.max_height = this.calcMaxHeight(this.data.heightArr);
    }

    // only show insert when we actually have the data
    if (!this.data.insert_probs || !this.data.delete_probs) {
      this.options.show_probs = false;
    }
    if (options.scaled_max) {
      this.data.max_height = options.data.max_height_obs || this.data.max_height || 2;
    } else {
      this.data.max_height = options.data.max_height_theory || this.data.max_height || 2;
    }
    if (options.colors) {
      this.changeColors(options.colors);
    } else {
      if (this.alphabet === 'aa') {
        this.aa_colors = __webpack_require__(/*! ./colors/aa.js */ "./node_modules/biojs-vis-seqlogo/src/colors/aa.js");
        this.changeColors(this.aa_colors);
      } else {
        this.dna_colors = __webpack_require__(/*! ./colors/dna.js */ "./node_modules/biojs-vis-seqlogo/src/colors/dna.js");
        this.changeColors(this.dna_colors);
      }
    }
  },
  initialize: function initialize(options) {
    if (!canvasSupport()) {
      this.el.textContent = "Your browser doesn't support canvas.";
      return;
    }
    if (options.data == undefined) {
      this.el.textContent = "No data added.";
    }

    // load default settings
    _.extend(this.options, options);
    var opt = this.options;
    this.loadDefault(opt);
    if (!this.options.show_probs) {
      this.info_content_height = this.height;
    } else {
      // turn off the insert rows if the hmm used the observed or weighted processing flags.
      if (this.data.processing && /^observed|weighted/.test(this.data.processing)) {
        this.show_inserts = 0;
        this.info_content_height = this.height - 14;
      } else {
        this.show_inserts = 1;
        this.info_content_height = this.height - 44;
      }
    }
    this.$el = jbone(this.el);
    this.initDivs();
    if (this.options.settings) {
      var form = settings(this, opt);
      this.$el.append(form);
    }
    eventListener(this.$el, this, this.logo_graphic);
    /*
       if (opt.columnInfo) {
       var columnInfo = require("./info/column_info.js");
       columnInfo(this);
       }
       */
  },
  initDivs: function initDivs() {
    var logo_graphic = mk("div");
    logo_graphic.className = "logo_graphic";
    this.logo_graphic = jbone(logo_graphic);
    var container = mk("div");
    container.className = "logo_container";
    container.style.height = this.height;
    this.container = jbone(container);
    this.container.append(logo_graphic);

    // add some internal divs for scrolling etc.
    this.$el.append(container);
    if (this.options.divider) {
      var divider = mk("div");
      divider.className = "logo_divider";
      this.$el.append(divider);
    }
    this.dom_element = jbone(logo_graphic);
    this.called_on = this.$el;
    if (this.options.xaxis) {
      axis.render_x_axis_label.call(this);
    }
    if (this.options.yaxis) {
      axis.render_y_axis_label.call(this);
    } else {
      this.container[0].style.marginLeft = "0px";
    }
  },
  render: function render() {
    _render.call(this);
    return this;
  },
  changeColors: function changeColors(colors) {
    this.colors = colors;
    var bUseColorObject = colors != undefined && colors.type != undefined;
    if (bUseColorObject) {
      this.colorscheme = "dynamic";
    }
    this.buildAlphabet();
  },
  buildAlphabet: function buildAlphabet() {
    /*
       if (this.alphabet === 'aa') {
       var probs_arr = this.data.probs_arr;
       if (probs_arr) {
       var cc = new ConsensusColors();
       this.cmap = cc.color_map(probs_arr);
       }
       }
       */

    //build the letter canvases
    this.letters = {};
    var colors = this.colors;
    if (this.colorscheme == "dynamic") {
      var tColors = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
      colors = {};
      tColors.forEach(function (e) {
        colors[e] = "";
      });
    }
    for (var letter in colors) {
      if (colors.hasOwnProperty(letter)) {
        var loptions = {
          color: colors[letter]
        };
        this.letters[letter] = new Letter(letter, loptions);
      }
    }
  },
  toggleColorscheme: function toggleColorscheme(scheme) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();
    if (scheme) {
      if (scheme === 'default') {
        this.colorscheme = 'default';
      } else {
        this.colorscheme = 'consensus';
      }
    } else {
      if (this.colorscheme === 'default') {
        this.colorscheme = 'consensus';
      } else {
        this.colorscheme = 'default';
      }
    }

    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },
  toggleScale: function toggleScale(scale) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();
    if (scale) {
      if (scale === 'obs') {
        this.data.max_height = this.data.max_height_obs;
      } else {
        this.data.max_height = this.data.max_height_theory;
      }
    } else {
      // toggle the max height
      if (this.data.max_height === this.data.max_height_obs) {
        this.data.max_height = this.data.max_height_theory;
      } else {
        this.data.max_height = this.data.max_height_obs;
      }
    }
    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];
    //update the y-axis
    if (this.logoYAxis) {
      this.logoYAxis.remove();
      //this.called_on.find('.logo_yaxis').remove();
    }
    axis.render_y_axis_label.call(this);

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },
  toggleAliMap: function toggleAliMap(coords) {
    // work out the current column we are on so we can return there
    var col_total = this.currentColumn();
    if (coords) {
      if (coords === 'model') {
        this.display_ali_map = 0;
      } else {
        this.display_ali_map = 1;
      }
    } else {
      // toggle the max height
      if (this.display_ali_map === 1) {
        this.display_ali_map = 0;
      } else {
        this.display_ali_map = 1;
      }
    }
    axis.render_x_axis_label(this);

    // reset the rendered counter so that each section will re-render
    // with the new heights
    this.rendered = [];

    // re-flow and re-render the content
    this.scrollme.reflow();
    //scroll off by one to force a render of the canvas.
    this.scrollToColumn(col_total + 1);
    //scroll back to the location we started at.
    this.scrollToColumn(col_total);
  },
  currentColumn: function currentColumn() {
    var before_left = this.scrollme.scroller.getValues().left,
      col_width = this.column_width * this.zoom,
      col_count = before_left / col_width,
      half_visible_columns = this.container.width() / col_width / 2,
      col_total = Math.ceil(col_count + half_visible_columns);
    return col_total;
  },
  changeZoom: function changeZoom(options) {
    var zoom_level = 0.3,
      expected_width = null;
    if (options.target) {
      zoom_level = options.target;
    } else if (options.distance) {
      zoom_level = (parseFloat(this.zoom) - parseFloat(options.distance)).toFixed(1);
      if (options.direction === '+') {
        zoom_level = (parseFloat(this.zoom) + parseFloat(options.distance)).toFixed(1);
      }
    }
    if (zoom_level > 1) {
      zoom_level = 1;
    } else if (zoom_level < 0.1) {
      zoom_level = 0.1;
    }

    // see if we need to zoom or not
    expected_width = this.logo_graphic.width() * zoom_level / this.zoom;
    if (expected_width > this.container.width()) {
      // if a center is not specified, then use the current center of the view
      if (!options.column) {
        //work out my current position
        var col_total = this.currentColumn();
        this.zoom = zoom_level;
        this.render({
          zoom: this.zoom
        });
        this.scrollme.reflow();

        //scroll to previous position
        this.scrollToColumn(col_total);
      } else {
        // center around the mouse click position.
        this.zoom = zoom_level;
        this.render({
          zoom: this.zoom
        });
        this.scrollme.reflow();
        var coords = this.coordinatesFromColumn(options.column);
        this.scrollme.scroller.scrollTo(coords - options.offset);
      }
    }
    return this.zoom;
  },
  columnFromCoordinates: function columnFromCoordinates(x) {
    var column = Math.ceil(x / (this.column_width * this.zoom));
    return column;
  },
  coordinatesFromColumn: function coordinatesFromColumn(col) {
    var new_column = col - 1,
      x = new_column * (this.column_width * this.zoom) + this.column_width * this.zoom / 2;
    return x;
  },
  scrollToColumn: function scrollToColumn(num, animate) {
    var half_view = this.logo_container.width() / 2,
      new_left = this.coordinatesFromColumn(num);
    this.scrollme.scroller.scrollTo(new_left - half_view, 0, animate);
  },
  calcMaxHeight: function calcMaxHeight(columns) {
    // loops over all columns and return the max height seen 
    return columns.reduce(function (m, c) {
      var col = 0;
      for (var k in c) {
        col += c[k];
      }
      return col > m ? col : m;
    }, 0);
  }
});
var mk = function mk(name) {
  return document.createElement(name);
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/info/settings.js":
/*!*************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/info/settings.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
module.exports = function (logo, options) {
  var form = $('<form class="logo_form"><fieldset><label for="position">Column number</label>' + '<input type="text" name="position" class="logo_position"></input>' + '<button class="button logo_change">Go</button></fieldset>' + '</form>');
  var settings = $('<div class="logo_settings"></div>');
  settings.append('<span class="close">x</span>');

  /* we don't want to toggle if the max height_obs is greater than max theoretical
   * as letters will fall off the top.
   */
  if (logo.scale_height_enabled && logo.data.max_height_obs < logo.data.max_height_theory) {
    var obs_checked = '',
      theory_checked = '',
      theory_help = '',
      obs_help = '';
    if (logo.data.max_height_obs === logo.data.max_height) {
      obs_checked = 'checked';
    } else {
      theory_checked = 'checked';
    }
  }
  var scale_controls = '<fieldset><legend>Scale</legend>' + '<label><input type="radio" name="scale" class="logo_scale" value="obs" ' + obs_checked + '/>Maximum Observed ' + obs_help + '</label></br>' + '<label><input type="radio" name="scale" class="logo_scale" value="theory" ' + theory_checked + '/>Maximum Theoretical ' + theory_help + '</label>' + '</fieldset>';
  settings.append(scale_controls);
  if (logo.data.height_calc !== 'score' && logo.data.alphabet === 'aa' && logo.data.probs_arr) {
    var def_color = null,
      con_color = null,
      def_help = '',
      con_help = '';
    if (logo.colorscheme === 'default') {
      def_color = 'checked';
    } else {
      con_color = 'checked';
    }
    ;
    if (options.help) {
      def_help = '<a class="help" href="/help#colors_default" title="Each letter receives its own color.">' + '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
      con_help = '<a class="help" href="/help#colors_consensus" title="Letters are colored as in Clustalx and Jalview, with colors depending on composition of the column.">' + '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
    }
    var color_controls = '<fieldset><legend>Color Scheme</legend>' + '<label><input type="radio" name="color" class="logo_color" value="default" ' + def_color + '/>Default ' + def_help + '</label></br>' + '<label><input type="radio" name="color" class="logo_color" value="consensus" ' + con_color + '/>Consensus Colors ' + con_help + '</label>' + '</fieldset>';
    settings.append(color_controls);
  }
  if (logo.data.ali_map) {
    var mod_checked = null,
      ali_checked = null,
      mod_help = '',
      ali_help = '';
    if (logo.display_ali_map === 0) {
      mod_checked = 'checked';
    } else {
      ali_checked = 'checked';
    }
    if (options.help) {
      mod_help = '<a class="help" href="/help#coords_model" title="The coordinates along the top of the plot show the model position.">' + '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
      ali_help = '<a class="help" href="/help#coords_ali" title="The coordinates along the top of the plot show the column in the alignment associated with the model">' + '<span aria-hidden="true" data-icon="?"></span><span class="reader-text">help</span></a>';
    }
    var ali_controls = '<fieldset><legend>Coordinates</legend>' + '<label><input type="radio" name="coords" class="logo_ali_map" value="model" ' + mod_checked + '/>Model ' + mod_help + '</label></br>' + '<label><input type="radio" name="coords" class="logo_ali_map" value="alignment" ' + ali_checked + '/>Alignment ' + ali_help + '</label>' + '</fieldset>';
    settings.append(ali_controls);
  }
  var controls = $('<div class="logo_controls"></div>');
  if (logo.zoom_enabled) {
    controls.append('<button class="logo_zoomout button">-</button>' + '<button class="logo_zoomin button">+</button>');
  }
  if (settings.children().length > 0) {
    controls.append('<button class="logo_settings_switch button">Settings</button>');
    controls.append(settings);
  }
  form.append(controls);
  return form;
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/model/letter.js":
/*!************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/model/letter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function Letter(letter, options) {
  options = options || {};
  this.value = letter;
  this.width = parseInt(options.width, 10) || 100;

  //W is 30% wider than the other letters, so need to make sure
  //it gets modified accordingly.
  if (this.value === 'W') {
    this.width += this.width * 30 / 100;
  }
  this.height = parseInt(options.height, 10) || 100;
  this.color = options.color || '#000000';
  // if the height and width are changed from the default, then
  // this will also need to be changed as it cant be calculated
  // dynamically.
  this.fontSize = options.fontSize || 138;
  this.scaled = function () {};
  this.draw = function (ext_ctx, target_height, target_width, x, y, color) {
    var h_ratio = target_height / this.height,
      w_ratio = target_width / this.width,
      prev_font = ext_ctx.font;
    ext_ctx.transform(w_ratio, 0, 0, h_ratio, x, y);
    ext_ctx.fillStyle = color || this.color;
    ext_ctx.textAlign = "center";
    ext_ctx.font = "bold " + this.fontSize + "px Arial";
    ext_ctx.fillText(this.value, 0, 0);
    //restore the canvas settings
    ext_ctx.setTransform(1, 0, 0, 1, 0, 0);
    ext_ctx.fillStyle = '#000000';
    ext_ctx.font = prev_font;
  };
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/draw/border.js":
/*!******************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/draw/border.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function draw_border(context, y, width) {
  context.beginPath();
  context.moveTo(0, y);
  context.lineTo(width, y);
  context.lineWidth = 1;
  context.strokeStyle = "#999999";
  context.stroke();
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/draw/column_number.js":
/*!*************************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/draw/column_number.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function draw_column_number(context, x, y, col_width, col_num, fontsize, right) {
  context.font = fontsize + "px Arial";
  context.textAlign = right ? "right" : "center";
  context.fillStyle = "#666666";
  context.fillText(col_num, x + col_width / 2, y);
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/draw/ticks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/draw/ticks.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function draw_ticks(context, x, y, height, color) {
  color = color || '#999999';
  context.beginPath();
  context.moveTo(x, y);
  context.lineTo(x, y + height);
  context.lineWidth = 1;
  context.strokeStyle = color;
  context.stroke();
};

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/render.js":
/*!*************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/render.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var renderWithText = __webpack_require__(/*! ./render_with_text.js */ "./node_modules/biojs-vis-seqlogo/src/render/render_with_text.js");
var renderWithRect = __webpack_require__(/*! ./render_with_rects.js */ "./node_modules/biojs-vis-seqlogo/src/render/render_with_rects.js");
var jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");

// the main render function that draws the logo based on the provided options.
module.exports = function (options) {
  if (!this.data) {
    return;
  }
  options = options || {};
  var zoom = options.zoom || this.zoom,
    target = options.target || 1,
    scaled = options.scaled || null;
  var parent_width = this.dom_element.parent().attr('width'),
    max_canvas_width = 1,
    end = null,
    start = null,
    i = 0;

  /*
  if (target === this.previous_target) {
    return;
  }
  */

  this.previous_target = target;
  if (options.start) {
    this.start = options.start;
  }
  if (options.end) {
    this.end = options.end;
  }
  if (zoom <= 0.1) {
    zoom = 0.1;
  } else if (zoom >= 1) {
    zoom = 1;
  }
  this.zoom = zoom;
  end = this.end || this.data.heightArr.length;
  start = this.start || 1;
  end = end > this.data.heightArr.length ? this.data.heightArr.length : end;
  end = end < start ? start : end;
  start = start > end ? end : start;
  start = start > 1 ? start : 1;
  this.y = this.height - 20;
  // Check to see if the logo will fit on the screen at full zoom.
  this.max_width = this.column_width * (end - start + 1);
  // If it fits then zoom out and disable zooming.
  if (parent_width > this.max_width) {
    zoom = 1;
    this.zoom_enabled = false;
  }
  this.zoom = zoom;
  this.zoomed_column = this.column_width * zoom;
  this.total_width = this.zoomed_column * (end - start + 1);

  // If zoom is not maxed and we still aren't filling the window
  // then ramp up the zoom level until it fits, then disable zooming.
  // Then we get a decent logo with out needing to zoom in or out.
  if (zoom < 1) {
    while (this.total_width < parent_width) {
      this.zoom += 0.1;
      this.zoomed_column = this.column_width * this.zoom;
      this.total_width = this.zoomed_column * (end - start + 1);
      this.zoom_enabled = false;
      if (zoom >= 1) {
        break;
      }
    }
  }
  if (target > this.total_width) {
    target = this.total_width;
  }
  this.dom_element.attr({
    'width': this.total_width + 'px'
  }).css({
    width: this.total_width + 'px'
  });
  this.canvas_width = this.total_width;
  var canvas_count = Math.ceil(this.total_width / this.canvas_width);
  this.columns_per_canvas = Math.ceil(this.canvas_width / this.zoomed_column);
  if (this.previous_zoom !== this.zoom) {
    this.dom_element.find('canvas').remove();
    this.previous_zoom = this.zoom;
    this.rendered = [];
  }
  this.canvases = [];
  this.contexts = [];
  for (i = 0; i < canvas_count; i++) {
    var split_start = this.columns_per_canvas * i + start,
      split_end = split_start + this.columns_per_canvas - 1;
    if (split_end > end) {
      split_end = end;
    }
    var adjusted_width = (split_end - split_start + 1) * this.zoomed_column;
    if (adjusted_width > max_canvas_width) {
      max_canvas_width = adjusted_width;
    }
    var canv_start = max_canvas_width * i,
      canv_end = canv_start + adjusted_width;
    if (target < canv_end + canv_end / 2 && target > canv_start - canv_start / 2) {
      // Check that we aren't redrawing the canvas and if not, then attach it and draw.
      //if (this.rendered[i] !== 1) {

      this.canvases[i] = attach_canvas(this.dom_element, this.height, adjusted_width, i, max_canvas_width);
      this.contexts[i] = this.canvases[i].getContext('2d');
      this.contexts[i].setTransform(1, 0, 0, 1, 0, 0);
      this.contexts[i].clearRect(0, 0, adjusted_width, this.height);
      this.contexts[i].fillStyle = "#ffffff";
      this.contexts[i].fillRect(0, 0, canv_end, this.height);
      if (this.zoomed_column > 12) {
        var fontsize = parseInt(10 * zoom, 10);
        fontsize = fontsize > 10 ? 10 : fontsize;
        if (this.debug) {
          renderWithRect.call(this, split_start, split_end, i, 1);
        }
        renderWithText.call(this, split_start, split_end, i, fontsize);
      } else {
        renderWithRect.call(this, split_start, split_end, i);
      }
      //this.rendered[i] = 1;
      //}
    }
  }

  // check if the scroller object has been initialised and if not then do so.
  // we do this here as opposed to at object creation, because we need to
  // make sure the logo has been rendered and the width is correct, otherwise
  // we get a weird initial state where the canvas will bounce back to the
  // beginning the first time it is scrolled, because it thinks it has a
  // width of 0.
  if (!this.scrollme && this.options.scroller) {
    this.scrollme = new EasyScroller(this.dom_element[0], {
      scrollingX: 1,
      scrollingY: 0,
      eventTarget: this.called_on
    });
  }
  if (target !== 1) {
    this.scrollme.reflow();
  }
  return;
};
function attach_canvas(DOMid, height, width, id, canv_width) {
  var canvas = jbone(DOMid).find('#canv_' + id);
  if (!canvas.length) {
    jbone(DOMid).append('<canvas class="canvas_logo" id="canv_' + id + '"  height="' + height + '" width="' + width + '" style="left:' + canv_width * id + 'px"></canvas>');
    canvas = jbone(DOMid).find('#canv_' + id);
  }
  jbone(canvas).attr('width', width).attr('height', height);
  return canvas[0];
}

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/render_with_rects.js":
/*!************************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/render_with_rects.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var draw_border = __webpack_require__(/*! ./draw/border.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/border.js");
var draw_ticks = __webpack_require__(/*! ./draw/ticks.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/ticks.js");
var draw_column_number = __webpack_require__(/*! ./draw/column_number.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/column_number.js");
module.exports = function (start, end, context_num, borders) {
  var x = 0,
    column_num = start,
    column_label = null,
    i = 0,
    top_height = Math.abs(this.data.max_height),
    bottom_height = Math.abs(this.data.min_height_obs),
    total_height = top_height + bottom_height,
    top_percentage = Math.round(Math.abs(this.data.max_height) * 100 / total_height),
    //convert % to pixels
    top_pix_height = Math.round(this.info_content_height * top_percentage / 100),
    bottom_pix_height = this.info_content_height - top_pix_height,
    mod = 10;
  for (i = start; i <= end; i++) {
    if (this.data.mmline && this.data.mmline[i - 1] === 1) {
      this.contexts[context_num].fillStyle = '#cccccc';
      this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
    } else {
      var column = this.data.heightArr[i - 1],
        previous_height = 0,
        previous_neg_height = top_pix_height,
        letters = column.length,
        j = 0;
      for (var j in column) {
        values = [j, column[j]];
        if (values[1] > 0.01) {
          var letter_height = parseFloat(values[1]) / this.data.max_height,
            x_pos = x,
            glyph_height = (this.info_content_height - 2) * letter_height,
            y_pos = this.info_content_height - 2 - previous_height - glyph_height,
            color = null;
          if (this.colorscheme === 'dynamic') {
            color = this.colors.getColor(values[0], {
              pos: i - 1
            });
          } else {
            if (this.colorscheme === 'consensus') {
              color = this.cmap[i - 1][values[0]] || "#7a7a7a";
            } else {
              color = this.colors[values[0]];
            }
          }
          if (borders) {
            this.contexts[context_num].strokeStyle = color;
            this.contexts[context_num].strokeRect(x_pos, y_pos, this.zoomed_column, glyph_height);
          } else {
            this.contexts[context_num].fillStyle = color;
            this.contexts[context_num].fillRect(x_pos, y_pos, this.zoomed_column, glyph_height);
          }
          previous_height = previous_height + glyph_height;
        }
      }
    }
    if (this.zoom < 0.2) {
      mod = 20;
    } else if (this.zoom < 0.3) {
      mod = 10;
    }
    if (this.options.positionMarker) {
      if (i % mod === 0) {
        // draw column dividers
        if (this.options.show_probs) {
          draw_ticks(this.contexts[context_num], x + this.zoomed_column, this.height - 30, parseFloat(this.height), '#dddddd');
        }
        // draw top ticks
        draw_ticks(this.contexts[context_num], x + this.zoomed_column, 0, 5);

        // if ali_coordinates exist and toggle is set then display the
        // alignment coordinates and not the model coordinates.
        if (this.display_ali_map) {
          column_label = this.data.ali_map[i - 1];
        } else {
          column_label = column_num;
        }
        // draw column numbers
        draw_column_number(this.contexts[context_num], x - 2, 10, this.zoomed_column, column_label, 10, true);
      }
    }

    // draw insert probabilities/lengths
    if (this.options.show_probs) {
      draw_small_insert(this.contexts[context_num], x, this.height - 42, this.zoomed_column, this.data.insert_probs[i - 1], this.data.insert_lengths[i - 1], this.data.delete_probs[i - 1], this.show_inserts);
    }
    if (this.options.show_probs) {
      // draw other dividers
      if (this.show_inserts) {
        draw_border(this.contexts[context_num], this.height - 45, this.total_width);
      } else {
        draw_border(this.contexts[context_num], this.height - 15, this.total_width);
      }
    }
    if (this.options.border) {
      draw_border(this.contexts[context_num], 0, this.total_width);
    }
    x += this.zoomed_column;
    column_num++;
  }
};
function draw_small_insert(context, x, y, col_width, in_odds, in_length, del_odds, show_inserts) {
  var fill = "#ffffff";
  if (show_inserts) {
    if (in_odds > 0.1) {
      fill = '#d7301f';
    } else if (in_odds > 0.05) {
      fill = '#fc8d59';
    } else if (in_odds > 0.03) {
      fill = '#fdcc8a';
    }
    context.fillStyle = fill;
    context.fillRect(x, y + 15, col_width, 10);
    fill = "#ffffff";
    // draw insert length
    if (in_length > 9) {
      fill = '#d7301f';
    } else if (in_length > 7) {
      fill = '#fc8d59';
    } else if (in_length > 4) {
      fill = '#fdcc8a';
    }
    context.fillStyle = fill;
    context.fillRect(x, y + 30, col_width, 10);
  } else {
    y = y + 30;
  }
  fill = "#ffffff";
  // draw delete odds
  if (del_odds < 0.75) {
    fill = '#2171b5';
  } else if (del_odds < 0.85) {
    fill = '#6baed6';
  } else if (del_odds < 0.95) {
    fill = '#bdd7e7';
  }
  context.fillStyle = fill;
  context.fillRect(x, y, col_width, 10);
}

/***/ }),

/***/ "./node_modules/biojs-vis-seqlogo/src/render/render_with_text.js":
/*!***********************************************************************!*\
  !*** ./node_modules/biojs-vis-seqlogo/src/render/render_with_text.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var draw_border = __webpack_require__(/*! ./draw/border.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/border.js");
var draw_ticks = __webpack_require__(/*! ./draw/ticks.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/ticks.js");
var draw_column_number = __webpack_require__(/*! ./draw/column_number.js */ "./node_modules/biojs-vis-seqlogo/src/render/draw/column_number.js");
module.exports = function (start, end, context_num, fontsize) {
  var x = 0,
    column_num = start,
    column_label = null,
    i = 0,
    top_height = Math.abs(this.data.max_height),
    bottom_height = isNaN(this.data.min_height_obs) ? 0 : parseInt(this.data.min_height_obs, 10),
    total_height = top_height + Math.abs(bottom_height),
    top_percentage = Math.round(Math.abs(this.data.max_height) * 100 / total_height),
    //convert % to pixels
    top_pix_height = Math.round(this.info_content_height * top_percentage / 100),
    bottom_pix_height = this.info_content_height - top_pix_height,
    // this is used to transform the 256px high letters into the correct size
    // when displaying negative values, so that they fit above the 0 line.
    top_pix_conversion = top_pix_height / this.info_content_height,
    bottom_pix_conversion = bottom_pix_height / this.info_content_height;

  // add 3 extra columns so that numbers don't get clipped at the end of a canvas
  // that ends before a large column. DF0000830 was suffering at zoom level 0.6,
  // column 2215. This adds a little extra overhead, but is the easiest fix for now.
  if (end + 3 <= this.end) {
    end += 3;
  }
  for (i = start; i <= end; i++) {
    if (this.data.mmline && this.data.mmline[i - 1] === 1) {
      this.contexts[context_num].fillStyle = '#cccccc';
      this.contexts[context_num].fillRect(x, 10, this.zoomed_column, this.height - 40);
    } else {
      var column = this.data.heightArr[i - 1],
        col_positions = [];
      if (column) {
        var previous_height = 0,
          letters = column.length,
          previous_neg_height = top_pix_height,
          j = 0,
          color = null;
        for (var j in column) {
          var letter = column[j],
            values = [j, letter];
          x_pos = x + this.zoomed_column / 2, letter_height = null;

          // we don't render anything with a value between 0 and 0.01. These
          // letters would be too small to be meaningful on any scale, so we
          // just squash them out.
          if (values[1] > 0.01) {
            letter_height = parseFloat(values[1]) / this.data.max_height;
            var y_pos = this.info_content_height - 2 - previous_height,
              glyph_height = (this.info_content_height - 2) * letter_height;
            col_positions[j] = [glyph_height, this.zoomed_column, x_pos, y_pos];
            previous_height = previous_height + glyph_height;
          }
        }

        // render the letters in reverse order so that the larger letters on the top
        // don't clobber the smaller letters below them.
        //for (j = letters; j >= 0; j--) {
        for (var j in column) {
          if (col_positions[j] && this.letters[j]) {
            if (this.colorscheme === 'dynamic') {
              color = this.colors.getColor(j, {
                pos: i - 1
              });
            } else {
              if (this.colorscheme === 'consensus') {
                color = this.cmap[i - 1][j] || "#7a7a7a";
              } else {
                color = null;
              }
            }
            this.letters[j].draw(this.contexts[context_num], col_positions[j][0], col_positions[j][1], col_positions[j][2], col_positions[j][3], color);
          }
        }
      }
    }

    // if ali_coordinates exist and toggle is set then display the
    // alignment coordinates and not the model coordinates.
    if (this.display_ali_map) {
      column_label = this.data.ali_map[i - 1];
    } else {
      column_label = column_num;
    }
    if (this.options.show_divider) {
      if (this.zoom < 0.7) {
        if (i % this.options.divider_step === 0) {
          draw_column_divider(this, {
            context_num: context_num,
            x: x,
            fontsize: 10,
            column_num: column_label,
            ralign: true
          });
        }
      } else {
        draw_column_divider(this, {
          context_num: context_num,
          x: x,
          fontsize: fontsize,
          column_num: column_label
        });
      }
    }
    if (this.options.show_probs) {
      draw_delete_odds(this.contexts[context_num], x, this.height, this.zoomed_column, this.data.delete_probs[i - 1], fontsize, this.show_inserts);
      //draw insert length ticks
      draw_ticks(this.contexts[context_num], x, this.height - 15, 5);
      if (this.show_inserts) {
        draw_insert_odds(this.contexts[context_num], x, this.height, this.zoomed_column, this.data.insert_probs[i - 1], fontsize);
        draw_insert_length(this.contexts[context_num], x, this.height - 5, this.zoomed_column, this.data.insert_lengths[i - 1], fontsize);

        // draw delete probability ticks
        draw_ticks(this.contexts[context_num], x, this.height - 45, 5);
        // draw insert probability ticks
        draw_ticks(this.contexts[context_num], x, this.height - 30, 5);
      }
    }
    x += this.zoomed_column;
    column_num++;
  }
  if (this.options.show_probs) {
    // draw other dividers
    if (this.show_inserts) {
      draw_border(this.contexts[context_num], this.height - 30, this.total_width);
      draw_border(this.contexts[context_num], this.height - 45, this.total_width);
    }
    draw_border(this.contexts[context_num], this.height - 15, this.total_width);
  }
  if (this.options.border) {
    draw_border(this.contexts[context_num], 0, this.total_width);
  }
};
function draw_delete_odds(context, x, height, col_width, text, fontsize, show_inserts) {
  var y = height - 4,
    fill = '#ffffff',
    textfill = '#555555';
  if (show_inserts) {
    y = height - 35;
  }
  if (text < 0.75) {
    fill = '#2171b5';
    textfill = '#ffffff';
  } else if (text < 0.85) {
    fill = '#6baed6';
  } else if (text < 0.95) {
    fill = '#bdd7e7';
  }
  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);
}
function draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill) {
  context.font = fontsize + "px Arial";
  context.fillStyle = fill;
  context.fillRect(x, y - 10, col_width, 14);
  context.textAlign = "center";
  context.fillStyle = textfill;
  context.fillText(text, x + col_width / 2, y);
}
function draw_column_divider(inst, opts) {
  var div_x = opts.ralign ? opts.x + inst.zoomed_column : opts.x,
    num_x = opts.ralign ? opts.x + 2 : opts.x;
  // draw column dividers
  draw_ticks(inst.contexts[opts.context_num], div_x, inst.height - 30, -30 - inst.height, '#dddddd');
  // draw top ticks
  draw_ticks(inst.contexts[opts.context_num], div_x, 0, 5);
  // draw column numbers
  draw_column_number(inst.contexts[opts.context_num], num_x, 10, inst.zoomed_column, opts.column_num, opts.fontsize, opts.ralign);
}
;
function draw_insert_odds(context, x, height, col_width, text, fontsize) {
  var y = height - 20,
    fill = '#ffffff',
    textfill = '#555555';
  if (text > 0.1) {
    fill = '#d7301f';
    textfill = '#ffffff';
  } else if (text > 0.05) {
    fill = '#fc8d59';
  } else if (text > 0.03) {
    fill = '#fdcc8a';
  }
  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);

  //draw vertical line to indicate where the insert would occur
  if (text > 0.03) {
    draw_ticks(context, x + col_width, height - 30, -30 - height, fill);
  }
}
function draw_insert_length(context, x, y, col_width, text, fontsize) {
  var fill = '#ffffff',
    textfill = '#555555';
  if (text > 9) {
    fill = '#d7301f';
    textfill = '#ffffff';
  } else if (text > 7) {
    fill = '#fc8d59';
  } else if (text > 4) {
    fill = '#fdcc8a';
  }
  draw_rect_with_text(context, x, y, text, fontsize, col_width, fill, textfill);
}

/***/ }),

/***/ "./node_modules/blueimp_canvastoblob/index.js":
/*!****************************************************!*\
  !*** ./node_modules/blueimp_canvastoblob/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * JavaScript Canvas to Blob 2.0.5
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */
var CanvasPrototype = window.HTMLCanvasElement && window.HTMLCanvasElement.prototype,
  hasBlobConstructor = window.Blob && function () {
    try {
      return Boolean(new Blob());
    } catch (e) {
      return false;
    }
  }(),
  hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && function () {
    try {
      return new Blob([new Uint8Array(100)]).size === 100;
    } catch (e) {
      return false;
    }
  }(),
  BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder,
  dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob && window.ArrayBuffer && window.Uint8Array && function (dataURI) {
    var byteString, arrayBuffer, intArray, i, mimeString, bb;
    if (dataURI.split(',')[0].indexOf('base64') >= 0) {
      // Convert base64 to raw binary data held in a string:
      byteString = atob(dataURI.split(',')[1]);
    } else {
      // Convert base64/URLEncoded data component to raw binary data:
      byteString = decodeURIComponent(dataURI.split(',')[1]);
    }
    // Write the bytes of the string to an ArrayBuffer:
    arrayBuffer = new ArrayBuffer(byteString.length);
    intArray = new Uint8Array(arrayBuffer);
    for (i = 0; i < byteString.length; i += 1) {
      intArray[i] = byteString.charCodeAt(i);
    }
    // Separate out the mime component:
    mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
    // Write the ArrayBuffer (or ArrayBufferView) to a blob:
    if (hasBlobConstructor) {
      return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], {
        type: mimeString
      });
    }
    bb = new BlobBuilder();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeString);
  };
if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
  if (CanvasPrototype.mozGetAsFile) {
    CanvasPrototype.toBlob = function (callback, type, quality) {
      if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
        callback(dataURLtoBlob(this.toDataURL(type, quality)));
      } else {
        callback(this.mozGetAsFile('blob', type));
      }
    };
  } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
    CanvasPrototype.toBlob = function (callback, type, quality) {
      callback(dataURLtoBlob(this.toDataURL(type, quality)));
    };
  }
}
module.exports = dataURLtoBlob;

/***/ }),

/***/ "./node_modules/browser-saveas/index.js":
/*!**********************************************!*\
  !*** ./node_modules/browser-saveas/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/* FileSaver.js
 *  A saveAs() FileSaver implementation.
 *  2014-05-27
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
// IE 10+ (native saveAs)
|| typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator)
// Everyone else
|| function (view) {
  "use strict";

  // IE <10 is explicitly unsupported
  if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
    return;
  }
  var doc = view.document
    // only get URL when necessary in case Blob.js hasn't overridden it yet
    ,
    get_URL = function get_URL() {
      return view.URL || view.webkitURL || view;
    },
    save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
    can_use_save_link = !view.externalHost && "download" in save_link,
    click = function click(node) {
      var event = doc.createEvent("MouseEvents");
      event.initMouseEvent("click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      node.dispatchEvent(event);
    },
    webkit_req_fs = view.webkitRequestFileSystem,
    req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
    throw_outside = function throw_outside(ex) {
      (view.setImmediate || view.setTimeout)(function () {
        throw ex;
      }, 0);
    },
    force_saveable_type = "application/octet-stream",
    fs_min_size = 0,
    deletion_queue = [],
    process_deletion_queue = function process_deletion_queue() {
      var i = deletion_queue.length;
      while (i--) {
        var file = deletion_queue[i];
        if (typeof file === "string") {
          // file is an object URL
          get_URL().revokeObjectURL(file);
        } else {
          // file is a File
          file.remove();
        }
      }
      deletion_queue.length = 0; // clear queue
    },
    dispatch = function dispatch(filesaver, event_types, event) {
      event_types = [].concat(event_types);
      var i = event_types.length;
      while (i--) {
        var listener = filesaver["on" + event_types[i]];
        if (typeof listener === "function") {
          try {
            listener.call(filesaver, event || filesaver);
          } catch (ex) {
            throw_outside(ex);
          }
        }
      }
    },
    FileSaver = function FileSaver(blob, name) {
      // First try a.download, then web filesystem, then object URLs
      var filesaver = this,
        type = blob.type,
        blob_changed = false,
        object_url,
        target_view,
        get_object_url = function get_object_url() {
          var object_url = get_URL().createObjectURL(blob);
          deletion_queue.push(object_url);
          return object_url;
        },
        dispatch_all = function dispatch_all() {
          dispatch(filesaver, "writestart progress write writeend".split(" "));
        }
        // on any filesys errors revert to saving with object URLs
        ,
        fs_error = function fs_error() {
          // don't create more object URLs than needed
          if (blob_changed || !object_url) {
            object_url = get_object_url(blob);
          }
          if (target_view) {
            target_view.location.href = object_url;
          } else {
            window.open(object_url, "_blank");
          }
          filesaver.readyState = filesaver.DONE;
          dispatch_all();
        },
        abortable = function abortable(func) {
          return function () {
            if (filesaver.readyState !== filesaver.DONE) {
              return func.apply(this, arguments);
            }
          };
        },
        create_if_not_found = {
          create: true,
          exclusive: false
        },
        slice;
      filesaver.readyState = filesaver.INIT;
      if (!name) {
        name = "download";
      }
      if (can_use_save_link) {
        object_url = get_object_url(blob);
        save_link.href = object_url;
        save_link.download = name;
        click(save_link);
        filesaver.readyState = filesaver.DONE;
        dispatch_all();
        return;
      }
      // Object and web filesystem URLs have a problem saving in Google Chrome when
      // viewed in a tab, so I force save with application/octet-stream
      // http://code.google.com/p/chromium/issues/detail?id=91158
      if (view.chrome && type && type !== force_saveable_type) {
        slice = blob.slice || blob.webkitSlice;
        blob = slice.call(blob, 0, blob.size, force_saveable_type);
        blob_changed = true;
      }
      // Since I can't be sure that the guessed media type will trigger a download
      // in WebKit, I append .download to the filename.
      // https://bugs.webkit.org/show_bug.cgi?id=65440
      if (webkit_req_fs && name !== "download") {
        name += ".download";
      }
      if (type === force_saveable_type || webkit_req_fs) {
        target_view = view;
      }
      if (!req_fs) {
        fs_error();
        return;
      }
      fs_min_size += blob.size;
      req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
        fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
          var save = function save() {
            dir.getFile(name, create_if_not_found, abortable(function (file) {
              file.createWriter(abortable(function (writer) {
                writer.onwriteend = function (event) {
                  target_view.location.href = file.toURL();
                  deletion_queue.push(file);
                  filesaver.readyState = filesaver.DONE;
                  dispatch(filesaver, "writeend", event);
                };
                writer.onerror = function () {
                  var error = writer.error;
                  if (error.code !== error.ABORT_ERR) {
                    fs_error();
                  }
                };
                "writestart progress write abort".split(" ").forEach(function (event) {
                  writer["on" + event] = filesaver["on" + event];
                });
                writer.write(blob);
                filesaver.abort = function () {
                  writer.abort();
                  filesaver.readyState = filesaver.DONE;
                };
                filesaver.readyState = filesaver.WRITING;
              }), fs_error);
            }), fs_error);
          };
          dir.getFile(name, {
            create: false
          }, abortable(function (file) {
            // delete file if it already exists
            file.remove();
            save();
          }), abortable(function (ex) {
            if (ex.code === ex.NOT_FOUND_ERR) {
              save();
            } else {
              fs_error();
            }
          }));
        }), fs_error);
      }), fs_error);
    },
    FS_proto = FileSaver.prototype,
    saveAs = function saveAs(blob, name) {
      return new FileSaver(blob, name);
    };
  FS_proto.abort = function () {
    var filesaver = this;
    filesaver.readyState = filesaver.DONE;
    dispatch(filesaver, "abort");
  };
  FS_proto.readyState = FS_proto.INIT = 0;
  FS_proto.WRITING = 1;
  FS_proto.DONE = 2;
  FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
  view.addEventListener("unload", process_deletion_queue, false);
  saveAs.unload = function () {
    process_deletion_queue();
    view.removeEventListener("unload", process_deletion_queue, false);
  };
  return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content);
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

var amdDefine = window.define;
if (typeof amdDefine === "undefined" && typeof window.almond !== "undefined" && "define" in window.almond) {
  amdDefine = window.almond.define;
}
if ( true && module !== null) {
  module.exports = saveAs;
} else if (typeof amdDefine !== "undefined" && amdDefine !== null && amdDefine.amd != null) {
  amdDefine("saveAs", [], function () {
    return saveAs;
  });
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/chart.js/dist/Chart.js":
/*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/Chart.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*!
 * Chart.js v2.8.0
 * https://www.chartjs.org
 * (c) 2019 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory(function () {
    try {
      return __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
    } catch (e) {}
  }()) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__], __WEBPACK_AMD_DEFINE_RESULT__ = (function (require) {
    return factory(function () {
      try {
        return __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
      } catch (e) {}
    }());
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

  /* MIT license */

  var conversions = {
    rgb2hsl: rgb2hsl,
    rgb2hsv: rgb2hsv,
    rgb2hwb: rgb2hwb,
    rgb2cmyk: rgb2cmyk,
    rgb2keyword: rgb2keyword,
    rgb2xyz: rgb2xyz,
    rgb2lab: rgb2lab,
    rgb2lch: rgb2lch,
    hsl2rgb: hsl2rgb,
    hsl2hsv: hsl2hsv,
    hsl2hwb: hsl2hwb,
    hsl2cmyk: hsl2cmyk,
    hsl2keyword: hsl2keyword,
    hsv2rgb: hsv2rgb,
    hsv2hsl: hsv2hsl,
    hsv2hwb: hsv2hwb,
    hsv2cmyk: hsv2cmyk,
    hsv2keyword: hsv2keyword,
    hwb2rgb: hwb2rgb,
    hwb2hsl: hwb2hsl,
    hwb2hsv: hwb2hsv,
    hwb2cmyk: hwb2cmyk,
    hwb2keyword: hwb2keyword,
    cmyk2rgb: cmyk2rgb,
    cmyk2hsl: cmyk2hsl,
    cmyk2hsv: cmyk2hsv,
    cmyk2hwb: cmyk2hwb,
    cmyk2keyword: cmyk2keyword,
    keyword2rgb: keyword2rgb,
    keyword2hsl: keyword2hsl,
    keyword2hsv: keyword2hsv,
    keyword2hwb: keyword2hwb,
    keyword2cmyk: keyword2cmyk,
    keyword2lab: keyword2lab,
    keyword2xyz: keyword2xyz,
    xyz2rgb: xyz2rgb,
    xyz2lab: xyz2lab,
    xyz2lch: xyz2lch,
    lab2xyz: lab2xyz,
    lab2rgb: lab2rgb,
    lab2lch: lab2lch,
    lch2lab: lch2lab,
    lch2xyz: lch2xyz,
    lch2rgb: lch2rgb
  };
  function rgb2hsl(rgb) {
    var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      l;
    if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    l = (min + max) / 2;
    if (max == min) s = 0;else if (l <= 0.5) s = delta / (max + min);else s = delta / (2 - max - min);
    return [h, s * 100, l * 100];
  }
  function rgb2hsv(rgb) {
    var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      delta = max - min,
      h,
      s,
      v;
    if (max == 0) s = 0;else s = delta / max * 1000 / 10;
    if (max == min) h = 0;else if (r == max) h = (g - b) / delta;else if (g == max) h = 2 + (b - r) / delta;else if (b == max) h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0) h += 360;
    v = max / 255 * 1000 / 10;
    return [h, s, v];
  }
  function rgb2hwb(rgb) {
    var r = rgb[0],
      g = rgb[1],
      b = rgb[2],
      h = rgb2hsl(rgb)[0],
      w = 1 / 255 * Math.min(r, Math.min(g, b)),
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  }
  function rgb2cmyk(rgb) {
    var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255,
      c,
      m,
      y,
      k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  }
  function rgb2keyword(rgb) {
    return reverseKeywords[JSON.stringify(rgb)];
  }
  function rgb2xyz(rgb) {
    var r = rgb[0] / 255,
      g = rgb[1] / 255,
      b = rgb[2] / 255;

    // assume sRGB
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  }
  function rgb2lab(rgb) {
    var xyz = rgb2xyz(rgb),
      x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  }
  function rgb2lch(args) {
    return lab2lch(rgb2lab(args));
  }
  function hsl2rgb(hsl) {
    var h = hsl[0] / 360,
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      t1,
      t2,
      t3,
      rgb,
      val;
    if (s == 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) t2 = l * (1 + s);else t2 = l + s - l * s;
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      t3 < 0 && t3++;
      t3 > 1 && t3--;
      if (6 * t3 < 1) val = t1 + (t2 - t1) * 6 * t3;else if (2 * t3 < 1) val = t2;else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;else val = t1;
      rgb[i] = val * 255;
    }
    return rgb;
  }
  function hsl2hsv(hsl) {
    var h = hsl[0],
      s = hsl[1] / 100,
      l = hsl[2] / 100,
      sv,
      v;
    if (l === 0) {
      // no need to do calc on black
      // also avoids divide by 0 error
      return [0, 0, 0];
    }
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    v = (l + s) / 2;
    sv = 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  }
  function hsl2hwb(args) {
    return rgb2hwb(hsl2rgb(args));
  }
  function hsl2cmyk(args) {
    return rgb2cmyk(hsl2rgb(args));
  }
  function hsl2keyword(args) {
    return rgb2keyword(hsl2rgb(args));
  }
  function hsv2rgb(hsv) {
    var h = hsv[0] / 60,
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      hi = Math.floor(h) % 6;
    var f = h - Math.floor(h),
      p = 255 * v * (1 - s),
      q = 255 * v * (1 - s * f),
      t = 255 * v * (1 - s * (1 - f)),
      v = 255 * v;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  }
  function hsv2hsl(hsv) {
    var h = hsv[0],
      s = hsv[1] / 100,
      v = hsv[2] / 100,
      sl,
      l;
    l = (2 - s) * v;
    sl = s * v;
    sl /= l <= 1 ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }
  function hsv2hwb(args) {
    return rgb2hwb(hsv2rgb(args));
  }
  function hsv2cmyk(args) {
    return rgb2cmyk(hsv2rgb(args));
  }
  function hsv2keyword(args) {
    return rgb2keyword(hsv2rgb(args));
  }

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  function hwb2rgb(hwb) {
    var h = hwb[0] / 360,
      wh = hwb[1] / 100,
      bl = hwb[2] / 100,
      ratio = wh + bl,
      i,
      v,
      f,
      n;

    // wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) != 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh); // linear interpolation

    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  }
  function hwb2hsl(args) {
    return rgb2hsl(hwb2rgb(args));
  }
  function hwb2hsv(args) {
    return rgb2hsv(hwb2rgb(args));
  }
  function hwb2cmyk(args) {
    return rgb2cmyk(hwb2rgb(args));
  }
  function hwb2keyword(args) {
    return rgb2keyword(hwb2rgb(args));
  }
  function cmyk2rgb(cmyk) {
    var c = cmyk[0] / 100,
      m = cmyk[1] / 100,
      y = cmyk[2] / 100,
      k = cmyk[3] / 100,
      r,
      g,
      b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  }
  function cmyk2hsl(args) {
    return rgb2hsl(cmyk2rgb(args));
  }
  function cmyk2hsv(args) {
    return rgb2hsv(cmyk2rgb(args));
  }
  function cmyk2hwb(args) {
    return rgb2hwb(cmyk2rgb(args));
  }
  function cmyk2keyword(args) {
    return rgb2keyword(cmyk2rgb(args));
  }
  function xyz2rgb(xyz) {
    var x = xyz[0] / 100,
      y = xyz[1] / 100,
      z = xyz[2] / 100,
      r,
      g,
      b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.2040 + z * 1.0570;

    // assume sRGB
    r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
    g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
    b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  }
  function xyz2lab(xyz) {
    var x = xyz[0],
      y = xyz[1],
      z = xyz[2],
      l,
      a,
      b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  }
  function xyz2lch(args) {
    return lab2lch(xyz2lab(args));
  }
  function lab2xyz(lab) {
    var l = lab[0],
      a = lab[1],
      b = lab[2],
      x,
      y,
      z,
      y2;
    if (l <= 8) {
      y = l * 100 / 903.3;
      y2 = 7.787 * (y / 100) + 16 / 116;
    } else {
      y = 100 * Math.pow((l + 16) / 116, 3);
      y2 = Math.pow(y / 100, 1 / 3);
    }
    x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
    z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
    return [x, y, z];
  }
  function lab2lch(lab) {
    var l = lab[0],
      a = lab[1],
      b = lab[2],
      hr,
      h,
      c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  }
  function lab2rgb(args) {
    return xyz2rgb(lab2xyz(args));
  }
  function lch2lab(lch) {
    var l = lch[0],
      c = lch[1],
      h = lch[2],
      a,
      b,
      hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  }
  function lch2xyz(args) {
    return lab2xyz(lch2lab(args));
  }
  function lch2rgb(args) {
    return lab2rgb(lch2lab(args));
  }
  function keyword2rgb(keyword) {
    return cssKeywords[keyword];
  }
  function keyword2hsl(args) {
    return rgb2hsl(keyword2rgb(args));
  }
  function keyword2hsv(args) {
    return rgb2hsv(keyword2rgb(args));
  }
  function keyword2hwb(args) {
    return rgb2hwb(keyword2rgb(args));
  }
  function keyword2cmyk(args) {
    return rgb2cmyk(keyword2rgb(args));
  }
  function keyword2lab(args) {
    return rgb2lab(keyword2rgb(args));
  }
  function keyword2xyz(args) {
    return rgb2xyz(keyword2rgb(args));
  }
  var cssKeywords = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
  }
  var convert = function convert() {
    return new Converter();
  };
  for (var func in conversions) {
    // export Raw versions
    convert[func + "Raw"] = function (func) {
      // accept array or plain args
      return function (arg) {
        if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
        return conversions[func](arg);
      };
    }(func);
    var pair = /(\w+)2(\w+)/.exec(func),
      from = pair[1],
      to = pair[2];

    // export rgb2hsl and ["rgb"]["hsl"]
    convert[from] = convert[from] || {};
    convert[from][to] = convert[func] = function (func) {
      return function (arg) {
        if (typeof arg == "number") arg = Array.prototype.slice.call(arguments);
        var val = conversions[func](arg);
        if (typeof val == "string" || val === undefined) return val; // keyword

        for (var i = 0; i < val.length; i++) val[i] = Math.round(val[i]);
        return val;
      };
    }(func);
  }

  /* Converter does lazy conversion and caching */
  var Converter = function Converter() {
    this.convs = {};
  };

  /* Either get the values for a space or
    set the values for a space, depending on args */
  Converter.prototype.routeSpace = function (space, args) {
    var values = args[0];
    if (values === undefined) {
      // color.rgb()
      return this.getValues(space);
    }
    // color.rgb(10, 10, 10)
    if (typeof values == "number") {
      values = Array.prototype.slice.call(args);
    }
    return this.setValues(space, values);
  };

  /* Set the values for a space, invalidating cache */
  Converter.prototype.setValues = function (space, values) {
    this.space = space;
    this.convs = {};
    this.convs[space] = values;
    return this;
  };

  /* Get the values for a space. If there's already
    a conversion for the space, fetch it, otherwise
    compute it */
  Converter.prototype.getValues = function (space) {
    var vals = this.convs[space];
    if (!vals) {
      var fspace = this.space,
        from = this.convs[fspace];
      vals = convert[fspace][space](from);
      this.convs[space] = vals;
    }
    return vals;
  };
  ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
    Converter.prototype[space] = function (vals) {
      return this.routeSpace(space, arguments);
    };
  });
  var colorConvert = convert;
  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  /* MIT license */

  var colorString = {
    getRgba: getRgba,
    getHsla: getHsla,
    getRgb: getRgb,
    getHsl: getHsl,
    getHwb: getHwb,
    getAlpha: getAlpha,
    hexString: hexString,
    rgbString: rgbString,
    rgbaString: rgbaString,
    percentString: percentString,
    percentaString: percentaString,
    hslString: hslString,
    hslaString: hslaString,
    hwbString: hwbString,
    keyword: keyword
  };
  function getRgba(string) {
    if (!string) {
      return;
    }
    var abbr = /^#([a-fA-F0-9]{3,4})$/i,
      hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
      rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
      per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
      keyword = /(\w+)/;
    var rgb = [0, 0, 0],
      a = 1,
      match = string.match(abbr),
      hexAlpha = "";
    if (match) {
      match = match[1];
      hexAlpha = match[3];
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }
      if (hexAlpha) {
        a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }
      if (hexAlpha) {
        a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match[i + 1]);
      }
      a = parseFloat(match[4]);
    } else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }
      a = parseFloat(match[4]);
    } else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
        return [0, 0, 0, 0];
      }
      rgb = colorName[match[1]];
      if (!rgb) {
        return;
      }
    }
    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
    }
    if (!a && a != 0) {
      a = 1;
    } else {
      a = scale(a, 0, 1);
    }
    rgb[3] = a;
    return rgb;
  }
  function getHsla(string) {
    if (!string) {
      return;
    }
    var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hsl);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
        s = scale(parseFloat(match[2]), 0, 100),
        l = scale(parseFloat(match[3]), 0, 100),
        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
  }
  function getHwb(string) {
    if (!string) {
      return;
    }
    var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hwb);
    if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
        w = scale(parseFloat(match[2]), 0, 100),
        b = scale(parseFloat(match[3]), 0, 100),
        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
  }
  function getRgb(string) {
    var rgba = getRgba(string);
    return rgba && rgba.slice(0, 3);
  }
  function getHsl(string) {
    var hsla = getHsla(string);
    return hsla && hsla.slice(0, 3);
  }
  function getAlpha(string) {
    var vals = getRgba(string);
    if (vals) {
      return vals[3];
    } else if (vals = getHsla(string)) {
      return vals[3];
    } else if (vals = getHwb(string)) {
      return vals[3];
    }
  }

  // generators
  function hexString(rgba, a) {
    var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
  }
  function rgbString(rgba, alpha) {
    if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return rgbaString(rgba, alpha);
    }
    return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
  }
  function rgbaString(rgba, alpha) {
    if (alpha === undefined) {
      alpha = rgba[3] !== undefined ? rgba[3] : 1;
    }
    return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
  }
  function percentString(rgba, alpha) {
    if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return percentaString(rgba, alpha);
    }
    var r = Math.round(rgba[0] / 255 * 100),
      g = Math.round(rgba[1] / 255 * 100),
      b = Math.round(rgba[2] / 255 * 100);
    return "rgb(" + r + "%, " + g + "%, " + b + "%)";
  }
  function percentaString(rgba, alpha) {
    var r = Math.round(rgba[0] / 255 * 100),
      g = Math.round(rgba[1] / 255 * 100),
      b = Math.round(rgba[2] / 255 * 100);
    return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
  }
  function hslString(hsla, alpha) {
    if (alpha < 1 || hsla[3] && hsla[3] < 1) {
      return hslaString(hsla, alpha);
    }
    return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
  }
  function hslaString(hsla, alpha) {
    if (alpha === undefined) {
      alpha = hsla[3] !== undefined ? hsla[3] : 1;
    }
    return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
  }

  // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
  // (hwb have alpha optional & 1 is default value)
  function hwbString(hwb, alpha) {
    if (alpha === undefined) {
      alpha = hwb[3] !== undefined ? hwb[3] : 1;
    }
    return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
  }
  function keyword(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  }

  // helpers
  function scale(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }
  function hexDouble(num) {
    var str = num.toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  }

  //create a list of reverse color names
  var reverseNames = {};
  for (var name in colorName) {
    reverseNames[colorName[name]] = name;
  }

  /* MIT license */

  var Color = function Color(obj) {
    if (obj instanceof Color) {
      return obj;
    }
    if (!(this instanceof Color)) {
      return new Color(obj);
    }
    this.valid = false;
    this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
    };

    // parse Color() argument
    var vals;
    if (typeof obj === 'string') {
      vals = colorString.getRgba(obj);
      if (vals) {
        this.setValues('rgb', vals);
      } else if (vals = colorString.getHsla(obj)) {
        this.setValues('hsl', vals);
      } else if (vals = colorString.getHwb(obj)) {
        this.setValues('hwb', vals);
      }
    } else if (_typeof(obj) === 'object') {
      vals = obj;
      if (vals.r !== undefined || vals.red !== undefined) {
        this.setValues('rgb', vals);
      } else if (vals.l !== undefined || vals.lightness !== undefined) {
        this.setValues('hsl', vals);
      } else if (vals.v !== undefined || vals.value !== undefined) {
        this.setValues('hsv', vals);
      } else if (vals.w !== undefined || vals.whiteness !== undefined) {
        this.setValues('hwb', vals);
      } else if (vals.c !== undefined || vals.cyan !== undefined) {
        this.setValues('cmyk', vals);
      }
    }
  };
  Color.prototype = {
    isValid: function isValid() {
      return this.valid;
    },
    rgb: function rgb() {
      return this.setSpace('rgb', arguments);
    },
    hsl: function hsl() {
      return this.setSpace('hsl', arguments);
    },
    hsv: function hsv() {
      return this.setSpace('hsv', arguments);
    },
    hwb: function hwb() {
      return this.setSpace('hwb', arguments);
    },
    cmyk: function cmyk() {
      return this.setSpace('cmyk', arguments);
    },
    rgbArray: function rgbArray() {
      return this.values.rgb;
    },
    hslArray: function hslArray() {
      return this.values.hsl;
    },
    hsvArray: function hsvArray() {
      return this.values.hsv;
    },
    hwbArray: function hwbArray() {
      var values = this.values;
      if (values.alpha !== 1) {
        return values.hwb.concat([values.alpha]);
      }
      return values.hwb;
    },
    cmykArray: function cmykArray() {
      return this.values.cmyk;
    },
    rgbaArray: function rgbaArray() {
      var values = this.values;
      return values.rgb.concat([values.alpha]);
    },
    hslaArray: function hslaArray() {
      var values = this.values;
      return values.hsl.concat([values.alpha]);
    },
    alpha: function alpha(val) {
      if (val === undefined) {
        return this.values.alpha;
      }
      this.setValues('alpha', val);
      return this;
    },
    red: function red(val) {
      return this.setChannel('rgb', 0, val);
    },
    green: function green(val) {
      return this.setChannel('rgb', 1, val);
    },
    blue: function blue(val) {
      return this.setChannel('rgb', 2, val);
    },
    hue: function hue(val) {
      if (val) {
        val %= 360;
        val = val < 0 ? 360 + val : val;
      }
      return this.setChannel('hsl', 0, val);
    },
    saturation: function saturation(val) {
      return this.setChannel('hsl', 1, val);
    },
    lightness: function lightness(val) {
      return this.setChannel('hsl', 2, val);
    },
    saturationv: function saturationv(val) {
      return this.setChannel('hsv', 1, val);
    },
    whiteness: function whiteness(val) {
      return this.setChannel('hwb', 1, val);
    },
    blackness: function blackness(val) {
      return this.setChannel('hwb', 2, val);
    },
    value: function value(val) {
      return this.setChannel('hsv', 2, val);
    },
    cyan: function cyan(val) {
      return this.setChannel('cmyk', 0, val);
    },
    magenta: function magenta(val) {
      return this.setChannel('cmyk', 1, val);
    },
    yellow: function yellow(val) {
      return this.setChannel('cmyk', 2, val);
    },
    black: function black(val) {
      return this.setChannel('cmyk', 3, val);
    },
    hexString: function hexString() {
      return colorString.hexString(this.values.rgb);
    },
    rgbString: function rgbString() {
      return colorString.rgbString(this.values.rgb, this.values.alpha);
    },
    rgbaString: function rgbaString() {
      return colorString.rgbaString(this.values.rgb, this.values.alpha);
    },
    percentString: function percentString() {
      return colorString.percentString(this.values.rgb, this.values.alpha);
    },
    hslString: function hslString() {
      return colorString.hslString(this.values.hsl, this.values.alpha);
    },
    hslaString: function hslaString() {
      return colorString.hslaString(this.values.hsl, this.values.alpha);
    },
    hwbString: function hwbString() {
      return colorString.hwbString(this.values.hwb, this.values.alpha);
    },
    keyword: function keyword() {
      return colorString.keyword(this.values.rgb, this.values.alpha);
    },
    rgbNumber: function rgbNumber() {
      var rgb = this.values.rgb;
      return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
    },
    luminosity: function luminosity() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];
      for (var i = 0; i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function contrast(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();
      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }
      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function level(color2) {
      var contrastRatio = this.contrast(color2);
      if (contrastRatio >= 7.1) {
        return 'AAA';
      }
      return contrastRatio >= 4.5 ? 'AA' : '';
    },
    dark: function dark() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    light: function light() {
      return !this.dark();
    },
    negate: function negate() {
      var rgb = [];
      for (var i = 0; i < 3; i++) {
        rgb[i] = 255 - this.values.rgb[i];
      }
      this.setValues('rgb', rgb);
      return this;
    },
    lighten: function lighten(ratio) {
      var hsl = this.values.hsl;
      hsl[2] += hsl[2] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    darken: function darken(ratio) {
      var hsl = this.values.hsl;
      hsl[2] -= hsl[2] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    saturate: function saturate(ratio) {
      var hsl = this.values.hsl;
      hsl[1] += hsl[1] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    desaturate: function desaturate(ratio) {
      var hsl = this.values.hsl;
      hsl[1] -= hsl[1] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    whiten: function whiten(ratio) {
      var hwb = this.values.hwb;
      hwb[1] += hwb[1] * ratio;
      this.setValues('hwb', hwb);
      return this;
    },
    blacken: function blacken(ratio) {
      var hwb = this.values.hwb;
      hwb[2] += hwb[2] * ratio;
      this.setValues('hwb', hwb);
      return this;
    },
    greyscale: function greyscale() {
      var rgb = this.values.rgb;
      // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues('rgb', [val, val, val]);
      return this;
    },
    clearer: function clearer(ratio) {
      var alpha = this.values.alpha;
      this.setValues('alpha', alpha - alpha * ratio);
      return this;
    },
    opaquer: function opaquer(ratio) {
      var alpha = this.values.alpha;
      this.setValues('alpha', alpha + alpha * ratio);
      return this;
    },
    rotate: function rotate(degrees) {
      var hsl = this.values.hsl;
      var hue = (hsl[0] + degrees) % 360;
      hsl[0] = hue < 0 ? 360 + hue : hue;
      this.setValues('hsl', hsl);
      return this;
    },
    /**
     * Ported from sass implementation in C
     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
     */
    mix: function mix(mixinColor, weight) {
      var color1 = this;
      var color2 = mixinColor;
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      var w2 = 1 - w1;
      return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
    },
    toJSON: function toJSON() {
      return this.rgb();
    },
    clone: function clone() {
      // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
      // making the final build way to big to embed in Chart.js. So let's do it manually,
      // assuming that values to clone are 1 dimension arrays containing only numbers,
      // except 'alpha' which is a number.
      var result = new Color();
      var source = this.values;
      var target = result.values;
      var value, type;
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          value = source[prop];
          type = {}.toString.call(value);
          if (type === '[object Array]') {
            target[prop] = value.slice(0);
          } else if (type === '[object Number]') {
            target[prop] = value;
          } else {
            console.error('unexpected color value:', value);
          }
        }
      }
      return result;
    }
  };
  Color.prototype.spaces = {
    rgb: ['red', 'green', 'blue'],
    hsl: ['hue', 'saturation', 'lightness'],
    hsv: ['hue', 'saturation', 'value'],
    hwb: ['hue', 'whiteness', 'blackness'],
    cmyk: ['cyan', 'magenta', 'yellow', 'black']
  };
  Color.prototype.maxes = {
    rgb: [255, 255, 255],
    hsl: [360, 100, 100],
    hsv: [360, 100, 100],
    hwb: [360, 100, 100],
    cmyk: [100, 100, 100, 100]
  };
  Color.prototype.getValues = function (space) {
    var values = this.values;
    var vals = {};
    for (var i = 0; i < space.length; i++) {
      vals[space.charAt(i)] = values[space][i];
    }
    if (values.alpha !== 1) {
      vals.a = values.alpha;
    }

    // {r: 255, g: 255, b: 255, a: 0.4}
    return vals;
  };
  Color.prototype.setValues = function (space, vals) {
    var values = this.values;
    var spaces = this.spaces;
    var maxes = this.maxes;
    var alpha = 1;
    var i;
    this.valid = true;
    if (space === 'alpha') {
      alpha = vals;
    } else if (vals.length) {
      // [10, 10, 10]
      values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
    } else if (vals[space.charAt(0)] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (i = 0; i < space.length; i++) {
        values[space][i] = vals[space.charAt(i)];
      }
      alpha = vals.a;
    } else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];
      for (i = 0; i < space.length; i++) {
        values[space][i] = vals[chans[i]];
      }
      alpha = vals.alpha;
    }
    values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));
    if (space === 'alpha') {
      return false;
    }
    var capped;

    // cap values of the space prior converting all values
    for (i = 0; i < space.length; i++) {
      capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
      values[space][i] = Math.round(capped);
    }

    // convert to all the other color spaces
    for (var sname in spaces) {
      if (sname !== space) {
        values[sname] = colorConvert[space][sname](values[space]);
      }
    }
    return true;
  };
  Color.prototype.setSpace = function (space, args) {
    var vals = args[0];
    if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
    }

    // color.rgb(10, 10, 10)
    if (typeof vals === 'number') {
      vals = Array.prototype.slice.call(args);
    }
    this.setValues(space, vals);
    return this;
  };
  Color.prototype.setChannel = function (space, index, val) {
    var svalues = this.values[space];
    if (val === undefined) {
      // color.red()
      return svalues[index];
    } else if (val === svalues[index]) {
      // color.red(color.red())
      return this;
    }

    // color.red(100)
    svalues[index] = val;
    this.setValues(space, svalues);
    return this;
  };
  if (typeof window !== 'undefined') {
    window.Color = Color;
  }
  var chartjsColor = Color;

  /**
   * @namespace Chart.helpers
   */
  var helpers = {
    /**
     * An empty function that can be used, for example, for optional callback.
     */
    noop: function noop() {},
    /**
     * Returns a unique id, sequentially generated from a global variable.
     * @returns {number}
     * @function
     */
    uid: function () {
      var id = 0;
      return function () {
        return id++;
      };
    }(),
    /**
     * Returns true if `value` is neither null nor undefined, else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @since 2.7.0
     */
    isNullOrUndef: function isNullOrUndef(value) {
      return value === null || typeof value === 'undefined';
    },
    /**
     * Returns true if `value` is an array (including typed arrays), else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @function
     */
    isArray: function isArray(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }
      var type = Object.prototype.toString.call(value);
      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
        return true;
      }
      return false;
    },
    /**
     * Returns true if `value` is an object (excluding null), else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @since 2.7.0
     */
    isObject: function isObject(value) {
      return value !== null && Object.prototype.toString.call(value) === '[object Object]';
    },
    /**
     * Returns true if `value` is a finite number, else returns false
     * @param {*} value  - The value to test.
     * @returns {boolean}
     */
    isFinite: function (_isFinite) {
      function isFinite(_x) {
        return _isFinite.apply(this, arguments);
      }
      isFinite.toString = function () {
        return _isFinite.toString();
      };
      return isFinite;
    }(function (value) {
      return (typeof value === 'number' || value instanceof Number) && isFinite(value);
    }),
    /**
     * Returns `value` if defined, else returns `defaultValue`.
     * @param {*} value - The value to return if defined.
     * @param {*} defaultValue - The value to return if `value` is undefined.
     * @returns {*}
     */
    valueOrDefault: function valueOrDefault(value, defaultValue) {
      return typeof value === 'undefined' ? defaultValue : value;
    },
    /**
     * Returns value at the given `index` in array if defined, else returns `defaultValue`.
     * @param {Array} value - The array to lookup for value at `index`.
     * @param {number} index - The index in `value` to lookup for value.
     * @param {*} defaultValue - The value to return if `value[index]` is undefined.
     * @returns {*}
     */
    valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
      return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
    },
    /**
     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
     * value returned by `fn`. If `fn` is not a function, this method returns undefined.
     * @param {function} fn - The function to call.
     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @returns {*}
     */
    callback: function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
      }
    },
    /**
     * Note(SB) for performance sake, this method should only be used when loopable type
     * is unknown or in none intensive code (not called often and small loopable). Else
     * it's preferable to use a regular for() loop and save extra function calls.
     * @param {object|Array} loopable - The object or array to be iterated.
     * @param {function} fn - The function to call for each item.
     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @param {boolean} [reverse] - If true, iterates backward on the loopable.
     */
    each: function each(loopable, fn, thisArg, reverse) {
      var i, len, keys;
      if (helpers.isArray(loopable)) {
        len = loopable.length;
        if (reverse) {
          for (i = len - 1; i >= 0; i--) {
            fn.call(thisArg, loopable[i], i);
          }
        } else {
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[i], i);
          }
        }
      } else if (helpers.isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
      }
    },
    /**
     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
     * @see https://stackoverflow.com/a/14853974
     * @param {Array} a0 - The array to compare
     * @param {Array} a1 - The array to compare
     * @returns {boolean}
     */
    arrayEquals: function arrayEquals(a0, a1) {
      var i, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }
      for (i = 0, ilen = a0.length; i < ilen; ++i) {
        v0 = a0[i];
        v1 = a1[i];
        if (v0 instanceof Array && v1 instanceof Array) {
          if (!helpers.arrayEquals(v0, v1)) {
            return false;
          }
        } else if (v0 !== v1) {
          // NOTE: two different object instances will never be equal: {x:20} != {x:20}
          return false;
        }
      }
      return true;
    },
    /**
     * Returns a deep copy of `source` without keeping references on objects and arrays.
     * @param {*} source - The value to clone.
     * @returns {*}
     */
    clone: function clone(source) {
      if (helpers.isArray(source)) {
        return source.map(helpers.clone);
      }
      if (helpers.isObject(source)) {
        var target = {};
        var keys = Object.keys(source);
        var klen = keys.length;
        var k = 0;
        for (; k < klen; ++k) {
          target[keys[k]] = helpers.clone(source[keys[k]]);
        }
        return target;
      }
      return source;
    },
    /**
     * The default merger when Chart.helpers.merge is called without merger option.
     * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
     * @private
     */
    _merger: function _merger(key, target, source, options) {
      var tval = target[key];
      var sval = source[key];
      if (helpers.isObject(tval) && helpers.isObject(sval)) {
        helpers.merge(tval, sval, options);
      } else {
        target[key] = helpers.clone(sval);
      }
    },
    /**
     * Merges source[key] in target[key] only if target[key] is undefined.
     * @private
     */
    _mergerIf: function _mergerIf(key, target, source) {
      var tval = target[key];
      var sval = source[key];
      if (helpers.isObject(tval) && helpers.isObject(sval)) {
        helpers.mergeIf(tval, sval);
      } else if (!target.hasOwnProperty(key)) {
        target[key] = helpers.clone(sval);
      }
    },
    /**
     * Recursively deep copies `source` properties into `target` with the given `options`.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {object} target - The target object in which all sources are merged into.
     * @param {object|object[]} source - Object(s) to merge into `target`.
     * @param {object} [options] - Merging options:
     * @param {function} [options.merger] - The merge method (key, target, source, options)
     * @returns {object} The `target` object.
     */
    merge: function merge(target, source, options) {
      var sources = helpers.isArray(source) ? source : [source];
      var ilen = sources.length;
      var merge, i, keys, klen, k;
      if (!helpers.isObject(target)) {
        return target;
      }
      options = options || {};
      merge = options.merger || helpers._merger;
      for (i = 0; i < ilen; ++i) {
        source = sources[i];
        if (!helpers.isObject(source)) {
          continue;
        }
        keys = Object.keys(source);
        for (k = 0, klen = keys.length; k < klen; ++k) {
          merge(keys[k], target, source, options);
        }
      }
      return target;
    },
    /**
     * Recursively deep copies `source` properties into `target` *only* if not defined in target.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {object} target - The target object in which all sources are merged into.
     * @param {object|object[]} source - Object(s) to merge into `target`.
     * @returns {object} The `target` object.
     */
    mergeIf: function mergeIf(target, source) {
      return helpers.merge(target, source, {
        merger: helpers._mergerIf
      });
    },
    /**
     * Applies the contents of two or more objects together into the first object.
     * @param {object} target - The target object in which all objects are merged into.
     * @param {object} arg1 - Object containing additional properties to merge in target.
     * @param {object} argN - Additional objects containing properties to merge in target.
     * @returns {object} The `target` object.
     */
    extend: function extend(target) {
      var setFn = function setFn(value, key) {
        target[key] = value;
      };
      for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
        helpers.each(arguments[i], setFn);
      }
      return target;
    },
    /**
     * Basic javascript inheritance based on the model created in Backbone.js
     */
    inherits: function inherits(extensions) {
      var me = this;
      var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
        return me.apply(this, arguments);
      };
      var Surrogate = function Surrogate() {
        this.constructor = ChartElement;
      };
      Surrogate.prototype = me.prototype;
      ChartElement.prototype = new Surrogate();
      ChartElement.extend = helpers.inherits;
      if (extensions) {
        helpers.extend(ChartElement.prototype, extensions);
      }
      ChartElement.__super__ = me.prototype;
      return ChartElement;
    }
  };
  var helpers_core = helpers;

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.callback instead.
   * @function Chart.helpers.callCallback
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   * @private
   */
  helpers.callCallback = helpers.callback;

  /**
   * Provided for backward compatibility, use Array.prototype.indexOf instead.
   * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
   * @function Chart.helpers.indexOf
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers.indexOf = function (array, item, fromIndex) {
    return Array.prototype.indexOf.call(array, item, fromIndex);
  };

  /**
   * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
   * @function Chart.helpers.getValueOrDefault
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers.getValueOrDefault = helpers.valueOrDefault;

  /**
   * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
   * @function Chart.helpers.getValueAtIndexOrDefault
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

  /**
   * Easing functions adapted from Robert Penner's easing equations.
   * @namespace Chart.helpers.easingEffects
   * @see http://www.robertpenner.com/easing/
   */
  var effects = {
    linear: function linear(t) {
      return t;
    },
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    easeOutQuad: function easeOutQuad(t) {
      return -t * (t - 2);
    },
    easeInOutQuad: function easeInOutQuad(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t;
      }
      return -0.5 * (--t * (t - 2) - 1);
    },
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    easeOutCubic: function easeOutCubic(t) {
      return (t = t - 1) * t * t + 1;
    },
    easeInOutCubic: function easeInOutCubic(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t;
      }
      return 0.5 * ((t -= 2) * t * t + 2);
    },
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    easeOutQuart: function easeOutQuart(t) {
      return -((t = t - 1) * t * t * t - 1);
    },
    easeInOutQuart: function easeInOutQuart(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t * t;
      }
      return -0.5 * ((t -= 2) * t * t * t - 2);
    },
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    easeOutQuint: function easeOutQuint(t) {
      return (t = t - 1) * t * t * t * t + 1;
    },
    easeInOutQuint: function easeInOutQuint(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t * t * t;
      }
      return 0.5 * ((t -= 2) * t * t * t * t + 2);
    },
    easeInSine: function easeInSine(t) {
      return -Math.cos(t * (Math.PI / 2)) + 1;
    },
    easeOutSine: function easeOutSine(t) {
      return Math.sin(t * (Math.PI / 2));
    },
    easeInOutSine: function easeInOutSine(t) {
      return -0.5 * (Math.cos(Math.PI * t) - 1);
    },
    easeInExpo: function easeInExpo(t) {
      return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
    },
    easeOutExpo: function easeOutExpo(t) {
      return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
    },
    easeInOutExpo: function easeInOutExpo(t) {
      if (t === 0) {
        return 0;
      }
      if (t === 1) {
        return 1;
      }
      if ((t /= 0.5) < 1) {
        return 0.5 * Math.pow(2, 10 * (t - 1));
      }
      return 0.5 * (-Math.pow(2, -10 * --t) + 2);
    },
    easeInCirc: function easeInCirc(t) {
      if (t >= 1) {
        return t;
      }
      return -(Math.sqrt(1 - t * t) - 1);
    },
    easeOutCirc: function easeOutCirc(t) {
      return Math.sqrt(1 - (t = t - 1) * t);
    },
    easeInOutCirc: function easeInOutCirc(t) {
      if ((t /= 0.5) < 1) {
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    },
    easeInElastic: function easeInElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;
      if (t === 0) {
        return 0;
      }
      if (t === 1) {
        return 1;
      }
      if (!p) {
        p = 0.3;
      }
      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }
      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
    },
    easeOutElastic: function easeOutElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;
      if (t === 0) {
        return 0;
      }
      if (t === 1) {
        return 1;
      }
      if (!p) {
        p = 0.3;
      }
      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }
      return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
    },
    easeInOutElastic: function easeInOutElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;
      if (t === 0) {
        return 0;
      }
      if ((t /= 0.5) === 2) {
        return 1;
      }
      if (!p) {
        p = 0.45;
      }
      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }
      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      }
      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    easeInBack: function easeInBack(t) {
      var s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack: function easeOutBack(t) {
      var s = 1.70158;
      return (t = t - 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack: function easeInOutBack(t) {
      var s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: function easeInBounce(t) {
      return 1 - effects.easeOutBounce(1 - t);
    },
    easeOutBounce: function easeOutBounce(t) {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      }
      if (t < 2 / 2.75) {
        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      }
      if (t < 2.5 / 2.75) {
        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      }
      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    },
    easeInOutBounce: function easeInOutBounce(t) {
      if (t < 0.5) {
        return effects.easeInBounce(t * 2) * 0.5;
      }
      return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
  };
  var helpers_easing = {
    effects: effects
  };

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
   * @function Chart.helpers.easingEffects
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers_core.easingEffects = effects;
  var PI = Math.PI;
  var RAD_PER_DEG = PI / 180;
  var DOUBLE_PI = PI * 2;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;

  /**
   * @namespace Chart.helpers.canvas
   */
  var exports$1 = {
    /**
     * Clears the entire canvas associated to the given `chart`.
     * @param {Chart} chart - The chart for which to clear the canvas.
     */
    clear: function clear(chart) {
      chart.ctx.clearRect(0, 0, chart.width, chart.height);
    },
    /**
     * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
     * given size (width, height) and the same `radius` for all corners.
     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
     * @param {number} x - The x axis of the coordinate for the rectangle starting point.
     * @param {number} y - The y axis of the coordinate for the rectangle starting point.
     * @param {number} width - The rectangle's width.
     * @param {number} height - The rectangle's height.
     * @param {number} radius - The rounded amount (in pixels) for the four corners.
     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
     */
    roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
      if (radius) {
        var r = Math.min(radius, height / 2, width / 2);
        var left = x + r;
        var top = y + r;
        var right = x + width - r;
        var bottom = y + height - r;
        ctx.moveTo(x, top);
        if (left < right && top < bottom) {
          ctx.arc(left, top, r, -PI, -HALF_PI);
          ctx.arc(right, top, r, -HALF_PI, 0);
          ctx.arc(right, bottom, r, 0, HALF_PI);
          ctx.arc(left, bottom, r, HALF_PI, PI);
        } else if (left < right) {
          ctx.moveTo(left, y);
          ctx.arc(right, top, r, -HALF_PI, HALF_PI);
          ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
        } else if (top < bottom) {
          ctx.arc(left, top, r, -PI, 0);
          ctx.arc(left, bottom, r, 0, PI);
        } else {
          ctx.arc(left, top, r, -PI, PI);
        }
        ctx.closePath();
        ctx.moveTo(x, y);
      } else {
        ctx.rect(x, y, width, height);
      }
    },
    drawPoint: function drawPoint(ctx, style, radius, x, y, rotation) {
      var type, xOffset, yOffset, size, cornerRadius;
      var rad = (rotation || 0) * RAD_PER_DEG;
      if (style && _typeof(style) === 'object') {
        type = style.toString();
        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
          ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
          return;
        }
      }
      if (isNaN(radius) || radius <= 0) {
        return;
      }
      ctx.beginPath();
      switch (style) {
        // Default includes circle
        default:
          ctx.arc(x, y, radius, 0, DOUBLE_PI);
          ctx.closePath();
          break;
        case 'triangle':
          ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          ctx.closePath();
          break;
        case 'rectRounded':
          // NOTE: the rounded rect implementation changed to use `arc` instead of
          // `quadraticCurveTo` since it generates better results when rect is
          // almost a circle. 0.516 (instead of 0.5) produces results with visually
          // closer proportion to the previous impl and it is inscribed in the
          // circle with `radius`. For more details, see the following PRs:
          // https://github.com/chartjs/Chart.js/issues/5597
          // https://github.com/chartjs/Chart.js/issues/5858
          cornerRadius = radius * 0.516;
          size = radius - cornerRadius;
          xOffset = Math.cos(rad + QUARTER_PI) * size;
          yOffset = Math.sin(rad + QUARTER_PI) * size;
          ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
          ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
          ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
          ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
          ctx.closePath();
          break;
        case 'rect':
          if (!rotation) {
            size = Math.SQRT1_2 * radius;
            ctx.rect(x - size, y - size, 2 * size, 2 * size);
            break;
          }
          rad += QUARTER_PI;
        /* falls through */
        case 'rectRot':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + yOffset, y - xOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          ctx.closePath();
          break;
        case 'crossRot':
          rad += QUARTER_PI;
        /* falls through */
        case 'cross':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;
        case 'star':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          rad += QUARTER_PI;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;
        case 'line':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          break;
        case 'dash':
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
          break;
      }
      ctx.fill();
      ctx.stroke();
    },
    /**
     * Returns true if the point is inside the rectangle
     * @param {object} point - The point to test
     * @param {object} area - The rectangle
     * @returns {boolean}
     * @private
     */
    _isPointInArea: function _isPointInArea(point, area) {
      var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

      return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
    },
    clipArea: function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    },
    unclipArea: function unclipArea(ctx) {
      ctx.restore();
    },
    lineTo: function lineTo(ctx, previous, target, flip) {
      var stepped = target.steppedLine;
      if (stepped) {
        if (stepped === 'middle') {
          var midpoint = (previous.x + target.x) / 2.0;
          ctx.lineTo(midpoint, flip ? target.y : previous.y);
          ctx.lineTo(midpoint, flip ? previous.y : target.y);
        } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
        return;
      }
      if (!target.tension) {
        ctx.lineTo(target.x, target.y);
        return;
      }
      ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
    }
  };
  var helpers_canvas = exports$1;

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
   * @namespace Chart.helpers.clear
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers_core.clear = exports$1.clear;

  /**
   * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
   * @namespace Chart.helpers.drawRoundedRectangle
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers_core.drawRoundedRectangle = function (ctx) {
    ctx.beginPath();
    exports$1.roundedRect.apply(exports$1, arguments);
  };
  var defaults = {
    /**
     * @private
     */
    _set: function _set(scope, values) {
      return helpers_core.merge(this[scope] || (this[scope] = {}), values);
    }
  };
  defaults._set('global', {
    defaultColor: 'rgba(0,0,0,0.1)',
    defaultFontColor: '#666',
    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
    defaultFontSize: 12,
    defaultFontStyle: 'normal',
    defaultLineHeight: 1.2,
    showLines: true
  });
  var core_defaults = defaults;
  var valueOrDefault = helpers_core.valueOrDefault;

  /**
   * Converts the given font object into a CSS font string.
   * @param {object} font - A font object.
   * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
   * @private
   */
  function toFontString(font) {
    if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
  }

  /**
   * @alias Chart.helpers.options
   * @namespace
   */
  var helpers_options = {
    /**
     * Converts the given line height `value` in pixels for a specific font `size`.
     * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
     * @param {number} size - The font size (in pixels) used to resolve relative `value`.
     * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
     * @since 2.7.0
     */
    toLineHeight: function toLineHeight(value, size) {
      var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      if (!matches || matches[1] === 'normal') {
        return size * 1.2;
      }
      value = +matches[2];
      switch (matches[3]) {
        case 'px':
          return value;
        case '%':
          value /= 100;
          break;
        default:
          break;
      }
      return size * value;
    },
    /**
     * Converts the given value into a padding object with pre-computed width/height.
     * @param {number|object} value - If a number, set the value to all TRBL component,
     *  else, if and object, use defined properties and sets undefined ones to 0.
     * @returns {object} The padding values (top, right, bottom, left, width, height)
     * @since 2.7.0
     */
    toPadding: function toPadding(value) {
      var t, r, b, l;
      if (helpers_core.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }
      return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        height: t + b,
        width: l + r
      };
    },
    /**
     * Parses font options and returns the font object.
     * @param {object} options - A object that contains font options to be parsed.
     * @return {object} The font object.
     * @todo Support font.* options and renamed to toFont().
     * @private
     */
    _parseFont: function _parseFont(options) {
      var globalDefaults = core_defaults.global;
      var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
      var font = {
        family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
        lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
        size: size,
        style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
        weight: null,
        string: ''
      };
      font.string = toFontString(font);
      return font;
    },
    /**
     * Evaluates the given `inputs` sequentially and returns the first defined value.
     * @param {Array} inputs - An array of values, falling back to the last value.
     * @param {object} [context] - If defined and the current value is a function, the value
     * is called with `context` as first argument and the result becomes the new input.
     * @param {number} [index] - If defined and the current value is an array, the value
     * at `index` become the new input.
     * @since 2.7.0
     */
    resolve: function resolve(inputs, context, index) {
      var i, ilen, value;
      for (i = 0, ilen = inputs.length; i < ilen; ++i) {
        value = inputs[i];
        if (value === undefined) {
          continue;
        }
        if (context !== undefined && typeof value === 'function') {
          value = value(context);
        }
        if (index !== undefined && helpers_core.isArray(value)) {
          value = value[index];
        }
        if (value !== undefined) {
          return value;
        }
      }
    }
  };
  var helpers$1 = helpers_core;
  var easing = helpers_easing;
  var canvas = helpers_canvas;
  var options = helpers_options;
  helpers$1.easing = easing;
  helpers$1.canvas = canvas;
  helpers$1.options = options;
  function interpolate(start, view, model, ease) {
    var keys = Object.keys(model);
    var i, ilen, key, actual, origin, target, type, c0, c1;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      target = model[key];

      // if a value is added to the model after pivot() has been called, the view
      // doesn't contain it, so let's initialize the view to the target value.
      if (!view.hasOwnProperty(key)) {
        view[key] = target;
      }
      actual = view[key];
      if (actual === target || key[0] === '_') {
        continue;
      }
      if (!start.hasOwnProperty(key)) {
        start[key] = actual;
      }
      origin = start[key];
      type = _typeof(target);
      if (type === _typeof(origin)) {
        if (type === 'string') {
          c0 = chartjsColor(origin);
          if (c0.valid) {
            c1 = chartjsColor(target);
            if (c1.valid) {
              view[key] = c1.mix(c0, ease).rgbString();
              continue;
            }
          }
        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
          view[key] = origin + (target - origin) * ease;
          continue;
        }
      }
      view[key] = target;
    }
  }
  var Element = function Element(configuration) {
    helpers$1.extend(this, configuration);
    this.initialize.apply(this, arguments);
  };
  helpers$1.extend(Element.prototype, {
    initialize: function initialize() {
      this.hidden = false;
    },
    pivot: function pivot() {
      var me = this;
      if (!me._view) {
        me._view = helpers$1.clone(me._model);
      }
      me._start = {};
      return me;
    },
    transition: function transition(ease) {
      var me = this;
      var model = me._model;
      var start = me._start;
      var view = me._view;

      // No animation -> No Transition
      if (!model || ease === 1) {
        me._view = model;
        me._start = null;
        return me;
      }
      if (!view) {
        view = me._view = {};
      }
      if (!start) {
        start = me._start = {};
      }
      interpolate(start, view, model, ease);
      return me;
    },
    tooltipPosition: function tooltipPosition() {
      return {
        x: this._model.x,
        y: this._model.y
      };
    },
    hasValue: function hasValue() {
      return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
    }
  });
  Element.extend = helpers$1.inherits;
  var core_element = Element;
  var exports$2 = core_element.extend({
    chart: null,
    // the animation associated chart instance
    currentStep: 0,
    // the current animation step
    numSteps: 60,
    // default number of steps
    easing: '',
    // the easing to use for this animation
    render: null,
    // render function used by the animation service

    onAnimationProgress: null,
    // user specified callback to fire on each step of the animation
    onAnimationComplete: null // user specified callback to fire when the animation finishes
  });
  var core_animation = exports$2;

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.Animation instead
   * @prop Chart.Animation#animationObject
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   */
  Object.defineProperty(exports$2.prototype, 'animationObject', {
    get: function get() {
      return this;
    }
  });

  /**
   * Provided for backward compatibility, use Chart.Animation#chart instead
   * @prop Chart.Animation#chartInstance
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   */
  Object.defineProperty(exports$2.prototype, 'chartInstance', {
    get: function get() {
      return this.chart;
    },
    set: function set(value) {
      this.chart = value;
    }
  });
  core_defaults._set('global', {
    animation: {
      duration: 1000,
      easing: 'easeOutQuart',
      onProgress: helpers$1.noop,
      onComplete: helpers$1.noop
    }
  });
  var core_animations = {
    animations: [],
    request: null,
    /**
     * @param {Chart} chart - The chart to animate.
     * @param {Chart.Animation} animation - The animation that we will animate.
     * @param {number} duration - The animation duration in ms.
     * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
     */
    addAnimation: function addAnimation(chart, animation, duration, lazy) {
      var animations = this.animations;
      var i, ilen;
      animation.chart = chart;
      animation.startTime = Date.now();
      animation.duration = duration;
      if (!lazy) {
        chart.animating = true;
      }
      for (i = 0, ilen = animations.length; i < ilen; ++i) {
        if (animations[i].chart === chart) {
          animations[i] = animation;
          return;
        }
      }
      animations.push(animation);

      // If there are no animations queued, manually kickstart a digest, for lack of a better word
      if (animations.length === 1) {
        this.requestAnimationFrame();
      }
    },
    cancelAnimation: function cancelAnimation(chart) {
      var index = helpers$1.findIndex(this.animations, function (animation) {
        return animation.chart === chart;
      });
      if (index !== -1) {
        this.animations.splice(index, 1);
        chart.animating = false;
      }
    },
    requestAnimationFrame: function requestAnimationFrame() {
      var me = this;
      if (me.request === null) {
        // Skip animation frame requests until the active one is executed.
        // This can happen when processing mouse events, e.g. 'mousemove'
        // and 'mouseout' events will trigger multiple renders.
        me.request = helpers$1.requestAnimFrame.call(window, function () {
          me.request = null;
          me.startDigest();
        });
      }
    },
    /**
     * @private
     */
    startDigest: function startDigest() {
      var me = this;
      me.advance();

      // Do we have more stuff to animate?
      if (me.animations.length > 0) {
        me.requestAnimationFrame();
      }
    },
    /**
     * @private
     */
    advance: function advance() {
      var animations = this.animations;
      var animation, chart, numSteps, nextStep;
      var i = 0;

      // 1 animation per chart, so we are looping charts here
      while (i < animations.length) {
        animation = animations[i];
        chart = animation.chart;
        numSteps = animation.numSteps;

        // Make sure that currentStep starts at 1
        // https://github.com/chartjs/Chart.js/issues/6104
        nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
        animation.currentStep = Math.min(nextStep, numSteps);
        helpers$1.callback(animation.render, [chart, animation], chart);
        helpers$1.callback(animation.onAnimationProgress, [animation], chart);
        if (animation.currentStep >= numSteps) {
          helpers$1.callback(animation.onAnimationComplete, [animation], chart);
          chart.animating = false;
          animations.splice(i, 1);
        } else {
          ++i;
        }
      }
    }
  };
  var resolve = helpers$1.options.resolve;
  var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

  /**
   * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
   * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
   * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
   */
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, '_chartjs', {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach(function (key) {
      var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
      var base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value: function value() {
          var args = Array.prototype.slice.call(arguments);
          var res = base.apply(this, args);
          helpers$1.each(array._chartjs.listeners, function (object) {
            if (typeof object[method] === 'function') {
              object[method].apply(object, args);
            }
          });
          return res;
        }
      });
    });
  }

  /**
   * Removes the given array event listener and cleanup extra attached properties (such as
   * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
   */
  function unlistenArrayEvents(array, listener) {
    var stub = array._chartjs;
    if (!stub) {
      return;
    }
    var listeners = stub.listeners;
    var index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach(function (key) {
      delete array[key];
    });
    delete array._chartjs;
  }

  // Base class for all dataset controllers (line, bar, etc)
  var DatasetController = function DatasetController(chart, datasetIndex) {
    this.initialize(chart, datasetIndex);
  };
  helpers$1.extend(DatasetController.prototype, {
    /**
     * Element type used to generate a meta dataset (e.g. Chart.element.Line).
     * @type {Chart.core.element}
     */
    datasetElementType: null,
    /**
     * Element type used to generate a meta data (e.g. Chart.element.Point).
     * @type {Chart.core.element}
     */
    dataElementType: null,
    initialize: function initialize(chart, datasetIndex) {
      var me = this;
      me.chart = chart;
      me.index = datasetIndex;
      me.linkScales();
      me.addElements();
    },
    updateIndex: function updateIndex(datasetIndex) {
      this.index = datasetIndex;
    },
    linkScales: function linkScales() {
      var me = this;
      var meta = me.getMeta();
      var dataset = me.getDataset();
      if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
        meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
      }
      if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
        meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
      }
    },
    getDataset: function getDataset() {
      return this.chart.data.datasets[this.index];
    },
    getMeta: function getMeta() {
      return this.chart.getDatasetMeta(this.index);
    },
    getScaleForId: function getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    },
    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().yAxisID;
    },
    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().xAxisID;
    },
    /**
     * @private
     */
    _getValueScale: function _getValueScale() {
      return this.getScaleForId(this._getValueScaleId());
    },
    /**
     * @private
     */
    _getIndexScale: function _getIndexScale() {
      return this.getScaleForId(this._getIndexScaleId());
    },
    reset: function reset() {
      this.update(true);
    },
    /**
     * @private
     */
    destroy: function destroy() {
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
    },
    createMetaDataset: function createMetaDataset() {
      var me = this;
      var type = me.datasetElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index
      });
    },
    createMetaData: function createMetaData(index) {
      var me = this;
      var type = me.dataElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index,
        _index: index
      });
    },
    addElements: function addElements() {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data || [];
      var metaData = meta.data;
      var i, ilen;
      for (i = 0, ilen = data.length; i < ilen; ++i) {
        metaData[i] = metaData[i] || me.createMetaData(i);
      }
      meta.dataset = meta.dataset || me.createMetaDataset();
    },
    addElementAndReset: function addElementAndReset(index) {
      var element = this.createMetaData(index);
      this.getMeta().data.splice(index, 0, element);
      this.updateElement(element, index, true);
    },
    buildOrUpdateElements: function buildOrUpdateElements() {
      var me = this;
      var dataset = me.getDataset();
      var data = dataset.data || (dataset.data = []);

      // In order to correctly handle data addition/deletion animation (an thus simulate
      // real-time charts), we need to monitor these data modifications and synchronize
      // the internal meta data accordingly.
      if (me._data !== data) {
        if (me._data) {
          // This case happens when the user replaced the data array instance.
          unlistenArrayEvents(me._data, me);
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, me);
        }
        me._data = data;
      }

      // Re-sync meta data in case the user replaced the data array or if we missed
      // any updates and so make sure that we handle number of datapoints changing.
      me.resyncElements();
    },
    update: helpers$1.noop,
    transition: function transition(easingValue) {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;
      for (; i < ilen; ++i) {
        elements[i].transition(easingValue);
      }
      if (meta.dataset) {
        meta.dataset.transition(easingValue);
      }
    },
    draw: function draw() {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;
      if (meta.dataset) {
        meta.dataset.draw();
      }
      for (; i < ilen; ++i) {
        elements[i].draw();
      }
    },
    removeHoverStyle: function removeHoverStyle(element) {
      helpers$1.merge(element._model, element.$previousStyle || {});
      delete element.$previousStyle;
    },
    setHoverStyle: function setHoverStyle(element) {
      var dataset = this.chart.data.datasets[element._datasetIndex];
      var index = element._index;
      var custom = element.custom || {};
      var model = element._model;
      var getHoverColor = helpers$1.getHoverColor;
      element.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
      model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
      model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
    },
    /**
     * @private
     */
    resyncElements: function resyncElements() {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data;
      var numMeta = meta.data.length;
      var numData = data.length;
      if (numData < numMeta) {
        meta.data.splice(numData, numMeta - numData);
      } else if (numData > numMeta) {
        me.insertElements(numMeta, numData - numMeta);
      }
    },
    /**
     * @private
     */
    insertElements: function insertElements(start, count) {
      for (var i = 0; i < count; ++i) {
        this.addElementAndReset(start + i);
      }
    },
    /**
     * @private
     */
    onDataPush: function onDataPush() {
      var count = arguments.length;
      this.insertElements(this.getDataset().data.length - count, count);
    },
    /**
     * @private
     */
    onDataPop: function onDataPop() {
      this.getMeta().data.pop();
    },
    /**
     * @private
     */
    onDataShift: function onDataShift() {
      this.getMeta().data.shift();
    },
    /**
     * @private
     */
    onDataSplice: function onDataSplice(start, count) {
      this.getMeta().data.splice(start, count);
      this.insertElements(start, arguments.length - 2);
    },
    /**
     * @private
     */
    onDataUnshift: function onDataUnshift() {
      this.insertElements(0, arguments.length);
    }
  });
  DatasetController.extend = helpers$1.inherits;
  var core_datasetController = DatasetController;
  core_defaults._set('global', {
    elements: {
      arc: {
        backgroundColor: core_defaults.global.defaultColor,
        borderColor: '#fff',
        borderWidth: 2,
        borderAlign: 'center'
      }
    }
  });
  var element_arc = core_element.extend({
    inLabelRange: function inLabelRange(mouseX) {
      var vm = this._view;
      if (vm) {
        return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
      }
      return false;
    },
    inRange: function inRange(chartX, chartY) {
      var vm = this._view;
      if (vm) {
        var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
          x: chartX,
          y: chartY
        });
        var angle = pointRelativePosition.angle;
        var distance = pointRelativePosition.distance;

        // Sanitise angle range
        var startAngle = vm.startAngle;
        var endAngle = vm.endAngle;
        while (endAngle < startAngle) {
          endAngle += 2.0 * Math.PI;
        }
        while (angle > endAngle) {
          angle -= 2.0 * Math.PI;
        }
        while (angle < startAngle) {
          angle += 2.0 * Math.PI;
        }

        // Check if within the range of the open/close angle
        var betweenAngles = angle >= startAngle && angle <= endAngle;
        var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
        return betweenAngles && withinRadius;
      }
      return false;
    },
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      var halfAngle = (vm.startAngle + vm.endAngle) / 2;
      var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
      return {
        x: vm.x + Math.cos(halfAngle) * halfRadius,
        y: vm.y + Math.sin(halfAngle) * halfRadius
      };
    },
    getArea: function getArea() {
      var vm = this._view;
      return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
      var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
      return {
        x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
        y: vm.y + Math.sin(centreAngle) * rangeFromCentre
      };
    },
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var sA = vm.startAngle;
      var eA = vm.endAngle;
      var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
      var angleMargin;
      ctx.save();
      ctx.beginPath();
      ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
      ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
      ctx.closePath();
      ctx.fillStyle = vm.backgroundColor;
      ctx.fill();
      if (vm.borderWidth) {
        if (vm.borderAlign === 'inner') {
          // Draw an inner border by cliping the arc and drawing a double-width border
          // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
          ctx.beginPath();
          angleMargin = pixelMargin / vm.outerRadius;
          ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);
          if (vm.innerRadius > pixelMargin) {
            angleMargin = pixelMargin / vm.innerRadius;
            ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
          } else {
            ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
          }
          ctx.closePath();
          ctx.clip();
          ctx.beginPath();
          ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
          ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
          ctx.closePath();
          ctx.lineWidth = vm.borderWidth * 2;
          ctx.lineJoin = 'round';
        } else {
          ctx.lineWidth = vm.borderWidth;
          ctx.lineJoin = 'bevel';
        }
        ctx.strokeStyle = vm.borderColor;
        ctx.stroke();
      }
      ctx.restore();
    }
  });
  var valueOrDefault$1 = helpers$1.valueOrDefault;
  var defaultColor = core_defaults.global.defaultColor;
  core_defaults._set('global', {
    elements: {
      line: {
        tension: 0.4,
        backgroundColor: defaultColor,
        borderWidth: 3,
        borderColor: defaultColor,
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0.0,
        borderJoinStyle: 'miter',
        capBezierPoints: true,
        fill: true // do we fill in the area between the line and its base axis
      }
    }
  });
  var element_line = core_element.extend({
    draw: function draw() {
      var me = this;
      var vm = me._view;
      var ctx = me._chart.ctx;
      var spanGaps = vm.spanGaps;
      var points = me._children.slice(); // clone array
      var globalDefaults = core_defaults.global;
      var globalOptionLineElements = globalDefaults.elements.line;
      var lastDrawnIndex = -1;
      var index, current, previous, currentVM;

      // If we are looping, adding the first point again
      if (me._loop && points.length) {
        points.push(points[0]);
      }
      ctx.save();

      // Stroke Line Options
      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

      // IE 9 and 10 do not support line dash
      if (ctx.setLineDash) {
        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
      }
      ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
      ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

      // Stroke Line
      ctx.beginPath();
      lastDrawnIndex = -1;
      for (index = 0; index < points.length; ++index) {
        current = points[index];
        previous = helpers$1.previousItem(points, index);
        currentVM = current._view;

        // First point moves to it's starting position no matter what
        if (index === 0) {
          if (!currentVM.skip) {
            ctx.moveTo(currentVM.x, currentVM.y);
            lastDrawnIndex = index;
          }
        } else {
          previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
          if (!currentVM.skip) {
            if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
              // There was a gap and this is the first point after the gap
              ctx.moveTo(currentVM.x, currentVM.y);
            } else {
              // Line to next point
              helpers$1.canvas.lineTo(ctx, previous._view, current._view);
            }
            lastDrawnIndex = index;
          }
        }
      }
      ctx.stroke();
      ctx.restore();
    }
  });
  var valueOrDefault$2 = helpers$1.valueOrDefault;
  var defaultColor$1 = core_defaults.global.defaultColor;
  core_defaults._set('global', {
    elements: {
      point: {
        radius: 3,
        pointStyle: 'circle',
        backgroundColor: defaultColor$1,
        borderColor: defaultColor$1,
        borderWidth: 1,
        // Hover
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1
      }
    }
  });
  function xRange(mouseX) {
    var vm = this._view;
    return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
  }
  function yRange(mouseY) {
    var vm = this._view;
    return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
  }
  var element_point = core_element.extend({
    inRange: function inRange(mouseX, mouseY) {
      var vm = this._view;
      return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
    },
    inLabelRange: xRange,
    inXRange: xRange,
    inYRange: yRange,
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y
      };
    },
    getArea: function getArea() {
      return Math.PI * Math.pow(this._view.radius, 2);
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y,
        padding: vm.radius + vm.borderWidth
      };
    },
    draw: function draw(chartArea) {
      var vm = this._view;
      var ctx = this._chart.ctx;
      var pointStyle = vm.pointStyle;
      var rotation = vm.rotation;
      var radius = vm.radius;
      var x = vm.x;
      var y = vm.y;
      var globalDefaults = core_defaults.global;
      var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

      if (vm.skip) {
        return;
      }

      // Clipping for Points.
      if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
        ctx.strokeStyle = vm.borderColor || defaultColor;
        ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
        ctx.fillStyle = vm.backgroundColor || defaultColor;
        helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
      }
    }
  });
  var defaultColor$2 = core_defaults.global.defaultColor;
  core_defaults._set('global', {
    elements: {
      rectangle: {
        backgroundColor: defaultColor$2,
        borderColor: defaultColor$2,
        borderSkipped: 'bottom',
        borderWidth: 0
      }
    }
  });
  function isVertical(vm) {
    return vm && vm.width !== undefined;
  }

  /**
   * Helper function to get the bounds of the bar regardless of the orientation
   * @param bar {Chart.Element.Rectangle} the bar
   * @return {Bounds} bounds of the bar
   * @private
   */
  function getBarBounds(vm) {
    var x1, x2, y1, y2, half;
    if (isVertical(vm)) {
      half = vm.width / 2;
      x1 = vm.x - half;
      x2 = vm.x + half;
      y1 = Math.min(vm.y, vm.base);
      y2 = Math.max(vm.y, vm.base);
    } else {
      half = vm.height / 2;
      x1 = Math.min(vm.x, vm.base);
      x2 = Math.max(vm.x, vm.base);
      y1 = vm.y - half;
      y2 = vm.y + half;
    }
    return {
      left: x1,
      top: y1,
      right: x2,
      bottom: y2
    };
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function parseBorderSkipped(vm) {
    var edge = vm.borderSkipped;
    var res = {};
    if (!edge) {
      return res;
    }
    if (vm.horizontal) {
      if (vm.base > vm.x) {
        edge = swap(edge, 'left', 'right');
      }
    } else if (vm.base < vm.y) {
      edge = swap(edge, 'bottom', 'top');
    }
    res[edge] = true;
    return res;
  }
  function parseBorderWidth(vm, maxW, maxH) {
    var value = vm.borderWidth;
    var skip = parseBorderSkipped(vm);
    var t, r, b, l;
    if (helpers$1.isObject(value)) {
      t = +value.top || 0;
      r = +value.right || 0;
      b = +value.bottom || 0;
      l = +value.left || 0;
    } else {
      t = r = b = l = +value || 0;
    }
    return {
      t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
      r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
      b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
      l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
    };
  }
  function boundingRects(vm) {
    var bounds = getBarBounds(vm);
    var width = bounds.right - bounds.left;
    var height = bounds.bottom - bounds.top;
    var border = parseBorderWidth(vm, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b
      }
    };
  }
  function _inRange(vm, x, y) {
    var skipX = x === null;
    var skipY = y === null;
    var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
    return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
  }
  var element_rectangle = core_element.extend({
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var rects = boundingRects(vm);
      var outer = rects.outer;
      var inner = rects.inner;
      ctx.fillStyle = vm.backgroundColor;
      ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
      if (outer.w === inner.w && outer.h === inner.h) {
        return;
      }
      ctx.save();
      ctx.beginPath();
      ctx.rect(outer.x, outer.y, outer.w, outer.h);
      ctx.clip();
      ctx.fillStyle = vm.borderColor;
      ctx.rect(inner.x, inner.y, inner.w, inner.h);
      ctx.fill('evenodd');
      ctx.restore();
    },
    height: function height() {
      var vm = this._view;
      return vm.base - vm.y;
    },
    inRange: function inRange(mouseX, mouseY) {
      return _inRange(this._view, mouseX, mouseY);
    },
    inLabelRange: function inLabelRange(mouseX, mouseY) {
      var vm = this._view;
      return isVertical(vm) ? _inRange(vm, mouseX, null) : _inRange(vm, null, mouseY);
    },
    inXRange: function inXRange(mouseX) {
      return _inRange(this._view, mouseX, null);
    },
    inYRange: function inYRange(mouseY) {
      return _inRange(this._view, null, mouseY);
    },
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      var x, y;
      if (isVertical(vm)) {
        x = vm.x;
        y = (vm.y + vm.base) / 2;
      } else {
        x = (vm.x + vm.base) / 2;
        y = vm.y;
      }
      return {
        x: x,
        y: y
      };
    },
    getArea: function getArea() {
      var vm = this._view;
      return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y
      };
    }
  });
  var elements = {};
  var Arc = element_arc;
  var Line = element_line;
  var Point = element_point;
  var Rectangle = element_rectangle;
  elements.Arc = Arc;
  elements.Line = Line;
  elements.Point = Point;
  elements.Rectangle = Rectangle;
  var resolve$1 = helpers$1.options.resolve;
  core_defaults._set('bar', {
    hover: {
      mode: 'label'
    },
    scales: {
      xAxes: [{
        type: 'category',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        offset: true,
        gridLines: {
          offsetGridLines: true
        }
      }],
      yAxes: [{
        type: 'linear'
      }]
    }
  });

  /**
   * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
   * @private
   */
  function computeMinSampleSize(scale, pixels) {
    var min = scale.isHorizontal() ? scale.width : scale.height;
    var ticks = scale.getTicks();
    var prev, curr, i, ilen;
    for (i = 1, ilen = pixels.length; i < ilen; ++i) {
      min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
    }
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      min = i > 0 ? Math.min(min, curr - prev) : min;
      prev = curr;
    }
    return min;
  }

  /**
   * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
   * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
   * mode currently always generates bars equally sized (until we introduce scriptable options?).
   * @private
   */
  function computeFitCategoryTraits(index, ruler, options) {
    var thickness = options.barThickness;
    var count = ruler.stackCount;
    var curr = ruler.pixels[index];
    var size, ratio;
    if (helpers$1.isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      // When bar thickness is enforced, category and bar percentages are ignored.
      // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
      // and deprecate barPercentage since this value is ignored when thickness is absolute.
      size = thickness * count;
      ratio = 1;
    }
    return {
      chunk: size / count,
      ratio: ratio,
      start: curr - size / 2
    };
  }

  /**
   * Computes an "optimal" category that globally arranges bars side by side (no gap when
   * percentage options are 1), based on the previous and following categories. This mode
   * generates bars with different widths when data are not evenly spaced.
   * @private
   */
  function computeFlexCategoryTraits(index, ruler, options) {
    var pixels = ruler.pixels;
    var curr = pixels[index];
    var prev = index > 0 ? pixels[index - 1] : null;
    var next = index < pixels.length - 1 ? pixels[index + 1] : null;
    var percent = options.categoryPercentage;
    var start, size;
    if (prev === null) {
      // first data: its size is double based on the next point or,
      // if it's also the last data, we use the scale size.
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      // last data: its size is also double based on the previous point.
      next = curr + curr - prev;
    }
    start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / ruler.stackCount,
      ratio: options.barPercentage,
      start: start
    };
  }
  var controller_bar = core_datasetController.extend({
    dataElementType: elements.Rectangle,
    initialize: function initialize() {
      var me = this;
      var meta;
      core_datasetController.prototype.initialize.apply(me, arguments);
      meta = me.getMeta();
      meta.stack = me.getDataset().stack;
      meta.bar = true;
    },
    update: function update(reset) {
      var me = this;
      var rects = me.getMeta().data;
      var i, ilen;
      me._ruler = me.getRuler();
      for (i = 0, ilen = rects.length; i < ilen; ++i) {
        me.updateElement(rects[i], i, reset);
      }
    },
    updateElement: function updateElement(rectangle, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var dataset = me.getDataset();
      var options = me._resolveElementOptions(rectangle, index);
      rectangle._xScale = me.getScaleForId(meta.xAxisID);
      rectangle._yScale = me.getScaleForId(meta.yAxisID);
      rectangle._datasetIndex = me.index;
      rectangle._index = index;
      rectangle._model = {
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderSkipped: options.borderSkipped,
        borderWidth: options.borderWidth,
        datasetLabel: dataset.label,
        label: me.chart.data.labels[index]
      };
      me._updateElementGeometry(rectangle, index, reset);
      rectangle.pivot();
    },
    /**
     * @private
     */
    _updateElementGeometry: function _updateElementGeometry(rectangle, index, reset) {
      var me = this;
      var model = rectangle._model;
      var vscale = me._getValueScale();
      var base = vscale.getBasePixel();
      var horizontal = vscale.isHorizontal();
      var ruler = me._ruler || me.getRuler();
      var vpixels = me.calculateBarValuePixels(me.index, index);
      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
      model.horizontal = horizontal;
      model.base = reset ? base : vpixels.base;
      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
      model.height = horizontal ? ipixels.size : undefined;
      model.width = horizontal ? undefined : ipixels.size;
    },
    /**
     * Returns the stacks based on groups and bar visibility.
     * @param {number} [last] - The dataset index
     * @returns {string[]} The list of stack IDs
     * @private
     */
    _getStacks: function _getStacks(last) {
      var me = this;
      var chart = me.chart;
      var scale = me._getIndexScale();
      var stacked = scale.options.stacked;
      var ilen = last === undefined ? chart.data.datasets.length : last + 1;
      var stacks = [];
      var i, meta;
      for (i = 0; i < ilen; ++i) {
        meta = chart.getDatasetMeta(i);
        if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
          stacks.push(meta.stack);
        }
      }
      return stacks;
    },
    /**
     * Returns the effective number of stacks based on groups and bar visibility.
     * @private
     */
    getStackCount: function getStackCount() {
      return this._getStacks().length;
    },
    /**
     * Returns the stack index for the given dataset based on groups and bar visibility.
     * @param {number} [datasetIndex] - The dataset index
     * @param {string} [name] - The stack name to find
     * @returns {number} The stack index
     * @private
     */
    getStackIndex: function getStackIndex(datasetIndex, name) {
      var stacks = this._getStacks(datasetIndex);
      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

      return index === -1 ? stacks.length - 1 : index;
    },
    /**
     * @private
     */
    getRuler: function getRuler() {
      var me = this;
      var scale = me._getIndexScale();
      var stackCount = me.getStackCount();
      var datasetIndex = me.index;
      var isHorizontal = scale.isHorizontal();
      var start = isHorizontal ? scale.left : scale.top;
      var end = start + (isHorizontal ? scale.width : scale.height);
      var pixels = [];
      var i, ilen, min;
      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
        pixels.push(scale.getPixelForValue(null, i, datasetIndex));
      }
      min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
      return {
        min: min,
        pixels: pixels,
        start: start,
        end: end,
        stackCount: stackCount,
        scale: scale
      };
    },
    /**
     * Note: pixel values are not clamped to the scale area.
     * @private
     */
    calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index) {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var scale = me._getValueScale();
      var isHorizontal = scale.isHorizontal();
      var datasets = chart.data.datasets;
      var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
      var minBarLength = scale.options.minBarLength;
      var stacked = scale.options.stacked;
      var stack = meta.stack;
      var start = 0;
      var i, imeta, ivalue, base, head, size;
      if (stacked || stacked === undefined && stack !== undefined) {
        for (i = 0; i < datasetIndex; ++i) {
          imeta = chart.getDatasetMeta(i);
          if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
            ivalue = +scale.getRightValue(datasets[i].data[index]);
            if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
              start += ivalue;
            }
          }
        }
      }
      base = scale.getPixelForValue(start);
      head = scale.getPixelForValue(start + value);
      size = head - base;
      if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
        size = minBarLength;
        if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
          head = base - minBarLength;
        } else {
          head = base + minBarLength;
        }
      }
      return {
        size: size,
        base: base,
        head: head,
        center: head + size / 2
      };
    },
    /**
     * @private
     */
    calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler) {
      var me = this;
      var options = ruler.scale.options;
      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
      var center = range.start + range.chunk * stackIndex + range.chunk / 2;
      var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
      return {
        base: center - size / 2,
        head: center + size / 2,
        center: center,
        size: size
      };
    },
    draw: function draw() {
      var me = this;
      var chart = me.chart;
      var scale = me._getValueScale();
      var rects = me.getMeta().data;
      var dataset = me.getDataset();
      var ilen = rects.length;
      var i = 0;
      helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
      for (; i < ilen; ++i) {
        if (!isNaN(scale.getRightValue(dataset.data[i]))) {
          rects[i].draw();
        }
      }
      helpers$1.canvas.unclipArea(chart.ctx);
    },
    /**
     * @private
     */
    _resolveElementOptions: function _resolveElementOptions(rectangle, index) {
      var me = this;
      var chart = me.chart;
      var datasets = chart.data.datasets;
      var dataset = datasets[me.index];
      var custom = rectangle.custom || {};
      var options = chart.options.elements.rectangle;
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
      }
      return values;
    }
  });
  var valueOrDefault$3 = helpers$1.valueOrDefault;
  var resolve$2 = helpers$1.options.resolve;
  core_defaults._set('bubble', {
    hover: {
      mode: 'single'
    },
    scales: {
      xAxes: [{
        type: 'linear',
        // bubble should probably use a linear scale by default
        position: 'bottom',
        id: 'x-axis-0' // need an ID so datasets can reference the scale
      }],
      yAxes: [{
        type: 'linear',
        position: 'left',
        id: 'y-axis-0'
      }]
    },
    tooltips: {
      callbacks: {
        title: function title() {
          // Title doesn't make sense for scatter since we format the data as a point
          return '';
        },
        label: function label(item, data) {
          var datasetLabel = data.datasets[item.datasetIndex].label || '';
          var dataPoint = data.datasets[item.datasetIndex].data[item.index];
          return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
        }
      }
    }
  });
  var controller_bubble = core_datasetController.extend({
    /**
     * @protected
     */
    dataElementType: elements.Point,
    /**
     * @protected
     */
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var points = meta.data;

      // Update Points
      helpers$1.each(points, function (point, index) {
        me.updateElement(point, index, reset);
      });
    },
    /**
     * @protected
     */
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var xScale = me.getScaleForId(meta.xAxisID);
      var yScale = me.getScaleForId(meta.yAxisID);
      var options = me._resolveElementOptions(point, index);
      var data = me.getDataset().data[index];
      var dsIndex = me.index;
      var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(_typeof(data) === 'object' ? data : NaN, index, dsIndex);
      var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
      point._xScale = xScale;
      point._yScale = yScale;
      point._options = options;
      point._datasetIndex = dsIndex;
      point._index = index;
      point._model = {
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        hitRadius: options.hitRadius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        radius: reset ? 0 : options.radius,
        skip: custom.skip || isNaN(x) || isNaN(y),
        x: x,
        y: y
      };
      point.pivot();
    },
    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
      model.radius = options.radius + options.hoverRadius;
    },
    /**
     * @private
     */
    _resolveElementOptions: function _resolveElementOptions(point, index) {
      var me = this;
      var chart = me.chart;
      var datasets = chart.data.datasets;
      var dataset = datasets[me.index];
      var custom = point.custom || {};
      var options = chart.options.elements.point;
      var data = dataset.data[index];
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
      }

      // Custom radius resolution
      values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
      return values;
    }
  });
  var resolve$3 = helpers$1.options.resolve;
  var valueOrDefault$4 = helpers$1.valueOrDefault;
  core_defaults._set('doughnut', {
    animation: {
      // Boolean - Whether we animate the rotation of the Doughnut
      animateRotate: true,
      // Boolean - Whether we animate scaling the Doughnut from the centre
      animateScale: false
    },
    hover: {
      mode: 'single'
    },
    legendCallback: function legendCallback(chart) {
      var text = [];
      text.push('<ul class="' + chart.id + '-legend">');
      var data = chart.data;
      var datasets = data.datasets;
      var labels = data.labels;
      if (datasets.length) {
        for (var i = 0; i < datasets[0].data.length; ++i) {
          text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
          if (labels[i]) {
            text.push(labels[i]);
          }
          text.push('</li>');
        }
      }
      text.push('</ul>');
      return text.join('');
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(chart) {
          var data = chart.data;
          if (data.labels.length && data.datasets.length) {
            return data.labels.map(function (label, i) {
              var meta = chart.getDatasetMeta(0);
              var ds = data.datasets[0];
              var arc = meta.data[i];
              var custom = arc && arc.custom || {};
              var arcOpts = chart.options.elements.arc;
              var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
              var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
              var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
              return {
                text: label,
                fillStyle: fill,
                strokeStyle: stroke,
                lineWidth: bw,
                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                // Extra data used for toggling the correct item
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick: function onClick(e, legendItem) {
        var index = legendItem.index;
        var chart = this.chart;
        var i, ilen, meta;
        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);
          // toggle visibility of index if exists
          if (meta.data[index]) {
            meta.data[index].hidden = !meta.data[index].hidden;
          }
        }
        chart.update();
      }
    },
    // The percentage of the chart that we cut out of the middle.
    cutoutPercentage: 50,
    // The rotation of the chart, where the first data arc begins.
    rotation: Math.PI * -0.5,
    // The total circumference of the chart.
    circumference: Math.PI * 2.0,
    // Need to override these to give a nice default
    tooltips: {
      callbacks: {
        title: function title() {
          return '';
        },
        label: function label(tooltipItem, data) {
          var dataLabel = data.labels[tooltipItem.index];
          var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
          if (helpers$1.isArray(dataLabel)) {
            // show value on first line of multiline label
            // need to clone because we are changing the value
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  });
  var controller_doughnut = core_datasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers$1.noop,
    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
    getRingIndex: function getRingIndex(datasetIndex) {
      var ringIndex = 0;
      for (var j = 0; j < datasetIndex; ++j) {
        if (this.chart.isDatasetVisible(j)) {
          ++ringIndex;
        }
      }
      return ringIndex;
    },
    update: function update(reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var availableWidth = chartArea.right - chartArea.left;
      var availableHeight = chartArea.bottom - chartArea.top;
      var minSize = Math.min(availableWidth, availableHeight);
      var offset = {
        x: 0,
        y: 0
      };
      var meta = me.getMeta();
      var arcs = meta.data;
      var cutoutPercentage = opts.cutoutPercentage;
      var circumference = opts.circumference;
      var chartWeight = me._getRingWeight(me.index);
      var i, ilen;

      // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc
      if (circumference < Math.PI * 2.0) {
        var startAngle = opts.rotation % (Math.PI * 2.0);
        startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
        var endAngle = startAngle + circumference;
        var start = {
          x: Math.cos(startAngle),
          y: Math.sin(startAngle)
        };
        var end = {
          x: Math.cos(endAngle),
          y: Math.sin(endAngle)
        };
        var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
        var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
        var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
        var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
        var cutout = cutoutPercentage / 100.0;
        var min = {
          x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
          y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
        };
        var max = {
          x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
          y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
        };
        var size = {
          width: (max.x - min.x) * 0.5,
          height: (max.y - min.y) * 0.5
        };
        minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
        offset = {
          x: (max.x + min.x) * -0.5,
          y: (max.y + min.y) * -0.5
        };
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arcs[i]._options = me._resolveElementOptions(arcs[i], i);
      }
      chart.borderWidth = me.getMaxBorderWidth();
      chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
      chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
      chart.offsetX = offset.x * chart.outerRadius;
      chart.offsetY = offset.y * chart.outerRadius;
      meta.total = me.calculateTotal();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
      me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        me.updateElement(arcs[i], i, reset);
      }
    },
    updateElement: function updateElement(arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var animationOpts = opts.animation;
      var centerX = (chartArea.left + chartArea.right) / 2;
      var centerY = (chartArea.top + chartArea.bottom) / 2;
      var startAngle = opts.rotation; // non reset case handled later
      var endAngle = opts.rotation; // non reset case handled later
      var dataset = me.getDataset();
      var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
      var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
      var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
      var options = arc._options || {};
      helpers$1.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        // Desired view properties
        _model: {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          borderAlign: options.borderAlign,
          x: centerX + chart.offsetX,
          y: centerY + chart.offsetY,
          startAngle: startAngle,
          endAngle: endAngle,
          circumference: circumference,
          outerRadius: outerRadius,
          innerRadius: innerRadius,
          label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
        }
      });
      var model = arc._model;

      // Set correct angles if not resetting
      if (!reset || !animationOpts.animateRotate) {
        if (index === 0) {
          model.startAngle = opts.rotation;
        } else {
          model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
        }
        model.endAngle = model.startAngle + model.circumference;
      }
      arc.pivot();
    },
    calculateTotal: function calculateTotal() {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var total = 0;
      var value;
      helpers$1.each(meta.data, function (element, index) {
        value = dataset.data[index];
        if (!isNaN(value) && !element.hidden) {
          total += Math.abs(value);
        }
      });

      /* if (total === 0) {
      	total = NaN;
      }*/

      return total;
    },
    calculateCircumference: function calculateCircumference(value) {
      var total = this.getMeta().total;
      if (total > 0 && !isNaN(value)) {
        return Math.PI * 2.0 * (Math.abs(value) / total);
      }
      return 0;
    },
    // gets the max border or hover width to properly scale pie charts
    getMaxBorderWidth: function getMaxBorderWidth(arcs) {
      var me = this;
      var max = 0;
      var chart = me.chart;
      var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;
      if (!arcs) {
        // Find the outmost visible dataset
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;
            if (i !== me.index) {
              controller = meta.controller;
            }
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arc = arcs[i];
        options = controller ? controller._resolveElementOptions(arc, i) : arc._options;
        if (options.borderAlign !== 'inner') {
          borderWidth = options.borderWidth;
          hoverWidth = options.hoverBorderWidth;
          max = borderWidth > max ? borderWidth : max;
          max = hoverWidth > max ? hoverWidth : max;
        }
      }
      return max;
    },
    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(arc) {
      var model = arc._model;
      var options = arc._options;
      var getHoverColor = helpers$1.getHoverColor;
      arc.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
    },
    /**
     * @private
     */
    _resolveElementOptions: function _resolveElementOptions(arc, index) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var custom = arc.custom || {};
      var options = chart.options.elements.arc;
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
      }
      return values;
    },
    /**
     * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
     * @private
     */
    _getRingWeightOffset: function _getRingWeightOffset(datasetIndex) {
      var ringWeightOffset = 0;
      for (var i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    },
    /**
     * @private
     */
    _getRingWeight: function _getRingWeight(dataSetIndex) {
      return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
    },
    /**
     * Returns the sum of all visibile data set weights.  This value can be 0.
     * @private
     */
    _getVisibleDatasetWeightTotal: function _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length);
    }
  });
  core_defaults._set('horizontalBar', {
    hover: {
      mode: 'index',
      axis: 'y'
    },
    scales: {
      xAxes: [{
        type: 'linear',
        position: 'bottom'
      }],
      yAxes: [{
        type: 'category',
        position: 'left',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        offset: true,
        gridLines: {
          offsetGridLines: true
        }
      }]
    },
    elements: {
      rectangle: {
        borderSkipped: 'left'
      }
    },
    tooltips: {
      mode: 'index',
      axis: 'y'
    }
  });
  var controller_horizontalBar = controller_bar.extend({
    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().xAxisID;
    },
    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().yAxisID;
    }
  });
  var valueOrDefault$5 = helpers$1.valueOrDefault;
  var resolve$4 = helpers$1.options.resolve;
  var isPointInArea = helpers$1.canvas._isPointInArea;
  core_defaults._set('line', {
    showLines: true,
    spanGaps: false,
    hover: {
      mode: 'label'
    },
    scales: {
      xAxes: [{
        type: 'category',
        id: 'x-axis-0'
      }],
      yAxes: [{
        type: 'linear',
        id: 'y-axis-0'
      }]
    }
  });
  function lineEnabled(dataset, options) {
    return valueOrDefault$5(dataset.showLine, options.showLines);
  }
  var controller_line = core_datasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data || [];
      var scale = me.getScaleForId(meta.yAxisID);
      var dataset = me.getDataset();
      var showLine = lineEnabled(dataset, me.chart.options);
      var i, ilen;

      // Update Line
      if (showLine) {
        // Compatibility: If the properties are defined with only the old name, use those values
        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        }

        // Utility
        line._scale = scale;
        line._datasetIndex = me.index;
        // Data
        line._children = points;
        // Model
        line._model = me._resolveLineOptions(line);
        line.pivot();
      }

      // Update Points
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        me.updateElement(points[i], i, reset);
      }
      if (showLine && line._model.tension !== 0) {
        me.updateBezierControlPoints();
      }

      // Now pivot the point for animation
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        points[i].pivot();
      }
    },
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var datasetIndex = me.index;
      var value = dataset.data[index];
      var yScale = me.getScaleForId(meta.yAxisID);
      var xScale = me.getScaleForId(meta.xAxisID);
      var lineModel = meta.dataset._model;
      var x, y;
      var options = me._resolvePointOptions(point, index);
      x = xScale.getPixelForValue(_typeof(value) === 'object' ? value : NaN, index, datasetIndex);
      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

      // Utility
      point._xScale = xScale;
      point._yScale = yScale;
      point._options = options;
      point._datasetIndex = datasetIndex;
      point._index = index;

      // Desired view properties
      point._model = {
        x: x,
        y: y,
        skip: custom.skip || isNaN(x) || isNaN(y),
        // Appearance
        radius: options.radius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
        steppedLine: lineModel ? lineModel.steppedLine : false,
        // Tooltip
        hitRadius: options.hitRadius
      };
    },
    /**
     * @private
     */
    _resolvePointOptions: function _resolvePointOptions(element, index) {
      var me = this;
      var chart = me.chart;
      var dataset = chart.data.datasets[me.index];
      var custom = element.custom || {};
      var options = chart.options.elements.point;
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var ELEMENT_OPTIONS = {
        backgroundColor: 'pointBackgroundColor',
        borderColor: 'pointBorderColor',
        borderWidth: 'pointBorderWidth',
        hitRadius: 'pointHitRadius',
        hoverBackgroundColor: 'pointHoverBackgroundColor',
        hoverBorderColor: 'pointHoverBorderColor',
        hoverBorderWidth: 'pointHoverBorderWidth',
        hoverRadius: 'pointHoverRadius',
        pointStyle: 'pointStyle',
        radius: 'pointRadius',
        rotation: 'pointRotation'
      };
      var keys = Object.keys(ELEMENT_OPTIONS);
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
      }
      return values;
    },
    /**
     * @private
     */
    _resolveLineOptions: function _resolveLineOptions(element) {
      var me = this;
      var chart = me.chart;
      var dataset = chart.data.datasets[me.index];
      var custom = element.custom || {};
      var options = chart.options;
      var elementOptions = options.elements.line;
      var values = {};
      var i, ilen, key;
      var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
      }

      // The default behavior of lines is to break at null values, according
      // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
      // This option gives lines the ability to span gaps
      values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
      values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
      values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
      return values;
    },
    calculatePointY: function calculatePointY(value, index, datasetIndex) {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var yScale = me.getScaleForId(meta.yAxisID);
      var sumPos = 0;
      var sumNeg = 0;
      var i, ds, dsMeta;
      if (yScale.options.stacked) {
        for (i = 0; i < datasetIndex; i++) {
          ds = chart.data.datasets[i];
          dsMeta = chart.getDatasetMeta(i);
          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
            var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
            if (stackedRightValue < 0) {
              sumNeg += stackedRightValue || 0;
            } else {
              sumPos += stackedRightValue || 0;
            }
          }
        }
        var rightValue = Number(yScale.getRightValue(value));
        if (rightValue < 0) {
          return yScale.getPixelForValue(sumNeg + rightValue);
        }
        return yScale.getPixelForValue(sumPos + rightValue);
      }
      return yScale.getPixelForValue(value);
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var lineModel = meta.dataset._model;
      var area = chart.chartArea;
      var points = meta.data || [];
      var i, ilen, model, controlPoints;

      // Only consider points that are drawn in case the spanGaps option is used
      if (lineModel.spanGaps) {
        points = points.filter(function (pt) {
          return !pt._model.skip;
        });
      }
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      if (lineModel.cubicInterpolationMode === 'monotone') {
        helpers$1.splineCurveMonotone(points);
      } else {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
          model.controlPointPreviousX = controlPoints.previous.x;
          model.controlPointPreviousY = controlPoints.previous.y;
          model.controlPointNextX = controlPoints.next.x;
          model.controlPointNextY = controlPoints.next.y;
        }
      }
      if (chart.options.elements.line.capBezierPoints) {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          if (isPointInArea(model, area)) {
            if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
            }
            if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
            }
          }
        }
      }
    },
    draw: function draw() {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var points = meta.data || [];
      var area = chart.chartArea;
      var ilen = points.length;
      var halfBorderWidth;
      var i = 0;
      if (lineEnabled(me.getDataset(), chart.options)) {
        halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
        helpers$1.canvas.clipArea(chart.ctx, {
          left: area.left,
          right: area.right,
          top: area.top - halfBorderWidth,
          bottom: area.bottom + halfBorderWidth
        });
        meta.dataset.draw();
        helpers$1.canvas.unclipArea(chart.ctx);
      }

      // Draw the points
      for (; i < ilen; ++i) {
        points[i].draw(area);
      }
    },
    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
      model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
    }
  });
  var resolve$5 = helpers$1.options.resolve;
  core_defaults._set('polarArea', {
    scale: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      gridLines: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      ticks: {
        beginAtZero: true
      }
    },
    // Boolean - Whether to animate the rotation of the chart
    animation: {
      animateRotate: true,
      animateScale: true
    },
    startAngle: -0.5 * Math.PI,
    legendCallback: function legendCallback(chart) {
      var text = [];
      text.push('<ul class="' + chart.id + '-legend">');
      var data = chart.data;
      var datasets = data.datasets;
      var labels = data.labels;
      if (datasets.length) {
        for (var i = 0; i < datasets[0].data.length; ++i) {
          text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
          if (labels[i]) {
            text.push(labels[i]);
          }
          text.push('</li>');
        }
      }
      text.push('</ul>');
      return text.join('');
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(chart) {
          var data = chart.data;
          if (data.labels.length && data.datasets.length) {
            return data.labels.map(function (label, i) {
              var meta = chart.getDatasetMeta(0);
              var ds = data.datasets[0];
              var arc = meta.data[i];
              var custom = arc.custom || {};
              var arcOpts = chart.options.elements.arc;
              var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
              var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
              var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
              return {
                text: label,
                fillStyle: fill,
                strokeStyle: stroke,
                lineWidth: bw,
                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                // Extra data used for toggling the correct item
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick: function onClick(e, legendItem) {
        var index = legendItem.index;
        var chart = this.chart;
        var i, ilen, meta;
        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);
          meta.data[index].hidden = !meta.data[index].hidden;
        }
        chart.update();
      }
    },
    // Need to override these to give a nice default
    tooltips: {
      callbacks: {
        title: function title() {
          return '';
        },
        label: function label(item, data) {
          return data.labels[item.index] + ': ' + item.yLabel;
        }
      }
    }
  });
  var controller_polarArea = core_datasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers$1.noop,
    update: function update(reset) {
      var me = this;
      var dataset = me.getDataset();
      var meta = me.getMeta();
      var start = me.chart.options.startAngle || 0;
      var starts = me._starts = [];
      var angles = me._angles = [];
      var arcs = meta.data;
      var i, ilen, angle;
      me._updateRadius();
      meta.count = me.countVisibleElements();
      for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
        starts[i] = start;
        angle = me._computeAngle(i);
        angles[i] = angle;
        start += angle;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        me.updateElement(arcs[i], i, reset);
      }
    },
    /**
     * @private
     */
    _updateRadius: function _updateRadius() {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      chart.outerRadius = Math.max(minSize / 2, 0);
      chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
      me.innerRadius = me.outerRadius - chart.radiusLength;
    },
    updateElement: function updateElement(arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var opts = chart.options;
      var animationOpts = opts.animation;
      var scale = chart.scale;
      var labels = chart.data.labels;
      var centerX = scale.xCenter;
      var centerY = scale.yCenter;

      // var negHalfPI = -0.5 * Math.PI;
      var datasetStartAngle = opts.startAngle;
      var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      var startAngle = me._starts[index];
      var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
      var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      var options = arc._options || {};
      helpers$1.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        _scale: scale,
        // Desired view properties
        _model: {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          borderAlign: options.borderAlign,
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius: reset ? resetRadius : distance,
          startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
          endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
          label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
        }
      });
      arc.pivot();
    },
    countVisibleElements: function countVisibleElements() {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var count = 0;
      helpers$1.each(meta.data, function (element, index) {
        if (!isNaN(dataset.data[index]) && !element.hidden) {
          count++;
        }
      });
      return count;
    },
    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(arc) {
      var model = arc._model;
      var options = arc._options;
      var getHoverColor = helpers$1.getHoverColor;
      var valueOrDefault = helpers$1.valueOrDefault;
      arc.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
    },
    /**
     * @private
     */
    _resolveElementOptions: function _resolveElementOptions(arc, index) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var custom = arc.custom || {};
      var options = chart.options.elements.arc;
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
      }
      return values;
    },
    /**
     * @private
     */
    _computeAngle: function _computeAngle(index) {
      var me = this;
      var count = this.getMeta().count;
      var dataset = me.getDataset();
      var meta = me.getMeta();
      if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
        return 0;
      }

      // Scriptable options
      var context = {
        chart: me.chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
    }
  });
  core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));
  core_defaults._set('pie', {
    cutoutPercentage: 0
  });

  // Pie charts are Doughnut chart with different defaults
  var controller_pie = controller_doughnut;
  var valueOrDefault$6 = helpers$1.valueOrDefault;
  var resolve$6 = helpers$1.options.resolve;
  core_defaults._set('radar', {
    scale: {
      type: 'radialLinear'
    },
    elements: {
      line: {
        tension: 0 // no bezier in radar
      }
    }
  });
  var controller_radar = core_datasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,
    linkScales: helpers$1.noop,
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data || [];
      var scale = me.chart.scale;
      var dataset = me.getDataset();
      var i, ilen;

      // Compatibility: If the properties are defined with only the old name, use those values
      if (dataset.tension !== undefined && dataset.lineTension === undefined) {
        dataset.lineTension = dataset.tension;
      }

      // Utility
      line._scale = scale;
      line._datasetIndex = me.index;
      // Data
      line._children = points;
      line._loop = true;
      // Model
      line._model = me._resolveLineOptions(line);
      line.pivot();

      // Update Points
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        me.updateElement(points[i], i, reset);
      }

      // Update bezier control points
      me.updateBezierControlPoints();

      // Now pivot the point for animation
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        points[i].pivot();
      }
    },
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var scale = me.chart.scale;
      var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
      var options = me._resolvePointOptions(point, index);
      var lineModel = me.getMeta().dataset._model;
      var x = reset ? scale.xCenter : pointPosition.x;
      var y = reset ? scale.yCenter : pointPosition.y;

      // Utility
      point._scale = scale;
      point._options = options;
      point._datasetIndex = me.index;
      point._index = index;

      // Desired view properties
      point._model = {
        x: x,
        // value not used in dataset scale, but we want a consistent API between scales
        y: y,
        skip: custom.skip || isNaN(x) || isNaN(y),
        // Appearance
        radius: options.radius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
        // Tooltip
        hitRadius: options.hitRadius
      };
    },
    /**
     * @private
     */
    _resolvePointOptions: function _resolvePointOptions(element, index) {
      var me = this;
      var chart = me.chart;
      var dataset = chart.data.datasets[me.index];
      var custom = element.custom || {};
      var options = chart.options.elements.point;
      var values = {};
      var i, ilen, key;

      // Scriptable options
      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      var ELEMENT_OPTIONS = {
        backgroundColor: 'pointBackgroundColor',
        borderColor: 'pointBorderColor',
        borderWidth: 'pointBorderWidth',
        hitRadius: 'pointHitRadius',
        hoverBackgroundColor: 'pointHoverBackgroundColor',
        hoverBorderColor: 'pointHoverBorderColor',
        hoverBorderWidth: 'pointHoverBorderWidth',
        hoverRadius: 'pointHoverRadius',
        pointStyle: 'pointStyle',
        radius: 'pointRadius',
        rotation: 'pointRotation'
      };
      var keys = Object.keys(ELEMENT_OPTIONS);
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
      }
      return values;
    },
    /**
     * @private
     */
    _resolveLineOptions: function _resolveLineOptions(element) {
      var me = this;
      var chart = me.chart;
      var dataset = chart.data.datasets[me.index];
      var custom = element.custom || {};
      var options = chart.options.elements.line;
      var values = {};
      var i, ilen, key;
      var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];
      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        values[key] = resolve$6([custom[key], dataset[key], options[key]]);
      }
      values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
      return values;
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var me = this;
      var meta = me.getMeta();
      var area = me.chart.chartArea;
      var points = meta.data || [];
      var i, ilen, model, controlPoints;
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        model = points[i]._model;
        controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);

        // Prevent the bezier going outside of the bounds of the graph
        model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
        model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
        model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
        model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
      }
    },
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
      model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
    }
  });
  core_defaults._set('scatter', {
    hover: {
      mode: 'single'
    },
    scales: {
      xAxes: [{
        id: 'x-axis-1',
        // need an ID so datasets can reference the scale
        type: 'linear',
        // scatter should not use a category axis
        position: 'bottom'
      }],
      yAxes: [{
        id: 'y-axis-1',
        type: 'linear',
        position: 'left'
      }]
    },
    showLines: false,
    tooltips: {
      callbacks: {
        title: function title() {
          return ''; // doesn't make sense for scatter since data are formatted as a point
        },
        label: function label(item) {
          return '(' + item.xLabel + ', ' + item.yLabel + ')';
        }
      }
    }
  });

  // Scatter charts use line controllers
  var controller_scatter = controller_line;

  // NOTE export a map in which the key represents the controller type, not
  // the class, and so must be CamelCase in order to be correctly retrieved
  // by the controller in core.controller.js (`controllers[meta.type]`).

  var controllers = {
    bar: controller_bar,
    bubble: controller_bubble,
    doughnut: controller_doughnut,
    horizontalBar: controller_horizontalBar,
    line: controller_line,
    polarArea: controller_polarArea,
    pie: controller_pie,
    radar: controller_radar,
    scatter: controller_scatter
  };

  /**
   * Helper function to get relative position for an event
   * @param {Event|IEvent} event - The event to get the position for
   * @param {Chart} chart - The chart
   * @returns {object} the event position
   */
  function getRelativePosition(e, chart) {
    if (e["native"]) {
      return {
        x: e.x,
        y: e.y
      };
    }
    return helpers$1.getRelativePosition(e, chart);
  }

  /**
   * Helper function to traverse all of the visible elements in the chart
   * @param {Chart} chart - the chart
   * @param {function} handler - the callback to execute for each visible item
   */
  function parseVisibleItems(chart, handler) {
    var datasets = chart.data.datasets;
    var meta, i, j, ilen, jlen;
    for (i = 0, ilen = datasets.length; i < ilen; ++i) {
      if (!chart.isDatasetVisible(i)) {
        continue;
      }
      meta = chart.getDatasetMeta(i);
      for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
        var element = meta.data[j];
        if (!element._view.skip) {
          handler(element);
        }
      }
    }
  }

  /**
   * Helper function to get the items that intersect the event position
   * @param {ChartElement[]} items - elements to filter
   * @param {object} position - the point to be nearest to
   * @return {ChartElement[]} the nearest items
   */
  function getIntersectItems(chart, position) {
    var elements = [];
    parseVisibleItems(chart, function (element) {
      if (element.inRange(position.x, position.y)) {
        elements.push(element);
      }
    });
    return elements;
  }

  /**
   * Helper function to get the items nearest to the event position considering all visible items in teh chart
   * @param {Chart} chart - the chart to look at elements from
   * @param {object} position - the point to be nearest to
   * @param {boolean} intersect - if true, only consider items that intersect the position
   * @param {function} distanceMetric - function to provide the distance between points
   * @return {ChartElement[]} the nearest items
   */
  function getNearestItems(chart, position, intersect, distanceMetric) {
    var minDistance = Number.POSITIVE_INFINITY;
    var nearestItems = [];
    parseVisibleItems(chart, function (element) {
      if (intersect && !element.inRange(position.x, position.y)) {
        return;
      }
      var center = element.getCenterPoint();
      var distance = distanceMetric(position, center);
      if (distance < minDistance) {
        nearestItems = [element];
        minDistance = distance;
      } else if (distance === minDistance) {
        // Can have multiple items at the same distance in which case we sort by size
        nearestItems.push(element);
      }
    });
    return nearestItems;
  }

  /**
   * Get a distance metric function for two points based on the
   * axis mode setting
   * @param {string} axis - the axis mode. x|y|xy
   */
  function getDistanceMetricForAxis(axis) {
    var useX = axis.indexOf('x') !== -1;
    var useY = axis.indexOf('y') !== -1;
    return function (pt1, pt2) {
      var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function indexMode(chart, e, options) {
    var position = getRelativePosition(e, chart);
    // Default axis for index mode is 'x' to match old behaviour
    options.axis = options.axis || 'x';
    var distanceMetric = getDistanceMetricForAxis(options.axis);
    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
    var elements = [];
    if (!items.length) {
      return [];
    }
    chart.data.datasets.forEach(function (dataset, datasetIndex) {
      if (chart.isDatasetVisible(datasetIndex)) {
        var meta = chart.getDatasetMeta(datasetIndex);
        var element = meta.data[items[0]._index];

        // don't count items that are skipped (null data)
        if (element && !element._view.skip) {
          elements.push(element);
        }
      }
    });
    return elements;
  }

  /**
   * @interface IInteractionOptions
   */
  /**
   * If true, only consider items that intersect the point
   * @name IInterfaceOptions#boolean
   * @type Boolean
   */

  /**
   * Contains interaction related functions
   * @namespace Chart.Interaction
   */
  var core_interaction = {
    // Helper function for different modes
    modes: {
      single: function single(chart, e) {
        var position = getRelativePosition(e, chart);
        var elements = [];
        parseVisibleItems(chart, function (element) {
          if (element.inRange(position.x, position.y)) {
            elements.push(element);
            return elements;
          }
        });
        return elements.slice(0, 1);
      },
      /**
       * @function Chart.Interaction.modes.label
       * @deprecated since version 2.4.0
       * @todo remove at version 3
       * @private
       */
      label: indexMode,
      /**
       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
       * @function Chart.Interaction.modes.index
       * @since v2.4.0
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use during interaction
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      index: indexMode,
      /**
       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
       * If the options.intersect is false, we find the nearest item and return the items in that dataset
       * @function Chart.Interaction.modes.dataset
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use during interaction
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      dataset: function dataset(chart, e, options) {
        var position = getRelativePosition(e, chart);
        options.axis = options.axis || 'xy';
        var distanceMetric = getDistanceMetricForAxis(options.axis);
        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
        if (items.length > 0) {
          items = chart.getDatasetMeta(items[0]._datasetIndex).data;
        }
        return items;
      },
      /**
       * @function Chart.Interaction.modes.x-axis
       * @deprecated since version 2.4.0. Use index mode and intersect == true
       * @todo remove at version 3
       * @private
       */
      'x-axis': function xAxis(chart, e) {
        return indexMode(chart, e, {
          intersect: false
        });
      },
      /**
       * Point mode returns all elements that hit test based on the event position
       * of the event
       * @function Chart.Interaction.modes.intersect
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      point: function point(chart, e) {
        var position = getRelativePosition(e, chart);
        return getIntersectItems(chart, position);
      },
      /**
       * nearest mode returns the element closest to the point
       * @function Chart.Interaction.modes.intersect
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      nearest: function nearest(chart, e, options) {
        var position = getRelativePosition(e, chart);
        options.axis = options.axis || 'xy';
        var distanceMetric = getDistanceMetricForAxis(options.axis);
        return getNearestItems(chart, position, options.intersect, distanceMetric);
      },
      /**
       * x mode returns the elements that hit-test at the current x coordinate
       * @function Chart.Interaction.modes.x
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      x: function x(chart, e, options) {
        var position = getRelativePosition(e, chart);
        var items = [];
        var intersectsItem = false;
        parseVisibleItems(chart, function (element) {
          if (element.inXRange(position.x)) {
            items.push(element);
          }
          if (element.inRange(position.x, position.y)) {
            intersectsItem = true;
          }
        });

        // If we want to trigger on an intersect and we don't have any items
        // that intersect the position, return nothing
        if (options.intersect && !intersectsItem) {
          items = [];
        }
        return items;
      },
      /**
       * y mode returns the elements that hit-test at the current y coordinate
       * @function Chart.Interaction.modes.y
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      y: function y(chart, e, options) {
        var position = getRelativePosition(e, chart);
        var items = [];
        var intersectsItem = false;
        parseVisibleItems(chart, function (element) {
          if (element.inYRange(position.y)) {
            items.push(element);
          }
          if (element.inRange(position.x, position.y)) {
            intersectsItem = true;
          }
        });

        // If we want to trigger on an intersect and we don't have any items
        // that intersect the position, return nothing
        if (options.intersect && !intersectsItem) {
          items = [];
        }
        return items;
      }
    }
  };
  function filterByPosition(array, position) {
    return helpers$1.where(array, function (v) {
      return v.position === position;
    });
  }
  function sortByWeight(array, reverse) {
    array.forEach(function (v, i) {
      v._tmpIndex_ = i;
      return v;
    });
    array.sort(function (a, b) {
      var v0 = reverse ? b : a;
      var v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
    });
    array.forEach(function (v) {
      delete v._tmpIndex_;
    });
  }
  function findMaxPadding(boxes) {
    var top = 0;
    var left = 0;
    var bottom = 0;
    var right = 0;
    helpers$1.each(boxes, function (box) {
      if (box.getPadding) {
        var boxPadding = box.getPadding();
        top = Math.max(top, boxPadding.top);
        left = Math.max(left, boxPadding.left);
        bottom = Math.max(bottom, boxPadding.bottom);
        right = Math.max(right, boxPadding.right);
      }
    });
    return {
      top: top,
      left: left,
      bottom: bottom,
      right: right
    };
  }
  function addSizeByPosition(boxes, size) {
    helpers$1.each(boxes, function (box) {
      size[box.position] += box.isHorizontal() ? box.height : box.width;
    });
  }
  core_defaults._set('global', {
    layout: {
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }
  });

  /**
   * @interface ILayoutItem
   * @prop {string} position - The position of the item in the chart layout. Possible values are
   * 'left', 'top', 'right', 'bottom', and 'chartArea'
   * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
   * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
   * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
   * @prop {function} update - Takes two parameters: width and height. Returns size of item
   * @prop {function} getPadding -  Returns an object with padding on the edges
   * @prop {number} width - Width of item. Must be valid after update()
   * @prop {number} height - Height of item. Must be valid after update()
   * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
   * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
   * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
   * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
   */

  // The layout service is very self explanatory.  It's responsible for the layout within a chart.
  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
  // It is this service's responsibility of carrying out that layout.
  var core_layouts = {
    defaults: {},
    /**
     * Register a box to a chart.
     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
     * @param {Chart} chart - the chart to use
     * @param {ILayoutItem} item - the item to add to be layed out
     */
    addBox: function addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }

      // initialize item with default values
      item.fullWidth = item.fullWidth || false;
      item.position = item.position || 'top';
      item.weight = item.weight || 0;
      chart.boxes.push(item);
    },
    /**
     * Remove a layoutItem from a chart
     * @param {Chart} chart - the chart to remove the box from
     * @param {ILayoutItem} layoutItem - the item to remove from the layout
     */
    removeBox: function removeBox(chart, layoutItem) {
      var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index !== -1) {
        chart.boxes.splice(index, 1);
      }
    },
    /**
     * Sets (or updates) options on the given `item`.
     * @param {Chart} chart - the chart in which the item lives (or will be added to)
     * @param {ILayoutItem} item - the item to configure with the given options
     * @param {object} options - the new item options.
     */
    configure: function configure(chart, item, options) {
      var props = ['fullWidth', 'position', 'weight'];
      var ilen = props.length;
      var i = 0;
      var prop;
      for (; i < ilen; ++i) {
        prop = props[i];
        if (options.hasOwnProperty(prop)) {
          item[prop] = options[prop];
        }
      }
    },
    /**
     * Fits boxes of the given chart into the given size by having each box measure itself
     * then running a fitting algorithm
     * @param {Chart} chart - the chart
     * @param {number} width - the width to fit into
     * @param {number} height - the height to fit into
     */
    update: function update(chart, width, height) {
      if (!chart) {
        return;
      }
      var layoutOptions = chart.options.layout || {};
      var padding = helpers$1.options.toPadding(layoutOptions.padding);
      var leftPadding = padding.left;
      var rightPadding = padding.right;
      var topPadding = padding.top;
      var bottomPadding = padding.bottom;
      var leftBoxes = filterByPosition(chart.boxes, 'left');
      var rightBoxes = filterByPosition(chart.boxes, 'right');
      var topBoxes = filterByPosition(chart.boxes, 'top');
      var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
      var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');

      // Sort boxes by weight. A higher weight is further away from the chart area
      sortByWeight(leftBoxes, true);
      sortByWeight(rightBoxes, false);
      sortByWeight(topBoxes, true);
      sortByWeight(bottomBoxes, false);
      var verticalBoxes = leftBoxes.concat(rightBoxes);
      var horizontalBoxes = topBoxes.concat(bottomBoxes);
      var outerBoxes = verticalBoxes.concat(horizontalBoxes);

      // Essentially we now have any number of boxes on each of the 4 sides.
      // Our canvas looks like the following.
      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
      // B1 is the bottom axis
      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
      // an error will be thrown.
      //
      // |----------------------------------------------------|
      // |                  T1 (Full Width)                   |
      // |----------------------------------------------------|
      // |    |    |                 T2                  |    |
      // |    |----|-------------------------------------|----|
      // |    |    | C1 |                           | C2 |    |
      // |    |    |----|                           |----|    |
      // |    |    |                                     |    |
      // | L1 | L2 |           ChartArea (C0)            | R1 |
      // |    |    |                                     |    |
      // |    |    |----|                           |----|    |
      // |    |    | C3 |                           | C4 |    |
      // |    |----|-------------------------------------|----|
      // |    |    |                 B1                  |    |
      // |----------------------------------------------------|
      // |                  B2 (Full Width)                   |
      // |----------------------------------------------------|
      //
      // What we do to find the best sizing, we do the following
      // 1. Determine the minimum size of the chart area.
      // 2. Split the remaining width equally between each vertical axis
      // 3. Split the remaining height equally between each horizontal axis
      // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
      // 5. Adjust the sizes of each axis based on it's minimum reported size.
      // 6. Refit each axis
      // 7. Position each axis in the final location
      // 8. Tell the chart the final location of the chart area
      // 9. Tell any axes that overlay the chart area the positions of the chart area

      // Step 1
      var chartWidth = width - leftPadding - rightPadding;
      var chartHeight = height - topPadding - bottomPadding;
      var chartAreaWidth = chartWidth / 2; // min 50%

      // Step 2
      var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length;

      // Step 3
      // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
      // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;

      // Step 4
      var maxChartAreaWidth = chartWidth;
      var maxChartAreaHeight = chartHeight;
      var outerBoxSizes = {
        top: topPadding,
        left: leftPadding,
        bottom: bottomPadding,
        right: rightPadding
      };
      var minBoxSizes = [];
      var maxPadding;
      function getMinimumBoxSize(box) {
        var minSize;
        var isHorizontal = box.isHorizontal();
        if (isHorizontal) {
          minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
          maxChartAreaHeight -= minSize.height;
        } else {
          minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
          maxChartAreaWidth -= minSize.width;
        }
        minBoxSizes.push({
          horizontal: isHorizontal,
          width: minSize.width,
          box: box
        });
      }
      helpers$1.each(outerBoxes, getMinimumBoxSize);

      // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)
      maxPadding = findMaxPadding(outerBoxes);

      // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
      // be if the axes are drawn at their minimum sizes.
      // Steps 5 & 6

      // Function to fit a box
      function fitBox(box) {
        var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
          return minBox.box === box;
        });
        if (minBoxSize) {
          if (minBoxSize.horizontal) {
            var scaleMargin = {
              left: Math.max(outerBoxSizes.left, maxPadding.left),
              right: Math.max(outerBoxSizes.right, maxPadding.right),
              top: 0,
              bottom: 0
            };

            // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
            // on the margin. Sometimes they need to increase in size slightly
            box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
          } else {
            box.update(minBoxSize.width, maxChartAreaHeight);
          }
        }
      }

      // Update, and calculate the left and right margins for the horizontal boxes
      helpers$1.each(verticalBoxes, fitBox);
      addSizeByPosition(verticalBoxes, outerBoxSizes);

      // Set the Left and Right margins for the horizontal boxes
      helpers$1.each(horizontalBoxes, fitBox);
      addSizeByPosition(horizontalBoxes, outerBoxSizes);
      function finalFitVerticalBox(box) {
        var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
          return minSize.box === box;
        });
        var scaleMargin = {
          left: 0,
          right: 0,
          top: outerBoxSizes.top,
          bottom: outerBoxSizes.bottom
        };
        if (minBoxSize) {
          box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
        }
      }

      // Let the left layout know the final margin
      helpers$1.each(verticalBoxes, finalFitVerticalBox);

      // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)
      outerBoxSizes = {
        top: topPadding,
        left: leftPadding,
        bottom: bottomPadding,
        right: rightPadding
      };
      addSizeByPosition(outerBoxes, outerBoxSizes);

      // We may be adding some padding to account for rotated x axis labels
      var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
      outerBoxSizes.left += leftPaddingAddition;
      outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
      var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
      outerBoxSizes.top += topPaddingAddition;
      outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0);

      // Figure out if our chart area changed. This would occur if the dataset layout label rotation
      // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
      // without calling `fit` again
      var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
      var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;
      if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
        helpers$1.each(verticalBoxes, function (box) {
          box.height = newMaxChartAreaHeight;
        });
        helpers$1.each(horizontalBoxes, function (box) {
          if (!box.fullWidth) {
            box.width = newMaxChartAreaWidth;
          }
        });
        maxChartAreaHeight = newMaxChartAreaHeight;
        maxChartAreaWidth = newMaxChartAreaWidth;
      }

      // Step 7 - Position the boxes
      var left = leftPadding + leftPaddingAddition;
      var top = topPadding + topPaddingAddition;
      function placeBox(box) {
        if (box.isHorizontal()) {
          box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
          box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
          box.top = top;
          box.bottom = top + box.height;

          // Move to next point
          top = box.bottom;
        } else {
          box.left = left;
          box.right = left + box.width;
          box.top = outerBoxSizes.top;
          box.bottom = outerBoxSizes.top + maxChartAreaHeight;

          // Move to next point
          left = box.right;
        }
      }
      helpers$1.each(leftBoxes.concat(topBoxes), placeBox);

      // Account for chart width and height
      left += maxChartAreaWidth;
      top += maxChartAreaHeight;
      helpers$1.each(rightBoxes, placeBox);
      helpers$1.each(bottomBoxes, placeBox);

      // Step 8
      chart.chartArea = {
        left: outerBoxSizes.left,
        top: outerBoxSizes.top,
        right: outerBoxSizes.left + maxChartAreaWidth,
        bottom: outerBoxSizes.top + maxChartAreaHeight
      };

      // Step 9
      helpers$1.each(chartAreaBoxes, function (box) {
        box.left = chart.chartArea.left;
        box.top = chart.chartArea.top;
        box.right = chart.chartArea.right;
        box.bottom = chart.chartArea.bottom;
        box.update(maxChartAreaWidth, maxChartAreaHeight);
      });
    }
  };

  /**
   * Platform fallback implementation (minimal).
   * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
   */

  var platform_basic = {
    acquireContext: function acquireContext(item) {
      if (item && item.canvas) {
        // Support for any object associated to a canvas (including a context2d)
        item = item.canvas;
      }
      return item && item.getContext('2d') || null;
    }
  };
  var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
  var platform_dom$1 = /*#__PURE__*/Object.freeze({
    "default": platform_dom
  });
  function getCjsExportFromNamespace(n) {
    return n && n["default"] || n;
  }
  var stylesheet = getCjsExportFromNamespace(platform_dom$1);
  var EXPANDO_KEY = '$chartjs';
  var CSS_PREFIX = 'chartjs-';
  var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
  var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
  var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
  var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

  /**
   * DOM event types -> Chart.js event types.
   * Note: only events with different types are mapped.
   * @see https://developer.mozilla.org/en-US/docs/Web/Events
   */
  var EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
  };

  /**
   * The "used" size is the final value of a dimension property after all calculations have
   * been performed. This method uses the computed style of `element` but returns undefined
   * if the computed style is not expressed in pixels. That can happen in some cases where
   * `element` has a size relative to its parent and this last one is not yet displayed,
   * for example because of `display: none` on a parent node.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
   * @returns {number} Size in pixels or undefined if unknown.
   */
  function readUsedSize(element, property) {
    var value = helpers$1.getStyle(element, property);
    var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? Number(matches[1]) : undefined;
  }

  /**
   * Initializes the canvas style and render size without modifying the canvas display size,
   * since responsiveness is handled by the controller.resize() method. The config is used
   * to determine the aspect ratio to apply in case no explicit height has been specified.
   */
  function initCanvas(canvas, config) {
    var style = canvas.style;

    // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
    // returns null or '' if no explicit value has been set to the canvas attribute.
    var renderHeight = canvas.getAttribute('height');
    var renderWidth = canvas.getAttribute('width');

    // Chart.js modifies some canvas values that we want to restore on destroy
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };

    // Force canvas to display as block to avoid extra space caused by inline
    // elements, which would interfere with the responsive resize process.
    // https://github.com/chartjs/Chart.js/issues/2538
    style.display = style.display || 'block';
    if (renderWidth === null || renderWidth === '') {
      var displayWidth = readUsedSize(canvas, 'width');
      if (displayWidth !== undefined) {
        canvas.width = displayWidth;
      }
    }
    if (renderHeight === null || renderHeight === '') {
      if (canvas.style.height === '') {
        // If no explicit render height and style height, let's apply the aspect ratio,
        // which one can be specified by the user but also by charts as default option
        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
        canvas.height = canvas.width / (config.options.aspectRatio || 2);
      } else {
        var displayHeight = readUsedSize(canvas, 'height');
        if (displayWidth !== undefined) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }

  /**
   * Detects support for options object argument in addEventListener.
   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
   * @private
   */
  var supportsEventListenerOptions = function () {
    var supports = false;
    try {
      var options = Object.defineProperty({}, 'passive', {
        // eslint-disable-next-line getter-return
        get: function get() {
          supports = true;
        }
      });
      window.addEventListener('e', null, options);
    } catch (e) {
      // continue regardless of error
    }
    return supports;
  }();

  // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
  // https://github.com/chartjs/Chart.js/issues/4287
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
  function removeListener(node, type, listener) {
    node.removeEventListener(type, listener, eventListenerOptions);
  }
  function createEvent(type, chart, x, y, nativeEvent) {
    return {
      type: type,
      chart: chart,
      "native": nativeEvent || null,
      x: x !== undefined ? x : null,
      y: y !== undefined ? y : null
    };
  }
  function fromNativeEvent(event, chart) {
    var type = EVENT_TYPES[event.type] || event.type;
    var pos = helpers$1.getRelativePosition(event, chart);
    return createEvent(type, chart, pos.x, pos.y, event);
  }
  function throttled(fn, thisArg) {
    var ticking = false;
    var args = [];
    return function () {
      args = Array.prototype.slice.call(arguments);
      thisArg = thisArg || this;
      if (!ticking) {
        ticking = true;
        helpers$1.requestAnimFrame.call(window, function () {
          ticking = false;
          fn.apply(thisArg, args);
        });
      }
    };
  }
  function createDiv(cls) {
    var el = document.createElement('div');
    el.className = cls || '';
    return el;
  }

  // Implementation based on https://github.com/marcj/css-element-queries
  function createResizer(handler) {
    var maxSize = 1000000;

    // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
    // https://github.com/chartjs/Chart.js/issues/5902
    var resizer = createDiv(CSS_SIZE_MONITOR);
    var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
    var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
    expand.appendChild(createDiv());
    shrink.appendChild(createDiv());
    resizer.appendChild(expand);
    resizer.appendChild(shrink);
    resizer._reset = function () {
      expand.scrollLeft = maxSize;
      expand.scrollTop = maxSize;
      shrink.scrollLeft = maxSize;
      shrink.scrollTop = maxSize;
    };
    var onScroll = function onScroll() {
      resizer._reset();
      handler();
    };
    addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
    addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
    return resizer;
  }

  // https://davidwalsh.name/detect-node-insertion
  function watchForRender(node, handler) {
    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
    var proxy = expando.renderProxy = function (e) {
      if (e.animationName === CSS_RENDER_ANIMATION) {
        handler();
      }
    };
    helpers$1.each(ANIMATION_START_EVENTS, function (type) {
      addListener(node, type, proxy);
    });

    // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
    // is removed then added back immediately (same animation frame?). Accessing the
    // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
    // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
    // https://github.com/chartjs/Chart.js/issues/4737
    expando.reflow = !!node.offsetParent;
    node.classList.add(CSS_RENDER_MONITOR);
  }
  function unwatchForRender(node) {
    var expando = node[EXPANDO_KEY] || {};
    var proxy = expando.renderProxy;
    if (proxy) {
      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        removeListener(node, type, proxy);
      });
      delete expando.renderProxy;
    }
    node.classList.remove(CSS_RENDER_MONITOR);
  }
  function addResizeListener(node, listener, chart) {
    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

    // Let's keep track of this added resizer and thus avoid DOM query when removing it.
    var resizer = expando.resizer = createResizer(throttled(function () {
      if (expando.resizer) {
        var container = chart.options.maintainAspectRatio && node.parentNode;
        var w = container ? container.clientWidth : 0;
        listener(createEvent('resize', chart));
        if (container && container.clientWidth < w && chart.canvas) {
          // If the container size shrank during chart resize, let's assume
          // scrollbar appeared. So we resize again with the scrollbar visible -
          // effectively making chart smaller and the scrollbar hidden again.
          // Because we are inside `throttled`, and currently `ticking`, scroll
          // events are ignored during this whole 2 resize process.
          // If we assumed wrong and something else happened, we are resizing
          // twice in a frame (potential performance issue)
          listener(createEvent('resize', chart));
        }
      }
    }));

    // The resizer needs to be attached to the node parent, so we first need to be
    // sure that `node` is attached to the DOM before injecting the resizer element.
    watchForRender(node, function () {
      if (expando.resizer) {
        var container = node.parentNode;
        if (container && container !== resizer.parentNode) {
          container.insertBefore(resizer, container.firstChild);
        }

        // The container size might have changed, let's reset the resizer state.
        resizer._reset();
      }
    });
  }
  function removeResizeListener(node) {
    var expando = node[EXPANDO_KEY] || {};
    var resizer = expando.resizer;
    delete expando.resizer;
    unwatchForRender(node);
    if (resizer && resizer.parentNode) {
      resizer.parentNode.removeChild(resizer);
    }
  }
  function injectCSS(platform, css) {
    // https://stackoverflow.com/q/3922139
    var style = platform._style || document.createElement('style');
    if (!platform._style) {
      platform._style = style;
      css = '/* Chart.js */\n' + css;
      style.setAttribute('type', 'text/css');
      document.getElementsByTagName('head')[0].appendChild(style);
    }
    style.appendChild(document.createTextNode(css));
  }
  var platform_dom$2 = {
    /**
     * When `true`, prevents the automatic injection of the stylesheet required to
     * correctly detect when the chart is added to the DOM and then resized. This
     * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
     * to be manually imported to make this library compatible with any CSP.
     * See https://github.com/chartjs/Chart.js/issues/5208
     */
    disableCSSInjection: false,
    /**
     * This property holds whether this platform is enabled for the current environment.
     * Currently used by platform.js to select the proper implementation.
     * @private
     */
    _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
    /**
     * @private
     */
    _ensureLoaded: function _ensureLoaded() {
      if (this._loaded) {
        return;
      }
      this._loaded = true;

      // https://github.com/chartjs/Chart.js/issues/5208
      if (!this.disableCSSInjection) {
        injectCSS(this, stylesheet);
      }
    },
    acquireContext: function acquireContext(item, config) {
      if (typeof item === 'string') {
        item = document.getElementById(item);
      } else if (item.length) {
        // Support for array based queries (such as jQuery)
        item = item[0];
      }
      if (item && item.canvas) {
        // Support for any object associated to a canvas (including a context2d)
        item = item.canvas;
      }

      // To prevent canvas fingerprinting, some add-ons undefine the getContext
      // method, for example: https://github.com/kkapsner/CanvasBlocker
      // https://github.com/chartjs/Chart.js/issues/2807
      var context = item && item.getContext && item.getContext('2d');

      // Load platform resources on first chart creation, to make possible to change
      // platform options after importing the library (e.g. `disableCSSInjection`).
      this._ensureLoaded();

      // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
      // inside an iframe or when running in a protected environment. We could guess the
      // types from their toString() value but let's keep things flexible and assume it's
      // a sufficient condition if the item has a context2D which has item as `canvas`.
      // https://github.com/chartjs/Chart.js/issues/3887
      // https://github.com/chartjs/Chart.js/issues/4102
      // https://github.com/chartjs/Chart.js/issues/4152
      if (context && context.canvas === item) {
        initCanvas(item, config);
        return context;
      }
      return null;
    },
    releaseContext: function releaseContext(context) {
      var canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return;
      }
      var initial = canvas[EXPANDO_KEY].initial;
      ['height', 'width'].forEach(function (prop) {
        var value = initial[prop];
        if (helpers$1.isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      helpers$1.each(initial.style || {}, function (value, key) {
        canvas.style[key] = value;
      });

      // The canvas render size might have been changed (and thus the state stack discarded),
      // we can't use save() and restore() to restore the initial state. So make sure that at
      // least the canvas context is reset to the default state by setting the canvas width.
      // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
      // eslint-disable-next-line no-self-assign
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
    },
    addEventListener: function addEventListener(chart, type, listener) {
      var canvas = chart.canvas;
      if (type === 'resize') {
        // Note: the resize event is not supported on all browsers.
        addResizeListener(canvas, listener, chart);
        return;
      }
      var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
      var proxies = expando.proxies || (expando.proxies = {});
      var proxy = proxies[chart.id + '_' + type] = function (event) {
        listener(fromNativeEvent(event, chart));
      };
      addListener(canvas, type, proxy);
    },
    removeEventListener: function removeEventListener(chart, type, listener) {
      var canvas = chart.canvas;
      if (type === 'resize') {
        // Note: the resize event is not supported on all browsers.
        removeResizeListener(canvas);
        return;
      }
      var expando = listener[EXPANDO_KEY] || {};
      var proxies = expando.proxies || {};
      var proxy = proxies[chart.id + '_' + type];
      if (!proxy) {
        return;
      }
      removeListener(canvas, type, proxy);
    }
  };

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use EventTarget.addEventListener instead.
   * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   * @function Chart.helpers.addEvent
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers$1.addEvent = addListener;

  /**
   * Provided for backward compatibility, use EventTarget.removeEventListener instead.
   * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
   * @function Chart.helpers.removeEvent
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */
  helpers$1.removeEvent = removeListener;

  // @TODO Make possible to select another platform at build time.
  var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;

  /**
   * @namespace Chart.platform
   * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
   * @since 2.4.0
   */
  var platform = helpers$1.extend({
    /**
     * @since 2.7.0
     */
    initialize: function initialize() {},
    /**
     * Called at chart construction time, returns a context2d instance implementing
     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
     * @param {*} item - The native item from which to acquire context (platform specific)
     * @param {object} options - The chart options
     * @returns {CanvasRenderingContext2D} context2d instance
     */
    acquireContext: function acquireContext() {},
    /**
     * Called at chart destruction time, releases any resources associated to the context
     * previously returned by the acquireContext() method.
     * @param {CanvasRenderingContext2D} context - The context2d instance
     * @returns {boolean} true if the method succeeded, else false
     */
    releaseContext: function releaseContext() {},
    /**
     * Registers the specified listener on the given chart.
     * @param {Chart} chart - Chart from which to listen for event
     * @param {string} type - The ({@link IEvent}) type to listen for
     * @param {function} listener - Receives a notification (an object that implements
     * the {@link IEvent} interface) when an event of the specified type occurs.
     */
    addEventListener: function addEventListener() {},
    /**
     * Removes the specified listener previously registered with addEventListener.
     * @param {Chart} chart - Chart from which to remove the listener
     * @param {string} type - The ({@link IEvent}) type to remove
     * @param {function} listener - The listener function to remove from the event target.
     */
    removeEventListener: function removeEventListener() {}
  }, implementation);
  core_defaults._set('global', {
    plugins: {}
  });

  /**
   * The plugin service singleton
   * @namespace Chart.plugins
   * @since 2.1.0
   */
  var core_plugins = {
    /**
     * Globally registered plugins.
     * @private
     */
    _plugins: [],
    /**
     * This identifier is used to invalidate the descriptors cache attached to each chart
     * when a global plugin is registered or unregistered. In this case, the cache ID is
     * incremented and descriptors are regenerated during following API calls.
     * @private
     */
    _cacheId: 0,
    /**
     * Registers the given plugin(s) if not already registered.
     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
     */
    register: function register(plugins) {
      var p = this._plugins;
      [].concat(plugins).forEach(function (plugin) {
        if (p.indexOf(plugin) === -1) {
          p.push(plugin);
        }
      });
      this._cacheId++;
    },
    /**
     * Unregisters the given plugin(s) only if registered.
     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
     */
    unregister: function unregister(plugins) {
      var p = this._plugins;
      [].concat(plugins).forEach(function (plugin) {
        var idx = p.indexOf(plugin);
        if (idx !== -1) {
          p.splice(idx, 1);
        }
      });
      this._cacheId++;
    },
    /**
     * Remove all registered plugins.
     * @since 2.1.5
     */
    clear: function clear() {
      this._plugins = [];
      this._cacheId++;
    },
    /**
     * Returns the number of registered plugins?
     * @returns {number}
     * @since 2.1.5
     */
    count: function count() {
      return this._plugins.length;
    },
    /**
     * Returns all registered plugin instances.
     * @returns {IPlugin[]} array of plugin objects.
     * @since 2.1.5
     */
    getAll: function getAll() {
      return this._plugins;
    },
    /**
     * Calls enabled plugins for `chart` on the specified hook and with the given args.
     * This method immediately returns as soon as a plugin explicitly returns false. The
     * returned value can be used, for instance, to interrupt the current action.
     * @param {Chart} chart - The chart instance for which plugins should be called.
     * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
     * @param {Array} [args] - Extra arguments to apply to the hook call.
     * @returns {boolean} false if any of the plugins return false, else returns true.
     */
    notify: function notify(chart, hook, args) {
      var descriptors = this.descriptors(chart);
      var ilen = descriptors.length;
      var i, descriptor, plugin, params, method;
      for (i = 0; i < ilen; ++i) {
        descriptor = descriptors[i];
        plugin = descriptor.plugin;
        method = plugin[hook];
        if (typeof method === 'function') {
          params = [chart].concat(args || []);
          params.push(descriptor.options);
          if (method.apply(plugin, params) === false) {
            return false;
          }
        }
      }
      return true;
    },
    /**
     * Returns descriptors of enabled plugins for the given chart.
     * @returns {object[]} [{ plugin, options }]
     * @private
     */
    descriptors: function descriptors(chart) {
      var cache = chart.$plugins || (chart.$plugins = {});
      if (cache.id === this._cacheId) {
        return cache.descriptors;
      }
      var plugins = [];
      var descriptors = [];
      var config = chart && chart.config || {};
      var options = config.options && config.options.plugins || {};
      this._plugins.concat(config.plugins || []).forEach(function (plugin) {
        var idx = plugins.indexOf(plugin);
        if (idx !== -1) {
          return;
        }
        var id = plugin.id;
        var opts = options[id];
        if (opts === false) {
          return;
        }
        if (opts === true) {
          opts = helpers$1.clone(core_defaults.global.plugins[id]);
        }
        plugins.push(plugin);
        descriptors.push({
          plugin: plugin,
          options: opts || {}
        });
      });
      cache.descriptors = descriptors;
      cache.id = this._cacheId;
      return descriptors;
    },
    /**
     * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
     * but in some cases, this reference can be changed by the user when updating options.
     * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
     * @private
     */
    _invalidate: function _invalidate(chart) {
      delete chart.$plugins;
    }
  };
  var core_scaleService = {
    // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
    // use the new chart options to grab the correct scale
    constructors: {},
    // Use a registration function so that we can move to an ES6 map when we no longer need to support
    // old browsers

    // Scale config defaults
    defaults: {},
    registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
      this.constructors[type] = scaleConstructor;
      this.defaults[type] = helpers$1.clone(scaleDefaults);
    },
    getScaleConstructor: function getScaleConstructor(type) {
      return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
    },
    getScaleDefaults: function getScaleDefaults(type) {
      // Return the scale defaults merged with the global settings so that we always use the latest ones
      return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
    },
    updateScaleDefaults: function updateScaleDefaults(type, additions) {
      var me = this;
      if (me.defaults.hasOwnProperty(type)) {
        me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
      }
    },
    addScalesToLayout: function addScalesToLayout(chart) {
      // Adds each scale to the chart.boxes array to be sized accordingly
      helpers$1.each(chart.scales, function (scale) {
        // Set ILayoutItem parameters for backwards compatibility
        scale.fullWidth = scale.options.fullWidth;
        scale.position = scale.options.position;
        scale.weight = scale.options.weight;
        core_layouts.addBox(chart, scale);
      });
    }
  };
  var valueOrDefault$7 = helpers$1.valueOrDefault;
  core_defaults._set('global', {
    tooltips: {
      enabled: true,
      custom: null,
      mode: 'nearest',
      position: 'average',
      intersect: true,
      backgroundColor: 'rgba(0,0,0,0.8)',
      titleFontStyle: 'bold',
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleFontColor: '#fff',
      titleAlign: 'left',
      bodySpacing: 2,
      bodyFontColor: '#fff',
      bodyAlign: 'left',
      footerFontStyle: 'bold',
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFontColor: '#fff',
      footerAlign: 'left',
      yPadding: 6,
      xPadding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      multiKeyBackground: '#fff',
      displayColors: true,
      borderColor: 'rgba(0,0,0,0)',
      borderWidth: 0,
      callbacks: {
        // Args are: (tooltipItems, data)
        beforeTitle: helpers$1.noop,
        title: function title(tooltipItems, data) {
          var title = '';
          var labels = data.labels;
          var labelCount = labels ? labels.length : 0;
          if (tooltipItems.length > 0) {
            var item = tooltipItems[0];
            if (item.label) {
              title = item.label;
            } else if (item.xLabel) {
              title = item.xLabel;
            } else if (labelCount > 0 && item.index < labelCount) {
              title = labels[item.index];
            }
          }
          return title;
        },
        afterTitle: helpers$1.noop,
        // Args are: (tooltipItems, data)
        beforeBody: helpers$1.noop,
        // Args are: (tooltipItem, data)
        beforeLabel: helpers$1.noop,
        label: function label(tooltipItem, data) {
          var label = data.datasets[tooltipItem.datasetIndex].label || '';
          if (label) {
            label += ': ';
          }
          if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
            label += tooltipItem.value;
          } else {
            label += tooltipItem.yLabel;
          }
          return label;
        },
        labelColor: function labelColor(tooltipItem, chart) {
          var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
          var activeElement = meta.data[tooltipItem.index];
          var view = activeElement._view;
          return {
            borderColor: view.borderColor,
            backgroundColor: view.backgroundColor
          };
        },
        labelTextColor: function labelTextColor() {
          return this._options.bodyFontColor;
        },
        afterLabel: helpers$1.noop,
        // Args are: (tooltipItems, data)
        afterBody: helpers$1.noop,
        // Args are: (tooltipItems, data)
        beforeFooter: helpers$1.noop,
        footer: helpers$1.noop,
        afterFooter: helpers$1.noop
      }
    }
  });
  var positioners = {
    /**
     * Average mode places the tooltip at the average position of the elements shown
     * @function Chart.Tooltip.positioners.average
     * @param elements {ChartElement[]} the elements being displayed in the tooltip
     * @returns {object} tooltip position
     */
    average: function average(elements) {
      if (!elements.length) {
        return false;
      }
      var i, len;
      var x = 0;
      var y = 0;
      var count = 0;
      for (i = 0, len = elements.length; i < len; ++i) {
        var el = elements[i];
        if (el && el.hasValue()) {
          var pos = el.tooltipPosition();
          x += pos.x;
          y += pos.y;
          ++count;
        }
      }
      return {
        x: x / count,
        y: y / count
      };
    },
    /**
     * Gets the tooltip position nearest of the item nearest to the event position
     * @function Chart.Tooltip.positioners.nearest
     * @param elements {Chart.Element[]} the tooltip elements
     * @param eventPosition {object} the position of the event in canvas coordinates
     * @returns {object} the tooltip position
     */
    nearest: function nearest(elements, eventPosition) {
      var x = eventPosition.x;
      var y = eventPosition.y;
      var minDistance = Number.POSITIVE_INFINITY;
      var i, len, nearestElement;
      for (i = 0, len = elements.length; i < len; ++i) {
        var el = elements[i];
        if (el && el.hasValue()) {
          var center = el.getCenterPoint();
          var d = helpers$1.distanceBetweenPoints(eventPosition, center);
          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        var tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x: x,
        y: y
      };
    }
  };

  // Helper to push or concat based on if the 2nd parameter is an array or not
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (helpers$1.isArray(toPush)) {
        // base = base.concat(toPush);
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }

  /**
   * Returns array of strings split by newline
   * @param {string} value - The value to split by newline.
   * @returns {string[]} value if newline present - Returned from String split() method
   * @function
   */
  function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
      return str.split('\n');
    }
    return str;
  }

  /**
   * Private helper to create a tooltip item model
   * @param element - the chart element (point, arc, bar) to create the tooltip item for
   * @return new tooltip item
   */
  function createTooltipItem(element) {
    var xScale = element._xScale;
    var yScale = element._yScale || element._scale; // handle radar || polarArea charts
    var index = element._index;
    var datasetIndex = element._datasetIndex;
    var controller = element._chart.getDatasetMeta(datasetIndex).controller;
    var indexScale = controller._getIndexScale();
    var valueScale = controller._getValueScale();
    return {
      xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
      yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
      label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
      value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
      index: index,
      datasetIndex: datasetIndex,
      x: element._model.x,
      y: element._model.y
    };
  }

  /**
   * Helper to get the reset model for the tooltip
   * @param tooltipOpts {object} the tooltip options
   */
  function getBaseModel(tooltipOpts) {
    var globalDefaults = core_defaults.global;
    return {
      // Positioning
      xPadding: tooltipOpts.xPadding,
      yPadding: tooltipOpts.yPadding,
      xAlign: tooltipOpts.xAlign,
      yAlign: tooltipOpts.yAlign,
      // Body
      bodyFontColor: tooltipOpts.bodyFontColor,
      _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
      _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
      _bodyAlign: tooltipOpts.bodyAlign,
      bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
      bodySpacing: tooltipOpts.bodySpacing,
      // Title
      titleFontColor: tooltipOpts.titleFontColor,
      _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
      _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
      titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
      _titleAlign: tooltipOpts.titleAlign,
      titleSpacing: tooltipOpts.titleSpacing,
      titleMarginBottom: tooltipOpts.titleMarginBottom,
      // Footer
      footerFontColor: tooltipOpts.footerFontColor,
      _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
      _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
      footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
      _footerAlign: tooltipOpts.footerAlign,
      footerSpacing: tooltipOpts.footerSpacing,
      footerMarginTop: tooltipOpts.footerMarginTop,
      // Appearance
      caretSize: tooltipOpts.caretSize,
      cornerRadius: tooltipOpts.cornerRadius,
      backgroundColor: tooltipOpts.backgroundColor,
      opacity: 0,
      legendColorBackground: tooltipOpts.multiKeyBackground,
      displayColors: tooltipOpts.displayColors,
      borderColor: tooltipOpts.borderColor,
      borderWidth: tooltipOpts.borderWidth
    };
  }

  /**
   * Get the size of the tooltip
   */
  function getTooltipSize(tooltip, model) {
    var ctx = tooltip._chart.ctx;
    var height = model.yPadding * 2; // Tooltip Padding
    var width = 0;

    // Count of all lines in the body
    var body = model.body;
    var combinedBodyLength = body.reduce(function (count, bodyItem) {
      return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
    }, 0);
    combinedBodyLength += model.beforeBody.length + model.afterBody.length;
    var titleLineCount = model.title.length;
    var footerLineCount = model.footer.length;
    var titleFontSize = model.titleFontSize;
    var bodyFontSize = model.bodyFontSize;
    var footerFontSize = model.footerFontSize;
    height += titleLineCount * titleFontSize; // Title Lines
    height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
    height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
    height += combinedBodyLength * bodyFontSize; // Body Lines
    height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
    height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
    height += footerLineCount * footerFontSize; // Footer Lines
    height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

    // Title width
    var widthPadding = 0;
    var maxLineWidth = function maxLineWidth(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
    helpers$1.each(model.title, maxLineWidth);

    // Body width
    ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
    helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

    // Body lines may include some extra width due to the color box
    widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
    helpers$1.each(body, function (bodyItem) {
      helpers$1.each(bodyItem.before, maxLineWidth);
      helpers$1.each(bodyItem.lines, maxLineWidth);
      helpers$1.each(bodyItem.after, maxLineWidth);
    });

    // Reset back to 0
    widthPadding = 0;

    // Footer width
    ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
    helpers$1.each(model.footer, maxLineWidth);

    // Add padding
    width += 2 * model.xPadding;
    return {
      width: width,
      height: height
    };
  }

  /**
   * Helper to get the alignment of a tooltip given the size
   */
  function determineAlignment(tooltip, size) {
    var model = tooltip._model;
    var chart = tooltip._chart;
    var chartArea = tooltip._chart.chartArea;
    var xAlign = 'center';
    var yAlign = 'center';
    if (model.y < size.height) {
      yAlign = 'top';
    } else if (model.y > chart.height - size.height) {
      yAlign = 'bottom';
    }
    var lf, rf; // functions to determine left, right alignment
    var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
    var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
    var midX = (chartArea.left + chartArea.right) / 2;
    var midY = (chartArea.top + chartArea.bottom) / 2;
    if (yAlign === 'center') {
      lf = function lf(x) {
        return x <= midX;
      };
      rf = function rf(x) {
        return x > midX;
      };
    } else {
      lf = function lf(x) {
        return x <= size.width / 2;
      };
      rf = function rf(x) {
        return x >= chart.width - size.width / 2;
      };
    }
    olf = function olf(x) {
      return x + size.width + model.caretSize + model.caretPadding > chart.width;
    };
    orf = function orf(x) {
      return x - size.width - model.caretSize - model.caretPadding < 0;
    };
    yf = function yf(y) {
      return y <= midY ? 'top' : 'bottom';
    };
    if (lf(model.x)) {
      xAlign = 'left';

      // Is tooltip too wide and goes over the right side of the chart.?
      if (olf(model.x)) {
        xAlign = 'center';
        yAlign = yf(model.y);
      }
    } else if (rf(model.x)) {
      xAlign = 'right';

      // Is tooltip too wide and goes outside left edge of canvas?
      if (orf(model.x)) {
        xAlign = 'center';
        yAlign = yf(model.y);
      }
    }
    var opts = tooltip._options;
    return {
      xAlign: opts.xAlign ? opts.xAlign : xAlign,
      yAlign: opts.yAlign ? opts.yAlign : yAlign
    };
  }

  /**
   * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
   */
  function getBackgroundPoint(vm, size, alignment, chart) {
    // Background Position
    var x = vm.x;
    var y = vm.y;
    var caretSize = vm.caretSize;
    var caretPadding = vm.caretPadding;
    var cornerRadius = vm.cornerRadius;
    var xAlign = alignment.xAlign;
    var yAlign = alignment.yAlign;
    var paddingAndSize = caretSize + caretPadding;
    var radiusAndPadding = cornerRadius + caretPadding;
    if (xAlign === 'right') {
      x -= size.width;
    } else if (xAlign === 'center') {
      x -= size.width / 2;
      if (x + size.width > chart.width) {
        x = chart.width - size.width;
      }
      if (x < 0) {
        x = 0;
      }
    }
    if (yAlign === 'top') {
      y += paddingAndSize;
    } else if (yAlign === 'bottom') {
      y -= size.height + paddingAndSize;
    } else {
      y -= size.height / 2;
    }
    if (yAlign === 'center') {
      if (xAlign === 'left') {
        x += paddingAndSize;
      } else if (xAlign === 'right') {
        x -= paddingAndSize;
      }
    } else if (xAlign === 'left') {
      x -= radiusAndPadding;
    } else if (xAlign === 'right') {
      x += radiusAndPadding;
    }
    return {
      x: x,
      y: y
    };
  }
  function getAlignedX(vm, align) {
    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
  }

  /**
   * Helper to build before and after body lines
   */
  function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
  }
  var exports$3 = core_element.extend({
    initialize: function initialize() {
      this._model = getBaseModel(this._options);
      this._lastActive = [];
    },
    // Get the title
    // Args are: (tooltipItem, data)
    getTitle: function getTitle() {
      var me = this;
      var opts = me._options;
      var callbacks = opts.callbacks;
      var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
      var title = callbacks.title.apply(me, arguments);
      var afterTitle = callbacks.afterTitle.apply(me, arguments);
      var lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    },
    // Args are: (tooltipItem, data)
    getBeforeBody: function getBeforeBody() {
      return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
    },
    // Args are: (tooltipItem, data)
    getBody: function getBody(tooltipItems, data) {
      var me = this;
      var callbacks = me._options.callbacks;
      var bodyItems = [];
      helpers$1.each(tooltipItems, function (tooltipItem) {
        var bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    },
    // Args are: (tooltipItem, data)
    getAfterBody: function getAfterBody() {
      return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
    },
    // Get the footer and beforeFooter and afterFooter lines
    // Args are: (tooltipItem, data)
    getFooter: function getFooter() {
      var me = this;
      var callbacks = me._options.callbacks;
      var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
      var footer = callbacks.footer.apply(me, arguments);
      var afterFooter = callbacks.afterFooter.apply(me, arguments);
      var lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    },
    update: function update(changed) {
      var me = this;
      var opts = me._options;

      // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
      // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
      // which breaks any animations.
      var existingModel = me._model;
      var model = me._model = getBaseModel(opts);
      var active = me._active;
      var data = me._data;

      // In the case where active.length === 0 we need to keep these at existing values for good animations
      var alignment = {
        xAlign: existingModel.xAlign,
        yAlign: existingModel.yAlign
      };
      var backgroundPoint = {
        x: existingModel.x,
        y: existingModel.y
      };
      var tooltipSize = {
        width: existingModel.width,
        height: existingModel.height
      };
      var tooltipPosition = {
        x: existingModel.caretX,
        y: existingModel.caretY
      };
      var i, len;
      if (active.length) {
        model.opacity = 1;
        var labelColors = [];
        var labelTextColors = [];
        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
        var tooltipItems = [];
        for (i = 0, len = active.length; i < len; ++i) {
          tooltipItems.push(createTooltipItem(active[i]));
        }

        // If the user provided a filter function, use it to modify the tooltip items
        if (opts.filter) {
          tooltipItems = tooltipItems.filter(function (a) {
            return opts.filter(a, data);
          });
        }

        // If the user provided a sorting function, use it to modify the tooltip items
        if (opts.itemSort) {
          tooltipItems = tooltipItems.sort(function (a, b) {
            return opts.itemSort(a, b, data);
          });
        }

        // Determine colors for boxes
        helpers$1.each(tooltipItems, function (tooltipItem) {
          labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
          labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
        });

        // Build the Text Lines
        model.title = me.getTitle(tooltipItems, data);
        model.beforeBody = me.getBeforeBody(tooltipItems, data);
        model.body = me.getBody(tooltipItems, data);
        model.afterBody = me.getAfterBody(tooltipItems, data);
        model.footer = me.getFooter(tooltipItems, data);

        // Initial positioning and colors
        model.x = tooltipPosition.x;
        model.y = tooltipPosition.y;
        model.caretPadding = opts.caretPadding;
        model.labelColors = labelColors;
        model.labelTextColors = labelTextColors;

        // data points
        model.dataPoints = tooltipItems;

        // We need to determine alignment of the tooltip
        tooltipSize = getTooltipSize(this, model);
        alignment = determineAlignment(this, tooltipSize);
        // Final Size and Position
        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
      } else {
        model.opacity = 0;
      }
      model.xAlign = alignment.xAlign;
      model.yAlign = alignment.yAlign;
      model.x = backgroundPoint.x;
      model.y = backgroundPoint.y;
      model.width = tooltipSize.width;
      model.height = tooltipSize.height;

      // Point where the caret on the tooltip points to
      model.caretX = tooltipPosition.x;
      model.caretY = tooltipPosition.y;
      me._model = model;
      if (changed && opts.custom) {
        opts.custom.call(me, model);
      }
      return me;
    },
    drawCaret: function drawCaret(tooltipPoint, size) {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    },
    getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
      var x1, x2, x3, y1, y2, y3;
      var caretSize = vm.caretSize;
      var cornerRadius = vm.cornerRadius;
      var xAlign = vm.xAlign;
      var yAlign = vm.yAlign;
      var ptX = tooltipPoint.x;
      var ptY = tooltipPoint.y;
      var width = size.width;
      var height = size.height;
      if (yAlign === 'center') {
        y2 = ptY + height / 2;
        if (xAlign === 'left') {
          x1 = ptX;
          x2 = x1 - caretSize;
          x3 = x1;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          x3 = x1;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
      } else {
        if (xAlign === 'left') {
          x2 = ptX + cornerRadius + caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else if (xAlign === 'right') {
          x2 = ptX + width - cornerRadius - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          x2 = vm.caretX;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        }
        if (yAlign === 'top') {
          y1 = ptY;
          y2 = y1 - caretSize;
          y3 = y1;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          y3 = y1;
          // invert drawing order
          var tmp = x3;
          x3 = x1;
          x1 = tmp;
        }
      }
      return {
        x1: x1,
        x2: x2,
        x3: x3,
        y1: y1,
        y2: y2,
        y3: y3
      };
    },
    drawTitle: function drawTitle(pt, vm, ctx) {
      var title = vm.title;
      if (title.length) {
        pt.x = getAlignedX(vm, vm._titleAlign);
        ctx.textAlign = vm._titleAlign;
        ctx.textBaseline = 'top';
        var titleFontSize = vm.titleFontSize;
        var titleSpacing = vm.titleSpacing;
        ctx.fillStyle = vm.titleFontColor;
        ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
        var i, len;
        for (i = 0, len = title.length; i < len; ++i) {
          ctx.fillText(title[i], pt.x, pt.y);
          pt.y += titleFontSize + titleSpacing; // Line Height and spacing

          if (i + 1 === title.length) {
            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
          }
        }
      }
    },
    drawBody: function drawBody(pt, vm, ctx) {
      var bodyFontSize = vm.bodyFontSize;
      var bodySpacing = vm.bodySpacing;
      var bodyAlign = vm._bodyAlign;
      var body = vm.body;
      var drawColorBoxes = vm.displayColors;
      var labelColors = vm.labelColors;
      var xLinePadding = 0;
      var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
      var textColor;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = 'top';
      ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
      pt.x = getAlignedX(vm, bodyAlign);

      // Before Body
      var fillLineOfText = function fillLineOfText(line) {
        ctx.fillText(line, pt.x + xLinePadding, pt.y);
        pt.y += bodyFontSize + bodySpacing;
      };

      // Before body lines
      ctx.fillStyle = vm.bodyFontColor;
      helpers$1.each(vm.beforeBody, fillLineOfText);
      xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;

      // Draw body lines now
      helpers$1.each(body, function (bodyItem, i) {
        textColor = vm.labelTextColors[i];
        ctx.fillStyle = textColor;
        helpers$1.each(bodyItem.before, fillLineOfText);
        helpers$1.each(bodyItem.lines, function (line) {
          // Draw Legend-like boxes if needed
          if (drawColorBoxes) {
            // Fill a white rect so that colours merge nicely if the opacity is < 1
            ctx.fillStyle = vm.legendColorBackground;
            ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);

            // Border
            ctx.lineWidth = 1;
            ctx.strokeStyle = labelColors[i].borderColor;
            ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);

            // Inner square
            ctx.fillStyle = labelColors[i].backgroundColor;
            ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
            ctx.fillStyle = textColor;
          }
          fillLineOfText(line);
        });
        helpers$1.each(bodyItem.after, fillLineOfText);
      });

      // Reset back to 0 for after body
      xLinePadding = 0;

      // After body lines
      helpers$1.each(vm.afterBody, fillLineOfText);
      pt.y -= bodySpacing; // Remove last body spacing
    },
    drawFooter: function drawFooter(pt, vm, ctx) {
      var footer = vm.footer;
      if (footer.length) {
        pt.x = getAlignedX(vm, vm._footerAlign);
        pt.y += vm.footerMarginTop;
        ctx.textAlign = vm._footerAlign;
        ctx.textBaseline = 'top';
        ctx.fillStyle = vm.footerFontColor;
        ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
        helpers$1.each(footer, function (line) {
          ctx.fillText(line, pt.x, pt.y);
          pt.y += vm.footerFontSize + vm.footerSpacing;
        });
      }
    },
    drawBackground: function drawBackground(pt, vm, ctx, tooltipSize) {
      ctx.fillStyle = vm.backgroundColor;
      ctx.strokeStyle = vm.borderColor;
      ctx.lineWidth = vm.borderWidth;
      var xAlign = vm.xAlign;
      var yAlign = vm.yAlign;
      var x = pt.x;
      var y = pt.y;
      var width = tooltipSize.width;
      var height = tooltipSize.height;
      var radius = vm.cornerRadius;
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      if (yAlign === 'top') {
        this.drawCaret(pt, tooltipSize);
      }
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      if (yAlign === 'center' && xAlign === 'right') {
        this.drawCaret(pt, tooltipSize);
      }
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      if (yAlign === 'bottom') {
        this.drawCaret(pt, tooltipSize);
      }
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      if (yAlign === 'center' && xAlign === 'left') {
        this.drawCaret(pt, tooltipSize);
      }
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
      if (vm.borderWidth > 0) {
        ctx.stroke();
      }
    },
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;
      if (vm.opacity === 0) {
        return;
      }
      var tooltipSize = {
        width: vm.width,
        height: vm.height
      };
      var pt = {
        x: vm.x,
        y: vm.y
      };

      // IE11/Edge does not like very small opacities, so snap to 0
      var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

      // Truthy/falsey value for empty tooltip
      var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
      if (this._options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;

        // Draw Background
        this.drawBackground(pt, vm, ctx, tooltipSize);

        // Draw Title, Body, and Footer
        pt.y += vm.yPadding;

        // Titles
        this.drawTitle(pt, vm, ctx);

        // Body
        this.drawBody(pt, vm, ctx);

        // Footer
        this.drawFooter(pt, vm, ctx);
        ctx.restore();
      }
    },
    /**
     * Handle an event
     * @private
     * @param {IEvent} event - The event to handle
     * @returns {boolean} true if the tooltip changed
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var options = me._options;
      var changed = false;
      me._lastActive = me._lastActive || [];

      // Find Active Elements for tooltips
      if (e.type === 'mouseout') {
        me._active = [];
      } else {
        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
      }

      // Remember Last Actives
      changed = !helpers$1.arrayEquals(me._active, me._lastActive);

      // Only handle target event on tooltip change
      if (changed) {
        me._lastActive = me._active;
        if (options.enabled || options.custom) {
          me._eventPosition = {
            x: e.x,
            y: e.y
          };
          me.update(true);
          me.pivot();
        }
      }
      return changed;
    }
  });

  /**
   * @namespace Chart.Tooltip.positioners
   */
  var positioners_1 = positioners;
  var core_tooltip = exports$3;
  core_tooltip.positioners = positioners_1;
  var valueOrDefault$8 = helpers$1.valueOrDefault;
  core_defaults._set('global', {
    elements: {},
    events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
    hover: {
      onHover: null,
      mode: 'nearest',
      intersect: true,
      animationDuration: 400
    },
    onClick: null,
    maintainAspectRatio: true,
    responsive: true,
    responsiveAnimationDuration: 0
  });

  /**
   * Recursively merge the given config objects representing the `scales` option
   * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
   * returns a deep copy of the result, thus doesn't alter inputs.
   */
  function mergeScaleConfig( /* config objects ... */
  ) {
    return helpers$1.merge({}, [].slice.call(arguments), {
      merger: function merger(key, target, source, options) {
        if (key === 'xAxes' || key === 'yAxes') {
          var slen = source[key].length;
          var i, type, scale;
          if (!target[key]) {
            target[key] = [];
          }
          for (i = 0; i < slen; ++i) {
            scale = source[key][i];
            type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');
            if (i >= target[key].length) {
              target[key].push({});
            }
            if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
              // new/untyped scale or type changed: let's apply the new defaults
              // then merge source scale to correctly overwrite the defaults.
              helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
            } else {
              // scales type are the same
              helpers$1.merge(target[key][i], scale);
            }
          }
        } else {
          helpers$1._merger(key, target, source, options);
        }
      }
    });
  }

  /**
   * Recursively merge the given config objects as the root options by handling
   * default scale options for the `scales` and `scale` properties, then returns
   * a deep copy of the result, thus doesn't alter inputs.
   */
  function mergeConfig( /* config objects ... */
  ) {
    return helpers$1.merge({}, [].slice.call(arguments), {
      merger: function merger(key, target, source, options) {
        var tval = target[key] || {};
        var sval = source[key];
        if (key === 'scales') {
          // scale config merging is complex. Add our own function here for that
          target[key] = mergeScaleConfig(tval, sval);
        } else if (key === 'scale') {
          // used in polar area & radar charts since there is only one scale
          target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
        } else {
          helpers$1._merger(key, target, source, options);
        }
      }
    });
  }
  function initConfig(config) {
    config = config || {};

    // Do NOT use mergeConfig for the data object because this method merges arrays
    // and so would change references to labels and datasets, preventing data updates.
    var data = config.data = config.data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
    return config;
  }
  function updateConfig(chart) {
    var newOptions = chart.options;
    helpers$1.each(chart.scales, function (scale) {
      core_layouts.removeBox(chart, scale);
    });
    newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
    chart.options = chart.config.options = newOptions;
    chart.ensureScalesHaveIDs();
    chart.buildOrUpdateScales();

    // Tooltip
    chart.tooltip._options = newOptions.tooltips;
    chart.tooltip.initialize();
  }
  function positionIsHorizontal(position) {
    return position === 'top' || position === 'bottom';
  }
  var Chart = function Chart(item, config) {
    this.construct(item, config);
    return this;
  };
  helpers$1.extend(Chart.prototype, /** @lends Chart */{
    /**
     * @private
     */
    construct: function construct(item, config) {
      var me = this;
      config = initConfig(config);
      var context = platform.acquireContext(item, config);
      var canvas = context && context.canvas;
      var height = canvas && canvas.height;
      var width = canvas && canvas.width;
      me.id = helpers$1.uid();
      me.ctx = context;
      me.canvas = canvas;
      me.config = config;
      me.width = width;
      me.height = height;
      me.aspectRatio = height ? width / height : null;
      me.options = config.options;
      me._bufferedRender = false;

      /**
       * Provided for backward compatibility, Chart and Chart.Controller have been merged,
       * the "instance" still need to be defined since it might be called from plugins.
       * @prop Chart#chart
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */
      me.chart = me;
      me.controller = me; // chart.chart.controller #inception

      // Add the chart instance to the global namespace
      Chart.instances[me.id] = me;

      // Define alias to the config data: `chart.data === chart.config.data`
      Object.defineProperty(me, 'data', {
        get: function get() {
          return me.config.data;
        },
        set: function set(value) {
          me.config.data = value;
        }
      });
      if (!context || !canvas) {
        // The given item is not a compatible context2d element, let's return before finalizing
        // the chart initialization but after setting basic chart / controller properties that
        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
        // https://github.com/chartjs/Chart.js/issues/2807
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      me.initialize();
      me.update();
    },
    /**
     * @private
     */
    initialize: function initialize() {
      var me = this;

      // Before init plugin notification
      core_plugins.notify(me, 'beforeInit');
      helpers$1.retinaScale(me, me.options.devicePixelRatio);
      me.bindEvents();
      if (me.options.responsive) {
        // Initial resize before chart draws (must be silent to preserve initial animations).
        me.resize(true);
      }

      // Make sure scales have IDs and are built before we build any controllers.
      me.ensureScalesHaveIDs();
      me.buildOrUpdateScales();
      me.initToolTip();

      // After init plugin notification
      core_plugins.notify(me, 'afterInit');
      return me;
    },
    clear: function clear() {
      helpers$1.canvas.clear(this);
      return this;
    },
    stop: function stop() {
      // Stops any current animation loop occurring
      core_animations.cancelAnimation(this);
      return this;
    },
    resize: function resize(silent) {
      var me = this;
      var options = me.options;
      var canvas = me.canvas;
      var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;

      // the canvas render width and height will be casted to integers so make sure that
      // the canvas display style uses the same integer values to avoid blurring effect.

      // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
      var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
      var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));
      if (me.width === newWidth && me.height === newHeight) {
        return;
      }
      canvas.width = me.width = newWidth;
      canvas.height = me.height = newHeight;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      helpers$1.retinaScale(me, options.devicePixelRatio);
      if (!silent) {
        // Notify any plugins about the resize
        var newSize = {
          width: newWidth,
          height: newHeight
        };
        core_plugins.notify(me, 'resize', [newSize]);

        // Notify of resize
        if (options.onResize) {
          options.onResize(me, newSize);
        }
        me.stop();
        me.update({
          duration: options.responsiveAnimationDuration
        });
      }
    },
    ensureScalesHaveIDs: function ensureScalesHaveIDs() {
      var options = this.options;
      var scalesOptions = options.scales || {};
      var scaleOptions = options.scale;
      helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
        xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
      });
      helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
        yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
      });
      if (scaleOptions) {
        scaleOptions.id = scaleOptions.id || 'scale';
      }
    },
    /**
     * Builds a map of scale ID to scale object for future lookup.
     */
    buildOrUpdateScales: function buildOrUpdateScales() {
      var me = this;
      var options = me.options;
      var scales = me.scales || {};
      var items = [];
      var updated = Object.keys(scales).reduce(function (obj, id) {
        obj[id] = false;
        return obj;
      }, {});
      if (options.scales) {
        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
          return {
            options: xAxisOptions,
            dtype: 'category',
            dposition: 'bottom'
          };
        }), (options.scales.yAxes || []).map(function (yAxisOptions) {
          return {
            options: yAxisOptions,
            dtype: 'linear',
            dposition: 'left'
          };
        }));
      }
      if (options.scale) {
        items.push({
          options: options.scale,
          dtype: 'radialLinear',
          isDefault: true,
          dposition: 'chartArea'
        });
      }
      helpers$1.each(items, function (item) {
        var scaleOptions = item.options;
        var id = scaleOptions.id;
        var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);
        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        var scale = null;
        if (id in scales && scales[id].type === scaleType) {
          scale = scales[id];
          scale.options = scaleOptions;
          scale.ctx = me.ctx;
          scale.chart = me;
        } else {
          var scaleClass = core_scaleService.getScaleConstructor(scaleType);
          if (!scaleClass) {
            return;
          }
          scale = new scaleClass({
            id: id,
            type: scaleType,
            options: scaleOptions,
            ctx: me.ctx,
            chart: me
          });
          scales[scale.id] = scale;
        }
        scale.mergeTicksOptions();

        // TODO(SB): I think we should be able to remove this custom case (options.scale)
        // and consider it as a regular scale part of the "scales"" map only! This would
        // make the logic easier and remove some useless? custom code.
        if (item.isDefault) {
          me.scale = scale;
        }
      });
      // clear up discarded scales
      helpers$1.each(updated, function (hasUpdated, id) {
        if (!hasUpdated) {
          delete scales[id];
        }
      });
      me.scales = scales;
      core_scaleService.addScalesToLayout(this);
    },
    buildOrUpdateControllers: function buildOrUpdateControllers() {
      var me = this;
      var newControllers = [];
      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
        var meta = me.getDatasetMeta(datasetIndex);
        var type = dataset.type || me.config.type;
        if (meta.type && meta.type !== type) {
          me.destroyDatasetMeta(datasetIndex);
          meta = me.getDatasetMeta(datasetIndex);
        }
        meta.type = type;
        if (meta.controller) {
          meta.controller.updateIndex(datasetIndex);
          meta.controller.linkScales();
        } else {
          var ControllerClass = controllers[meta.type];
          if (ControllerClass === undefined) {
            throw new Error('"' + meta.type + '" is not a chart type.');
          }
          meta.controller = new ControllerClass(me, datasetIndex);
          newControllers.push(meta.controller);
        }
      }, me);
      return newControllers;
    },
    /**
     * Reset the elements of all datasets
     * @private
     */
    resetElements: function resetElements() {
      var me = this;
      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
        me.getDatasetMeta(datasetIndex).controller.reset();
      }, me);
    },
    /**
    * Resets the chart back to it's state before the initial animation
    */
    reset: function reset() {
      this.resetElements();
      this.tooltip.initialize();
    },
    update: function update(config) {
      var me = this;
      if (!config || _typeof(config) !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }
      updateConfig(me);

      // plugins options references might have change, let's invalidate the cache
      // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
      core_plugins._invalidate(me);
      if (core_plugins.notify(me, 'beforeUpdate') === false) {
        return;
      }

      // In case the entire data object changed
      me.tooltip._data = me.data;

      // Make sure dataset controllers are updated and new controllers are reset
      var newControllers = me.buildOrUpdateControllers();

      // Make sure all dataset controllers have correct meta data counts
      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
        me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
      }, me);
      me.updateLayout();

      // Can only reset the new controllers after the scales have been updated
      if (me.options.animation && me.options.animation.duration) {
        helpers$1.each(newControllers, function (controller) {
          controller.reset();
        });
      }
      me.updateDatasets();

      // Need to reset tooltip in case it is displayed with elements that are removed
      // after update.
      me.tooltip.initialize();

      // Last active contains items that were previously in the tooltip.
      // When we reset the tooltip, we need to clear it
      me.lastActive = [];

      // Do this before render so that any plugins that need final scale updates can use it
      core_plugins.notify(me, 'afterUpdate');
      if (me._bufferedRender) {
        me._bufferedRequest = {
          duration: config.duration,
          easing: config.easing,
          lazy: config.lazy
        };
      } else {
        me.render(config);
      }
    },
    /**
     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
     * hook, in which case, plugins will not be called on `afterLayout`.
     * @private
     */
    updateLayout: function updateLayout() {
      var me = this;
      if (core_plugins.notify(me, 'beforeLayout') === false) {
        return;
      }
      core_layouts.update(this, this.width, this.height);

      /**
       * Provided for backward compatibility, use `afterLayout` instead.
       * @method IPlugin#afterScaleUpdate
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */
      core_plugins.notify(me, 'afterScaleUpdate');
      core_plugins.notify(me, 'afterLayout');
    },
    /**
     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
     * @private
     */
    updateDatasets: function updateDatasets() {
      var me = this;
      if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
        return;
      }
      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.updateDataset(i);
      }
      core_plugins.notify(me, 'afterDatasetsUpdate');
    },
    /**
     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
     * @private
     */
    updateDataset: function updateDataset(index) {
      var me = this;
      var meta = me.getDatasetMeta(index);
      var args = {
        meta: meta,
        index: index
      };
      if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
        return;
      }
      meta.controller.update();
      core_plugins.notify(me, 'afterDatasetUpdate', [args]);
    },
    render: function render(config) {
      var me = this;
      if (!config || _typeof(config) !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }
      var animationOptions = me.options.animation;
      var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
      var lazy = config.lazy;
      if (core_plugins.notify(me, 'beforeRender') === false) {
        return;
      }
      var onComplete = function onComplete(animation) {
        core_plugins.notify(me, 'afterRender');
        helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
      };
      if (animationOptions && duration) {
        var animation = new core_animation({
          numSteps: duration / 16.66,
          // 60 fps
          easing: config.easing || animationOptions.easing,
          render: function render(chart, animationObject) {
            var easingFunction = helpers$1.easing.effects[animationObject.easing];
            var currentStep = animationObject.currentStep;
            var stepDecimal = currentStep / animationObject.numSteps;
            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
          },
          onAnimationProgress: animationOptions.onProgress,
          onAnimationComplete: onComplete
        });
        core_animations.addAnimation(me, animation, duration, lazy);
      } else {
        me.draw();

        // See https://github.com/chartjs/Chart.js/issues/3781
        onComplete(new core_animation({
          numSteps: 0,
          chart: me
        }));
      }
      return me;
    },
    draw: function draw(easingValue) {
      var me = this;
      me.clear();
      if (helpers$1.isNullOrUndef(easingValue)) {
        easingValue = 1;
      }
      me.transition(easingValue);
      if (me.width <= 0 || me.height <= 0) {
        return;
      }
      if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
        return;
      }

      // Draw all the scales
      helpers$1.each(me.boxes, function (box) {
        box.draw(me.chartArea);
      }, me);
      me.drawDatasets(easingValue);
      me._drawTooltip(easingValue);
      core_plugins.notify(me, 'afterDraw', [easingValue]);
    },
    /**
     * @private
     */
    transition: function transition(easingValue) {
      var me = this;
      for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
        if (me.isDatasetVisible(i)) {
          me.getDatasetMeta(i).controller.transition(easingValue);
        }
      }
      me.tooltip.transition(easingValue);
    },
    /**
     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
     * @private
     */
    drawDatasets: function drawDatasets(easingValue) {
      var me = this;
      if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
        return;
      }

      // Draw datasets reversed to support proper line stacking
      for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
        if (me.isDatasetVisible(i)) {
          me.drawDataset(i, easingValue);
        }
      }
      core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
    },
    /**
     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
     * hook, in which case, plugins will not be called on `afterDatasetDraw`.
     * @private
     */
    drawDataset: function drawDataset(index, easingValue) {
      var me = this;
      var meta = me.getDatasetMeta(index);
      var args = {
        meta: meta,
        index: index,
        easingValue: easingValue
      };
      if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
        return;
      }
      meta.controller.draw(easingValue);
      core_plugins.notify(me, 'afterDatasetDraw', [args]);
    },
    /**
     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
     * hook, in which case, plugins will not be called on `afterTooltipDraw`.
     * @private
     */
    _drawTooltip: function _drawTooltip(easingValue) {
      var me = this;
      var tooltip = me.tooltip;
      var args = {
        tooltip: tooltip,
        easingValue: easingValue
      };
      if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
        return;
      }
      tooltip.draw();
      core_plugins.notify(me, 'afterTooltipDraw', [args]);
    },
    /**
     * Get the single element that was clicked on
     * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
     */
    getElementAtEvent: function getElementAtEvent(e) {
      return core_interaction.modes.single(this, e);
    },
    getElementsAtEvent: function getElementsAtEvent(e) {
      return core_interaction.modes.label(this, e, {
        intersect: true
      });
    },
    getElementsAtXAxis: function getElementsAtXAxis(e) {
      return core_interaction.modes['x-axis'](this, e, {
        intersect: true
      });
    },
    getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
      var method = core_interaction.modes[mode];
      if (typeof method === 'function') {
        return method(this, e, options);
      }
      return [];
    },
    getDatasetAtEvent: function getDatasetAtEvent(e) {
      return core_interaction.modes.dataset(this, e, {
        intersect: true
      });
    },
    getDatasetMeta: function getDatasetMeta(datasetIndex) {
      var me = this;
      var dataset = me.data.datasets[datasetIndex];
      if (!dataset._meta) {
        dataset._meta = {};
      }
      var meta = dataset._meta[me.id];
      if (!meta) {
        meta = dataset._meta[me.id] = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          // See isDatasetVisible() comment
          xAxisID: null,
          yAxisID: null
        };
      }
      return meta;
    },
    getVisibleDatasetCount: function getVisibleDatasetCount() {
      var count = 0;
      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        if (this.isDatasetVisible(i)) {
          count++;
        }
      }
      return count;
    },
    isDatasetVisible: function isDatasetVisible(datasetIndex) {
      var meta = this.getDatasetMeta(datasetIndex);

      // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
    },
    generateLegend: function generateLegend() {
      return this.options.legendCallback(this);
    },
    /**
     * @private
     */
    destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
      var id = this.id;
      var dataset = this.data.datasets[datasetIndex];
      var meta = dataset._meta && dataset._meta[id];
      if (meta) {
        meta.controller.destroy();
        delete dataset._meta[id];
      }
    },
    destroy: function destroy() {
      var me = this;
      var canvas = me.canvas;
      var i, ilen;
      me.stop();

      // dataset controllers need to cleanup associated data
      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.destroyDatasetMeta(i);
      }
      if (canvas) {
        me.unbindEvents();
        helpers$1.canvas.clear(me);
        platform.releaseContext(me.ctx);
        me.canvas = null;
        me.ctx = null;
      }
      core_plugins.notify(me, 'destroy');
      delete Chart.instances[me.id];
    },
    toBase64Image: function toBase64Image() {
      return this.canvas.toDataURL.apply(this.canvas, arguments);
    },
    initToolTip: function initToolTip() {
      var me = this;
      me.tooltip = new core_tooltip({
        _chart: me,
        _chartInstance: me,
        // deprecated, backward compatibility
        _data: me.data,
        _options: me.options.tooltips
      }, me);
    },
    /**
     * @private
     */
    bindEvents: function bindEvents() {
      var me = this;
      var listeners = me._listeners = {};
      var listener = function listener() {
        me.eventHandler.apply(me, arguments);
      };
      helpers$1.each(me.options.events, function (type) {
        platform.addEventListener(me, type, listener);
        listeners[type] = listener;
      });

      // Elements used to detect size change should not be injected for non responsive charts.
      // See https://github.com/chartjs/Chart.js/issues/2210
      if (me.options.responsive) {
        listener = function listener() {
          me.resize();
        };
        platform.addEventListener(me, 'resize', listener);
        listeners.resize = listener;
      }
    },
    /**
     * @private
     */
    unbindEvents: function unbindEvents() {
      var me = this;
      var listeners = me._listeners;
      if (!listeners) {
        return;
      }
      delete me._listeners;
      helpers$1.each(listeners, function (listener, type) {
        platform.removeEventListener(me, type, listener);
      });
    },
    updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
      var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
      var element, i, ilen;
      for (i = 0, ilen = elements.length; i < ilen; ++i) {
        element = elements[i];
        if (element) {
          this.getDatasetMeta(element._datasetIndex).controller[method](element);
        }
      }
    },
    /**
     * @private
     */
    eventHandler: function eventHandler(e) {
      var me = this;
      var tooltip = me.tooltip;
      if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
        return;
      }

      // Buffer any update calls so that renders do not occur
      me._bufferedRender = true;
      me._bufferedRequest = null;
      var changed = me.handleEvent(e);
      // for smooth tooltip animations issue #4989
      // the tooltip should be the source of change
      // Animation check workaround:
      // tooltip._start will be null when tooltip isn't animating
      if (tooltip) {
        changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
      }
      core_plugins.notify(me, 'afterEvent', [e]);
      var bufferedRequest = me._bufferedRequest;
      if (bufferedRequest) {
        // If we have an update that was triggered, we need to do a normal render
        me.render(bufferedRequest);
      } else if (changed && !me.animating) {
        // If entering, leaving, or changing elements, animate the change via pivot
        me.stop();

        // We only need to render at this point. Updating will cause scales to be
        // recomputed generating flicker & using more memory than necessary.
        me.render({
          duration: me.options.hover.animationDuration,
          lazy: true
        });
      }
      me._bufferedRender = false;
      me._bufferedRequest = null;
      return me;
    },
    /**
     * Handle an event
     * @private
     * @param {IEvent} event the event to handle
     * @return {boolean} true if the chart needs to re-render
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var options = me.options || {};
      var hoverOptions = options.hover;
      var changed = false;
      me.lastActive = me.lastActive || [];

      // Find Active Elements for hover and tooltips
      if (e.type === 'mouseout') {
        me.active = [];
      } else {
        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
      }

      // Invoke onHover hook
      // Need to call with native event here to not break backwards compatibility
      helpers$1.callback(options.onHover || options.hover.onHover, [e["native"], me.active], me);
      if (e.type === 'mouseup' || e.type === 'click') {
        if (options.onClick) {
          // Use e.native here for backwards compatibility
          options.onClick.call(me, e["native"], me.active);
        }
      }

      // Remove styling for last active (even if it may still be active)
      if (me.lastActive.length) {
        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
      }

      // Built in hover styling
      if (me.active.length && hoverOptions.mode) {
        me.updateHoverStyle(me.active, hoverOptions.mode, true);
      }
      changed = !helpers$1.arrayEquals(me.active, me.lastActive);

      // Remember Last Actives
      me.lastActive = me.active;
      return changed;
    }
  });

  /**
   * NOTE(SB) We actually don't use this container anymore but we need to keep it
   * for backward compatibility. Though, it can still be useful for plugins that
   * would need to work on multiple charts?!
   */
  Chart.instances = {};
  var core_controller = Chart;

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart instead.
   * @class Chart.Controller
   * @deprecated since version 2.6
   * @todo remove at version 3
   * @private
   */
  Chart.Controller = Chart;

  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart
   * @deprecated since version 2.8
   * @todo remove at version 3
   * @private
   */
  Chart.types = {};

  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.helpers.configMerge
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */
  helpers$1.configMerge = mergeConfig;

  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.helpers.scaleMerge
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */
  helpers$1.scaleMerge = mergeScaleConfig;
  var core_helpers = function core_helpers() {
    // -- Basic js utility methods

    helpers$1.where = function (collection, filterCallback) {
      if (helpers$1.isArray(collection) && Array.prototype.filter) {
        return collection.filter(filterCallback);
      }
      var filtered = [];
      helpers$1.each(collection, function (item) {
        if (filterCallback(item)) {
          filtered.push(item);
        }
      });
      return filtered;
    };
    helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
      return array.findIndex(callback, scope);
    } : function (array, callback, scope) {
      scope = scope === undefined ? array : scope;
      for (var i = 0, ilen = array.length; i < ilen; ++i) {
        if (callback.call(scope, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
      // Default to start of the array
      if (helpers$1.isNullOrUndef(startIndex)) {
        startIndex = -1;
      }
      for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
        var currentItem = arrayToSearch[i];
        if (filterCallback(currentItem)) {
          return currentItem;
        }
      }
    };
    helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
      // Default to end of the array
      if (helpers$1.isNullOrUndef(startIndex)) {
        startIndex = arrayToSearch.length;
      }
      for (var i = startIndex - 1; i >= 0; i--) {
        var currentItem = arrayToSearch[i];
        if (filterCallback(currentItem)) {
          return currentItem;
        }
      }
    };

    // -- Math methods
    helpers$1.isNumber = function (n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    };
    helpers$1.almostEquals = function (x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    };
    helpers$1.almostWhole = function (x, epsilon) {
      var rounded = Math.round(x);
      return rounded - epsilon < x && rounded + epsilon > x;
    };
    helpers$1.max = function (array) {
      return array.reduce(function (max, value) {
        if (!isNaN(value)) {
          return Math.max(max, value);
        }
        return max;
      }, Number.NEGATIVE_INFINITY);
    };
    helpers$1.min = function (array) {
      return array.reduce(function (min, value) {
        if (!isNaN(value)) {
          return Math.min(min, value);
        }
        return min;
      }, Number.POSITIVE_INFINITY);
    };
    helpers$1.sign = Math.sign ? function (x) {
      return Math.sign(x);
    } : function (x) {
      x = +x; // convert to a number
      if (x === 0 || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    };
    helpers$1.log10 = Math.log10 ? function (x) {
      return Math.log10(x);
    } : function (x) {
      var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
      // Check for whole powers of 10,
      // which due to floating point rounding error should be corrected.
      var powerOf10 = Math.round(exponent);
      var isPowerOf10 = x === Math.pow(10, powerOf10);
      return isPowerOf10 ? powerOf10 : exponent;
    };
    helpers$1.toRadians = function (degrees) {
      return degrees * (Math.PI / 180);
    };
    helpers$1.toDegrees = function (radians) {
      return radians * (180 / Math.PI);
    };

    /**
     * Returns the number of decimal places
     * i.e. the number of digits after the decimal point, of the value of this Number.
     * @param {number} x - A number.
     * @returns {number} The number of decimal places.
     * @private
     */
    helpers$1._decimalPlaces = function (x) {
      if (!helpers$1.isFinite(x)) {
        return;
      }
      var e = 1;
      var p = 0;
      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }
      return p;
    };

    // Gets the angle from vertical upright to the point about a centre.
    helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
      var distanceFromXCenter = anglePoint.x - centrePoint.x;
      var distanceFromYCenter = anglePoint.y - centrePoint.y;
      var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < -0.5 * Math.PI) {
        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
      }
      return {
        angle: angle,
        distance: radialDistanceFromCenter
      };
    };
    helpers$1.distanceBetweenPoints = function (pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    };

    /**
     * Provided for backward compatibility, not available anymore
     * @function Chart.helpers.aliasPixel
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */
    helpers$1.aliasPixel = function (pixelWidth) {
      return pixelWidth % 2 === 0 ? 0 : 0.5;
    };

    /**
     * Returns the aligned pixel value to avoid anti-aliasing blur
     * @param {Chart} chart - The chart instance.
     * @param {number} pixel - A pixel value.
     * @param {number} width - The width of the element.
     * @returns {number} The aligned pixel value.
     * @private
     */
    helpers$1._alignPixel = function (chart, pixel, width) {
      var devicePixelRatio = chart.currentDevicePixelRatio;
      var halfWidth = width / 2;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    };
    helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
      // Props to Rob Spencer at scaled innovation for his post on splining between points
      // http://scaledinnovation.com/analytics/splines/aboutSplines.html

      // This function must also respect "skipped" points

      var previous = firstPoint.skip ? middlePoint : firstPoint;
      var current = middlePoint;
      var next = afterPoint.skip ? middlePoint : afterPoint;
      var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
      var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
      var s01 = d01 / (d01 + d12);
      var s12 = d12 / (d01 + d12);

      // If all points are the same, s01 & s02 will be inf
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      var fa = t * s01; // scaling factor for triangle Ta
      var fb = t * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    };
    helpers$1.EPSILON = Number.EPSILON || 1e-14;
    helpers$1.splineCurveMonotone = function (points) {
      // This function calculates Bzier control points in a similar way than |splineCurve|,
      // but preserves monotonicity of the provided data and ensures no local extremums are added
      // between the dataset discrete points due to the interpolation.
      // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

      var pointsWithTangents = (points || []).map(function (point) {
        return {
          model: point._model,
          deltaK: 0,
          mK: 0
        };
      });

      // Calculate slopes (deltaK) and initialize tangents (mK)
      var pointsLen = pointsWithTangents.length;
      var i, pointBefore, pointCurrent, pointAfter;
      for (i = 0; i < pointsLen; ++i) {
        pointCurrent = pointsWithTangents[i];
        if (pointCurrent.model.skip) {
          continue;
        }
        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
        if (pointAfter && !pointAfter.model.skip) {
          var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;

          // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
          pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
        }
        if (!pointBefore || pointBefore.model.skip) {
          pointCurrent.mK = pointCurrent.deltaK;
        } else if (!pointAfter || pointAfter.model.skip) {
          pointCurrent.mK = pointBefore.deltaK;
        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
          pointCurrent.mK = 0;
        } else {
          pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
        }
      }

      // Adjust tangents to ensure monotonic properties
      var alphaK, betaK, tauK, squaredMagnitude;
      for (i = 0; i < pointsLen - 1; ++i) {
        pointCurrent = pointsWithTangents[i];
        pointAfter = pointsWithTangents[i + 1];
        if (pointCurrent.model.skip || pointAfter.model.skip) {
          continue;
        }
        if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
          pointCurrent.mK = pointAfter.mK = 0;
          continue;
        }
        alphaK = pointCurrent.mK / pointCurrent.deltaK;
        betaK = pointAfter.mK / pointCurrent.deltaK;
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) {
          continue;
        }
        tauK = 3 / Math.sqrt(squaredMagnitude);
        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
      }

      // Compute control points
      var deltaX;
      for (i = 0; i < pointsLen; ++i) {
        pointCurrent = pointsWithTangents[i];
        if (pointCurrent.model.skip) {
          continue;
        }
        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
        if (pointBefore && !pointBefore.model.skip) {
          deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
          pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
          pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
        }
        if (pointAfter && !pointAfter.model.skip) {
          deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
          pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
          pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
        }
      }
    };
    helpers$1.nextItem = function (collection, index, loop) {
      if (loop) {
        return index >= collection.length - 1 ? collection[0] : collection[index + 1];
      }
      return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
    };
    helpers$1.previousItem = function (collection, index, loop) {
      if (loop) {
        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
      }
      return index <= 0 ? collection[0] : collection[index - 1];
    };
    // Implementation of the nice number algorithm used in determining where axis labels will go
    helpers$1.niceNum = function (range, round) {
      var exponent = Math.floor(helpers$1.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;
      if (round) {
        if (fraction < 1.5) {
          niceFraction = 1;
        } else if (fraction < 3) {
          niceFraction = 2;
        } else if (fraction < 7) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }
      } else if (fraction <= 1.0) {
        niceFraction = 1;
      } else if (fraction <= 2) {
        niceFraction = 2;
      } else if (fraction <= 5) {
        niceFraction = 5;
      } else {
        niceFraction = 10;
      }
      return niceFraction * Math.pow(10, exponent);
    };
    // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
    helpers$1.requestAnimFrame = function () {
      if (typeof window === 'undefined') {
        return function (callback) {
          callback();
        };
      }
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        return window.setTimeout(callback, 1000 / 60);
      };
    }();
    // -- DOM methods
    helpers$1.getRelativePosition = function (evt, chart) {
      var mouseX, mouseY;
      var e = evt.originalEvent || evt;
      var canvas = evt.target || evt.srcElement;
      var boundingRect = canvas.getBoundingClientRect();
      var touches = e.touches;
      if (touches && touches.length > 0) {
        mouseX = touches[0].clientX;
        mouseY = touches[0].clientY;
      } else {
        mouseX = e.clientX;
        mouseY = e.clientY;
      }

      // Scale mouse coordinates into canvas coordinates
      // by following the pattern laid out by 'jerryj' in the comments of
      // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
      var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
      var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
      var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
      var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
      var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
      var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

      // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
      // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
      mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
      mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
      return {
        x: mouseX,
        y: mouseY
      };
    };

    // Private helper function to convert max-width/max-height values that may be percentages into a number
    function parseMaxStyle(styleValue, node, parentProperty) {
      var valueInPixels;
      if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf('%') !== -1) {
          // percentage * size in dimension
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }
      return valueInPixels;
    }

    /**
     * Returns if the given value contains an effective constraint.
     * @private
     */
    function isConstrainedValue(value) {
      return value !== undefined && value !== null && value !== 'none';
    }

    /**
     * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
     * @param {HTMLElement} domNode - the node to check the constraint on
     * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
     * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
     * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
     */
    function getConstraintDimension(domNode, maxStyle, percentageProperty) {
      var view = document.defaultView;
      var parentNode = helpers$1._getParentNode(domNode);
      var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
      var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
      var hasCNode = isConstrainedValue(constrainedNode);
      var hasCContainer = isConstrainedValue(constrainedContainer);
      var infinity = Number.POSITIVE_INFINITY;
      if (hasCNode || hasCContainer) {
        return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
      }
      return 'none';
    }
    // returns Number or undefined if no constraint
    helpers$1.getConstraintWidth = function (domNode) {
      return getConstraintDimension(domNode, 'max-width', 'clientWidth');
    };
    // returns Number or undefined if no constraint
    helpers$1.getConstraintHeight = function (domNode) {
      return getConstraintDimension(domNode, 'max-height', 'clientHeight');
    };
    /**
     * @private
    	 */
    helpers$1._calculatePadding = function (container, padding, parentDimension) {
      padding = helpers$1.getStyle(container, padding);
      return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
    };
    /**
     * @private
     */
    helpers$1._getParentNode = function (domNode) {
      var parent = domNode.parentNode;
      if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
      }
      return parent;
    };
    helpers$1.getMaximumWidth = function (domNode) {
      var container = helpers$1._getParentNode(domNode);
      if (!container) {
        return domNode.clientWidth;
      }
      var clientWidth = container.clientWidth;
      var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);
      var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);
      var w = clientWidth - paddingLeft - paddingRight;
      var cw = helpers$1.getConstraintWidth(domNode);
      return isNaN(cw) ? w : Math.min(w, cw);
    };
    helpers$1.getMaximumHeight = function (domNode) {
      var container = helpers$1._getParentNode(domNode);
      if (!container) {
        return domNode.clientHeight;
      }
      var clientHeight = container.clientHeight;
      var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);
      var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);
      var h = clientHeight - paddingTop - paddingBottom;
      var ch = helpers$1.getConstraintHeight(domNode);
      return isNaN(ch) ? h : Math.min(h, ch);
    };
    helpers$1.getStyle = function (el, property) {
      return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
    };
    helpers$1.retinaScale = function (chart, forceRatio) {
      var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;
      if (pixelRatio === 1) {
        return;
      }
      var canvas = chart.canvas;
      var height = chart.height;
      var width = chart.width;
      canvas.height = height * pixelRatio;
      canvas.width = width * pixelRatio;
      chart.ctx.scale(pixelRatio, pixelRatio);

      // If no style has been set on the canvas, the render size is used as display size,
      // making the chart visually bigger, so let's enforce it to the "correct" values.
      // See https://github.com/chartjs/Chart.js/issues/3575
      if (!canvas.style.height && !canvas.style.width) {
        canvas.style.height = height + 'px';
        canvas.style.width = width + 'px';
      }
    };
    // -- Canvas methods
    helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
      return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
    };
    helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
      cache = cache || {};
      var data = cache.data = cache.data || {};
      var gc = cache.garbageCollect = cache.garbageCollect || [];
      if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
      }
      ctx.font = font;
      var longest = 0;
      helpers$1.each(arrayOfThings, function (thing) {
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
          longest = helpers$1.measureText(ctx, data, gc, longest, thing);
        } else if (helpers$1.isArray(thing)) {
          // if it is an array lets measure each element
          // to do maybe simplify this function a bit so we can do this more recursively?
          helpers$1.each(thing, function (nestedThing) {
            // Undefined strings and arrays should not be measured
            if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
              longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
            }
          });
        }
      });
      var gcLen = gc.length / 2;
      if (gcLen > arrayOfThings.length) {
        for (var i = 0; i < gcLen; i++) {
          delete data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
      return longest;
    };
    helpers$1.measureText = function (ctx, data, gc, longest, string) {
      var textWidth = data[string];
      if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
      }
      if (textWidth > longest) {
        longest = textWidth;
      }
      return longest;
    };
    helpers$1.numberOfLabelLines = function (arrayOfThings) {
      var numberOfLines = 1;
      helpers$1.each(arrayOfThings, function (thing) {
        if (helpers$1.isArray(thing)) {
          if (thing.length > numberOfLines) {
            numberOfLines = thing.length;
          }
        }
      });
      return numberOfLines;
    };
    helpers$1.color = !chartjsColor ? function (value) {
      console.error('Color.js not found!');
      return value;
    } : function (value) {
      /* global CanvasGradient */
      if (value instanceof CanvasGradient) {
        value = core_defaults.global.defaultColor;
      }
      return chartjsColor(value);
    };
    helpers$1.getHoverColor = function (colorValue) {
      /* global CanvasPattern */
      return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
    };
  };
  function _abstract() {
    throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
  }

  /**
   * Date adapter (current used by the time scale)
   * @namespace Chart._adapters._date
   * @memberof Chart._adapters
   * @private
   */

  /**
   * Currently supported unit string values.
   * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
   * @memberof Chart._adapters._date
   * @name Unit
   */

  /**
   * @class
   */
  function DateAdapter(options) {
    this.options = options || {};
  }
  helpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */{
    /**
     * Returns a map of time formats for the supported formatting units defined
     * in Unit as well as 'datetime' representing a detailed date/time string.
     * @returns {{string: string}}
     */
    formats: _abstract,
    /**
     * Parses the given `value` and return the associated timestamp.
     * @param {any} value - the value to parse (usually comes from the data)
     * @param {string} [format] - the expected data format
     * @returns {(number|null)}
     * @function
     */
    parse: _abstract,
    /**
     * Returns the formatted date in the specified `format` for a given `timestamp`.
     * @param {number} timestamp - the timestamp to format
     * @param {string} format - the date/time token
     * @return {string}
     * @function
     */
    format: _abstract,
    /**
     * Adds the specified `amount` of `unit` to the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {number} amount - the amount to add
     * @param {Unit} unit - the unit as string
     * @return {number}
     * @function
     */
    add: _abstract,
    /**
     * Returns the number of `unit` between the given timestamps.
     * @param {number} max - the input timestamp (reference)
     * @param {number} min - the timestamp to substract
     * @param {Unit} unit - the unit as string
     * @return {number}
     * @function
     */
    diff: _abstract,
    /**
     * Returns start of `unit` for the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {Unit} unit - the unit as string
     * @param {number} [weekday] - the ISO day of the week with 1 being Monday
     * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
     * @function
     */
    startOf: _abstract,
    /**
     * Returns end of `unit` for the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {Unit} unit - the unit as string
     * @function
     */
    endOf: _abstract,
    // DEPRECATIONS

    /**
     * Provided for backward compatibility for scale.getValueForPixel(),
     * this method should be overridden only by the moment adapter.
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */
    _create: function _create(value) {
      return value;
    }
  });
  DateAdapter.override = function (members) {
    helpers$1.extend(DateAdapter.prototype, members);
  };
  var _date = DateAdapter;
  var core_adapters = {
    _date: _date
  };

  /**
   * Namespace to hold static tick generation functions
   * @namespace Chart.Ticks
   */
  var core_ticks = {
    /**
     * Namespace to hold formatters for different types of ticks
     * @namespace Chart.Ticks.formatters
     */
    formatters: {
      /**
       * Formatter for value labels
       * @method Chart.Ticks.formatters.values
       * @param value the value to display
       * @return {string|string[]} the label to display
       */
      values: function values(value) {
        return helpers$1.isArray(value) ? value : '' + value;
      },
      /**
       * Formatter for linear numeric ticks
       * @method Chart.Ticks.formatters.linear
       * @param tickValue {number} the value to be formatted
       * @param index {number} the position of the tickValue parameter in the ticks array
       * @param ticks {number[]} the list of ticks being converted
       * @return {string} string representation of the tickValue parameter
       */
      linear: function linear(tickValue, index, ticks) {
        // If we have lots of ticks, don't use the ones
        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

        // If we have a number like 2.5 as the delta, figure out how many decimal places we need
        if (Math.abs(delta) > 1) {
          if (tickValue !== Math.floor(tickValue)) {
            // not an integer
            delta = tickValue - Math.floor(tickValue);
          }
        }
        var logDelta = helpers$1.log10(Math.abs(delta));
        var tickString = '';
        if (tickValue !== 0) {
          var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
          if (maxTick < 1e-4) {
            // all ticks are small numbers; use scientific notation
            var logTick = helpers$1.log10(Math.abs(tickValue));
            tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
          } else {
            var numDecimal = -1 * Math.floor(logDelta);
            numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
            tickString = tickValue.toFixed(numDecimal);
          }
        } else {
          tickString = '0'; // never show decimal places for 0
        }
        return tickString;
      },
      logarithmic: function logarithmic(tickValue, index, ticks) {
        var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
        if (tickValue === 0) {
          return '0';
        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
          return tickValue.toExponential();
        }
        return '';
      }
    }
  };
  var valueOrDefault$9 = helpers$1.valueOrDefault;
  var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
  core_defaults._set('scale', {
    display: true,
    position: 'left',
    offset: false,
    // grid line settings
    gridLines: {
      display: true,
      color: 'rgba(0, 0, 0, 0.1)',
      lineWidth: 1,
      drawBorder: true,
      drawOnChartArea: true,
      drawTicks: true,
      tickMarkLength: 10,
      zeroLineWidth: 1,
      zeroLineColor: 'rgba(0,0,0,0.25)',
      zeroLineBorderDash: [],
      zeroLineBorderDashOffset: 0.0,
      offsetGridLines: false,
      borderDash: [],
      borderDashOffset: 0.0
    },
    // scale label
    scaleLabel: {
      // display property
      display: false,
      // actual label
      labelString: '',
      // top/bottom padding
      padding: {
        top: 4,
        bottom: 4
      }
    },
    // label settings
    ticks: {
      beginAtZero: false,
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      padding: 0,
      reverse: false,
      display: true,
      autoSkip: true,
      autoSkipPadding: 0,
      labelOffset: 0,
      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
      callback: core_ticks.formatters.values,
      minor: {},
      major: {}
    }
  });
  function labelsFromTicks(ticks) {
    var labels = [];
    var i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      labels.push(ticks[i].label);
    }
    return labels;
  }
  function getPixelForGridLine(scale, index, offsetGridLines) {
    var lineValue = scale.getPixelForTick(index);
    if (offsetGridLines) {
      if (scale.getTicks().length === 1) {
        lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
      } else if (index === 0) {
        lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
      }
    }
    return lineValue;
  }
  function computeTextSize(context, tick, font) {
    return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
  }
  var core_scale = core_element.extend({
    /**
     * Get the padding needed for the scale
     * @method getPadding
     * @private
     * @returns {Padding} the necessary padding
     */
    getPadding: function getPadding() {
      var me = this;
      return {
        left: me.paddingLeft || 0,
        top: me.paddingTop || 0,
        right: me.paddingRight || 0,
        bottom: me.paddingBottom || 0
      };
    },
    /**
     * Returns the scale tick objects ({label, major})
     * @since 2.7
     */
    getTicks: function getTicks() {
      return this._ticks;
    },
    // These methods are ordered by lifecyle. Utilities then follow.
    // Any function defined here is inherited by all scale types.
    // Any function can be extended by the scale type

    mergeTicksOptions: function mergeTicksOptions() {
      var ticks = this.options.ticks;
      if (ticks.minor === false) {
        ticks.minor = {
          display: false
        };
      }
      if (ticks.major === false) {
        ticks.major = {
          display: false
        };
      }
      for (var key in ticks) {
        if (key !== 'major' && key !== 'minor') {
          if (typeof ticks.minor[key] === 'undefined') {
            ticks.minor[key] = ticks[key];
          }
          if (typeof ticks.major[key] === 'undefined') {
            ticks.major[key] = ticks[key];
          }
        }
      }
    },
    beforeUpdate: function beforeUpdate() {
      helpers$1.callback(this.options.beforeUpdate, [this]);
    },
    update: function update(maxWidth, maxHeight, margins) {
      var me = this;
      var i, ilen, labels, label, ticks, tick;

      // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
      me.beforeUpdate();

      // Absorb the master measurements
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = helpers$1.extend({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      me._maxLabelLines = 0;
      me.longestLabelWidth = 0;
      me.longestTextCache = me.longestTextCache || {};

      // Dimensions
      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions();

      // Data min/max
      me.beforeDataLimits();
      me.determineDataLimits();
      me.afterDataLimits();

      // Ticks - `this.ticks` is now DEPRECATED!
      // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
      // and must not be accessed directly from outside this class. `this.ticks` being
      // around for long time and not marked as private, we can't change its structure
      // without unexpected breaking changes. If you need to access the scale ticks,
      // use scale.getTicks() instead.

      me.beforeBuildTicks();

      // New implementations should return an array of objects but for BACKWARD COMPAT,
      // we still support no return (`this.ticks` internally set by calling this method).
      ticks = me.buildTicks() || [];

      // Allow modification of ticks in callback.
      ticks = me.afterBuildTicks(ticks) || ticks;
      me.beforeTickToLabelConversion();

      // New implementations should return the formatted tick labels but for BACKWARD
      // COMPAT, we still support no return (`this.ticks` internally changed by calling
      // this method and supposed to contain only string values).
      labels = me.convertTicksToLabels(ticks) || me.ticks;
      me.afterTickToLabelConversion();
      me.ticks = labels; // BACKWARD COMPATIBILITY

      // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!

      // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        label = labels[i];
        tick = ticks[i];
        if (!tick) {
          ticks.push(tick = {
            label: label,
            major: false
          });
        } else {
          tick.label = label;
        }
      }
      me._ticks = ticks;

      // Tick Rotation
      me.beforeCalculateTickRotation();
      me.calculateTickRotation();
      me.afterCalculateTickRotation();
      // Fit
      me.beforeFit();
      me.fit();
      me.afterFit();
      //
      me.afterUpdate();
      return me.minSize;
    },
    afterUpdate: function afterUpdate() {
      helpers$1.callback(this.options.afterUpdate, [this]);
    },
    //

    beforeSetDimensions: function beforeSetDimensions() {
      helpers$1.callback(this.options.beforeSetDimensions, [this]);
    },
    setDimensions: function setDimensions() {
      var me = this;
      // Set the unconstrained dimension before label rotation
      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight;

        // Reset position before calculating rotation
        me.top = 0;
        me.bottom = me.height;
      }

      // Reset padding
      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0;
    },
    afterSetDimensions: function afterSetDimensions() {
      helpers$1.callback(this.options.afterSetDimensions, [this]);
    },
    // Data limits
    beforeDataLimits: function beforeDataLimits() {
      helpers$1.callback(this.options.beforeDataLimits, [this]);
    },
    determineDataLimits: helpers$1.noop,
    afterDataLimits: function afterDataLimits() {
      helpers$1.callback(this.options.afterDataLimits, [this]);
    },
    //
    beforeBuildTicks: function beforeBuildTicks() {
      helpers$1.callback(this.options.beforeBuildTicks, [this]);
    },
    buildTicks: helpers$1.noop,
    afterBuildTicks: function afterBuildTicks(ticks) {
      var me = this;
      // ticks is empty for old axis implementations here
      if (helpers$1.isArray(ticks) && ticks.length) {
        return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
      }
      // Support old implementations (that modified `this.ticks` directly in buildTicks)
      me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
      return ticks;
    },
    beforeTickToLabelConversion: function beforeTickToLabelConversion() {
      helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this;
      // Convert ticks to strings
      var tickOpts = me.options.ticks;
      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
    },
    afterTickToLabelConversion: function afterTickToLabelConversion() {
      helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
    },
    //

    beforeCalculateTickRotation: function beforeCalculateTickRotation() {
      helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
    },
    calculateTickRotation: function calculateTickRotation() {
      var me = this;
      var context = me.ctx;
      var tickOpts = me.options.ticks;
      var labels = labelsFromTicks(me._ticks);

      // Get the width of each grid by calculating the difference
      // between x offsets between 0 and 1.
      var tickFont = helpers$1.options._parseFont(tickOpts);
      context.font = tickFont.string;
      var labelRotation = tickOpts.minRotation || 0;
      if (labels.length && me.options.display && me.isHorizontal()) {
        var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
        var labelWidth = originalLabelWidth;
        var cosRotation, sinRotation;

        // Allow 3 pixels x2 padding either side for label readability
        var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;

        // Max label rotation can be set or default to 90 - also act as a loop counter
        while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
          var angleRadians = helpers$1.toRadians(labelRotation);
          cosRotation = Math.cos(angleRadians);
          sinRotation = Math.sin(angleRadians);
          if (sinRotation * originalLabelWidth > me.maxHeight) {
            // go back one step
            labelRotation--;
            break;
          }
          labelRotation++;
          labelWidth = cosRotation * originalLabelWidth;
        }
      }
      me.labelRotation = labelRotation;
    },
    afterCalculateTickRotation: function afterCalculateTickRotation() {
      helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
    },
    //

    beforeFit: function beforeFit() {
      helpers$1.callback(this.options.beforeFit, [this]);
    },
    fit: function fit() {
      var me = this;
      // Reset
      var minSize = me.minSize = {
        width: 0,
        height: 0
      };
      var labels = labelsFromTicks(me._ticks);
      var opts = me.options;
      var tickOpts = opts.ticks;
      var scaleLabelOpts = opts.scaleLabel;
      var gridLineOpts = opts.gridLines;
      var display = me._isVisible();
      var position = opts.position;
      var isHorizontal = me.isHorizontal();
      var parseFont = helpers$1.options._parseFont;
      var tickFont = parseFont(tickOpts);
      var tickMarkLength = opts.gridLines.tickMarkLength;

      // Width
      if (isHorizontal) {
        // subtract the margins to line up with the chartArea if we are a full width scale
        minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
      } else {
        minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
      }

      // height
      if (isHorizontal) {
        minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
      } else {
        minSize.height = me.maxHeight; // fill all the height
      }

      // Are we showing a title for the scale?
      if (scaleLabelOpts.display && display) {
        var scaleLabelFont = parseFont(scaleLabelOpts);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
        var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;
        if (isHorizontal) {
          minSize.height += deltaHeight;
        } else {
          minSize.width += deltaHeight;
        }
      }

      // Don't bother fitting the ticks if we are not showing the labels
      if (tickOpts.display && display) {
        var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
        var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
        var lineSpace = tickFont.size * 0.5;
        var tickPadding = me.options.ticks.padding;

        // Store max number of lines and widest label for _autoSkip
        me._maxLabelLines = tallestLabelHeightInLines;
        me.longestLabelWidth = largestTextWidth;
        if (isHorizontal) {
          var angleRadians = helpers$1.toRadians(me.labelRotation);
          var cosRotation = Math.cos(angleRadians);
          var sinRotation = Math.sin(angleRadians);

          // TODO - improve this calculation
          var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
          me.ctx.font = tickFont.string;
          var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
          var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
          var offsetLeft = me.getPixelForTick(0) - me.left;
          var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
          var paddingLeft, paddingRight;

          // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
          // which means that the right padding is dominated by the font height
          if (me.labelRotation !== 0) {
            paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
            paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
          } else {
            paddingLeft = firstLabelWidth / 2;
            paddingRight = lastLabelWidth / 2;
          }
          me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges
          me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
        } else {
          // A vertical axis is more constrained by the width. Labels are the
          // dominant factor here, so get that length first and account for padding
          if (tickOpts.mirror) {
            largestTextWidth = 0;
          } else {
            // use lineSpace for consistency with horizontal axis
            // tickPadding is not implemented for horizontal
            largestTextWidth += tickPadding + lineSpace;
          }
          minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
          me.paddingTop = tickFont.size / 2;
          me.paddingBottom = tickFont.size / 2;
        }
      }
      me.handleMargins();
      me.width = minSize.width;
      me.height = minSize.height;
    },
    /**
     * Handle margins and padding interactions
     * @private
     */
    handleMargins: function handleMargins() {
      var me = this;
      if (me.margins) {
        me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
        me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
        me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
        me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
      }
    },
    afterFit: function afterFit() {
      helpers$1.callback(this.options.afterFit, [this]);
    },
    // Shared Methods
    isHorizontal: function isHorizontal() {
      return this.options.position === 'top' || this.options.position === 'bottom';
    },
    isFullWidth: function isFullWidth() {
      return this.options.fullWidth;
    },
    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
    getRightValue: function getRightValue(rawValue) {
      // Null and undefined values first
      if (helpers$1.isNullOrUndef(rawValue)) {
        return NaN;
      }
      // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
      if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
        return NaN;
      }
      // If it is in fact an object, dive in one more level
      if (rawValue) {
        if (this.isHorizontal()) {
          if (rawValue.x !== undefined) {
            return this.getRightValue(rawValue.x);
          }
        } else if (rawValue.y !== undefined) {
          return this.getRightValue(rawValue.y);
        }
      }

      // Value is good, return it
      return rawValue;
    },
    /**
     * Used to get the value to display in the tooltip for the data at the given index
     * @param index
     * @param datasetIndex
     */
    getLabelForIndex: helpers$1.noop,
    /**
     * Returns the location of the given data point. Value can either be an index or a numerical value
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     * @param value
     * @param index
     * @param datasetIndex
     */
    getPixelForValue: helpers$1.noop,
    /**
     * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     * @param pixel
     */
    getValueForPixel: helpers$1.noop,
    /**
     * Returns the location of the tick at the given index
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getPixelForTick: function getPixelForTick(index) {
      var me = this;
      var offset = me.options.offset;
      if (me.isHorizontal()) {
        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
        var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var pixel = tickWidth * index + me.paddingLeft;
        if (offset) {
          pixel += tickWidth / 2;
        }
        var finalVal = me.left + pixel;
        finalVal += me.isFullWidth() ? me.margins.left : 0;
        return finalVal;
      }
      var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
      return me.top + index * (innerHeight / (me._ticks.length - 1));
    },
    /**
     * Utility for getting the pixel location of a percentage of scale
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getPixelForDecimal: function getPixelForDecimal(decimal) {
      var me = this;
      if (me.isHorizontal()) {
        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
        var valueOffset = innerWidth * decimal + me.paddingLeft;
        var finalVal = me.left + valueOffset;
        finalVal += me.isFullWidth() ? me.margins.left : 0;
        return finalVal;
      }
      return me.top + decimal * me.height;
    },
    /**
     * Returns the pixel for the minimum chart value
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getBasePixel: function getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    },
    getBaseValue: function getBaseValue() {
      var me = this;
      var min = me.min;
      var max = me.max;
      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    },
    /**
     * Returns a subset of ticks to be plotted to avoid overlapping labels.
     * @private
     */
    _autoSkip: function _autoSkip(ticks) {
      var me = this;
      var isHorizontal = me.isHorizontal();
      var optionTicks = me.options.ticks.minor;
      var tickCount = ticks.length;
      var skipRatio = false;
      var maxTicks = optionTicks.maxTicksLimit;

      // Total space needed to display all ticks. First and last ticks are
      // drawn as their center at end of axis, so tickCount-1
      var ticksLength = me._tickSize() * (tickCount - 1);

      // Axis length
      var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
      var result = [];
      var i, tick;
      if (ticksLength > axisLength) {
        skipRatio = 1 + Math.floor(ticksLength / axisLength);
      }

      // if they defined a max number of optionTicks,
      // increase skipRatio until that number is met
      if (tickCount > maxTicks) {
        skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
      }
      for (i = 0; i < tickCount; i++) {
        tick = ticks[i];
        if (skipRatio > 1 && i % skipRatio > 0) {
          // leave tick in place but make sure it's not displayed (#4635)
          delete tick.label;
        }
        result.push(tick);
      }
      return result;
    },
    /**
     * @private
     */
    _tickSize: function _tickSize() {
      var me = this;
      var isHorizontal = me.isHorizontal();
      var optionTicks = me.options.ticks.minor;

      // Calculate space needed by label in axis direction.
      var rot = helpers$1.toRadians(me.labelRotation);
      var cos = Math.abs(Math.cos(rot));
      var sin = Math.abs(Math.sin(rot));
      var padding = optionTicks.autoSkipPadding || 0;
      var w = me.longestLabelWidth + padding || 0;
      var tickFont = helpers$1.options._parseFont(optionTicks);
      var h = me._maxLabelLines * tickFont.lineHeight + padding || 0;

      // Calculate space needed for 1 tick in axis direction.
      return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    },
    /**
     * @private
     */
    _isVisible: function _isVisible() {
      var me = this;
      var chart = me.chart;
      var display = me.options.display;
      var i, ilen, meta;
      if (display !== 'auto') {
        return !!display;
      }

      // When 'auto', the scale is visible if at least one associated dataset is visible.
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
            return true;
          }
        }
      }
      return false;
    },
    /**
     * Actually draw the scale on the canvas
     * @param {object} chartArea - the area of the chart to draw full grid lines on
     */
    draw: function draw(chartArea) {
      var me = this;
      var options = me.options;
      if (!me._isVisible()) {
        return;
      }
      var chart = me.chart;
      var context = me.ctx;
      var globalDefaults = core_defaults.global;
      var defaultFontColor = globalDefaults.defaultFontColor;
      var optionTicks = options.ticks.minor;
      var optionMajorTicks = options.ticks.major || optionTicks;
      var gridLines = options.gridLines;
      var scaleLabel = options.scaleLabel;
      var position = options.position;
      var isRotated = me.labelRotation !== 0;
      var isMirrored = optionTicks.mirror;
      var isHorizontal = me.isHorizontal();
      var parseFont = helpers$1.options._parseFont;
      var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
      var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
      var tickFont = parseFont(optionTicks);
      var lineHeight = tickFont.lineHeight;
      var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
      var majorTickFont = parseFont(optionMajorTicks);
      var tickPadding = optionTicks.padding;
      var labelOffset = optionTicks.labelOffset;
      var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
      var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
      var scaleLabelFont = parseFont(scaleLabel);
      var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
      var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
      var itemsToDraw = [];
      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
      var alignPixel = helpers$1._alignPixel;
      var borderValue, tickStart, tickEnd;
      if (position === 'top') {
        borderValue = alignPixel(chart, me.bottom, axisWidth);
        tickStart = me.bottom - tl;
        tickEnd = borderValue - axisWidth / 2;
      } else if (position === 'bottom') {
        borderValue = alignPixel(chart, me.top, axisWidth);
        tickStart = borderValue + axisWidth / 2;
        tickEnd = me.top + tl;
      } else if (position === 'left') {
        borderValue = alignPixel(chart, me.right, axisWidth);
        tickStart = me.right - tl;
        tickEnd = borderValue - axisWidth / 2;
      } else {
        borderValue = alignPixel(chart, me.left, axisWidth);
        tickStart = borderValue + axisWidth / 2;
        tickEnd = me.left + tl;
      }
      var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

      helpers$1.each(ticks, function (tick, index) {
        // autoskipper skipped this tick (#4635)
        if (helpers$1.isNullOrUndef(tick.label)) {
          return;
        }
        var label = tick.label;
        var lineWidth, lineColor, borderDash, borderDashOffset;
        if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
          // Draw the first index specially
          lineWidth = gridLines.zeroLineWidth;
          lineColor = gridLines.zeroLineColor;
          borderDash = gridLines.zeroLineBorderDash || [];
          borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
        } else {
          lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
          lineColor = valueAtIndexOrDefault(gridLines.color, index);
          borderDash = gridLines.borderDash || [];
          borderDashOffset = gridLines.borderDashOffset || 0.0;
        }

        // Common properties
        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
        var labelCount = helpers$1.isArray(label) ? label.length : 1;
        var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);
        if (isHorizontal) {
          var labelYOffset = tl + tickPadding;
          if (lineValue < me.left - epsilon) {
            lineColor = 'rgba(0,0,0,0)';
          }
          tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
          ty1 = tickStart;
          ty2 = tickEnd;
          labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

          if (position === 'top') {
            y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
            y2 = chartArea.bottom;
            textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
            textAlign = !isRotated ? 'center' : 'left';
            labelY = me.bottom - labelYOffset;
          } else {
            y1 = chartArea.top;
            y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
            textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
            textAlign = !isRotated ? 'center' : 'right';
            labelY = me.top + labelYOffset;
          }
        } else {
          var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;
          if (lineValue < me.top - epsilon) {
            lineColor = 'rgba(0,0,0,0)';
          }
          tx1 = tickStart;
          tx2 = tickEnd;
          ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
          labelY = me.getPixelForTick(index) + labelOffset;
          textOffset = (1 - labelCount) * lineHeight / 2;
          if (position === 'left') {
            x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
            x2 = chartArea.right;
            textAlign = isMirrored ? 'left' : 'right';
            labelX = me.right - labelXOffset;
          } else {
            x1 = chartArea.left;
            x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
            textAlign = isMirrored ? 'right' : 'left';
            labelX = me.left + labelXOffset;
          }
        }
        itemsToDraw.push({
          tx1: tx1,
          ty1: ty1,
          tx2: tx2,
          ty2: ty2,
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          labelX: labelX,
          labelY: labelY,
          glWidth: lineWidth,
          glColor: lineColor,
          glBorderDash: borderDash,
          glBorderDashOffset: borderDashOffset,
          rotation: -1 * labelRotationRadians,
          label: label,
          major: tick.major,
          textOffset: textOffset,
          textAlign: textAlign
        });
      });

      // Draw all of the tick labels, tick marks, and grid lines at the correct places
      helpers$1.each(itemsToDraw, function (itemToDraw) {
        var glWidth = itemToDraw.glWidth;
        var glColor = itemToDraw.glColor;
        if (gridLines.display && glWidth && glColor) {
          context.save();
          context.lineWidth = glWidth;
          context.strokeStyle = glColor;
          if (context.setLineDash) {
            context.setLineDash(itemToDraw.glBorderDash);
            context.lineDashOffset = itemToDraw.glBorderDashOffset;
          }
          context.beginPath();
          if (gridLines.drawTicks) {
            context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
            context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
          }
          if (gridLines.drawOnChartArea) {
            context.moveTo(itemToDraw.x1, itemToDraw.y1);
            context.lineTo(itemToDraw.x2, itemToDraw.y2);
          }
          context.stroke();
          context.restore();
        }
        if (optionTicks.display) {
          // Make sure we draw text in the correct color and font
          context.save();
          context.translate(itemToDraw.labelX, itemToDraw.labelY);
          context.rotate(itemToDraw.rotation);
          context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
          context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
          context.textBaseline = 'middle';
          context.textAlign = itemToDraw.textAlign;
          var label = itemToDraw.label;
          var y = itemToDraw.textOffset;
          if (helpers$1.isArray(label)) {
            for (var i = 0; i < label.length; ++i) {
              // We just make sure the multiline element is a string here..
              context.fillText('' + label[i], 0, y);
              y += lineHeight;
            }
          } else {
            context.fillText(label, 0, y);
          }
          context.restore();
        }
      });
      if (scaleLabel.display) {
        // Draw the scale label
        var scaleLabelX;
        var scaleLabelY;
        var rotation = 0;
        var halfLineHeight = scaleLabelFont.lineHeight / 2;
        if (isHorizontal) {
          scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width
          scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
        } else {
          var isLeft = position === 'left';
          scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
          scaleLabelY = me.top + (me.bottom - me.top) / 2;
          rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
        }
        context.save();
        context.translate(scaleLabelX, scaleLabelY);
        context.rotate(rotation);
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = scaleLabelFontColor; // render in correct colour
        context.font = scaleLabelFont.string;
        context.fillText(scaleLabel.labelString, 0, 0);
        context.restore();
      }
      if (axisWidth) {
        // Draw the line at the edge of the axis
        var firstLineWidth = axisWidth;
        var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
        var x1, x2, y1, y2;
        if (isHorizontal) {
          x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
          x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
          y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }
        context.lineWidth = axisWidth;
        context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
      }
    }
  });
  var defaultConfig = {
    position: 'bottom'
  };
  var scale_category = core_scale.extend({
    /**
    * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
    * else fall back to data.labels
    * @private
    */
    getLabels: function getLabels() {
      var data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
    },
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var labels = me.getLabels();
      me.minIndex = 0;
      me.maxIndex = labels.length - 1;
      var findIndex;
      if (me.options.ticks.min !== undefined) {
        // user specified min value
        findIndex = labels.indexOf(me.options.ticks.min);
        me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
      }
      if (me.options.ticks.max !== undefined) {
        // user specified max value
        findIndex = labels.indexOf(me.options.ticks.max);
        me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
      }
      me.min = labels[me.minIndex];
      me.max = labels[me.maxIndex];
    },
    buildTicks: function buildTicks() {
      var me = this;
      var labels = me.getLabels();
      // If we are viewing some subset of labels, slice the original array
      me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      var me = this;
      var chart = me.chart;
      if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
        return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
      }
      return me.ticks[index - me.minIndex];
    },
    // Used to get data value locations.  Value can either be an index or a numerical value
    getPixelForValue: function getPixelForValue(value, index) {
      var me = this;
      var offset = me.options.offset;
      // 1 is added because we need the length but we have the indexes
      var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1);

      // If value is a data object, then index is the index in the data array,
      // not the index of the scale. We need to change that.
      var valueCategory;
      if (value !== undefined && value !== null) {
        valueCategory = me.isHorizontal() ? value.x : value.y;
      }
      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
        var labels = me.getLabels();
        value = valueCategory || value;
        var idx = labels.indexOf(value);
        index = idx !== -1 ? idx : index;
      }
      if (me.isHorizontal()) {
        var valueWidth = me.width / offsetAmt;
        var widthOffset = valueWidth * (index - me.minIndex);
        if (offset) {
          widthOffset += valueWidth / 2;
        }
        return me.left + widthOffset;
      }
      var valueHeight = me.height / offsetAmt;
      var heightOffset = valueHeight * (index - me.minIndex);
      if (offset) {
        heightOffset += valueHeight / 2;
      }
      return me.top + heightOffset;
    },
    getPixelForTick: function getPixelForTick(index) {
      return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var offset = me.options.offset;
      var value;
      var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
      var horz = me.isHorizontal();
      var valueDimension = (horz ? me.width : me.height) / offsetAmt;
      pixel -= horz ? me.left : me.top;
      if (offset) {
        pixel -= valueDimension / 2;
      }
      if (pixel <= 0) {
        value = 0;
      } else {
        value = Math.round(pixel / valueDimension);
      }
      return value + me.minIndex;
    },
    getBasePixel: function getBasePixel() {
      return this.bottom;
    }
  });

  // INTERNAL: static default options, registered in src/index.js
  var _defaults = defaultConfig;
  scale_category._defaults = _defaults;
  var noop = helpers$1.noop;
  var isNullOrUndef = helpers$1.isNullOrUndef;

  /**
   * Generate a set of linear ticks
   * @param generationOptions the options used to generate the ticks
   * @param dataRange the range of the data
   * @returns {number[]} array of tick values
   */
  function generateTicks(generationOptions, dataRange) {
    var ticks = [];
    // To get a "nice" value for the tick spacing, we will use the appropriately named
    // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
    // for details.

    var MIN_SPACING = 1e-14;
    var stepSize = generationOptions.stepSize;
    var unit = stepSize || 1;
    var maxNumSpaces = generationOptions.maxTicks - 1;
    var min = generationOptions.min;
    var max = generationOptions.max;
    var precision = generationOptions.precision;
    var rmin = dataRange.min;
    var rmax = dataRange.max;
    var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
    var factor, niceMin, niceMax, numSpaces;

    // Beyond MIN_SPACING floating point numbers being to lose precision
    // such that we can't do the math necessary to generate ticks
    if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
      return [rmin, rmax];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxNumSpaces) {
      // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
      spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
    }
    if (stepSize || isNullOrUndef(precision)) {
      // If a precision is not specified, calculate factor based on spacing
      factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
    } else {
      // If the user specified a precision, round to that number of decimal places
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;

    // If min, max and stepSize is set and they make an evenly spaced scale use it.
    if (stepSize) {
      // If very close to our whole number, use it.
      if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
        niceMin = min;
      }
      if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
        niceMax = max;
      }
    }
    numSpaces = (niceMax - niceMin) / spacing;
    // If very close to our rounded value, use it.
    if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    ticks.push(isNullOrUndef(min) ? niceMin : min);
    for (var j = 1; j < numSpaces; ++j) {
      ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
    }
    ticks.push(isNullOrUndef(max) ? niceMax : max);
    return ticks;
  }
  var scale_linearbase = core_scale.extend({
    getRightValue: function getRightValue(value) {
      if (typeof value === 'string') {
        return +value;
      }
      return core_scale.prototype.getRightValue.call(this, value);
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks;

      // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
      // do nothing since that would make the chart weird. If the user really wants a weird chart
      // axis, they can manually override it
      if (tickOpts.beginAtZero) {
        var minSign = helpers$1.sign(me.min);
        var maxSign = helpers$1.sign(me.max);
        if (minSign < 0 && maxSign < 0) {
          // move the top up to 0
          me.max = 0;
        } else if (minSign > 0 && maxSign > 0) {
          // move the bottom down to 0
          me.min = 0;
        }
      }
      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
      if (tickOpts.min !== undefined) {
        me.min = tickOpts.min;
      } else if (tickOpts.suggestedMin !== undefined) {
        if (me.min === null) {
          me.min = tickOpts.suggestedMin;
        } else {
          me.min = Math.min(me.min, tickOpts.suggestedMin);
        }
      }
      if (tickOpts.max !== undefined) {
        me.max = tickOpts.max;
      } else if (tickOpts.suggestedMax !== undefined) {
        if (me.max === null) {
          me.max = tickOpts.suggestedMax;
        } else {
          me.max = Math.max(me.max, tickOpts.suggestedMax);
        }
      }
      if (setMin !== setMax) {
        // We set the min or the max but not both.
        // So ensure that our range is good
        // Inverted or 0 length range can happen when
        // ticks.min is set, and no datasets are visible
        if (me.min >= me.max) {
          if (setMin) {
            me.max = me.min + 1;
          } else {
            me.min = me.max - 1;
          }
        }
      }
      if (me.min === me.max) {
        me.max++;
        if (!tickOpts.beginAtZero) {
          me.min--;
        }
      }
    },
    getTickLimit: function getTickLimit() {
      var me = this;
      var tickOpts = me.options.ticks;
      var stepSize = tickOpts.stepSize;
      var maxTicksLimit = tickOpts.maxTicksLimit;
      var maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
      } else {
        maxTicks = me._computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    },
    _computeTickLimit: function _computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    },
    handleDirectionalChanges: noop,
    buildTicks: function buildTicks() {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks;

      // Figure out what the max number of ticks we can support it is based on the size of
      // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
      // the graph. Make sure we always have at least 2 ticks
      var maxTicks = me.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      var numericGeneratorOptions = {
        maxTicks: maxTicks,
        min: tickOpts.min,
        max: tickOpts.max,
        precision: tickOpts.precision,
        stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
      };
      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
      me.handleDirectionalChanges();

      // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale
      me.max = helpers$1.max(ticks);
      me.min = helpers$1.min(ticks);
      if (tickOpts.reverse) {
        ticks.reverse();
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this;
      me.ticksAsNumbers = me.ticks.slice();
      me.zeroLineIndex = me.ticks.indexOf(0);
      core_scale.prototype.convertTicksToLabels.call(me);
    }
  });
  var defaultConfig$1 = {
    position: 'left',
    ticks: {
      callback: core_ticks.formatters.linear
    }
  };
  var scale_linear = scale_linearbase.extend({
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var data = chart.data;
      var datasets = data.datasets;
      var isHorizontal = me.isHorizontal();
      var DEFAULT_MIN = 0;
      var DEFAULT_MAX = 1;
      function IDMatches(meta) {
        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
      }

      // First Calculate the range
      me.min = null;
      me.max = null;
      var hasStacks = opts.stacked;
      if (hasStacks === undefined) {
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          if (hasStacks) {
            return;
          }
          var meta = chart.getDatasetMeta(datasetIndex);
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
            hasStacks = true;
          }
        });
      }
      if (opts.stacked || hasStacks) {
        var valuesPerStack = {};
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var key = [meta.type,
          // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');
          if (valuesPerStack[key] === undefined) {
            valuesPerStack[key] = {
              positiveValues: [],
              negativeValues: []
            };
          }

          // Store these per type
          var positiveValues = valuesPerStack[key].positiveValues;
          var negativeValues = valuesPerStack[key].negativeValues;
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);
              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }
              positiveValues[index] = positiveValues[index] || 0;
              negativeValues[index] = negativeValues[index] || 0;
              if (opts.relativePoints) {
                positiveValues[index] = 100;
              } else if (value < 0) {
                negativeValues[index] += value;
              } else {
                positiveValues[index] += value;
              }
            });
          }
        });
        helpers$1.each(valuesPerStack, function (valuesForType) {
          var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
          var minVal = helpers$1.min(values);
          var maxVal = helpers$1.max(values);
          me.min = me.min === null ? minVal : Math.min(me.min, minVal);
          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
        });
      } else {
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);
              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }
              if (me.min === null) {
                me.min = value;
              } else if (value < me.min) {
                me.min = value;
              }
              if (me.max === null) {
                me.max = value;
              } else if (value > me.max) {
                me.max = value;
              }
            });
          }
        });
      }
      me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
      me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

      // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
      this.handleTickRangeOptions();
    },
    // Returns the maximum number of ticks based on the scale dimension
    _computeTickLimit: function _computeTickLimit() {
      var me = this;
      var tickFont;
      if (me.isHorizontal()) {
        return Math.ceil(me.width / 40);
      }
      tickFont = helpers$1.options._parseFont(me.options.ticks);
      return Math.ceil(me.height / tickFont.lineHeight);
    },
    // Called after the ticks are built. We need
    handleDirectionalChanges: function handleDirectionalChanges() {
      if (!this.isHorizontal()) {
        // We are in a vertical orientation. The top value is the highest. So reverse the array
        this.ticks.reverse();
      }
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    // Utils
    getPixelForValue: function getPixelForValue(value) {
      // This must be called after fit has been run so that
      // this.left, this.top, this.right, and this.bottom have been defined
      var me = this;
      var start = me.start;
      var rightValue = +me.getRightValue(value);
      var pixel;
      var range = me.end - start;
      if (me.isHorizontal()) {
        pixel = me.left + me.width / range * (rightValue - start);
      } else {
        pixel = me.bottom - me.height / range * (rightValue - start);
      }
      return pixel;
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var isHorizontal = me.isHorizontal();
      var innerDimension = isHorizontal ? me.width : me.height;
      var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
      return me.start + (me.end - me.start) * offset;
    },
    getPixelForTick: function getPixelForTick(index) {
      return this.getPixelForValue(this.ticksAsNumbers[index]);
    }
  });

  // INTERNAL: static default options, registered in src/index.js
  var _defaults$1 = defaultConfig$1;
  scale_linear._defaults = _defaults$1;
  var valueOrDefault$a = helpers$1.valueOrDefault;

  /**
   * Generate a set of logarithmic ticks
   * @param generationOptions the options used to generate the ticks
   * @param dataRange the range of the data
   * @returns {number[]} array of tick values
   */
  function generateTicks$1(generationOptions, dataRange) {
    var ticks = [];
    var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
    var endExp = Math.floor(helpers$1.log10(dataRange.max));
    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    var exp, significand;
    if (tickVal === 0) {
      exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
      significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
      ticks.push(tickVal);
      tickVal = significand * Math.pow(10, exp);
    } else {
      exp = Math.floor(helpers$1.log10(tickVal));
      significand = Math.floor(tickVal / Math.pow(10, exp));
    }
    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    do {
      ticks.push(tickVal);
      ++significand;
      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }
      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);
    var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
    ticks.push(lastTick);
    return ticks;
  }
  var defaultConfig$2 = {
    position: 'left',
    // label settings
    ticks: {
      callback: core_ticks.formatters.logarithmic
    }
  };

  // TODO(v3): change this to positiveOrDefault
  function nonNegativeOrDefault(value, defaultValue) {
    return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
  }
  var scale_logarithmic = core_scale.extend({
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var data = chart.data;
      var datasets = data.datasets;
      var isHorizontal = me.isHorizontal();
      function IDMatches(meta) {
        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
      }

      // Calculate Range
      me.min = null;
      me.max = null;
      me.minNotZero = null;
      var hasStacks = opts.stacked;
      if (hasStacks === undefined) {
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          if (hasStacks) {
            return;
          }
          var meta = chart.getDatasetMeta(datasetIndex);
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
            hasStacks = true;
          }
        });
      }
      if (opts.stacked || hasStacks) {
        var valuesPerStack = {};
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var key = [meta.type,
          // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = [];
            }
            helpers$1.each(dataset.data, function (rawValue, index) {
              var values = valuesPerStack[key];
              var value = +me.getRightValue(rawValue);
              // invalid, hidden and negative values are ignored
              if (isNaN(value) || meta.data[index].hidden || value < 0) {
                return;
              }
              values[index] = values[index] || 0;
              values[index] += value;
            });
          }
        });
        helpers$1.each(valuesPerStack, function (valuesForType) {
          if (valuesForType.length > 0) {
            var minVal = helpers$1.min(valuesForType);
            var maxVal = helpers$1.max(valuesForType);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          }
        });
      } else {
        helpers$1.each(datasets, function (dataset, datasetIndex) {
          var meta = chart.getDatasetMeta(datasetIndex);
          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);
              // invalid, hidden and negative values are ignored
              if (isNaN(value) || meta.data[index].hidden || value < 0) {
                return;
              }
              if (me.min === null) {
                me.min = value;
              } else if (value < me.min) {
                me.min = value;
              }
              if (me.max === null) {
                me.max = value;
              } else if (value > me.max) {
                me.max = value;
              }
              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                me.minNotZero = value;
              }
            });
          }
        });
      }

      // Common base implementation to handle ticks.min, ticks.max
      this.handleTickRangeOptions();
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var me = this;
      var tickOpts = me.options.ticks;
      var DEFAULT_MIN = 1;
      var DEFAULT_MAX = 10;
      me.min = nonNegativeOrDefault(tickOpts.min, me.min);
      me.max = nonNegativeOrDefault(tickOpts.max, me.max);
      if (me.min === me.max) {
        if (me.min !== 0 && me.min !== null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
          me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
        } else {
          me.min = DEFAULT_MIN;
          me.max = DEFAULT_MAX;
        }
      }
      if (me.min === null) {
        me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
      }
      if (me.max === null) {
        me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
      }
      if (me.minNotZero === null) {
        if (me.min > 0) {
          me.minNotZero = me.min;
        } else if (me.max < 1) {
          me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
        } else {
          me.minNotZero = DEFAULT_MIN;
        }
      }
    },
    buildTicks: function buildTicks() {
      var me = this;
      var tickOpts = me.options.ticks;
      var reverse = !me.isHorizontal();
      var generationOptions = {
        min: nonNegativeOrDefault(tickOpts.min),
        max: nonNegativeOrDefault(tickOpts.max)
      };
      var ticks = me.ticks = generateTicks$1(generationOptions, me);

      // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale
      me.max = helpers$1.max(ticks);
      me.min = helpers$1.min(ticks);
      if (tickOpts.reverse) {
        reverse = !reverse;
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }
      if (reverse) {
        ticks.reverse();
      }
    },
    convertTicksToLabels: function convertTicksToLabels() {
      this.tickValues = this.ticks.slice();
      core_scale.prototype.convertTicksToLabels.call(this);
    },
    // Get the correct tooltip label
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    getPixelForTick: function getPixelForTick(index) {
      return this.getPixelForValue(this.tickValues[index]);
    },
    /**
     * Returns the value of the first tick.
     * @param {number} value - The minimum not zero value.
     * @return {number} The first tick value.
     * @private
     */
    _getFirstTickValue: function _getFirstTickValue(value) {
      var exp = Math.floor(helpers$1.log10(value));
      var significand = Math.floor(value / Math.pow(10, exp));
      return significand * Math.pow(10, exp);
    },
    getPixelForValue: function getPixelForValue(value) {
      var me = this;
      var tickOpts = me.options.ticks;
      var reverse = tickOpts.reverse;
      var log10 = helpers$1.log10;
      var firstTickValue = me._getFirstTickValue(me.minNotZero);
      var offset = 0;
      var innerDimension, pixel, start, end, sign;
      value = +me.getRightValue(value);
      if (reverse) {
        start = me.end;
        end = me.start;
        sign = -1;
      } else {
        start = me.start;
        end = me.end;
        sign = 1;
      }
      if (me.isHorizontal()) {
        innerDimension = me.width;
        pixel = reverse ? me.right : me.left;
      } else {
        innerDimension = me.height;
        sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)
        pixel = reverse ? me.top : me.bottom;
      }
      if (value !== start) {
        if (start === 0) {
          // include zero tick
          offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
          innerDimension -= offset;
          start = firstTickValue;
        }
        if (value !== 0) {
          offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
        }
        pixel += sign * offset;
      }
      return pixel;
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var tickOpts = me.options.ticks;
      var reverse = tickOpts.reverse;
      var log10 = helpers$1.log10;
      var firstTickValue = me._getFirstTickValue(me.minNotZero);
      var innerDimension, start, end, value;
      if (reverse) {
        start = me.end;
        end = me.start;
      } else {
        start = me.start;
        end = me.end;
      }
      if (me.isHorizontal()) {
        innerDimension = me.width;
        value = reverse ? me.right - pixel : pixel - me.left;
      } else {
        innerDimension = me.height;
        value = reverse ? pixel - me.top : me.bottom - pixel;
      }
      if (value !== start) {
        if (start === 0) {
          // include zero tick
          var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
          value -= offset;
          innerDimension -= offset;
          start = firstTickValue;
        }
        value *= log10(end) - log10(start);
        value /= innerDimension;
        value = Math.pow(10, log10(start) + value);
      }
      return value;
    }
  });

  // INTERNAL: static default options, registered in src/index.js
  var _defaults$2 = defaultConfig$2;
  scale_logarithmic._defaults = _defaults$2;
  var valueOrDefault$b = helpers$1.valueOrDefault;
  var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
  var resolve$7 = helpers$1.options.resolve;
  var defaultConfig$3 = {
    display: true,
    // Boolean - Whether to animate scaling the chart from the centre
    animate: true,
    position: 'chartArea',
    angleLines: {
      display: true,
      color: 'rgba(0, 0, 0, 0.1)',
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0.0
    },
    gridLines: {
      circular: false
    },
    // label settings
    ticks: {
      // Boolean - Show a backdrop to the scale label
      showLabelBackdrop: true,
      // String - The colour of the label backdrop
      backdropColor: 'rgba(255,255,255,0.75)',
      // Number - The backdrop padding above & below the label in pixels
      backdropPaddingY: 2,
      // Number - The backdrop padding to the side of the label in pixels
      backdropPaddingX: 2,
      callback: core_ticks.formatters.linear
    },
    pointLabels: {
      // Boolean - if true, show point labels
      display: true,
      // Number - Point label font size in pixels
      fontSize: 10,
      // Function - Used to convert point labels
      callback: function callback(label) {
        return label;
      }
    }
  };
  function getValueCount(scale) {
    var opts = scale.options;
    return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
  }
  function getTickBackdropHeight(opts) {
    var tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
    }
    return 0;
  }
  function measureLabelSize(ctx, lineHeight, label) {
    if (helpers$1.isArray(label)) {
      return {
        w: helpers$1.longestText(ctx, ctx.font, label),
        h: label.length * lineHeight
      };
    }
    return {
      w: ctx.measureText(label).width,
      h: lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }

  /**
   * Helper function to fit a radial linear scale with point labels
   */
  function fitWithPointLabels(scale) {
    // Right, this is really confusing and there is a lot of maths going on here
    // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
    //
    // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
    //
    // Solution:
    //
    // We assume the radius of the polygon is half the size of the canvas at first
    // at each index we check if the text overlaps.
    //
    // Where it does, we store that angle and that index.
    //
    // After finding the largest index and angle we calculate how much we need to remove
    // from the shape radius to move the point inwards by that x.
    //
    // We average the left and right distances to get the maximum shape radius that can fit in the box
    // along with labels.
    //
    // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
    // on each side, removing that from the size, halving it and adding the left x protrusion width.
    //
    // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
    // and position it in the most space efficient manner
    //
    // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif

    var plFont = helpers$1.options._parseFont(scale.options.pointLabels);

    // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
    var furthestLimits = {
      l: 0,
      r: scale.width,
      t: 0,
      b: scale.height - scale.paddingTop
    };
    var furthestAngles = {};
    var i, textSize, pointPosition;
    scale.ctx.font = plFont.string;
    scale._pointLabelSizes = [];
    var valueCount = getValueCount(scale);
    for (i = 0; i < valueCount; i++) {
      pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
      textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
      scale._pointLabelSizes[i] = textSize;

      // Add quarter circle to make degree 0 mean top of circle
      var angleRadians = scale.getIndexAngle(i);
      var angle = helpers$1.toDegrees(angleRadians) % 360;
      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      if (hLimits.start < furthestLimits.l) {
        furthestLimits.l = hLimits.start;
        furthestAngles.l = angleRadians;
      }
      if (hLimits.end > furthestLimits.r) {
        furthestLimits.r = hLimits.end;
        furthestAngles.r = angleRadians;
      }
      if (vLimits.start < furthestLimits.t) {
        furthestLimits.t = vLimits.start;
        furthestAngles.t = angleRadians;
      }
      if (vLimits.end > furthestLimits.b) {
        furthestLimits.b = vLimits.end;
        furthestAngles.b = angleRadians;
      }
    }
    scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return 'center';
    } else if (angle < 180) {
      return 'left';
    }
    return 'right';
  }
  function fillText(ctx, text, position, lineHeight) {
    var y = position.y + lineHeight / 2;
    var i, ilen;
    if (helpers$1.isArray(text)) {
      for (i = 0, ilen = text.length; i < ilen; ++i) {
        ctx.fillText(text[i], position.x, y);
        y += lineHeight;
      }
    } else {
      ctx.fillText(text, position.x, y);
    }
  }
  function adjustPointPositionForLabelHeight(angle, textSize, position) {
    if (angle === 90 || angle === 270) {
      position.y -= textSize.h / 2;
    } else if (angle > 270 || angle < 90) {
      position.y -= textSize.h;
    }
  }
  function drawPointLabels(scale) {
    var ctx = scale.ctx;
    var opts = scale.options;
    var angleLineOpts = opts.angleLines;
    var gridLineOpts = opts.gridLines;
    var pointLabelOpts = opts.pointLabels;
    var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
    var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
    var tickBackdropHeight = getTickBackdropHeight(opts);
    ctx.save();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = lineColor;
    if (ctx.setLineDash) {
      ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
      ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
    }
    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

    // Point Label Font
    var plFont = helpers$1.options._parseFont(pointLabelOpts);
    ctx.font = plFont.string;
    ctx.textBaseline = 'middle';
    for (var i = getValueCount(scale) - 1; i >= 0; i--) {
      if (angleLineOpts.display && lineWidth && lineColor) {
        var outerPosition = scale.getPointPosition(i, outerDistance);
        ctx.beginPath();
        ctx.moveTo(scale.xCenter, scale.yCenter);
        ctx.lineTo(outerPosition.x, outerPosition.y);
        ctx.stroke();
      }
      if (pointLabelOpts.display) {
        // Extra pixels out for some label spacing
        var extra = i === 0 ? tickBackdropHeight / 2 : 0;
        var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);

        // Keep this in loop since we may support array properties here
        var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
        ctx.fillStyle = pointLabelFontColor;
        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians);
        ctx.textAlign = getTextAlignForAngle(angle);
        adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
        fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
      }
    }
    ctx.restore();
  }
  function drawRadiusLine(scale, gridLineOpts, radius, index) {
    var ctx = scale.ctx;
    var circular = gridLineOpts.circular;
    var valueCount = getValueCount(scale);
    var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
    var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
    var pointPosition;
    if (!circular && !valueCount || !lineColor || !lineWidth) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;
    if (ctx.setLineDash) {
      ctx.setLineDash(gridLineOpts.borderDash || []);
      ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
    }
    ctx.beginPath();
    if (circular) {
      // Draw circular arcs between the points
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
    } else {
      // Draw straight lines connecting each index
      pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (var i = 1; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function numberOrZero(param) {
    return helpers$1.isNumber(param) ? param : 0;
  }
  var scale_radialLinear = scale_linearbase.extend({
    setDimensions: function setDimensions() {
      var me = this;

      // Set the unconstrained dimension before label rotation
      me.width = me.maxWidth;
      me.height = me.maxHeight;
      me.paddingTop = getTickBackdropHeight(me.options) / 2;
      me.xCenter = Math.floor(me.width / 2);
      me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
      me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
    },
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var chart = me.chart;
      var min = Number.POSITIVE_INFINITY;
      var max = Number.NEGATIVE_INFINITY;
      helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          helpers$1.each(dataset.data, function (rawValue, index) {
            var value = +me.getRightValue(rawValue);
            if (isNaN(value) || meta.data[index].hidden) {
              return;
            }
            min = Math.min(value, min);
            max = Math.max(value, max);
          });
        }
      });
      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;

      // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
      me.handleTickRangeOptions();
    },
    // Returns the maximum number of ticks based on the scale dimension
    _computeTickLimit: function _computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this;
      scale_linearbase.prototype.convertTicksToLabels.call(me);

      // Point labels
      me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    fit: function fit() {
      var me = this;
      var opts = me.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(me);
      } else {
        me.setCenterPoint(0, 0, 0, 0);
      }
    },
    /**
     * Set radius reductions and determine new radius and center point
     * @private
     */
    setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
      var me = this;
      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
      var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
      radiusReductionLeft = numberOrZero(radiusReductionLeft);
      radiusReductionRight = numberOrZero(radiusReductionRight);
      radiusReductionTop = numberOrZero(radiusReductionTop);
      radiusReductionBottom = numberOrZero(radiusReductionBottom);
      me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
    },
    setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      var me = this;
      var maxRight = me.width - rightMovement - me.drawingArea;
      var maxLeft = leftMovement + me.drawingArea;
      var maxTop = topMovement + me.drawingArea;
      var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
      me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
      me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
    },
    getIndexAngle: function getIndexAngle(index) {
      var angleMultiplier = Math.PI * 2 / getValueCount(this);
      var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
      var startAngleRadians = startAngle * Math.PI * 2 / 360;

      // Start from the top instead of right, so remove a quarter of the circle
      return index * angleMultiplier + startAngleRadians;
    },
    getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
      var me = this;
      if (value === null) {
        return 0; // null always in center
      }

      // Take into account half font size + the yPadding of the top value
      var scalingFactor = me.drawingArea / (me.max - me.min);
      if (me.options.ticks.reverse) {
        return (me.max - value) * scalingFactor;
      }
      return (value - me.min) * scalingFactor;
    },
    getPointPosition: function getPointPosition(index, distanceFromCenter) {
      var me = this;
      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
      return {
        x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
        y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
      };
    },
    getPointPositionForValue: function getPointPositionForValue(index, value) {
      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    },
    getBasePosition: function getBasePosition() {
      var me = this;
      var min = me.min;
      var max = me.max;
      return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
    },
    draw: function draw() {
      var me = this;
      var opts = me.options;
      var gridLineOpts = opts.gridLines;
      var tickOpts = opts.ticks;
      if (opts.display) {
        var ctx = me.ctx;
        var startAngle = this.getIndexAngle(0);
        var tickFont = helpers$1.options._parseFont(tickOpts);
        if (opts.angleLines.display || opts.pointLabels.display) {
          drawPointLabels(me);
        }
        helpers$1.each(me.ticks, function (label, index) {
          // Don't draw a centre value (if it is minimum)
          if (index > 0 || tickOpts.reverse) {
            var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

            // Draw circular lines around the scale
            if (gridLineOpts.display && index !== 0) {
              drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
            }
            if (tickOpts.display) {
              var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
              ctx.font = tickFont.string;
              ctx.save();
              ctx.translate(me.xCenter, me.yCenter);
              ctx.rotate(startAngle);
              if (tickOpts.showLabelBackdrop) {
                var labelWidth = ctx.measureText(label).width;
                ctx.fillStyle = tickOpts.backdropColor;
                ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
              }
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillStyle = tickFontColor;
              ctx.fillText(label, 0, -yCenterOffset);
              ctx.restore();
            }
          }
        });
      }
    }
  });

  // INTERNAL: static default options, registered in src/index.js
  var _defaults$3 = defaultConfig$3;
  scale_radialLinear._defaults = _defaults$3;
  var valueOrDefault$c = helpers$1.valueOrDefault;

  // Integer constants are from the ES6 spec.
  var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
    },
    second: {
      common: true,
      size: 1000,
      steps: [1, 2, 5, 10, 15, 30]
    },
    minute: {
      common: true,
      size: 60000,
      steps: [1, 2, 5, 10, 15, 30]
    },
    hour: {
      common: true,
      size: 3600000,
      steps: [1, 2, 3, 6, 12]
    },
    day: {
      common: true,
      size: 86400000,
      steps: [1, 2, 5]
    },
    week: {
      common: false,
      size: 604800000,
      steps: [1, 2, 3, 4]
    },
    month: {
      common: true,
      size: 2.628e9,
      steps: [1, 2, 3]
    },
    quarter: {
      common: false,
      size: 7.884e9,
      steps: [1, 2, 3, 4]
    },
    year: {
      common: true,
      size: 3.154e10
    }
  };
  var UNITS = Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function arrayUnique(items) {
    var hash = {};
    var out = [];
    var i, ilen, item;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      if (!hash[item]) {
        hash[item] = true;
        out.push(item);
      }
    }
    return out;
  }

  /**
   * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
   * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
   * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
   * extremity (left + width or top + height). Note that it would be more optimized to directly
   * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
   * to create the lookup table. The table ALWAYS contains at least two items: min and max.
   *
   * @param {number[]} timestamps - timestamps sorted from lowest to highest.
   * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
   * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
   * If 'series', timestamps will be positioned at the same distance from each other. In this
   * case, only timestamps that break the time linearity are registered, meaning that in the
   * best case, all timestamps are linear, the table contains only min and max.
   */
  function buildLookupTable(timestamps, min, max, distribution) {
    if (distribution === 'linear' || !timestamps.length) {
      return [{
        time: min,
        pos: 0
      }, {
        time: max,
        pos: 1
      }];
    }
    var table = [];
    var items = [min];
    var i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr > min && curr < max) {
        items.push(curr);
      }
    }
    items.push(max);
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];

      // only add points that breaks the scale linearity
      if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }

  // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
  function lookup(table, key, value) {
    var lo = 0;
    var hi = table.length - 1;
    var mid, i0, i1;
    while (lo >= 0 && lo <= hi) {
      mid = lo + hi >> 1;
      i0 = table[mid - 1] || null;
      i1 = table[mid];
      if (!i0) {
        // given value is outside table (before first item)
        return {
          lo: null,
          hi: i1
        };
      } else if (i1[key] < value) {
        lo = mid + 1;
      } else if (i0[key] > value) {
        hi = mid - 1;
      } else {
        return {
          lo: i0,
          hi: i1
        };
      }
    }

    // given value is outside table (after last item)
    return {
      lo: i1,
      hi: null
    };
  }

  /**
   * Linearly interpolates the given source `value` using the table items `skey` values and
   * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
   * returns the position for a timestamp equal to 42. If value is out of bounds, values at
   * index [0, 1] or [n - 1, n] are used for the interpolation.
   */
  function interpolate$1(table, skey, sval, tkey) {
    var range = lookup(table, skey, sval);

    // Note: the lookup table ALWAYS contains at least 2 items (min and max)
    var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
    var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
    var span = next[skey] - prev[skey];
    var ratio = span ? (sval - prev[skey]) / span : 0;
    var offset = (next[tkey] - prev[tkey]) * ratio;
    return prev[tkey] + offset;
  }
  function toTimestamp(scale, input) {
    var adapter = scale._adapter;
    var options = scale.options.time;
    var parser = options.parser;
    var format = parser || options.format;
    var value = input;
    if (typeof parser === 'function') {
      value = parser(value);
    }

    // Only parse if its not a timestamp already
    if (!helpers$1.isFinite(value)) {
      value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
    }
    if (value !== null) {
      return +value;
    }

    // Labels are in an incompatible format and no `parser` has been provided.
    // The user might still use the deprecated `format` option for parsing.
    if (!parser && typeof format === 'function') {
      value = format(input);

      // `format` could return something else than a timestamp, if so, parse it
      if (!helpers$1.isFinite(value)) {
        value = adapter.parse(value);
      }
    }
    return value;
  }
  function parse(scale, input) {
    if (helpers$1.isNullOrUndef(input)) {
      return null;
    }
    var options = scale.options.time;
    var value = toTimestamp(scale, scale.getRightValue(input));
    if (value === null) {
      return value;
    }
    if (options.round) {
      value = +scale._adapter.startOf(value, options.round);
    }
    return value;
  }

  /**
   * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
   * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
   */
  function determineStepSize(min, max, unit, capacity) {
    var range = max - min;
    var interval = INTERVALS[unit];
    var milliseconds = interval.size;
    var steps = interval.steps;
    var i, ilen, factor;
    if (!steps) {
      return Math.ceil(range / (capacity * milliseconds));
    }
    for (i = 0, ilen = steps.length; i < ilen; ++i) {
      factor = steps[i];
      if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
        break;
      }
    }
    return factor;
  }

  /**
   * Figures out what unit results in an appropriate number of auto-generated ticks
   */
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    var ilen = UNITS.length;
    var i, interval, factor;
    for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      interval = INTERVALS[UNITS[i]];
      factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }

  /**
   * Figures out what unit to format a set of ticks with
   */
  function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
    var ilen = UNITS.length;
    var i, unit;
    for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
      unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }

  /**
   * Generates a maximum of `capacity` timestamps between min and max, rounded to the
   * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
   * Important: this method can return ticks outside the min and max range, it's the
   * responsibility of the calling code to clamp values if needed.
   */
  function generate(scale, min, max, capacity) {
    var adapter = scale._adapter;
    var options = scale.options;
    var timeOpts = options.time;
    var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
    var major = determineMajorUnit(minor);
    var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
    var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    var majorTicksEnabled = options.ticks.major.enabled;
    var interval = INTERVALS[minor];
    var first = min;
    var last = max;
    var ticks = [];
    var time;
    if (!stepSize) {
      stepSize = determineStepSize(min, max, minor, capacity);
    }

    // For 'week' unit, handle the first day of week option
    if (weekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
      last = +adapter.startOf(last, 'isoWeek', weekday);
    }

    // Align first/last ticks on unit
    first = +adapter.startOf(first, weekday ? 'day' : minor);
    last = +adapter.startOf(last, weekday ? 'day' : minor);

    // Make sure that the last tick include max
    if (last < max) {
      last = +adapter.add(last, 1, minor);
    }
    time = first;
    if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
      // Align the first tick on the previous `minor` unit aligned on the `major` unit:
      // we first aligned time on the previous `major` unit then add the number of full
      // stepSize there is between first and the previous major time.
      time = +adapter.startOf(time, major);
      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
    }
    for (; time < last; time = +adapter.add(time, stepSize, minor)) {
      ticks.push(+time);
    }
    ticks.push(+time);
    return ticks;
  }

  /**
   * Returns the start and end offsets from edges in the form of {start, end}
   * where each value is a relative width to the scale and ranges between 0 and 1.
   * They add extra margins on the both sides by scaling down the original scale.
   * Offsets are added when the `offset` option is true.
   */
  function computeOffsets(table, ticks, min, max, options) {
    var start = 0;
    var end = 0;
    var first, last;
    if (options.offset && ticks.length) {
      if (!options.time.min) {
        first = interpolate$1(table, 'time', ticks[0], 'pos');
        if (ticks.length === 1) {
          start = 1 - first;
        } else {
          start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
        }
      }
      if (!options.time.max) {
        last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');
        if (ticks.length === 1) {
          end = last;
        } else {
          end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
        }
      }
    }
    return {
      start: start,
      end: end
    };
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    var ticks = [];
    var i, ilen, value, major;
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      value = values[i];
      major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
      ticks.push({
        value: value,
        major: major
      });
    }
    return ticks;
  }
  var defaultConfig$4 = {
    position: 'bottom',
    /**
     * Data distribution along the scale:
     * - 'linear': data are spread according to their time (distances can vary),
     * - 'series': data are spread at the same distance from each other.
     * @see https://github.com/chartjs/Chart.js/pull/4507
     * @since 2.7.0
     */
    distribution: 'linear',
    /**
     * Scale boundary strategy (bypassed by min/max time options)
     * - `data`: make sure data are fully visible, ticks outside are removed
     * - `ticks`: make sure ticks are fully visible, data outside are truncated
     * @see https://github.com/chartjs/Chart.js/pull/4556
     * @since 2.7.0
     */
    bounds: 'data',
    adapters: {},
    time: {
      parser: false,
      // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
      format: false,
      // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
      unit: false,
      // false == automatic or override with week, month, year, etc.
      round: false,
      // none, or override with week, month, year, etc.
      displayFormat: false,
      // DEPRECATED
      isoWeekday: false,
      // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
      minUnit: 'millisecond',
      displayFormats: {}
    },
    ticks: {
      autoSkip: false,
      /**
       * Ticks generation input values:
       * - 'auto': generates "optimal" ticks based on scale size and time options.
       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
       * - 'labels': generates ticks from user given `data.labels` values ONLY.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      source: 'auto',
      major: {
        enabled: false
      }
    }
  };
  var scale_time = core_scale.extend({
    initialize: function initialize() {
      this.mergeTicksOptions();
      core_scale.prototype.initialize.call(this);
    },
    update: function update() {
      var me = this;
      var options = me.options;
      var time = options.time || (options.time = {});
      var adapter = me._adapter = new core_adapters._date(options.adapters.date);

      // DEPRECATIONS: output a message only one time per update
      if (time.format) {
        console.warn('options.time.format is deprecated and replaced by options.time.parser.');
      }

      // Backward compatibility: before introducing adapter, `displayFormats` was
      // supposed to contain *all* unit/string pairs but this can't be resolved
      // when loading the scale (adapters are loaded afterward), so let's populate
      // missing formats on update
      helpers$1.mergeIf(time.displayFormats, adapter.formats());
      return core_scale.prototype.update.apply(me, arguments);
    },
    /**
     * Allows data to be referenced via 't' attribute
     */
    getRightValue: function getRightValue(rawValue) {
      if (rawValue && rawValue.t !== undefined) {
        rawValue = rawValue.t;
      }
      return core_scale.prototype.getRightValue.call(this, rawValue);
    },
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var chart = me.chart;
      var adapter = me._adapter;
      var timeOpts = me.options.time;
      var unit = timeOpts.unit || 'day';
      var min = MAX_INTEGER;
      var max = MIN_INTEGER;
      var timestamps = [];
      var datasets = [];
      var labels = [];
      var i, j, ilen, jlen, data, timestamp;
      var dataLabels = chart.data.labels || [];

      // Convert labels to timestamps
      for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
        labels.push(parse(me, dataLabels[i]));
      }

      // Convert data to timestamps
      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          data = chart.data.datasets[i].data;

          // Let's consider that all data have the same format.
          if (helpers$1.isObject(data[0])) {
            datasets[i] = [];
            for (j = 0, jlen = data.length; j < jlen; ++j) {
              timestamp = parse(me, data[j]);
              timestamps.push(timestamp);
              datasets[i][j] = timestamp;
            }
          } else {
            for (j = 0, jlen = labels.length; j < jlen; ++j) {
              timestamps.push(labels[j]);
            }
            datasets[i] = labels.slice(0);
          }
        } else {
          datasets[i] = [];
        }
      }
      if (labels.length) {
        // Sort labels **after** data have been converted
        labels = arrayUnique(labels).sort(sorter);
        min = Math.min(min, labels[0]);
        max = Math.max(max, labels[labels.length - 1]);
      }
      if (timestamps.length) {
        timestamps = arrayUnique(timestamps).sort(sorter);
        min = Math.min(min, timestamps[0]);
        max = Math.max(max, timestamps[timestamps.length - 1]);
      }
      min = parse(me, timeOpts.min) || min;
      max = parse(me, timeOpts.max) || max;

      // In case there is no valid min/max, set limits based on unit time option
      min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
      max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;

      // Make sure that max is strictly higher than min (required by the lookup table)
      me.min = Math.min(min, max);
      me.max = Math.max(min + 1, max);

      // PRIVATE
      me._horizontal = me.isHorizontal();
      me._table = [];
      me._timestamps = {
        data: timestamps,
        datasets: datasets,
        labels: labels
      };
    },
    buildTicks: function buildTicks() {
      var me = this;
      var min = me.min;
      var max = me.max;
      var options = me.options;
      var timeOpts = options.time;
      var timestamps = [];
      var ticks = [];
      var i, ilen, timestamp;
      switch (options.ticks.source) {
        case 'data':
          timestamps = me._timestamps.data;
          break;
        case 'labels':
          timestamps = me._timestamps.labels;
          break;
        case 'auto':
        default:
          timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
      }
      if (options.bounds === 'ticks' && timestamps.length) {
        min = timestamps[0];
        max = timestamps[timestamps.length - 1];
      }

      // Enforce limits with user min/max options
      min = parse(me, timeOpts.min) || min;
      max = parse(me, timeOpts.max) || max;

      // Remove ticks outside the min/max range
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        timestamp = timestamps[i];
        if (timestamp >= min && timestamp <= max) {
          ticks.push(timestamp);
        }
      }
      me.min = min;
      me.max = max;

      // PRIVATE
      me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
      me._majorUnit = determineMajorUnit(me._unit);
      me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
      me._offsets = computeOffsets(me._table, ticks, min, max, options);
      if (options.ticks.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(me, ticks, me._majorUnit);
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      var me = this;
      var adapter = me._adapter;
      var data = me.chart.data;
      var timeOpts = me.options.time;
      var label = data.labels && index < data.labels.length ? data.labels[index] : '';
      var value = data.datasets[datasetIndex].data[index];
      if (helpers$1.isObject(value)) {
        label = me.getRightValue(value);
      }
      if (timeOpts.tooltipFormat) {
        return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
      }
      if (typeof label === 'string') {
        return label;
      }
      return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
    },
    /**
     * Function to format an individual tick mark
     * @private
     */
    tickFormatFunction: function tickFormatFunction(time, index, ticks, format) {
      var me = this;
      var adapter = me._adapter;
      var options = me.options;
      var formats = options.time.displayFormats;
      var minorFormat = formats[me._unit];
      var majorUnit = me._majorUnit;
      var majorFormat = formats[majorUnit];
      var majorTime = +adapter.startOf(time, majorUnit);
      var majorTickOpts = options.ticks.major;
      var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
      var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
      var tickOpts = major ? majorTickOpts : options.ticks.minor;
      var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
      return formatter ? formatter(label, index, ticks) : label;
    },
    convertTicksToLabels: function convertTicksToLabels(ticks) {
      var labels = [];
      var i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
      }
      return labels;
    },
    /**
     * @private
     */
    getPixelForOffset: function getPixelForOffset(time) {
      var me = this;
      var isReverse = me.options.ticks.reverse;
      var size = me._horizontal ? me.width : me.height;
      var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
      var pos = interpolate$1(me._table, 'time', time, 'pos');
      var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
      return isReverse ? start - offset : start + offset;
    },
    getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
      var me = this;
      var time = null;
      if (index !== undefined && datasetIndex !== undefined) {
        time = me._timestamps.datasets[datasetIndex][index];
      }
      if (time === null) {
        time = parse(me, value);
      }
      if (time !== null) {
        return me.getPixelForOffset(time);
      }
    },
    getPixelForTick: function getPixelForTick(index) {
      var ticks = this.getTicks();
      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var size = me._horizontal ? me.width : me.height;
      var start = me._horizontal ? me.left : me.top;
      var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
      var time = interpolate$1(me._table, 'pos', pos, 'time');

      // DEPRECATION, we should return time directly
      return me._adapter._create(time);
    },
    /**
     * Crude approximation of what the label width might be
     * @private
     */
    getLabelWidth: function getLabelWidth(label) {
      var me = this;
      var ticksOpts = me.options.ticks;
      var tickLabelWidth = me.ctx.measureText(label).width;
      var angle = helpers$1.toRadians(ticksOpts.maxRotation);
      var cosRotation = Math.cos(angle);
      var sinRotation = Math.sin(angle);
      var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
      return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
    },
    /**
     * @private
     */
    getLabelCapacity: function getLabelCapacity(exampleTime) {
      var me = this;

      // pick the longest format (milliseconds) for guestimation
      var format = me.options.time.displayFormats.millisecond;
      var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
      var tickLabelWidth = me.getLabelWidth(exampleLabel);
      var innerWidth = me.isHorizontal() ? me.width : me.height;
      var capacity = Math.floor(innerWidth / tickLabelWidth);
      return capacity > 0 ? capacity : 1;
    }
  });

  // INTERNAL: static default options, registered in src/index.js
  var _defaults$4 = defaultConfig$4;
  scale_time._defaults = _defaults$4;
  var scales = {
    category: scale_category,
    linear: scale_linear,
    logarithmic: scale_logarithmic,
    radialLinear: scale_radialLinear,
    time: scale_time
  };
  var FORMATS = {
    datetime: 'MMM D, YYYY, h:mm:ss a',
    millisecond: 'h:mm:ss.SSS a',
    second: 'h:mm:ss a',
    minute: 'h:mm a',
    hour: 'hA',
    day: 'MMM D',
    week: 'll',
    month: 'MMM YYYY',
    quarter: '[Q]Q - YYYY',
    year: 'YYYY'
  };
  core_adapters._date.override(typeof moment === 'function' ? {
    _id: 'moment',
    // DEBUG ONLY

    formats: function formats() {
      return FORMATS;
    },
    parse: function parse(value, format) {
      if (typeof value === 'string' && typeof format === 'string') {
        value = moment(value, format);
      } else if (!(value instanceof moment)) {
        value = moment(value);
      }
      return value.isValid() ? value.valueOf() : null;
    },
    format: function format(time, _format) {
      return moment(time).format(_format);
    },
    add: function add(time, amount, unit) {
      return moment(time).add(amount, unit).valueOf();
    },
    diff: function diff(max, min, unit) {
      return moment.duration(moment(max).diff(moment(min))).as(unit);
    },
    startOf: function startOf(time, unit, weekday) {
      time = moment(time);
      if (unit === 'isoWeek') {
        return time.isoWeekday(weekday).valueOf();
      }
      return time.startOf(unit).valueOf();
    },
    endOf: function endOf(time, unit) {
      return moment(time).endOf(unit).valueOf();
    },
    // DEPRECATIONS

    /**
     * Provided for backward compatibility with scale.getValueForPixel().
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */
    _create: function _create(time) {
      return moment(time);
    }
  } : {});
  core_defaults._set('global', {
    plugins: {
      filler: {
        propagate: true
      }
    }
  });
  var mappers = {
    dataset: function dataset(source) {
      var index = source.fill;
      var chart = source.chart;
      var meta = chart.getDatasetMeta(index);
      var visible = meta && chart.isDatasetVisible(index);
      var points = visible && meta.dataset._children || [];
      var length = points.length || 0;
      return !length ? null : function (point, i) {
        return i < length && points[i]._view || null;
      };
    },
    boundary: function boundary(source) {
      var boundary = source.boundary;
      var x = boundary ? boundary.x : null;
      var y = boundary ? boundary.y : null;
      return function (point) {
        return {
          x: x === null ? point.x : x,
          y: y === null ? point.y : y
        };
      };
    }
  };

  // @todo if (fill[0] === '#')
  function decodeFill(el, index, count) {
    var model = el._model || {};
    var fill = model.fill;
    var target;
    if (fill === undefined) {
      fill = !!model.backgroundColor;
    }
    if (fill === false || fill === null) {
      return false;
    }
    if (fill === true) {
      return 'origin';
    }
    target = parseFloat(fill, 10);
    if (isFinite(target) && Math.floor(target) === target) {
      if (fill[0] === '-' || fill[0] === '+') {
        target = index + target;
      }
      if (target === index || target < 0 || target >= count) {
        return false;
      }
      return target;
    }
    switch (fill) {
      // compatibility
      case 'bottom':
        return 'start';
      case 'top':
        return 'end';
      case 'zero':
        return 'origin';
      // supported boundaries
      case 'origin':
      case 'start':
      case 'end':
        return fill;
      // invalid fill values
      default:
        return false;
    }
  }
  function computeBoundary(source) {
    var model = source.el._model || {};
    var scale = source.el._scale || {};
    var fill = source.fill;
    var target = null;
    var horizontal;
    if (isFinite(fill)) {
      return null;
    }

    // Backward compatibility: until v3, we still need to support boundary values set on
    // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
    // controllers might still use it (e.g. the Smith chart).

    if (fill === 'start') {
      target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
    } else if (fill === 'end') {
      target = model.scaleTop === undefined ? scale.top : model.scaleTop;
    } else if (model.scaleZero !== undefined) {
      target = model.scaleZero;
    } else if (scale.getBasePosition) {
      target = scale.getBasePosition();
    } else if (scale.getBasePixel) {
      target = scale.getBasePixel();
    }
    if (target !== undefined && target !== null) {
      if (target.x !== undefined && target.y !== undefined) {
        return target;
      }
      if (helpers$1.isFinite(target)) {
        horizontal = scale.isHorizontal();
        return {
          x: horizontal ? target : null,
          y: horizontal ? null : target
        };
      }
    }
    return null;
  }
  function resolveTarget(sources, index, propagate) {
    var source = sources[index];
    var fill = source.fill;
    var visited = [index];
    var target;
    if (!propagate) {
      return fill;
    }
    while (fill !== false && visited.indexOf(fill) === -1) {
      if (!isFinite(fill)) {
        return fill;
      }
      target = sources[fill];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill;
      }
      visited.push(fill);
      fill = target.fill;
    }
    return false;
  }
  function createMapper(source) {
    var fill = source.fill;
    var type = 'dataset';
    if (fill === false) {
      return null;
    }
    if (!isFinite(fill)) {
      type = 'boundary';
    }
    return mappers[type](source);
  }
  function isDrawable(point) {
    return point && !point.skip;
  }
  function drawArea(ctx, curve0, curve1, len0, len1) {
    var i;
    if (!len0 || !len1) {
      return;
    }

    // building first area curve (normal)
    ctx.moveTo(curve0[0].x, curve0[0].y);
    for (i = 1; i < len0; ++i) {
      helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
    }

    // joining the two area curves
    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

    // building opposite area curve (reverse)
    for (i = len1 - 1; i > 0; --i) {
      helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
    }
  }
  function doFill(ctx, points, mapper, view, color, loop) {
    var count = points.length;
    var span = view.spanGaps;
    var curve0 = [];
    var curve1 = [];
    var len0 = 0;
    var len1 = 0;
    var i, ilen, index, p0, p1, d0, d1;
    ctx.beginPath();
    for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
      index = i % count;
      p0 = points[index]._view;
      p1 = mapper(p0, index, view);
      d0 = isDrawable(p0);
      d1 = isDrawable(p1);
      if (d0 && d1) {
        len0 = curve0.push(p0);
        len1 = curve1.push(p1);
      } else if (len0 && len1) {
        if (!span) {
          drawArea(ctx, curve0, curve1, len0, len1);
          len0 = len1 = 0;
          curve0 = [];
          curve1 = [];
        } else {
          if (d0) {
            curve0.push(p0);
          }
          if (d1) {
            curve1.push(p1);
          }
        }
      }
    }
    drawArea(ctx, curve0, curve1, len0, len1);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }
  var plugin_filler = {
    id: 'filler',
    afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
      var count = (chart.data.datasets || []).length;
      var propagate = options.propagate;
      var sources = [];
      var meta, i, el, source;
      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        el = meta.dataset;
        source = null;
        if (el && el._model && el instanceof elements.Line) {
          source = {
            visible: chart.isDatasetVisible(i),
            fill: decodeFill(el, i, count),
            chart: chart,
            el: el
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i = 0; i < count; ++i) {
        source = sources[i];
        if (!source) {
          continue;
        }
        source.fill = resolveTarget(sources, i, propagate);
        source.boundary = computeBoundary(source);
        source.mapper = createMapper(source);
      }
    },
    beforeDatasetDraw: function beforeDatasetDraw(chart, args) {
      var meta = args.meta.$filler;
      if (!meta) {
        return;
      }
      var ctx = chart.ctx;
      var el = meta.el;
      var view = el._view;
      var points = el._children || [];
      var mapper = meta.mapper;
      var color = view.backgroundColor || core_defaults.global.defaultColor;
      if (mapper && color && points.length) {
        helpers$1.canvas.clipArea(ctx, chart.chartArea);
        doFill(ctx, points, mapper, view, color, el._loop);
        helpers$1.canvas.unclipArea(ctx);
      }
    }
  };
  var noop$1 = helpers$1.noop;
  var valueOrDefault$d = helpers$1.valueOrDefault;
  core_defaults._set('global', {
    legend: {
      display: true,
      position: 'top',
      fullWidth: true,
      reverse: false,
      weight: 1000,
      // a callback that will handle
      onClick: function onClick(e, legendItem) {
        var index = legendItem.datasetIndex;
        var ci = this.chart;
        var meta = ci.getDatasetMeta(index);

        // See controller.isDatasetVisible comment
        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

        // We hid a dataset ... rerender the chart
        ci.update();
      },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        // Generates labels shown in the legend
        // Valid properties to return:
        // text : text to display
        // fillStyle : fill of coloured box
        // strokeStyle: stroke of coloured box
        // hidden : if this legend item refers to a hidden item
        // lineCap : cap style for line
        // lineDash
        // lineDashOffset :
        // lineJoin :
        // lineWidth :
        generateLabels: function generateLabels(chart) {
          var data = chart.data;
          return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
            return {
              text: dataset.label,
              fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
              hidden: !chart.isDatasetVisible(i),
              lineCap: dataset.borderCapStyle,
              lineDash: dataset.borderDash,
              lineDashOffset: dataset.borderDashOffset,
              lineJoin: dataset.borderJoinStyle,
              lineWidth: dataset.borderWidth,
              strokeStyle: dataset.borderColor,
              pointStyle: dataset.pointStyle,
              // Below is extra data used for toggling the datasets
              datasetIndex: i
            };
          }, this) : [];
        }
      }
    },
    legendCallback: function legendCallback(chart) {
      var text = [];
      text.push('<ul class="' + chart.id + '-legend">');
      for (var i = 0; i < chart.data.datasets.length; i++) {
        text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
        if (chart.data.datasets[i].label) {
          text.push(chart.data.datasets[i].label);
        }
        text.push('</li>');
      }
      text.push('</ul>');
      return text.join('');
    }
  });

  /**
   * Helper function to get the box width based on the usePointStyle option
   * @param {object} labelopts - the label options on the legend
   * @param {number} fontSize - the label font size
   * @return {number} width of the color box area
   */
  function getBoxWidth(labelOpts, fontSize) {
    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
  }

  /**
   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
   */
  var Legend = core_element.extend({
    initialize: function initialize(config) {
      helpers$1.extend(this, config);

      // Contains hit boxes for each dataset (in dataset order)
      this.legendHitBoxes = [];

      /**
      	 * @private
      	 */
      this._hoveredItem = null;

      // Are we in doughnut mode which has a different data type
      this.doughnutMode = false;
    },
    // These methods are ordered by lifecycle. Utilities then follow.
    // Any function defined here is inherited by all legend types.
    // Any function can be extended by the legend type

    beforeUpdate: noop$1,
    update: function update(maxWidth, maxHeight, margins) {
      var me = this;

      // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
      me.beforeUpdate();

      // Absorb the master measurements
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = margins;

      // Dimensions
      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions();
      // Labels
      me.beforeBuildLabels();
      me.buildLabels();
      me.afterBuildLabels();

      // Fit
      me.beforeFit();
      me.fit();
      me.afterFit();
      //
      me.afterUpdate();
      return me.minSize;
    },
    afterUpdate: noop$1,
    //

    beforeSetDimensions: noop$1,
    setDimensions: function setDimensions() {
      var me = this;
      // Set the unconstrained dimension before label rotation
      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight;

        // Reset position before calculating rotation
        me.top = 0;
        me.bottom = me.height;
      }

      // Reset padding
      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0;

      // Reset minSize
      me.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: noop$1,
    //

    beforeBuildLabels: noop$1,
    buildLabels: function buildLabels() {
      var me = this;
      var labelOpts = me.options.labels || {};
      var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter(function (item) {
          return labelOpts.filter(item, me.chart.data);
        });
      }
      if (me.options.reverse) {
        legendItems.reverse();
      }
      me.legendItems = legendItems;
    },
    afterBuildLabels: noop$1,
    //

    beforeFit: noop$1,
    fit: function fit() {
      var me = this;
      var opts = me.options;
      var labelOpts = opts.labels;
      var display = opts.display;
      var ctx = me.ctx;
      var labelFont = helpers$1.options._parseFont(labelOpts);
      var fontSize = labelFont.size;

      // Reset hit boxes
      var hitboxes = me.legendHitBoxes = [];
      var minSize = me.minSize;
      var isHorizontal = me.isHorizontal();
      if (isHorizontal) {
        minSize.width = me.maxWidth; // fill all the width
        minSize.height = display ? 10 : 0;
      } else {
        minSize.width = display ? 10 : 0;
        minSize.height = me.maxHeight; // fill all the height
      }

      // Increase sizes here
      if (display) {
        ctx.font = labelFont.string;
        if (isHorizontal) {
          // Labels

          // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
          var lineWidths = me.lineWidths = [0];
          var totalHeight = 0;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'top';
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
              totalHeight += fontSize + labelOpts.padding;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
            }

            // Store the hitbox width and height here. Final position will be updated in `draw`
            hitboxes[i] = {
              left: 0,
              top: 0,
              width: width,
              height: fontSize
            };
            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
          });
          minSize.height += totalHeight;
        } else {
          var vPadding = labelOpts.padding;
          var columnWidths = me.columnWidths = [];
          var totalWidth = labelOpts.padding;
          var currentColWidth = 0;
          var currentColHeight = 0;
          var itemHeight = fontSize + vPadding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var boxWidth = getBoxWidth(labelOpts, fontSize);
            var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

            // If too tall, go to new column
            if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
              totalWidth += currentColWidth + labelOpts.padding;
              columnWidths.push(currentColWidth); // previous column width

              currentColWidth = 0;
              currentColHeight = 0;
            }

            // Get max width
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight;

            // Store the hitbox width and height here. Final position will be updated in `draw`
            hitboxes[i] = {
              left: 0,
              top: 0,
              width: itemWidth,
              height: fontSize
            };
          });
          totalWidth += currentColWidth;
          columnWidths.push(currentColWidth);
          minSize.width += totalWidth;
        }
      }
      me.width = minSize.width;
      me.height = minSize.height;
    },
    afterFit: noop$1,
    // Shared Methods
    isHorizontal: function isHorizontal() {
      return this.options.position === 'top' || this.options.position === 'bottom';
    },
    // Actually draw the legend on the canvas
    draw: function draw() {
      var me = this;
      var opts = me.options;
      var labelOpts = opts.labels;
      var globalDefaults = core_defaults.global;
      var defaultColor = globalDefaults.defaultColor;
      var lineDefault = globalDefaults.elements.line;
      var legendWidth = me.width;
      var lineWidths = me.lineWidths;
      if (opts.display) {
        var ctx = me.ctx;
        var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);
        var labelFont = helpers$1.options._parseFont(labelOpts);
        var fontSize = labelFont.size;
        var cursor;

        // Canvas setup
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = fontColor; // for strikethrough effect
        ctx.fillStyle = fontColor; // render in correct colour
        ctx.font = labelFont.string;
        var boxWidth = getBoxWidth(labelOpts, fontSize);
        var hitboxes = me.legendHitBoxes;

        // current position
        var drawLegendBox = function drawLegendBox(x, y, legendItem) {
          if (isNaN(boxWidth) || boxWidth <= 0) {
            return;
          }

          // Set the ctx for the box
          ctx.save();
          var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
          ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
          ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
          ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
          ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);
          if (ctx.setLineDash) {
            // IE 9 and 10 do not support line dash
            ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
          }
          if (opts.labels && opts.labels.usePointStyle) {
            // Recalculate x and y for drawPoint() because its expecting
            // x and y to be center of figure (instead of top left)
            var radius = boxWidth * Math.SQRT2 / 2;
            var centerX = x + boxWidth / 2;
            var centerY = y + fontSize / 2;

            // Draw pointStyle as legend symbol
            helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
          } else {
            // Draw box as legend symbol
            if (lineWidth !== 0) {
              ctx.strokeRect(x, y, boxWidth, fontSize);
            }
            ctx.fillRect(x, y, boxWidth, fontSize);
          }
          ctx.restore();
        };
        var fillText = function fillText(x, y, legendItem, textWidth) {
          var halfFontSize = fontSize / 2;
          var xLeft = boxWidth + halfFontSize + x;
          var yMiddle = y + halfFontSize;
          ctx.fillText(legendItem.text, xLeft, yMiddle);
          if (legendItem.hidden) {
            // Strikethrough the text if hidden
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.moveTo(xLeft, yMiddle);
            ctx.lineTo(xLeft + textWidth, yMiddle);
            ctx.stroke();
          }
        };

        // Horizontal
        var isHorizontal = me.isHorizontal();
        if (isHorizontal) {
          cursor = {
            x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
            y: me.top + labelOpts.padding,
            line: 0
          };
        } else {
          cursor = {
            x: me.left + labelOpts.padding,
            y: me.top + labelOpts.padding,
            line: 0
          };
        }
        var itemHeight = fontSize + labelOpts.padding;
        helpers$1.each(me.legendItems, function (legendItem, i) {
          var textWidth = ctx.measureText(legendItem.text).width;
          var width = boxWidth + fontSize / 2 + textWidth;
          var x = cursor.x;
          var y = cursor.y;

          // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
          // instead of me.right and me.bottom because me.width and me.height
          // may have been changed since me.minSize was calculated
          if (isHorizontal) {
            if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
              y = cursor.y += itemHeight;
              cursor.line++;
              x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
            }
          } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
            y = cursor.y = me.top + labelOpts.padding;
            cursor.line++;
          }
          drawLegendBox(x, y, legendItem);
          hitboxes[i].left = x;
          hitboxes[i].top = y;

          // Fill the actual label
          fillText(x, y, legendItem, textWidth);
          if (isHorizontal) {
            cursor.x += width + labelOpts.padding;
          } else {
            cursor.y += itemHeight;
          }
        });
      }
    },
    /**
     * @private
     */
    _getLegendItemAt: function _getLegendItemAt(x, y) {
      var me = this;
      var i, hitBox, lh;
      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
        // See if we are touching one of the dataset boxes
        lh = me.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
            // Touching an element
            return me.legendItems[i];
          }
        }
      }
      return null;
    },
    /**
     * Handle an event
     * @private
     * @param {IEvent} event - The event to handle
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var opts = me.options;
      var type = e.type === 'mouseup' ? 'click' : e.type;
      var hoveredItem;
      if (type === 'mousemove') {
        if (!opts.onHover && !opts.onLeave) {
          return;
        }
      } else if (type === 'click') {
        if (!opts.onClick) {
          return;
        }
      } else {
        return;
      }

      // Chart event already has relative position in it
      hoveredItem = me._getLegendItemAt(e.x, e.y);
      if (type === 'click') {
        if (hoveredItem && opts.onClick) {
          // use e.native for backwards compatibility
          opts.onClick.call(me, e["native"], hoveredItem);
        }
      } else {
        if (opts.onLeave && hoveredItem !== me._hoveredItem) {
          if (me._hoveredItem) {
            opts.onLeave.call(me, e["native"], me._hoveredItem);
          }
          me._hoveredItem = hoveredItem;
        }
        if (opts.onHover && hoveredItem) {
          // use e.native for backwards compatibility
          opts.onHover.call(me, e["native"], hoveredItem);
        }
      }
    }
  });
  function createNewLegendAndAttach(chart, legendOpts) {
    var legend = new Legend({
      ctx: chart.ctx,
      options: legendOpts,
      chart: chart
    });
    core_layouts.configure(chart, legend, legendOpts);
    core_layouts.addBox(chart, legend);
    chart.legend = legend;
  }
  var plugin_legend = {
    id: 'legend',
    /**
     * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
     * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
     * the plugin, which one will be re-exposed in the chart.js file.
     * https://github.com/chartjs/Chart.js/pull/2640
     * @private
     */
    _element: Legend,
    beforeInit: function beforeInit(chart) {
      var legendOpts = chart.options.legend;
      if (legendOpts) {
        createNewLegendAndAttach(chart, legendOpts);
      }
    },
    beforeUpdate: function beforeUpdate(chart) {
      var legendOpts = chart.options.legend;
      var legend = chart.legend;
      if (legendOpts) {
        helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
        if (legend) {
          core_layouts.configure(chart, legend, legendOpts);
          legend.options = legendOpts;
        } else {
          createNewLegendAndAttach(chart, legendOpts);
        }
      } else if (legend) {
        core_layouts.removeBox(chart, legend);
        delete chart.legend;
      }
    },
    afterEvent: function afterEvent(chart, e) {
      var legend = chart.legend;
      if (legend) {
        legend.handleEvent(e);
      }
    }
  };
  var noop$2 = helpers$1.noop;
  core_defaults._set('global', {
    title: {
      display: false,
      fontStyle: 'bold',
      fullWidth: true,
      padding: 10,
      position: 'top',
      text: '',
      weight: 2000 // by default greater than legend (1000) to be above
    }
  });

  /**
   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
   */
  var Title = core_element.extend({
    initialize: function initialize(config) {
      var me = this;
      helpers$1.extend(me, config);

      // Contains hit boxes for each dataset (in dataset order)
      me.legendHitBoxes = [];
    },
    // These methods are ordered by lifecycle. Utilities then follow.

    beforeUpdate: noop$2,
    update: function update(maxWidth, maxHeight, margins) {
      var me = this;

      // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
      me.beforeUpdate();

      // Absorb the master measurements
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = margins;

      // Dimensions
      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions();
      // Labels
      me.beforeBuildLabels();
      me.buildLabels();
      me.afterBuildLabels();

      // Fit
      me.beforeFit();
      me.fit();
      me.afterFit();
      //
      me.afterUpdate();
      return me.minSize;
    },
    afterUpdate: noop$2,
    //

    beforeSetDimensions: noop$2,
    setDimensions: function setDimensions() {
      var me = this;
      // Set the unconstrained dimension before label rotation
      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight;

        // Reset position before calculating rotation
        me.top = 0;
        me.bottom = me.height;
      }

      // Reset padding
      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0;

      // Reset minSize
      me.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: noop$2,
    //

    beforeBuildLabels: noop$2,
    buildLabels: noop$2,
    afterBuildLabels: noop$2,
    //

    beforeFit: noop$2,
    fit: function fit() {
      var me = this;
      var opts = me.options;
      var display = opts.display;
      var minSize = me.minSize;
      var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
      var fontOpts = helpers$1.options._parseFont(opts);
      var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;
      if (me.isHorizontal()) {
        minSize.width = me.maxWidth; // fill all the width
        minSize.height = textSize;
      } else {
        minSize.width = textSize;
        minSize.height = me.maxHeight; // fill all the height
      }
      me.width = minSize.width;
      me.height = minSize.height;
    },
    afterFit: noop$2,
    // Shared Methods
    isHorizontal: function isHorizontal() {
      var pos = this.options.position;
      return pos === 'top' || pos === 'bottom';
    },
    // Actually draw the title block on the canvas
    draw: function draw() {
      var me = this;
      var ctx = me.ctx;
      var opts = me.options;
      if (opts.display) {
        var fontOpts = helpers$1.options._parseFont(opts);
        var lineHeight = fontOpts.lineHeight;
        var offset = lineHeight / 2 + opts.padding;
        var rotation = 0;
        var top = me.top;
        var left = me.left;
        var bottom = me.bottom;
        var right = me.right;
        var maxWidth, titleX, titleY;
        ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour
        ctx.font = fontOpts.string;

        // Horizontal
        if (me.isHorizontal()) {
          titleX = left + (right - left) / 2; // midpoint of the width
          titleY = top + offset;
          maxWidth = right - left;
        } else {
          titleX = opts.position === 'left' ? left + offset : right - offset;
          titleY = top + (bottom - top) / 2;
          maxWidth = bottom - top;
          rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
        }
        ctx.save();
        ctx.translate(titleX, titleY);
        ctx.rotate(rotation);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        var text = opts.text;
        if (helpers$1.isArray(text)) {
          var y = 0;
          for (var i = 0; i < text.length; ++i) {
            ctx.fillText(text[i], 0, y, maxWidth);
            y += lineHeight;
          }
        } else {
          ctx.fillText(text, 0, 0, maxWidth);
        }
        ctx.restore();
      }
    }
  });
  function createNewTitleBlockAndAttach(chart, titleOpts) {
    var title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart: chart
    });
    core_layouts.configure(chart, title, titleOpts);
    core_layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: 'title',
    /**
     * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
     * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
     * the plugin, which one will be re-exposed in the chart.js file.
     * https://github.com/chartjs/Chart.js/pull/2640
     * @private
     */
    _element: Title,
    beforeInit: function beforeInit(chart) {
      var titleOpts = chart.options.title;
      if (titleOpts) {
        createNewTitleBlockAndAttach(chart, titleOpts);
      }
    },
    beforeUpdate: function beforeUpdate(chart) {
      var titleOpts = chart.options.title;
      var titleBlock = chart.titleBlock;
      if (titleOpts) {
        helpers$1.mergeIf(titleOpts, core_defaults.global.title);
        if (titleBlock) {
          core_layouts.configure(chart, titleBlock, titleOpts);
          titleBlock.options = titleOpts;
        } else {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      } else if (titleBlock) {
        core_layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
      }
    }
  };
  var plugins = {};
  var filler = plugin_filler;
  var legend = plugin_legend;
  var title = plugin_title;
  plugins.filler = filler;
  plugins.legend = legend;
  plugins.title = title;

  /**
   * @namespace Chart
   */

  core_controller.helpers = helpers$1;

  // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
  core_helpers(core_controller);
  core_controller._adapters = core_adapters;
  core_controller.Animation = core_animation;
  core_controller.animationService = core_animations;
  core_controller.controllers = controllers;
  core_controller.DatasetController = core_datasetController;
  core_controller.defaults = core_defaults;
  core_controller.Element = core_element;
  core_controller.elements = elements;
  core_controller.Interaction = core_interaction;
  core_controller.layouts = core_layouts;
  core_controller.platform = platform;
  core_controller.plugins = core_plugins;
  core_controller.Scale = core_scale;
  core_controller.scaleService = core_scaleService;
  core_controller.Ticks = core_ticks;
  core_controller.Tooltip = core_tooltip;

  // Register built-in scales

  core_controller.helpers.each(scales, function (scale, type) {
    core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
  });

  // Load to register built-in adapters (as side effects)

  // Loading built-in plugins

  for (var k in plugins) {
    if (plugins.hasOwnProperty(k)) {
      core_controller.plugins.register(plugins[k]);
    }
  }
  core_controller.platform.initialize();
  var src = core_controller;
  if (typeof window !== 'undefined') {
    window.Chart = core_controller;
  }

  // DEPRECATIONS

  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Chart
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */
  core_controller.Chart = core_controller;

  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Legend
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */
  core_controller.Legend = plugins.legend._element;

  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Title
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */
  core_controller.Title = plugins.title._element;

  /**
   * Provided for backward compatibility, use Chart.plugins instead
   * @namespace Chart.pluginService
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */
  core_controller.pluginService = core_controller.plugins;

  /**
   * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
   * effect, instead simply create/register plugins via plain JavaScript objects.
   * @interface Chart.PluginBase
   * @deprecated since version 2.5.0
   * @todo remove at version 3
   * @private
   */
  core_controller.PluginBase = core_controller.Element.extend({});

  /**
   * Provided for backward compatibility, use Chart.helpers.canvas instead.
   * @namespace Chart.canvasHelpers
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   * @private
   */
  core_controller.canvasHelpers = core_controller.helpers.canvas;

  /**
   * Provided for backward compatibility, use Chart.layouts instead.
   * @namespace Chart.layoutService
   * @deprecated since version 2.7.3
   * @todo remove at version 3
   * @private
   */
  core_controller.layoutService = core_controller.layouts;

  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.LinearScaleBase
   * @deprecated since version 2.8
   * @todo remove at version 3
   * @private
   */
  core_controller.LinearScaleBase = scale_linearbase;

  /**
   * Provided for backward compatibility, instead we should create a new Chart
   * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   */
  core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
    core_controller[klass] = function (ctx, cfg) {
      return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
        type: klass.charAt(0).toLowerCase() + klass.slice(1)
      }));
    };
  });
  return src;
});

/***/ }),

/***/ "./node_modules/dom-helper/index.js":
/*!******************************************!*\
  !*** ./node_modules/dom-helper/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var Utils = {};

/*
Remove an element and provide a function that inserts it into its original position
https://developers.google.com/speed/articles/javascript-dom
@param element {Element} The element to be temporarily removed
@return {Function} A function that inserts the element into its original position
 */

Utils.removeToInsertLater = function (element) {
  var nextSibling, parentNode;
  parentNode = element.parentNode;
  nextSibling = element.nextSibling;
  parentNode.removeChild(element);
  return function () {
    if (nextSibling) {
      parentNode.insertBefore(element, nextSibling);
    } else {
      parentNode.appendChild(element);
    }
  };
};

/*
fastest possible way to destroy all sub nodes (aka childs)
http://jsperf.com/innerhtml-vs-removechild/15
@param element {Element} The element for which all childs should be removed
 */

Utils.removeAllChilds = function (element) {
  var count;
  count = 0;
  while (element.firstChild) {
    count++;
    element.removeChild(element.firstChild);
  }
};
module.exports = Utils;

/***/ }),

/***/ "./node_modules/expose-loader/index.js?$!./node_modules/jquery/src/jquery.js-exposed":
/*!**********************************************************************************!*\
  !*** ./node_modules/expose-loader?$!./node_modules/jquery/src/jquery.js-exposed ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["$"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--9-0!./jquery.js */ "./node_modules/jquery/src/jquery.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?fasta!./node_modules/biojs-io-fasta/lib/index.js-exposed":
/*!*********************************************************************************************!*\
  !*** ./node_modules/expose-loader?fasta!./node_modules/biojs-io-fasta/lib/index.js-exposed ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["fasta"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--9-0!./index.js */ "./node_modules/biojs-io-fasta/lib/index.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?jsgrid!./node_modules/jsgrid/dist/jsgrid.js-exposed":
/*!****************************************************************************************!*\
  !*** ./node_modules/expose-loader?jsgrid!./node_modules/jsgrid/dist/jsgrid.js-exposed ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jsgrid"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--9-0!./jsgrid.js */ "./node_modules/jsgrid/dist/jsgrid.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?msa!./node_modules/msa/lib/index.js-exposed":
/*!********************************************************************************!*\
  !*** ./node_modules/expose-loader?msa!./node_modules/msa/lib/index.js-exposed ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["msa"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--9-0!./index.js */ "./node_modules/msa/lib/index.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(/*! is-callable */ "./node_modules/for-each/node_modules/is-callable/index.js");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};
var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};
var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};
var forEach = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }
  var receiver;
  if (arguments.length >= 3) {
    receiver = thisArg;
  }
  if (toStr.call(list) === '[object Array]') {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};
module.exports = forEach;

/***/ }),

/***/ "./node_modules/for-each/node_modules/is-callable/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/for-each/node_modules/is-callable/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var fnToStr = Function.prototype.toString;
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};
var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }
    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && _typeof(Symbol.toStringTag) === 'symbol';
module.exports = function isCallable(value) {
  if (!value) {
    return false;
  }
  if (typeof value !== 'function' && _typeof(value) !== 'object') {
    return false;
  }
  if (typeof value === 'function' && !value.prototype) {
    return true;
  }
  if (hasToStringTag) {
    return tryFunctionObject(value);
  }
  if (isES6ClassFn(value)) {
    return false;
  }
  var strClass = toStr.call(value);
  return strClass === fnClass || strClass === genClass;
};

/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;
if (typeof window !== "undefined") {
  win = window;
} else if (typeof global !== "undefined") {
  win = global;
} else if (typeof self !== "undefined") {
  win = self;
} else {
  win = {};
}
module.exports = win;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = isFunction;
var toString = Object.prototype.toString;
function isFunction(fn) {
  var string = toString.call(fn);
  return string === '[object Function]' || typeof fn === 'function' && string !== '[object RegExp]' || typeof window !== 'undefined' && (
  // IE8 and below
  fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
}
;

/***/ }),

/***/ "./node_modules/jbone/dist/jbone.js":
/*!******************************************!*\
  !*** ./node_modules/jbone/dist/jbone.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*!
 * jBone v1.2.1 - 2017-09-19 - Library for DOM manipulation
 *
 * http://jbone.js.org
 *
 * Copyright 2017 Alexey Kupriyanenko
 * Released under the MIT license.
 */

(function (win) {
  var
    // cache previous versions
    _$ = win.$,
    _jBone = win.jBone,
    // Quick match a standalone tag
    rquickSingleTag = /^<(\w+)\s*\/?>$/,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash
    rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
    // Alias for function
    slice = [].slice,
    splice = [].splice,
    keys = Object.keys,
    // Alias for global variables
    doc = win.document,
    isString = function isString(el) {
      return typeof el === "string";
    },
    isObject = function isObject(el) {
      return el instanceof Object;
    },
    isFunction = function isFunction(el) {
      return {}.toString.call(el) === "[object Function]";
    },
    isArray = function isArray(el) {
      return Array.isArray(el);
    },
    jBone = function jBone(element, data) {
      return new fn.init(element, data);
    },
    fn;

  // set previous values and return the instance upon calling the no-conflict mode
  jBone.noConflict = function () {
    win.$ = _$;
    win.jBone = _jBone;
    return jBone;
  };
  fn = jBone.fn = jBone.prototype = {
    init: function init(element, data) {
      var elements, tag, wraper, fragment;
      if (!element) {
        return this;
      }
      if (isString(element)) {
        // Create single DOM element
        if (tag = rquickSingleTag.exec(element)) {
          this[0] = doc.createElement(tag[1]);
          this.length = 1;
          if (isObject(data)) {
            this.attr(data);
          }
          return this;
        }
        // Create DOM collection
        if ((tag = rquickExpr.exec(element)) && tag[1]) {
          fragment = doc.createDocumentFragment();
          wraper = doc.createElement("div");
          wraper.innerHTML = element;
          while (wraper.lastChild) {
            fragment.appendChild(wraper.firstChild);
          }
          elements = slice.call(fragment.childNodes);
          return jBone.merge(this, elements);
        }
        // Find DOM elements with querySelectorAll
        if (jBone.isElement(data)) {
          return jBone(data).find(element);
        }
        try {
          elements = doc.querySelectorAll(element);
          return jBone.merge(this, elements);
        } catch (e) {
          return this;
        }
      }
      // Wrap DOMElement
      if (element.nodeType) {
        this[0] = element;
        this.length = 1;
        return this;
      }
      // Run function
      if (isFunction(element)) {
        return element();
      }
      // Return jBone element as is
      if (element instanceof jBone) {
        return element;
      }

      // Return element wrapped by jBone
      return jBone.makeArray(element, this);
    },
    pop: [].pop,
    push: [].push,
    reverse: [].reverse,
    shift: [].shift,
    sort: [].sort,
    splice: [].splice,
    slice: [].slice,
    indexOf: [].indexOf,
    forEach: [].forEach,
    unshift: [].unshift,
    concat: [].concat,
    join: [].join,
    every: [].every,
    some: [].some,
    filter: [].filter,
    map: [].map,
    reduce: [].reduce,
    reduceRight: [].reduceRight,
    length: 0
  };
  fn.constructor = jBone;
  fn.init.prototype = fn;
  jBone.setId = function (el) {
    var jid = el.jid;
    if (el === win) {
      jid = "window";
    } else if (el.jid === undefined) {
      el.jid = jid = ++jBone._cache.jid;
    }
    if (!jBone._cache.events[jid]) {
      jBone._cache.events[jid] = {};
    }
  };
  jBone.getData = function (el) {
    el = el instanceof jBone ? el[0] : el;
    var jid = el === win ? "window" : el.jid;
    return {
      jid: jid,
      events: jBone._cache.events[jid]
    };
  };
  jBone.isElement = function (el) {
    return el && el instanceof jBone || el instanceof HTMLElement || isString(el);
  };
  jBone._cache = {
    events: {},
    jid: 0
  };
  function isArraylike(obj) {
    var length = obj.length,
      type = _typeof(obj);
    if (isFunction(type) || obj === win) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return isArray(type) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }
  fn.pushStack = function (elems) {
    var ret = jBone.merge(this.constructor(), elems);
    return ret;
  };
  jBone.merge = function (first, second) {
    var l = second.length,
      i = first.length,
      j = 0;
    while (j < l) {
      first[i++] = second[j++];
    }
    first.length = i;
    return first;
  };
  jBone.contains = function (container, contained) {
    return container.contains(contained);
  };
  jBone.extend = function (target) {
    var tg;
    splice.call(arguments, 1).forEach(function (source) {
      tg = target; //caching target for perf improvement

      if (source) {
        for (var prop in source) {
          tg[prop] = source[prop];
        }
      }
    });
    return target;
  };
  jBone.makeArray = function (arr, results) {
    var ret = results || [];
    if (arr !== null) {
      if (isArraylike(arr)) {
        jBone.merge(ret, isString(arr) ? [arr] : arr);
      } else {
        ret.push(arr);
      }
    }
    return ret;
  };
  jBone.unique = function (array) {
    if (array == null) {
      return [];
    }
    var result = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (result.indexOf(value) < 0) {
        result.push(value);
      }
    }
    return result;
  };
  function BoneEvent(e, data) {
    var key, setter;
    this.originalEvent = e;
    setter = function setter(key, e) {
      if (key === "preventDefault") {
        this[key] = function () {
          this.defaultPrevented = true;
          return e[key]();
        };
      } else if (key === "stopImmediatePropagation") {
        this[key] = function () {
          this.immediatePropagationStopped = true;
          return e[key]();
        };
      } else if (isFunction(e[key])) {
        this[key] = function () {
          return e[key]();
        };
      } else {
        this[key] = e[key];
      }
    };
    for (key in e) {
      if (e[key] || typeof e[key] === "function") {
        setter.call(this, key, e);
      }
    }
    jBone.extend(this, data, {
      isImmediatePropagationStopped: function isImmediatePropagationStopped() {
        return !!this.immediatePropagationStopped;
      }
    });
  }
  jBone.Event = function (event, data) {
    var namespace, eventType;
    if (event.type && !data) {
      data = event;
      event = event.type;
    }
    namespace = event.split(".").splice(1).join(".");
    eventType = event.split(".")[0];
    event = doc.createEvent("Event");
    event.initEvent(eventType, true, true);
    return jBone.extend(event, {
      namespace: namespace,
      isDefaultPrevented: function isDefaultPrevented() {
        return event.defaultPrevented;
      }
    }, data);
  };
  jBone.event = {
    /**
     * Attach a handler to an event for the elements
     * @param {Node}        el         - Events will be attached to this DOM Node
     * @param {String}      types      - One or more space-separated event types and optional namespaces
     * @param {Function}    handler    - A function to execute when the event is triggered
     * @param {Object}      [data]     - Data to be passed to the handler in event.data
     * @param {String}      [selector] - A selector string to filter the descendants of the selected elements
     */
    add: function add(el, types, handler, data, selector) {
      jBone.setId(el);
      var eventHandler = function eventHandler(e) {
          jBone.event.dispatch.call(el, e);
        },
        events = jBone.getData(el).events,
        eventType,
        t,
        event;
      types = types.split(" ");
      t = types.length;
      while (t--) {
        event = types[t];
        eventType = event.split(".")[0];
        events[eventType] = events[eventType] || [];
        if (events[eventType].length) {
          // override with previous event handler
          eventHandler = events[eventType][0].fn;
        } else {
          el.addEventListener && el.addEventListener(eventType, eventHandler, false);
        }
        events[eventType].push({
          namespace: event.split(".").splice(1).join("."),
          fn: eventHandler,
          selector: selector,
          data: data,
          originfn: handler
        });
      }
    },
    /**
     * Remove an event handler
     * @param  {Node}       el        - Events will be deattached from this DOM Node
     * @param  {String}     types     - One or more space-separated event types and optional namespaces
     * @param  {Function}   handler   - A handler function previously attached for the event(s)
     * @param  {String}     [selector] - A selector string to filter the descendants of the selected elements
     */
    remove: function remove(el, types, handler, selector) {
      var removeListener = function removeListener(events, eventType, index, el, e) {
          var callback;

          // get callback
          if (handler && e.originfn === handler || !handler) {
            callback = e.fn;
          }
          if (events[eventType][index].fn === callback) {
            // remove handler from cache
            events[eventType].splice(index, 1);
            if (!events[eventType].length) {
              el.removeEventListener(eventType, callback);
            }
          }
        },
        events = jBone.getData(el).events,
        l,
        eventsByType;
      if (!events) {
        return;
      }

      // remove all events
      if (!types && events) {
        return keys(events).forEach(function (eventType) {
          eventsByType = events[eventType];
          l = eventsByType.length;
          while (l--) {
            removeListener(events, eventType, l, el, eventsByType[l]);
          }
        });
      }
      types.split(" ").forEach(function (eventName) {
        var eventType = eventName.split(".")[0],
          namespace = eventName.split(".").splice(1).join("."),
          e;

        // remove named events
        if (events[eventType]) {
          eventsByType = events[eventType];
          l = eventsByType.length;
          while (l--) {
            e = eventsByType[l];
            if ((!namespace || namespace && e.namespace === namespace) && (!selector || selector && e.selector === selector)) {
              removeListener(events, eventType, l, el, e);
            }
          }
        }
        // remove all namespaced events
        else if (namespace) {
          keys(events).forEach(function (eventType) {
            eventsByType = events[eventType];
            l = eventsByType.length;
            while (l--) {
              e = eventsByType[l];
              if (e.namespace.split(".")[0] === namespace.split(".")[0]) {
                removeListener(events, eventType, l, el, e);
              }
            }
          });
        }
      });
    },
    /**
     * Execute all handlers and behaviors attached to the matched elements for the given event type.
     * @param  {Node}       el       - Events will be triggered for thie DOM Node
     * @param  {String}     event    - One or more space-separated event types and optional namespaces
     */
    trigger: function trigger(el, event) {
      var events = [];
      if (isString(event)) {
        events = event.split(" ").map(function (event) {
          return jBone.Event(event);
        });
      } else {
        event = event instanceof Event ? event : jBone.Event(event);
        events = [event];
      }
      events.forEach(function (event) {
        if (!event.type) {
          return;
        }
        el.dispatchEvent && el.dispatchEvent(event);
      });
    },
    dispatch: function dispatch(e) {
      var i = 0,
        j = 0,
        el = this,
        handlers = jBone.getData(el).events[e.type],
        length = handlers.length,
        handlerQueue = [],
        targets = [],
        l,
        expectedTarget,
        handler,
        event,
        eventOptions;

      // cache all events handlers, fix issue with multiple handlers (issue #45)
      for (; i < length; i++) {
        handlerQueue.push(handlers[i]);
      }
      i = 0;
      length = handlerQueue.length;
      for (;
      // if event exists
      i < length &&
      // if handler is not removed from stack
      ~handlers.indexOf(handlerQueue[i]) &&
      // if propagation is not stopped
      !(event && event.isImmediatePropagationStopped()); i++) {
        expectedTarget = null;
        eventOptions = {};
        handler = handlerQueue[i];
        handler.data && (eventOptions.data = handler.data);

        // event handler without selector
        if (!handler.selector) {
          event = new BoneEvent(e, eventOptions);
          if (!(e.namespace && e.namespace !== handler.namespace)) {
            handler.originfn.call(el, event);
          }
        }
        // event handler with selector
        else if (
        // if target and selected element the same
        ~(targets = jBone(el).find(handler.selector)).indexOf(e.target) && (expectedTarget = e.target) ||
        // if one of element matched with selector contains target
        el !== e.target && el.contains(e.target)) {
          // get element matched with selector
          if (!expectedTarget) {
            l = targets.length;
            j = 0;
            for (; j < l; j++) {
              if (targets[j] && targets[j].contains(e.target)) {
                expectedTarget = targets[j];
              }
            }
          }
          if (!expectedTarget) {
            continue;
          }
          eventOptions.currentTarget = expectedTarget;
          event = new BoneEvent(e, eventOptions);
          if (!(e.namespace && e.namespace !== handler.namespace)) {
            handler.originfn.call(expectedTarget, event);
          }
        }
      }
    }
  };
  fn.on = function (types, selector, data, fn) {
    var length = this.length,
      i = 0;
    if (data == null && fn == null) {
      // (types, fn)
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // (types, selector, fn)
        fn = data;
        data = undefined;
      } else {
        // (types, data, fn)
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (!fn) {
      return this;
    }
    for (; i < length; i++) {
      jBone.event.add(this[i], types, fn, data, selector);
    }
    return this;
  };
  fn.one = function (event) {
    var args = arguments,
      i = 0,
      length = this.length,
      oneArgs = slice.call(args, 1, args.length - 1),
      callback = slice.call(args, -1)[0],
      addListener;
    addListener = function addListener(el) {
      var $el = jBone(el);
      event.split(" ").forEach(function (event) {
        var fn = function fn(e) {
          $el.off(event, fn);
          callback.call(el, e);
        };
        $el.on.apply($el, [event].concat(oneArgs, fn));
      });
    };
    for (; i < length; i++) {
      addListener(this[i]);
    }
    return this;
  };
  fn.trigger = function (event) {
    var i = 0,
      length = this.length;
    if (!event) {
      return this;
    }
    for (; i < length; i++) {
      jBone.event.trigger(this[i], event);
    }
    return this;
  };
  fn.off = function (types, selector, handler) {
    var i = 0,
      length = this.length;
    if (isFunction(selector)) {
      handler = selector;
      selector = undefined;
    }
    for (; i < length; i++) {
      jBone.event.remove(this[i], types, handler, selector);
    }
    return this;
  };
  fn.find = function (selector) {
    var results = [],
      i = 0,
      length = this.length,
      finder = function finder(el) {
        if (isFunction(el.querySelectorAll)) {
          [].forEach.call(el.querySelectorAll(selector), function (found) {
            results.push(found);
          });
        }
      };
    for (; i < length; i++) {
      finder(this[i]);
    }
    return jBone(results);
  };
  fn.get = function (index) {
    return index != null ?
    // Return just one element from the set
    index < 0 ? this[index + this.length] : this[index] :
    // Return all the elements in a clean array
    slice.call(this);
  };
  fn.eq = function (index) {
    return jBone(this[index]);
  };
  fn.parent = function () {
    var results = [],
      parent,
      i = 0,
      length = this.length;
    for (; i < length; i++) {
      if (!~results.indexOf(parent = this[i].parentElement) && parent) {
        results.push(parent);
      }
    }
    return jBone(results);
  };
  fn.toArray = function () {
    return slice.call(this);
  };
  fn.is = function () {
    var args = arguments;
    return this.some(function (el) {
      return el.tagName.toLowerCase() === args[0];
    });
  };
  fn.has = function () {
    var args = arguments;
    return this.some(function (el) {
      return el.querySelectorAll(args[0]).length;
    });
  };
  fn.add = function (selector, context) {
    return this.pushStack(jBone.unique(jBone.merge(this.get(), jBone(selector, context))));
  };
  fn.attr = function (key, value) {
    var args = arguments,
      i = 0,
      length = this.length,
      setter;
    if (isString(key) && args.length === 1) {
      return this[0] && this[0].getAttribute(key);
    }
    if (args.length === 2) {
      setter = function setter(el) {
        el.setAttribute(key, value);
      };
    } else if (isObject(key)) {
      setter = function setter(el) {
        keys(key).forEach(function (name) {
          el.setAttribute(name, key[name]);
        });
      };
    }
    for (; i < length; i++) {
      setter(this[i]);
    }
    return this;
  };
  fn.removeAttr = function (key) {
    var i = 0,
      length = this.length;
    for (; i < length; i++) {
      this[i].removeAttribute(key);
    }
    return this;
  };
  fn.val = function (value) {
    var i = 0,
      length = this.length;
    if (arguments.length === 0) {
      return this[0] && this[0].value;
    }
    for (; i < length; i++) {
      this[i].value = value;
    }
    return this;
  };
  fn.css = function (key, value) {
    var args = arguments,
      i = 0,
      length = this.length,
      setter;

    // Get attribute
    if (isString(key) && args.length === 1) {
      return this[0] && win.getComputedStyle(this[0])[key];
    }

    // Set attributes
    if (args.length === 2) {
      setter = function setter(el) {
        el.style[key] = value;
      };
    } else if (isObject(key)) {
      setter = function setter(el) {
        keys(key).forEach(function (name) {
          el.style[name] = key[name];
        });
      };
    }
    for (; i < length; i++) {
      setter(this[i]);
    }
    return this;
  };
  fn.data = function (key, value) {
    var args = arguments,
      data = {},
      i = 0,
      length = this.length,
      setter,
      setValue = function setValue(el, key, value) {
        if (isObject(value)) {
          el.jdata = el.jdata || {};
          el.jdata[key] = value;
        } else {
          el.dataset[key] = value;
        }
      },
      getValue = function getValue(value) {
        if (value === "true") {
          return true;
        } else if (value === "false") {
          return false;
        } else {
          return value;
        }
      };

    // Get all data
    if (args.length === 0) {
      this[0].jdata && (data = this[0].jdata);
      keys(this[0].dataset).forEach(function (key) {
        data[key] = getValue(this[0].dataset[key]);
      }, this);
      return data;
    }
    // Get data by name
    if (args.length === 1 && isString(key)) {
      return this[0] && getValue(this[0].dataset[key] || this[0].jdata && this[0].jdata[key]);
    }

    // Set data
    if (args.length === 1 && isObject(key)) {
      setter = function setter(el) {
        keys(key).forEach(function (name) {
          setValue(el, name, key[name]);
        });
      };
    } else if (args.length === 2) {
      setter = function setter(el) {
        setValue(el, key, value);
      };
    }
    for (; i < length; i++) {
      setter(this[i]);
    }
    return this;
  };
  fn.removeData = function (key) {
    var i = 0,
      length = this.length,
      jdata,
      dataset;
    for (; i < length; i++) {
      jdata = this[i].jdata;
      dataset = this[i].dataset;
      if (key) {
        jdata && jdata[key] && delete jdata[key];
        delete dataset[key];
      } else {
        for (key in jdata) {
          delete jdata[key];
        }
        for (key in dataset) {
          delete dataset[key];
        }
      }
    }
    return this;
  };
  fn.addClass = function (className) {
    var i = 0,
      j = 0,
      length = this.length,
      classes = className ? className.trim().split(/\s+/) : [];
    for (; i < length; i++) {
      j = 0;
      for (j = 0; j < classes.length; j++) {
        this[i].classList.add(classes[j]);
      }
    }
    return this;
  };
  fn.removeClass = function (className) {
    var i = 0,
      j = 0,
      length = this.length,
      classes = className ? className.trim().split(/\s+/) : [];
    for (; i < length; i++) {
      j = 0;
      for (j = 0; j < classes.length; j++) {
        this[i].classList.remove(classes[j]);
      }
    }
    return this;
  };
  fn.toggleClass = function (className, force) {
    var i = 0,
      length = this.length,
      method = "toggle";
    force === true && (method = "add") || force === false && (method = "remove");
    if (className) {
      for (; i < length; i++) {
        this[i].classList[method](className);
      }
    }
    return this;
  };
  fn.hasClass = function (className) {
    var i = 0,
      length = this.length;
    if (className) {
      for (; i < length; i++) {
        if (this[i].classList.contains(className)) {
          return true;
        }
      }
    }
    return false;
  };
  fn.html = function (value) {
    var args = arguments,
      el;

    // add HTML into elements
    if (args.length === 1 && value !== undefined) {
      return this.empty().append(value);
    }
    // get HTML from element
    else if (args.length === 0 && (el = this[0])) {
      return el.innerHTML;
    }
    return this;
  };
  fn.append = function (appended) {
    var i = 0,
      length = this.length,
      setter;

    // create jBone object and then append
    if (isString(appended) && rquickExpr.exec(appended)) {
      appended = jBone(appended);
    }
    // create text node for insertion
    else if (!isObject(appended)) {
      appended = document.createTextNode(appended);
    }
    appended = appended instanceof jBone ? appended : jBone(appended);
    setter = function setter(el, i) {
      appended.forEach(function (node) {
        if (i) {
          el.appendChild(node.cloneNode(true));
        } else {
          el.appendChild(node);
        }
      });
    };
    for (; i < length; i++) {
      setter(this[i], i);
    }
    return this;
  };
  fn.appendTo = function (to) {
    jBone(to).append(this);
    return this;
  };
  fn.empty = function () {
    var i = 0,
      length = this.length,
      el;
    for (; i < length; i++) {
      el = this[i];
      while (el.lastChild) {
        el.removeChild(el.lastChild);
      }
    }
    return this;
  };
  fn.remove = function () {
    var i = 0,
      length = this.length,
      el;

    // remove all listeners
    this.off();
    for (; i < length; i++) {
      el = this[i];

      // remove data and nodes
      delete el.jdata;
      el.parentNode && el.parentNode.removeChild(el);
    }
    return this;
  };
  if (( false ? undefined : _typeof(module)) === "object" && module && _typeof(module.exports) === "object") {
    // Expose jBone as module.exports in loaders that implement the Node
    // module pattern (including browserify). Do not create the global, since
    // the user will be storing it themselves locally, and globals are frowned
    // upon in the Node module world.
    module.exports = jBone;
  }
  // Register as a AMD module
  else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jBone;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    win.jBone = win.$ = jBone;
  } else {}
})(typeof window !== "undefined" ? window : this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/jquery-ui/ui/version.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery-ui/ui/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  $.ui = $.ui || {};
  return $.ui.version = "1.12.1";
});

/***/ }),

/***/ "./node_modules/jquery-ui/ui/widget.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery-ui/ui/widget.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/

(function (factory) {
  if (true) {
    // AMD. Register as an anonymous module.
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  var widgetUuid = 0;
  var widgetSlice = Array.prototype.slice;
  $.cleanData = function (orig) {
    return function (elems) {
      var events, elem, i;
      for (i = 0; (elem = elems[i]) != null; i++) {
        try {
          // Only trigger remove when necessary to save time
          events = $._data(elem, "events");
          if (events && events.remove) {
            $(elem).triggerHandler("remove");
          }

          // Http://bugs.jquery.com/ticket/8235
        } catch (e) {}
      }
      orig(elems);
    };
  }($.cleanData);
  $.widget = function (name, base, prototype) {
    var existingConstructor, constructor, basePrototype;

    // ProxiedPrototype allows the provided prototype to remain unmodified
    // so that it can be used as a mixin for multiple widgets (#8876)
    var proxiedPrototype = {};
    var namespace = name.split(".")[0];
    name = name.split(".")[1];
    var fullName = namespace + "-" + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    if ($.isArray(prototype)) {
      prototype = $.extend.apply(null, [{}].concat(prototype));
    }

    // Create selector for plugin
    $.expr[":"][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // Allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // Allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };

    // Extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      // Copy the object used to create the prototype in case we need to
      // redefine the widget later
      _proto: $.extend({}, prototype),
      // Track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });
    basePrototype = new base();

    // We need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        function _super() {
          return base.prototype[prop].apply(this, arguments);
        }
        function _superApply(args) {
          return base.prototype[prop].apply(this, args);
        }
        return function () {
          var __super = this._super;
          var __superApply = this._superApply;
          var returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, {
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
    }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;

        // Redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
      });

      // Remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
    return constructor;
  };
  $.widget.extend = function (target) {
    var input = widgetSlice.call(arguments, 1);
    var inputIndex = 0;
    var inputLength = input.length;
    var key;
    var value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :
            // Don't extend strings, arrays, etc. with objects
            $.widget.extend({}, value);

            // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === "string";
      var args = widgetSlice.call(arguments, 1);
      var returnValue = this;
      if (isMethodCall) {
        // If this is an empty collection, we need to have the instance method
        // return undefined instead of the jQuery instance
        if (!this.length && options === "instance") {
          returnValue = undefined;
        } else {
          this.each(function () {
            var methodValue;
            var instance = $.data(this, fullName);
            if (options === "instance") {
              returnValue = instance;
              return false;
            }
            if (!instance) {
              return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
            }
            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
              return $.error("no such method '" + options + "' for " + name + " widget instance");
            }
            methodValue = instance[options].apply(instance, args);
            if (methodValue !== instance && methodValue !== undefined) {
              returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
              return false;
            }
          });
        }
      } else {
        // Allow multiple hashes to be passed on init
        if (args.length) {
          options = $.widget.extend.apply(null, [options].concat(args));
        }
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {});
            if (instance._init) {
              instance._init();
            }
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function /* options, element */ () {};
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      classes: {},
      disabled: false,
      // Callbacks
      create: null
    },
    _createWidget: function _createWidget(options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = widgetUuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      this.classesElementLookup = {};
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function remove(event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ?
        // Element within the document
        element.ownerDocument :
        // Element is window or document
        element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this._create();
      if (this.options.disabled) {
        this._setOptionDisabled(this.options.disabled);
      }
      this._trigger("create", null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: function _getCreateOptions() {
      return {};
    },
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function destroy() {
      var that = this;
      this._destroy();
      $.each(this.classesElementLookup, function (key, value) {
        that._removeClass(value, key);
      });

      // We can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.off(this.eventNamespace).removeData(this.widgetFullName);
      this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

      // Clean up events and states
      this.bindings.off(this.eventNamespace);
    },
    _destroy: $.noop,
    widget: function widget() {
      return this.element;
    },
    option: function option(key, value) {
      var options = key;
      var parts;
      var curOption;
      var i;
      if (arguments.length === 0) {
        // Don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }
      if (typeof key === "string") {
        // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function _setOptions(options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function _setOption(key, value) {
      if (key === "classes") {
        this._setOptionClasses(value);
      }
      this.options[key] = value;
      if (key === "disabled") {
        this._setOptionDisabled(value);
      }
      return this;
    },
    _setOptionClasses: function _setOptionClasses(value) {
      var classKey, elements, currentElements;
      for (classKey in value) {
        currentElements = this.classesElementLookup[classKey];
        if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
          continue;
        }

        // We are doing this to create a new jQuery object because the _removeClass() call
        // on the next line is going to destroy the reference to the current elements being
        // tracked. We need to save a copy of this collection so that we can add the new classes
        // below.
        elements = $(currentElements.get());
        this._removeClass(currentElements, classKey);

        // We don't use _addClass() here, because that uses this.options.classes
        // for generating the string of classes. We want to use the value passed in from
        // _setOption(), this is the new value of the classes option which was passed to
        // _setOption(). We pass this value directly to _classes().
        elements.addClass(this._classes({
          element: elements,
          keys: classKey,
          classes: value,
          add: true
        }));
      }
    },
    _setOptionDisabled: function _setOptionDisabled(value) {
      this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!value);

      // If the widget is becoming disabled, then nothing is interactive
      if (value) {
        this._removeClass(this.hoverable, null, "ui-state-hover");
        this._removeClass(this.focusable, null, "ui-state-focus");
      }
    },
    enable: function enable() {
      return this._setOptions({
        disabled: false
      });
    },
    disable: function disable() {
      return this._setOptions({
        disabled: true
      });
    },
    _classes: function _classes(options) {
      var full = [];
      var that = this;
      options = $.extend({
        element: this.element,
        classes: this.options.classes || {}
      }, options);
      function processClassString(classes, checkOption) {
        var current, i;
        for (i = 0; i < classes.length; i++) {
          current = that.classesElementLookup[classes[i]] || $();
          if (options.add) {
            current = $($.unique(current.get().concat(options.element.get())));
          } else {
            current = $(current.not(options.element).get());
          }
          that.classesElementLookup[classes[i]] = current;
          full.push(classes[i]);
          if (checkOption && options.classes[classes[i]]) {
            full.push(options.classes[classes[i]]);
          }
        }
      }
      this._on(options.element, {
        "remove": "_untrackClassesElement"
      });
      if (options.keys) {
        processClassString(options.keys.match(/\S+/g) || [], true);
      }
      if (options.extra) {
        processClassString(options.extra.match(/\S+/g) || []);
      }
      return full.join(" ");
    },
    _untrackClassesElement: function _untrackClassesElement(event) {
      var that = this;
      $.each(that.classesElementLookup, function (key, value) {
        if ($.inArray(event.target, value) !== -1) {
          that.classesElementLookup[key] = $(value.not(event.target).get());
        }
      });
    },
    _removeClass: function _removeClass(element, keys, extra) {
      return this._toggleClass(element, keys, extra, false);
    },
    _addClass: function _addClass(element, keys, extra) {
      return this._toggleClass(element, keys, extra, true);
    },
    _toggleClass: function _toggleClass(element, keys, extra, add) {
      add = typeof add === "boolean" ? add : extra;
      var shift = typeof element === "string" || element === null,
        options = {
          extra: shift ? keys : extra,
          keys: shift ? element : keys,
          element: shift ? this.element : element,
          add: add
        };
      options.element.toggleClass(this._classes(options), add);
      return this;
    },
    _on: function _on(suppressDisabledCheck, element, handlers) {
      var delegateElement;
      var instance = this;

      // No suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // No element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // Allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
            return;
          }
          return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
        }

        // Copy the guid so direct unbinding works
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^([\w:-]*)\s*(.*)$/);
        var eventName = match[1] + instance.eventNamespace;
        var selector = match[2];
        if (selector) {
          delegateElement.on(eventName, selector, handlerProxy);
        } else {
          element.on(eventName, handlerProxy);
        }
      });
    },
    _off: function _off(element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
      element.off(eventName).off(eventName);

      // Clear the stack to avoid memory leaks (#10056)
      this.bindings = $(this.bindings.not(element).get());
      this.focusable = $(this.focusable.not(element).get());
      this.hoverable = $(this.hoverable.not(element).get());
    },
    _delay: function _delay(handler, delay) {
      function handlerProxy() {
        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function _hoverable(element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function mouseenter(event) {
          this._addClass($(event.currentTarget), null, "ui-state-hover");
        },
        mouseleave: function mouseleave(event) {
          this._removeClass($(event.currentTarget), null, "ui-state-hover");
        }
      });
    },
    _focusable: function _focusable(element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function focusin(event) {
          this._addClass($(event.currentTarget), null, "ui-state-focus");
        },
        focusout: function focusout(event) {
          this._removeClass($(event.currentTarget), null, "ui-state-focus");
        }
      });
    },
    _trigger: function _trigger(type, event, data) {
      var prop, orig;
      var callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();

      // The original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];

      // Copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: "fadeIn",
    hide: "fadeOut"
  }, function (method, defaultEffect) {
    $.Widget.prototype["_" + method] = function (element, options, callback) {
      if (typeof options === "string") {
        options = {
          effect: options
        };
      }
      var hasOptions;
      var effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === "number") {
        options = {
          duration: options
        };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
  return $.widget;
});

/***/ }),

/***/ "./node_modules/jquery/external/sizzle/dist/sizzle.js":
/*!************************************************************!*\
  !*** ./node_modules/jquery/external/sizzle/dist/sizzle.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function (window) {
  var i,
    support,
    Expr,
    getText,
    isXML,
    tokenize,
    compile,
    select,
    outermostContext,
    sortInput,
    hasDuplicate,
    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,
    // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }
      return 0;
    },
    // Instance methods
    hasOwn = {}.hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
        len = list.length;
      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }
      return -1;
    },
    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
    // Regular expressions

    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
    // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace +
    // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
    pseudos = ":(" + identifier + ")(?:\\((" +
    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
    // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
    // 3. anything else (capture 2)
    ".*" + ")\\)|)",
    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
    rpseudo = new RegExp(pseudos),
    ridentifier = new RegExp("^" + identifier + "$"),
    matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,
    rnative = /^[^{]+\{\s*\[native \w/,
    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    rsibling = /[+~]/,
    // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
    funescape = function funescape(_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 0x10000;
      // NaN means non-codepoint
      // Support: Firefox<24
      // Workaround erroneous numeric interpretation of +"0x"
      return high !== high || escapedWhitespace ? escaped : high < 0 ?
      // BMP codepoint
      String.fromCharCode(high + 0x10000) :
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
    // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
    fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        }

        // Control characters and (dependent upon position) numbers get escaped as code points
        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      }

      // Other potentially-special ASCII characters get backslash-escaped
      return "\\" + ch;
    },
    // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
    disabledAncestor = addCombinator(function (elem) {
      return elem.disabled === true && ("form" in elem || "label" in elem);
    }, {
      dir: "parentNode",
      next: "legend"
    });

  // Optimize for push.apply( _, NodeList )
  try {
    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
    // Support: Android<4.0
    // Detect silently failing push.apply
    arr[preferredDoc.childNodes.length].nodeType;
  } catch (e) {
    push = {
      apply: arr.length ?
      // Leverage slice if possible
      function (target, els) {
        push_native.apply(target, slice.call(els));
      } :
      // Support: IE<9
      // Otherwise append directly
      function (target, els) {
        var j = target.length,
          i = 0;
        // Can't trust NodeList.length
        while (target[j++] = els[i++]) {}
        target.length = j - 1;
      }
    };
  }
  function Sizzle(selector, context, results, seed) {
    var m,
      i,
      elem,
      nid,
      match,
      groups,
      newSelector,
      newContext = context && context.ownerDocument,
      // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
    results = results || [];

    // Return early from calls with invalid selector or context
    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
      return results;
    }

    // Try to shortcut find operations (as opposed to filters) in HTML documents
    if (!seed) {
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      if (documentIsHTML) {
        // If the selector is sufficiently simple, try using a "get*By*" DOM method
        // (excepting DocumentFragment context, where the methods don't exist)
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          // ID selector
          if (m = match[1]) {
            // Document context
            if (nodeType === 9) {
              if (elem = context.getElementById(m)) {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }

              // Element context
            } else {
              // Support: IE, Opera, Webkit
              // TODO: identify versions
              // getElementById can match elements by name instead of ID
              if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }

            // Type selector
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;

            // Class selector
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }

        // Take advantage of querySelectorAll
        if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          if (nodeType !== 1) {
            newContext = context;
            newSelector = selector;

            // qSA looks outside Element context, which is not what we want
            // Thanks to Andrew Dupont for this workaround technique
            // Support: IE <=8
            // Exclude object elements
          } else if (context.nodeName.toLowerCase() !== "object") {
            // Capture the context ID, setting it first if necessary
            if (nid = context.getAttribute("id")) {
              nid = nid.replace(rcssescape, fcssescape);
            } else {
              context.setAttribute("id", nid = expando);
            }

            // Prefix every selector in the list
            groups = tokenize(selector);
            i = groups.length;
            while (i--) {
              groups[i] = "#" + nid + " " + toSelector(groups[i]);
            }
            newSelector = groups.join(",");

            // Expand context for sibling selectors
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      }
    }

    // All others
    return select(selector.replace(rtrim, "$1"), context, results, seed);
  }

  /**
   * Create key-value caches of limited size
   * @returns {function(string, object)} Returns the Object data after storing it on itself with
   *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
   *	deleting the oldest entry
   */
  function createCache() {
    var keys = [];
    function cache(key, value) {
      // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
      if (keys.push(key + " ") > Expr.cacheLength) {
        // Only keep the most recent entries
        delete cache[keys.shift()];
      }
      return cache[key + " "] = value;
    }
    return cache;
  }

  /**
   * Mark a function for special use by Sizzle
   * @param {Function} fn The function to mark
   */
  function markFunction(fn) {
    fn[expando] = true;
    return fn;
  }

  /**
   * Support testing using an element
   * @param {Function} fn Passed the created element and returns a boolean result
   */
  function assert(fn) {
    var el = document.createElement("fieldset");
    try {
      return !!fn(el);
    } catch (e) {
      return false;
    } finally {
      // Remove from its parent by default
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      // release memory in IE
      el = null;
    }
  }

  /**
   * Adds the same handler for all of the specified attrs
   * @param {String} attrs Pipe-separated list of attributes
   * @param {Function} handler The method that will be applied
   */
  function addHandle(attrs, handler) {
    var arr = attrs.split("|"),
      i = arr.length;
    while (i--) {
      Expr.attrHandle[arr[i]] = handler;
    }
  }

  /**
   * Checks document order of two siblings
   * @param {Element} a
   * @param {Element} b
   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
   */
  function siblingCheck(a, b) {
    var cur = b && a,
      diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;

    // Use IE sourceIndex if available on both nodes
    if (diff) {
      return diff;
    }

    // Check if b follows a
    if (cur) {
      while (cur = cur.nextSibling) {
        if (cur === b) {
          return -1;
        }
      }
    }
    return a ? 1 : -1;
  }

  /**
   * Returns a function to use in pseudos for input types
   * @param {String} type
   */
  function createInputPseudo(type) {
    return function (elem) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  }

  /**
   * Returns a function to use in pseudos for buttons
   * @param {String} type
   */
  function createButtonPseudo(type) {
    return function (elem) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && elem.type === type;
    };
  }

  /**
   * Returns a function to use in pseudos for :enabled/:disabled
   * @param {Boolean} disabled true for :disabled; false for :enabled
   */
  function createDisabledPseudo(disabled) {
    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
    return function (elem) {
      // Only certain elements can match :enabled or :disabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
      // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
      if ("form" in elem) {
        // Check for inherited disabledness on relevant non-disabled elements:
        // * listed form-associated elements in a disabled fieldset
        //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
        // * option elements in a disabled optgroup
        //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
        // All such elements have a "form" property.
        if (elem.parentNode && elem.disabled === false) {
          // Option elements defer to a parent optgroup if present
          if ("label" in elem) {
            if ("label" in elem.parentNode) {
              return elem.parentNode.disabled === disabled;
            } else {
              return elem.disabled === disabled;
            }
          }

          // Support: IE 6 - 11
          // Use the isDisabled shortcut property to check for disabled fieldset ancestors
          return elem.isDisabled === disabled ||
          // Where there is no isDisabled, check manually
          /* jshint -W018 */
          elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
        }
        return elem.disabled === disabled;

        // Try to winnow out elements that can't be disabled before trusting the disabled property.
        // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
        // even exist on them, let alone have a boolean value.
      } else if ("label" in elem) {
        return elem.disabled === disabled;
      }

      // Remaining elements are neither :enabled nor :disabled
      return false;
    };
  }

  /**
   * Returns a function to use in pseudos for positionals
   * @param {Function} fn
   */
  function createPositionalPseudo(fn) {
    return markFunction(function (argument) {
      argument = +argument;
      return markFunction(function (seed, matches) {
        var j,
          matchIndexes = fn([], seed.length, argument),
          i = matchIndexes.length;

        // Match elements found at the specified indexes
        while (i--) {
          if (seed[j = matchIndexes[i]]) {
            seed[j] = !(matches[j] = seed[j]);
          }
        }
      });
    });
  }

  /**
   * Checks a node for validity as a Sizzle context
   * @param {Element|Object=} context
   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
   */
  function testContext(context) {
    return context && typeof context.getElementsByTagName !== "undefined" && context;
  }

  // Expose support vars for convenience
  support = Sizzle.support = {};

  /**
   * Detects XML nodes
   * @param {Element|Object} elem An element or a document
   * @returns {Boolean} True iff elem is a non-HTML XML node
   */
  isXML = Sizzle.isXML = function (elem) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
  };

  /**
   * Sets document-related variables once based on the current document
   * @param {Element|Object} [doc] An element or document object to use to set the document
   * @returns {Object} Returns the current document
   */
  setDocument = Sizzle.setDocument = function (node) {
    var hasCompare,
      subWindow,
      doc = node ? node.ownerDocument || node : preferredDoc;

    // Return early if doc is invalid or already selected
    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
      return document;
    }

    // Update global variables
    document = doc;
    docElem = document.documentElement;
    documentIsHTML = !isXML(document);

    // Support: IE 9-11, Edge
    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
    if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
      // Support: IE 11, Edge
      if (subWindow.addEventListener) {
        subWindow.addEventListener("unload", unloadHandler, false);

        // Support: IE 9 - 10 only
      } else if (subWindow.attachEvent) {
        subWindow.attachEvent("onunload", unloadHandler);
      }
    }

    /* Attributes
    ---------------------------------------------------------------------- */

    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties
    // (excepting IE8 booleans)
    support.attributes = assert(function (el) {
      el.className = "i";
      return !el.getAttribute("className");
    });

    /* getElement(s)By*
    ---------------------------------------------------------------------- */

    // Check if getElementsByTagName("*") returns only elements
    support.getElementsByTagName = assert(function (el) {
      el.appendChild(document.createComment(""));
      return !el.getElementsByTagName("*").length;
    });

    // Support: IE<9
    support.getElementsByClassName = rnative.test(document.getElementsByClassName);

    // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programmatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert(function (el) {
      docElem.appendChild(el).id = expando;
      return !document.getElementsByName || !document.getElementsByName(expando).length;
    });

    // ID filter and find
    if (support.getById) {
      Expr.filter["ID"] = function (id) {
        var attrId = id.replace(runescape, funescape);
        return function (elem) {
          return elem.getAttribute("id") === attrId;
        };
      };
      Expr.find["ID"] = function (id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var elem = context.getElementById(id);
          return elem ? [elem] : [];
        }
      };
    } else {
      Expr.filter["ID"] = function (id) {
        var attrId = id.replace(runescape, funescape);
        return function (elem) {
          var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
          return node && node.value === attrId;
        };
      };

      // Support: IE 6 - 7 only
      // getElementById is not reliable as a find shortcut
      Expr.find["ID"] = function (id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var node,
            i,
            elems,
            elem = context.getElementById(id);
          if (elem) {
            // Verify the id attribute
            node = elem.getAttributeNode("id");
            if (node && node.value === id) {
              return [elem];
            }

            // Fall back on getElementsByName
            elems = context.getElementsByName(id);
            i = 0;
            while (elem = elems[i++]) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
            }
          }
          return [];
        }
      };
    }

    // Tag
    Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
      if (typeof context.getElementsByTagName !== "undefined") {
        return context.getElementsByTagName(tag);

        // DocumentFragment nodes don't have gEBTN
      } else if (support.qsa) {
        return context.querySelectorAll(tag);
      }
    } : function (tag, context) {
      var elem,
        tmp = [],
        i = 0,
        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag);

      // Filter out possible comments
      if (tag === "*") {
        while (elem = results[i++]) {
          if (elem.nodeType === 1) {
            tmp.push(elem);
          }
        }
        return tmp;
      }
      return results;
    };

    // Class
    Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
      if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
        return context.getElementsByClassName(className);
      }
    };

    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */

    // QSA and matchesSelector support

    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];

    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See https://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];
    if (support.qsa = rnative.test(document.querySelectorAll)) {
      // Build QSA regex
      // Regex strategy adopted from Diego Perini
      assert(function (el) {
        // Select is set to empty string on purpose
        // This is to test IE's treatment of not explicitly
        // setting a boolean content attribute,
        // since its presence should be enough
        // https://bugs.jquery.com/ticket/12359
        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

        // Support: IE8, Opera 11-12.16
        // Nothing should be selected when empty strings follow ^= or $= or *=
        // The test attribute must be unknown in Opera but "safe" for WinRT
        // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
        if (el.querySelectorAll("[msallowcapture^='']").length) {
          rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
        }

        // Support: IE8
        // Boolean attributes and "value" are not treated correctly
        if (!el.querySelectorAll("[selected]").length) {
          rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
        }

        // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
          rbuggyQSA.push("~=");
        }

        // Webkit/Opera - :checked should return selected option elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        // IE8 throws error here and will not see later tests
        if (!el.querySelectorAll(":checked").length) {
          rbuggyQSA.push(":checked");
        }

        // Support: Safari 8+, iOS 8+
        // https://bugs.webkit.org/show_bug.cgi?id=136851
        // In-page `selector#id sibling-combinator selector` fails
        if (!el.querySelectorAll("a#" + expando + "+*").length) {
          rbuggyQSA.push(".#.+[+~]");
        }
      });
      assert(function (el) {
        el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";

        // Support: Windows 8 Native Apps
        // The type and name attributes are restricted during .innerHTML assignment
        var input = document.createElement("input");
        input.setAttribute("type", "hidden");
        el.appendChild(input).setAttribute("name", "D");

        // Support: IE8
        // Enforce case-sensitivity of name attribute
        if (el.querySelectorAll("[name=d]").length) {
          rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
        }

        // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
        // IE8 throws error here and will not see later tests
        if (el.querySelectorAll(":enabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }

        // Support: IE9-11+
        // IE's :disabled selector does not pick up the children of disabled fieldsets
        docElem.appendChild(el).disabled = true;
        if (el.querySelectorAll(":disabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }

        // Opera 10-11 does not throw on post-comma invalid pseudos
        el.querySelectorAll("*,:x");
        rbuggyQSA.push(",.*:");
      });
    }
    if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
      assert(function (el) {
        // Check to see if it's possible to do matchesSelector
        // on a disconnected node (IE 9)
        support.disconnectedMatch = matches.call(el, "*");

        // This should fail with an exception
        // Gecko does not error, returns false instead
        matches.call(el, "[s!='']:x");
        rbuggyMatches.push("!=", pseudos);
      });
    }
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

    /* Contains
    ---------------------------------------------------------------------- */
    hasCompare = rnative.test(docElem.compareDocumentPosition);

    // Element contains another
    // Purposefully self-exclusive
    // As in, an element does not contain itself
    contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
        bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function (a, b) {
      if (b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
      }
      return false;
    };

    /* Sorting
    ---------------------------------------------------------------------- */

    // Document order sorting
    sortOrder = hasCompare ? function (a, b) {
      // Flag for duplicate removal
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }

      // Sort on method existence if only one input has compareDocumentPosition
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if (compare) {
        return compare;
      }

      // Calculate position if both inputs belong to the same document
      compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :
      // Otherwise we know they are disconnected
      1;

      // Disconnected nodes
      if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
        // Choose the first element that is related to our preferred document
        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
          return -1;
        }
        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
          return 1;
        }

        // Maintain original order
        return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
      }
      return compare & 4 ? -1 : 1;
    } : function (a, b) {
      // Exit early if the nodes are identical
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var cur,
        i = 0,
        aup = a.parentNode,
        bup = b.parentNode,
        ap = [a],
        bp = [b];

      // Parentless nodes are either documents or disconnected
      if (!aup || !bup) {
        return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;

        // If the nodes are siblings, we can do a quick check
      } else if (aup === bup) {
        return siblingCheck(a, b);
      }

      // Otherwise we need full lists of their ancestors for comparison
      cur = a;
      while (cur = cur.parentNode) {
        ap.unshift(cur);
      }
      cur = b;
      while (cur = cur.parentNode) {
        bp.unshift(cur);
      }

      // Walk down the tree looking for a discrepancy
      while (ap[i] === bp[i]) {
        i++;
      }
      return i ?
      // Do a sibling check if the nodes have a common ancestor
      siblingCheck(ap[i], bp[i]) :
      // Otherwise nodes in our document sort first
      ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
    };
    return document;
  };
  Sizzle.matches = function (expr, elements) {
    return Sizzle(expr, null, null, elements);
  };
  Sizzle.matchesSelector = function (elem, expr) {
    // Set document vars if needed
    if ((elem.ownerDocument || elem) !== document) {
      setDocument(elem);
    }

    // Make sure that attribute selectors are quoted
    expr = expr.replace(rattributeQuotes, "='$1']");
    if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
      try {
        var ret = matches.call(elem, expr);

        // IE 9's matchesSelector returns false on disconnected nodes
        if (ret || support.disconnectedMatch ||
        // As well, disconnected nodes are said to be in a document
        // fragment in IE 9
        elem.document && elem.document.nodeType !== 11) {
          return ret;
        }
      } catch (e) {}
    }
    return Sizzle(expr, document, null, [elem]).length > 0;
  };
  Sizzle.contains = function (context, elem) {
    // Set document vars if needed
    if ((context.ownerDocument || context) !== document) {
      setDocument(context);
    }
    return contains(context, elem);
  };
  Sizzle.attr = function (elem, name) {
    // Set document vars if needed
    if ((elem.ownerDocument || elem) !== document) {
      setDocument(elem);
    }
    var fn = Expr.attrHandle[name.toLowerCase()],
      // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
    return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
  };
  Sizzle.escape = function (sel) {
    return (sel + "").replace(rcssescape, fcssescape);
  };
  Sizzle.error = function (msg) {
    throw new Error("Syntax error, unrecognized expression: " + msg);
  };

  /**
   * Document sorting and removing duplicates
   * @param {ArrayLike} results
   */
  Sizzle.uniqueSort = function (results) {
    var elem,
      duplicates = [],
      j = 0,
      i = 0;

    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);
    if (hasDuplicate) {
      while (elem = results[i++]) {
        if (elem === results[i]) {
          j = duplicates.push(i);
        }
      }
      while (j--) {
        results.splice(duplicates[j], 1);
      }
    }

    // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225
    sortInput = null;
    return results;
  };

  /**
   * Utility function for retrieving the text value of an array of DOM nodes
   * @param {Array|Element} elem
   */
  getText = Sizzle.getText = function (elem) {
    var node,
      ret = "",
      i = 0,
      nodeType = elem.nodeType;
    if (!nodeType) {
      // If no nodeType, this is expected to be an array
      while (node = elem[i++]) {
        // Do not traverse comment nodes
        ret += getText(node);
      }
    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
      // Use textContent for elements
      // innerText usage removed for consistency of new lines (jQuery #11153)
      if (typeof elem.textContent === "string") {
        return elem.textContent;
      } else {
        // Traverse its children
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText(elem);
        }
      }
    } else if (nodeType === 3 || nodeType === 4) {
      return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes

    return ret;
  };
  Expr = Sizzle.selectors = {
    // Can be adjusted by the user
    cacheLength: 50,
    createPseudo: markFunction,
    match: matchExpr,
    attrHandle: {},
    find: {},
    relative: {
      ">": {
        dir: "parentNode",
        first: true
      },
      " ": {
        dir: "parentNode"
      },
      "+": {
        dir: "previousSibling",
        first: true
      },
      "~": {
        dir: "previousSibling"
      }
    },
    preFilter: {
      "ATTR": function ATTR(match) {
        match[1] = match[1].replace(runescape, funescape);

        // Move the given value to match[3] whether quoted or unquoted
        match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
        if (match[2] === "~=") {
          match[3] = " " + match[3] + " ";
        }
        return match.slice(0, 4);
      },
      "CHILD": function CHILD(match) {
        /* matches from matchExpr["CHILD"]
        	1 type (only|nth|...)
        	2 what (child|of-type)
        	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        	4 xn-component of xn+y argument ([+-]?\d*n|)
        	5 sign of xn-component
        	6 x of xn-component
        	7 sign of y-component
        	8 y of y-component
        */
        match[1] = match[1].toLowerCase();
        if (match[1].slice(0, 3) === "nth") {
          // nth-* requires argument
          if (!match[3]) {
            Sizzle.error(match[0]);
          }

          // numeric x and y parameters for Expr.filter.CHILD
          // remember that false/true cast respectively to 0/1
          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +(match[7] + match[8] || match[3] === "odd");

          // other types prohibit arguments
        } else if (match[3]) {
          Sizzle.error(match[0]);
        }
        return match;
      },
      "PSEUDO": function PSEUDO(match) {
        var excess,
          unquoted = !match[6] && match[2];
        if (matchExpr["CHILD"].test(match[0])) {
          return null;
        }

        // Accept quoted arguments as-is
        if (match[3]) {
          match[2] = match[4] || match[5] || "";

          // Strip excess characters from unquoted arguments
        } else if (unquoted && rpseudo.test(unquoted) && (
        // Get excess from tokenize (recursively)
        excess = tokenize(unquoted, true)) && (
        // advance to the next closing parenthesis
        excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          // excess is a negative index
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        }

        // Return only captures needed by the pseudo filter method (type and argument)
        return match.slice(0, 3);
      }
    },
    filter: {
      "TAG": function TAG(nodeNameSelector) {
        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function () {
          return true;
        } : function (elem) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      "CLASS": function CLASS(className) {
        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
          return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
        });
      },
      "ATTR": function ATTR(name, operator, check) {
        return function (elem) {
          var result = Sizzle.attr(elem, name);
          if (result == null) {
            return operator === "!=";
          }
          if (!operator) {
            return true;
          }
          result += "";
          return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      "CHILD": function CHILD(type, what, argument, first, last) {
        var simple = type.slice(0, 3) !== "nth",
          forward = type.slice(-4) !== "last",
          ofType = what === "of-type";
        return first === 1 && last === 0 ?
        // Shortcut for :nth-*(n)
        function (elem) {
          return !!elem.parentNode;
        } : function (elem, context, xml) {
          var cache,
            uniqueCache,
            outerCache,
            node,
            nodeIndex,
            start,
            dir = simple !== forward ? "nextSibling" : "previousSibling",
            parent = elem.parentNode,
            name = ofType && elem.nodeName.toLowerCase(),
            useCache = !xml && !ofType,
            diff = false;
          if (parent) {
            // :(first|last|only)-(child|of-type)
            if (simple) {
              while (dir) {
                node = elem;
                while (node = node[dir]) {
                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                    return false;
                  }
                }
                // Reverse direction for :only-* (if we haven't yet done so)
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }
            start = [forward ? parent.firstChild : parent.lastChild];

            // non-xml :nth-child(...) stores cache data on `parent`
            if (forward && useCache) {
              // Seek `elem` from a previously-cached index

              // ...in a gzip-friendly way
              node = parent;
              outerCache = node[expando] || (node[expando] = {});

              // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)
              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
              cache = uniqueCache[type] || [];
              nodeIndex = cache[0] === dirruns && cache[1];
              diff = nodeIndex && cache[2];
              node = nodeIndex && parent.childNodes[nodeIndex];
              while (node = ++nodeIndex && node && node[dir] || (
              // Fallback to seeking `elem` from the start
              diff = nodeIndex = 0) || start.pop()) {
                // When found, cache indexes on `parent` and break
                if (node.nodeType === 1 && ++diff && node === elem) {
                  uniqueCache[type] = [dirruns, nodeIndex, diff];
                  break;
                }
              }
            } else {
              // Use previously-cached element index if available
              if (useCache) {
                // ...in a gzip-friendly way
                node = elem;
                outerCache = node[expando] || (node[expando] = {});

                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex;
              }

              // xml :nth-child(...)
              // or :nth-last-child(...) or :nth(-last)?-of-type(...)
              if (diff === false) {
                // Use the same loop as above to seek `elem` from the start
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    // Cache the index of each encountered element
                    if (useCache) {
                      outerCache = node[expando] || (node[expando] = {});

                      // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      uniqueCache[type] = [dirruns, diff];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
            }

            // Incorporate the offset, then check against cycle size
            diff -= last;
            return diff === first || diff % first === 0 && diff / first >= 0;
          }
        };
      },
      "PSEUDO": function PSEUDO(pseudo, argument) {
        // pseudo-class names are case-insensitive
        // http://www.w3.org/TR/selectors/#pseudo-classes
        // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
        // Remember that setFilters inherits from pseudos
        var args,
          fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

        // The user may use createPseudo to indicate that
        // arguments are needed to create the filter function
        // just as Sizzle does
        if (fn[expando]) {
          return fn(argument);
        }

        // But maintain support for old signatures
        if (fn.length > 1) {
          args = [pseudo, pseudo, "", argument];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
            var idx,
              matched = fn(seed, argument),
              i = matched.length;
            while (i--) {
              idx = indexOf(seed, matched[i]);
              seed[idx] = !(matches[idx] = matched[i]);
            }
          }) : function (elem) {
            return fn(elem, 0, args);
          };
        }
        return fn;
      }
    },
    pseudos: {
      // Potentially complex pseudos
      "not": markFunction(function (selector) {
        // Trim the selector passed to compile
        // to avoid treating leading and trailing
        // spaces as combinators
        var input = [],
          results = [],
          matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
          var elem,
            unmatched = matcher(seed, null, xml, []),
            i = seed.length;

          // Match elements unmatched by `matcher`
          while (i--) {
            if (elem = unmatched[i]) {
              seed[i] = !(matches[i] = elem);
            }
          }
        }) : function (elem, context, xml) {
          input[0] = elem;
          matcher(input, null, xml, results);
          // Don't keep the element (issue #299)
          input[0] = null;
          return !results.pop();
        };
      }),
      "has": markFunction(function (selector) {
        return function (elem) {
          return Sizzle(selector, elem).length > 0;
        };
      }),
      "contains": markFunction(function (text) {
        text = text.replace(runescape, funescape);
        return function (elem) {
          return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
        };
      }),
      // "Whether an element is represented by a :lang() selector
      // is based solely on the element's language value
      // being equal to the identifier C,
      // or beginning with the identifier C immediately followed by "-".
      // The matching of C against the element's language value is performed case-insensitively.
      // The identifier C does not have to be a valid language name."
      // http://www.w3.org/TR/selectors/#lang-pseudo
      "lang": markFunction(function (lang) {
        // lang value must be a valid identifier
        if (!ridentifier.test(lang || "")) {
          Sizzle.error("unsupported lang: " + lang);
        }
        lang = lang.replace(runescape, funescape).toLowerCase();
        return function (elem) {
          var elemLang;
          do {
            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            }
          } while ((elem = elem.parentNode) && elem.nodeType === 1);
          return false;
        };
      }),
      // Miscellaneous
      "target": function target(elem) {
        var hash = window.location && window.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      "root": function root(elem) {
        return elem === docElem;
      },
      "focus": function focus(elem) {
        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      // Boolean properties
      "enabled": createDisabledPseudo(false),
      "disabled": createDisabledPseudo(true),
      "checked": function checked(elem) {
        // In CSS3, :checked should return both checked and selected elements
        // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
        var nodeName = elem.nodeName.toLowerCase();
        return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
      },
      "selected": function selected(elem) {
        // Accessing this property makes selected-by-default
        // options in Safari work properly
        if (elem.parentNode) {
          elem.parentNode.selectedIndex;
        }
        return elem.selected === true;
      },
      // Contents
      "empty": function empty(elem) {
        // http://www.w3.org/TR/selectors/#empty-pseudo
        // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
        //   but not by others (comment: 8; processing instruction: 7; etc.)
        // nodeType < 6 works because attributes (2) do not appear as children
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          if (elem.nodeType < 6) {
            return false;
          }
        }
        return true;
      },
      "parent": function parent(elem) {
        return !Expr.pseudos["empty"](elem);
      },
      // Element/input types
      "header": function header(elem) {
        return rheader.test(elem.nodeName);
      },
      "input": function input(elem) {
        return rinputs.test(elem.nodeName);
      },
      "button": function button(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
      "text": function text(elem) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && (
        // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      // Position-in-collection
      "first": createPositionalPseudo(function () {
        return [0];
      }),
      "last": createPositionalPseudo(function (matchIndexes, length) {
        return [length - 1];
      }),
      "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
        return [argument < 0 ? argument + length : argument];
      }),
      "even": createPositionalPseudo(function (matchIndexes, length) {
        var i = 0;
        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      "odd": createPositionalPseudo(function (matchIndexes, length) {
        var i = 1;
        for (; i < length; i += 2) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;
        for (; --i >= 0;) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      }),
      "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
        var i = argument < 0 ? argument + length : argument;
        for (; ++i < length;) {
          matchIndexes.push(i);
        }
        return matchIndexes;
      })
    }
  };
  Expr.pseudos["nth"] = Expr.pseudos["eq"];

  // Add button/input type pseudos
  for (i in {
    radio: true,
    checkbox: true,
    file: true,
    password: true,
    image: true
  }) {
    Expr.pseudos[i] = createInputPseudo(i);
  }
  for (i in {
    submit: true,
    reset: true
  }) {
    Expr.pseudos[i] = createButtonPseudo(i);
  }

  // Easy API for creating new setFilters
  function setFilters() {}
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  tokenize = Sizzle.tokenize = function (selector, parseOnly) {
    var matched,
      match,
      tokens,
      type,
      soFar,
      groups,
      preFilters,
      cached = tokenCache[selector + " "];
    if (cached) {
      return parseOnly ? 0 : cached.slice(0);
    }
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
    while (soFar) {
      // Comma and first run
      if (!matched || (match = rcomma.exec(soFar))) {
        if (match) {
          // Don't consume trailing commas as valid
          soFar = soFar.slice(match[0].length) || soFar;
        }
        groups.push(tokens = []);
      }
      matched = false;

      // Combinators
      if (match = rcombinators.exec(soFar)) {
        matched = match.shift();
        tokens.push({
          value: matched,
          // Cast descendant combinators to space
          type: match[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      }

      // Filters
      for (type in Expr.filter) {
        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: type,
            matches: match
          });
          soFar = soFar.slice(matched.length);
        }
      }
      if (!matched) {
        break;
      }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :
    // Cache the tokens
    tokenCache(selector, groups).slice(0);
  };
  function toSelector(tokens) {
    var i = 0,
      len = tokens.length,
      selector = "";
    for (; i < len; i++) {
      selector += tokens[i].value;
    }
    return selector;
  }
  function addCombinator(matcher, combinator, base) {
    var dir = combinator.dir,
      skip = combinator.next,
      key = skip || dir,
      checkNonElements = base && key === "parentNode",
      doneName = done++;
    return combinator.first ?
    // Check against closest ancestor/preceding element
    function (elem, context, xml) {
      while (elem = elem[dir]) {
        if (elem.nodeType === 1 || checkNonElements) {
          return matcher(elem, context, xml);
        }
      }
      return false;
    } :
    // Check against all ancestor/preceding elements
    function (elem, context, xml) {
      var oldCache,
        uniqueCache,
        outerCache,
        newCache = [dirruns, doneName];

      // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
      if (xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            if (matcher(elem, context, xml)) {
              return true;
            }
          }
        }
      } else {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            outerCache = elem[expando] || (elem[expando] = {});

            // Support: IE <9 only
            // Defend against cloned attroperties (jQuery gh-1709)
            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
            if (skip && skip === elem.nodeName.toLowerCase()) {
              elem = elem[dir] || elem;
            } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
              // Assign to newCache so results back-propagate to previous elements
              return newCache[2] = oldCache[2];
            } else {
              // Reuse newcache so results back-propagate to previous elements
              uniqueCache[key] = newCache;

              // A match means we're done; a fail means we have to keep checking
              if (newCache[2] = matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
  }
  function elementMatcher(matchers) {
    return matchers.length > 1 ? function (elem, context, xml) {
      var i = matchers.length;
      while (i--) {
        if (!matchers[i](elem, context, xml)) {
          return false;
        }
      }
      return true;
    } : matchers[0];
  }
  function multipleContexts(selector, contexts, results) {
    var i = 0,
      len = contexts.length;
    for (; i < len; i++) {
      Sizzle(selector, contexts[i], results);
    }
    return results;
  }
  function condense(unmatched, map, filter, context, xml) {
    var elem,
      newUnmatched = [],
      i = 0,
      len = unmatched.length,
      mapped = map != null;
    for (; i < len; i++) {
      if (elem = unmatched[i]) {
        if (!filter || filter(elem, context, xml)) {
          newUnmatched.push(elem);
          if (mapped) {
            map.push(i);
          }
        }
      }
    }
    return newUnmatched;
  }
  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    if (postFilter && !postFilter[expando]) {
      postFilter = setMatcher(postFilter);
    }
    if (postFinder && !postFinder[expando]) {
      postFinder = setMatcher(postFinder, postSelector);
    }
    return markFunction(function (seed, results, context, xml) {
      var temp,
        i,
        elem,
        preMap = [],
        postMap = [],
        preexisting = results.length,
        // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
        // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
        matcherOut = matcher ?
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ?
        // ...intermediate processing is necessary
        [] :
        // ...otherwise use results directly
        results : matcherIn;

      // Find primary matches
      if (matcher) {
        matcher(matcherIn, matcherOut, context, xml);
      }

      // Apply postFilter
      if (postFilter) {
        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context, xml);

        // Un-match failing elements by moving them back to matcherIn
        i = temp.length;
        while (i--) {
          if (elem = temp[i]) {
            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
          }
        }
      }
      if (seed) {
        if (postFinder || preFilter) {
          if (postFinder) {
            // Get the final matcherOut by condensing this intermediate into postFinder contexts
            temp = [];
            i = matcherOut.length;
            while (i--) {
              if (elem = matcherOut[i]) {
                // Restore matcherIn since elem is not yet a final match
                temp.push(matcherIn[i] = elem);
              }
            }
            postFinder(null, matcherOut = [], temp, xml);
          }

          // Move matched elements from seed to results to keep them synchronized
          i = matcherOut.length;
          while (i--) {
            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
              seed[temp] = !(results[temp] = elem);
            }
          }
        }

        // Add elements to results, through postFinder if defined
      } else {
        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
        if (postFinder) {
          postFinder(null, results, matcherOut, xml);
        } else {
          push.apply(results, matcherOut);
        }
      }
    });
  }
  function matcherFromTokens(tokens) {
    var checkContext,
      matcher,
      j,
      len = tokens.length,
      leadingRelative = Expr.relative[tokens[0].type],
      implicitRelative = leadingRelative || Expr.relative[" "],
      i = leadingRelative ? 1 : 0,
      // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
      matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
      matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
        // Avoid hanging onto element (issue #299)
        checkContext = null;
        return ret;
      }];
    for (; i < len; i++) {
      if (matcher = Expr.relative[tokens[i].type]) {
        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {
        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

        // Return special upon seeing a positional matcher
        if (matcher[expando]) {
          // Find the next relative operator (if any) for proper handling
          j = ++i;
          for (; j < len; j++) {
            if (Expr.relative[tokens[j].type]) {
              break;
            }
          }
          return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(
          // If the preceding token was a descendant combinator, insert an implicit any-element `*`
          tokens.slice(0, i - 1).concat({
            value: tokens[i - 2].type === " " ? "*" : ""
          })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
        }
        matchers.push(matcher);
      }
    }
    return elementMatcher(matchers);
  }
  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    var bySet = setMatchers.length > 0,
      byElement = elementMatchers.length > 0,
      superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
          j,
          matcher,
          matchedCount = 0,
          i = "0",
          unmatched = seed && [],
          setMatched = [],
          contextBackup = outermostContext,
          // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
          // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
          len = elems.length;
        if (outermost) {
          outermostContext = context === document || context || outermost;
        }

        // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0;
            if (!context && elem.ownerDocument !== document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }
            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
            }
          }

          // Track unmatched elements for set filters
          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            }

            // Lengthen the array for every element, matched or not
            if (seed) {
              unmatched.push(elem);
            }
          }
        }

        // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.
        matchedCount += i;

        // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.
        if (bySet && i !== matchedCount) {
          j = 0;
          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }
          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            }

            // Discard index placeholder values to get only actual matches
            setMatched = condense(setMatched);
          }

          // Add matches to results
          push.apply(results, setMatched);

          // Seedless set matches succeeding multiple successful matchers stipulate sorting
          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        }

        // Override manipulation of globals by nested matchers
        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
        return unmatched;
      };
    return bySet ? markFunction(superMatcher) : superMatcher;
  }
  compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {
    var i,
      setMatchers = [],
      elementMatchers = [],
      cached = compilerCache[selector + " "];
    if (!cached) {
      // Generate a function of recursive functions that can be used to check each element
      if (!match) {
        match = tokenize(selector);
      }
      i = match.length;
      while (i--) {
        cached = matcherFromTokens(match[i]);
        if (cached[expando]) {
          setMatchers.push(cached);
        } else {
          elementMatchers.push(cached);
        }
      }

      // Cache the compiled function
      cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

      // Save selector and tokenization
      cached.selector = selector;
    }
    return cached;
  };

  /**
   * A low-level selection function that works with Sizzle's compiled
   *  selector functions
   * @param {String|Function} selector A selector or a pre-compiled
   *  selector function built with Sizzle.compile
   * @param {Element} context
   * @param {Array} [results]
   * @param {Array} [seed] A set of elements to match against
   */
  select = Sizzle.select = function (selector, context, results, seed) {
    var i,
      tokens,
      token,
      type,
      find,
      compiled = typeof selector === "function" && selector,
      match = !seed && tokenize(selector = compiled.selector || selector);
    results = results || [];

    // Try to minimize operations if there is only one selector in the list and no seed
    // (the latter of which guarantees us context)
    if (match.length === 1) {
      // Reduce context if the leading compound selector is an ID
      tokens = match[0] = match[0].slice(0);
      if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
        context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
        if (!context) {
          return results;

          // Precompiled matchers will still verify ancestry, so step up a level
        } else if (compiled) {
          context = context.parentNode;
        }
        selector = selector.slice(tokens.shift().value.length);
      }

      // Fetch a seed set for right-to-left matching
      i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
      while (i--) {
        token = tokens[i];

        // Abort if we hit a combinator
        if (Expr.relative[type = token.type]) {
          break;
        }
        if (find = Expr.find[type]) {
          // Search, expanding context for leading sibling combinators
          if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
            // If seed is empty or no tokens remain, we can return early
            tokens.splice(i, 1);
            selector = seed.length && toSelector(tokens);
            if (!selector) {
              push.apply(results, seed);
              return results;
            }
            break;
          }
        }
      }
    }

    // Compile and execute a filtering function if one is not provided
    // Provide `match` to avoid retokenization if we modified the selector above
    (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
    return results;
  };

  // One-time assignments

  // Sort stability
  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

  // Support: Chrome 14-35+
  // Always assume duplicates if they aren't passed to the comparison function
  support.detectDuplicates = !!hasDuplicate;

  // Initialize against the default document
  setDocument();

  // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
  // Detached nodes confoundingly follow *each other*
  support.sortDetached = assert(function (el) {
    // Should return 1, but returns 4 (following)
    return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
  });

  // Support: IE<8
  // Prevent attribute/property "interpolation"
  // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if (!assert(function (el) {
    el.innerHTML = "<a href='#'></a>";
    return el.firstChild.getAttribute("href") === "#";
  })) {
    addHandle("type|href|height|width", function (elem, name, isXML) {
      if (!isXML) {
        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
      }
    });
  }

  // Support: IE<9
  // Use defaultValue in place of getAttribute("value")
  if (!support.attributes || !assert(function (el) {
    el.innerHTML = "<input/>";
    el.firstChild.setAttribute("value", "");
    return el.firstChild.getAttribute("value") === "";
  })) {
    addHandle("value", function (elem, name, isXML) {
      if (!isXML && elem.nodeName.toLowerCase() === "input") {
        return elem.defaultValue;
      }
    });
  }

  // Support: IE<9
  // Use getAttributeNode to fetch booleans when getAttribute lies
  if (!assert(function (el) {
    return el.getAttribute("disabled") == null;
  })) {
    addHandle(booleans, function (elem, name, isXML) {
      var val;
      if (!isXML) {
        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      }
    });
  }

  // EXPOSE
  var _sizzle = window.Sizzle;
  Sizzle.noConflict = function () {
    if (window.Sizzle === Sizzle) {
      window.Sizzle = _sizzle;
    }
    return Sizzle;
  };
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return Sizzle;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    // Sizzle requires that there be a global window in Common-JS like environments
  } else {}
  // EXPOSE
})(window);

/***/ }),

/***/ "./node_modules/jquery/src/ajax.js":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/ajax.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ./ajax/var/location */ "./node_modules/jquery/src/ajax/var/location.js"), __webpack_require__(/*! ./ajax/var/nonce */ "./node_modules/jquery/src/ajax/var/nonce.js"), __webpack_require__(/*! ./ajax/var/rquery */ "./node_modules/jquery/src/ajax/var/rquery.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./ajax/parseXML */ "./node_modules/jquery/src/ajax/parseXML.js"), __webpack_require__(/*! ./event/trigger */ "./node_modules/jquery/src/event/trigger.js"), __webpack_require__(/*! ./deferred */ "./node_modules/jquery/src/deferred.js"), __webpack_require__(/*! ./serialize */ "./node_modules/jquery/src/serialize.js") // jQuery.param
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, isFunction, rnothtmlwhite, location, nonce, rquery) {
  "use strict";

  var r20 = /%20/g,
    rhash = /#.*$/,
    rantiCache = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},
    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),
    // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
  originAnchor.href = location.href;

  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
        i = 0,
        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);

            // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }

  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
      seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }

  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var key,
      deep,
      flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }

  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
      type,
      finalDataType,
      firstDataType,
      contents = s.contents,
      dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }

    // Check if we're dealing with a known content-type
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }

    // Check to see if we have a response for the expected dataType
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }

      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }

  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
      current,
      conv,
      tmp,
      prev,
      converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();

    // Convert to each sequential dataType
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }

      // Apply the dataFilter if provided
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev;

          // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current];

          // If none found, seek a pair
          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2];

                    // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }

          // Apply converter (if not an equivalence)
          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */

      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ?
      // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
      // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      }

      // Force options to be an object
      options = options || {};
      var transport,
        // URL without anti-cache param
        cacheURL,
        // Response headers
        responseHeadersString,
        responseHeaders,
        // timeout handle
        timeoutTimer,
        // Url cleanup var
        urlAnchor,
        // Request state (becomes false upon send and true upon completion)
        completed,
        // To know if global events are to be dispatched
        fireGlobals,
        // Loop variable
        i,
        // uncached part of the url
        uncached,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(),
        completeDeferred = jQuery.Callbacks("once memory"),
        // Status-dependent callbacks
        _statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {},
        requestHeadersNames = {},
        // Default abort message
        strAbort = "canceled",
        // Fake xhr
        jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function getResponseHeader(key) {
            var match;
            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          // Raw string
          getAllResponseHeaders: function getAllResponseHeaders() {
            return completed ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function setRequestHeader(name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function overrideMimeType(type) {
            if (completed == null) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function statusCode(map) {
            var code;
            if (map) {
              if (completed) {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              } else {
                // Lazy-add the new callbacks in a way that preserves old ones
                for (code in map) {
                  _statusCode[code] = [_statusCode[code], map[code]];
                }
              }
            }
            return this;
          },
          // Cancel the request
          abort: function abort(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };

      // Attach deferreds
      deferred.promise(jqXHR);

      // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");

      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;

      // Extract dataTypes list
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

      // A cross-domain request is in order when the origin doesn't match the current origin.
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");

        // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/
        try {
          urlAnchor.href = s.url;

          // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      }

      // Convert data if not already a string
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }

      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

      // If request was aborted inside a prefilter, stop there
      if (completed) {
        return jqXHR;
      }

      // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
      fireGlobals = jQuery.event && s.global;

      // Watch for a new set of requests
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }

      // Uppercase the type
      s.type = s.type.toUpperCase();

      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);

      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation
      cacheURL = s.url.replace(rhash, "");

      // More options handling for requests with no content
      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length);

        // If data is available and should be processed, append data to url
        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }

        // Add or update anti-cache param if needed
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
        }

        // Put hash and anti-cache on the URL that will be requested (gh-1732)
        s.url = cacheURL + uncached;

        // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }

      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }

      // Set the correct header, if data is being sent
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }

      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

      // Check for headers option
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }

      // Allow custom headers/mimetypes and early abort
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      }

      // Aborting is no longer a cancellation
      strAbort = "abort";

      // Install callbacks on deferreds
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);

      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

      // If no transport, we auto-abort
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;

        // Send global event
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }

        // If request was aborted inside ajaxSend, stop there
        if (completed) {
          return jqXHR;
        }

        // Timeout
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          }

          // Propagate others as results
          done(-1, e);
        }
      }

      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
          success,
          error,
          response,
          modified,
          statusText = nativeStatusText;

        // Ignore repeat invocations
        if (completed) {
          return;
        }
        completed = true;

        // Clear timeout if it exists
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }

        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;

        // Cache response headers
        responseHeadersString = headers || "";

        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;

        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;

        // Get response data
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }

        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);

        // If successful, handle type chaining
        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }

          // if no content
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";

            // if not modified
          } else if (status === 304) {
            statusText = "notmodified";

            // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }

        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";

        // Success/Error
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }

        // Status-dependent callbacks
        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }

        // Complete
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

          // Handle the global AJAX counter
          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      // The url can be an options object (which then must have .url)
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/jsonp.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/ajax/jsonp.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/nonce */ "./node_modules/jquery/src/ajax/var/nonce.js"), __webpack_require__(/*! ./var/rquery */ "./node_modules/jquery/src/ajax/var/rquery.js"), __webpack_require__(/*! ../ajax */ "./node_modules/jquery/src/ajax.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction, nonce, rquery) {
  "use strict";

  var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  });

  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
      overwritten,
      responseContainer,
      jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

      // Insert callback into url or form data
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }

      // Use data converter to retrieve json after script execution
      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };

      // Force json dataType
      s.dataTypes[0] = "json";

      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };

      // Clean-up function (fires after converters)
      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);

          // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        }

        // Save back as free
        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;

          // Save the callback name for future use
          oldCallbacks.push(callbackName);
        }

        // Call if it was a function and we have a response
        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });

      // Delegate to script
      return "script";
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/load.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/ajax/load.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/stripAndCollapse */ "./node_modules/jquery/src/core/stripAndCollapse.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ../core/parseHTML */ "./node_modules/jquery/src/core/parseHTML.js"), __webpack_require__(/*! ../ajax */ "./node_modules/jquery/src/ajax.js"), __webpack_require__(/*! ../traversing */ "./node_modules/jquery/src/traversing.js"), __webpack_require__(/*! ../manipulation */ "./node_modules/jquery/src/manipulation.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, isFunction) {
  "use strict";

  /**
   * Load a url into a page
   */
  jQuery.fn.load = function (url, params, callback) {
    var selector,
      type,
      response,
      self = this,
      off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }

    // If it's a function
    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined;

      // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    }

    // If we have elements to modify, make the request
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ?
        // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
        // Otherwise use the full result
        responseText);

        // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/parseXML.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/ajax/parseXML.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // Cross-browser xml parsing
  jQuery.parseXML = function (data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }

    // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.
    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  return jQuery.parseXML;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/script.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/ajax/script.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../ajax */ "./node_modules/jquery/src/ajax.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document) {
  "use strict";

  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });

  // Install script dataType
  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });

  // Handle cache's special case and crossDomain
  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });

  // Bind script tag hack transport
  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, _callback;
      return {
        send: function send(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback = function callback(evt) {
            script.remove();
            _callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });

          // Use native DOM manipulation to avoid our domManip AJAX trickery
          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/var/location.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/location.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return window.location;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/var/nonce.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/nonce.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return Date.now();
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/var/rquery.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/ajax/var/rquery.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /\?/;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/ajax/xhr.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/ajax/xhr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js"), __webpack_require__(/*! ../ajax */ "./node_modules/jquery/src/ajax.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, support) {
  "use strict";

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // #1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
    xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback;

    // Cross domain only allowed if supported through XMLHttpRequest
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
            xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);

          // Apply custom fields if provided
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }

          // Override mime type if needed
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }

          // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }

          // Set headers
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }

          // Callback
          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(
                    // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
                  // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          };

          // Listen to events
          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error");

          // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          }

          // Create the abort callback
          _callback = _callback("abort");
          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/attributes.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./attributes/attr */ "./node_modules/jquery/src/attributes/attr.js"), __webpack_require__(/*! ./attributes/prop */ "./node_modules/jquery/src/attributes/prop.js"), __webpack_require__(/*! ./attributes/classes */ "./node_modules/jquery/src/attributes/classes.js"), __webpack_require__(/*! ./attributes/val */ "./node_modules/jquery/src/attributes/val.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // Return jQuery for attributes-only inclusion
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes/attr.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/attributes/attr.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ../core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ./support */ "./node_modules/jquery/src/attributes/support.js"), __webpack_require__(/*! ../var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, nodeName, support, rnothtmlwhite) {
  "use strict";

  var boolHook,
    attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set attributes on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      // Fallback to prop when attributes are not supported
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }

      // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);

      // Non-existent attributes return null, we normalize to undefined
      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
        i = 0,
        // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  });

  // Hooks for boolean attributes
  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function (elem, name, isXML) {
      var ret,
        handle,
        lowercaseName = name.toLowerCase();
      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes/classes.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/attributes/classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/stripAndCollapse */ "./node_modules/jquery/src/core/stripAndCollapse.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ../var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ../data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ../core/init */ "./node_modules/jquery/src/core/init.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, isFunction, rnothtmlwhite, dataPriv) {
  "use strict";

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }
    return [];
  }
  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;
      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      classes = classesToArray(value);
      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
        elem,
        cur,
        curValue,
        clazz,
        j,
        finalValue,
        i = 0;
      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      classes = classesToArray(value);
      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);

          // This expression is here for better compressibility (see addClass)
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }

            // Only assign if different to avoid unneeded rendering.
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
        isValidValue = type === "string" || Array.isArray(value);
      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function () {
        var className, i, self, classNames;
        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);
          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }

          // Toggle whole class name
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          }

          // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
        elem,
        i = 0;
      className = " " + selector + " ";
      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes/prop.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/attributes/prop.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./support */ "./node_modules/jquery/src/attributes/support.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, support) {
  "use strict";

  var rfocusable = /^(?:input|select|textarea|button)$/i,
    rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
        hooks,
        nType = elem.nodeType;

      // Don't get/set properties on text, comment and attribute nodes
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return elem[name] = value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });

  // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */

        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes/support.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/attributes/support.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict";

  (function () {
    var input = document.createElement("input"),
      select = document.createElement("select"),
      opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";

    // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"
    support.checkOn = input.value !== "";

    // Support: IE <=11 only
    // Must access selectedIndex to make default options select
    support.optSelected = opt.selected;

    // Support: IE <=11 only
    // An input loses its value after becoming a radio
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/attributes/val.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/attributes/val.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/stripAndCollapse */ "./node_modules/jquery/src/core/stripAndCollapse.js"), __webpack_require__(/*! ./support */ "./node_modules/jquery/src/attributes/support.js"), __webpack_require__(/*! ../core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ../core/init */ "./node_modules/jquery/src/core/init.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, stripAndCollapse, support, nodeName, isFunction) {
  "use strict";

  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
        ret,
        valueIsFunction,
        elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;

          // Handle most common string cases
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }

          // Handle cases where value is null/undef or number
          return ret == null ? "" : ret;
        }
        return;
      }
      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }

        // Treat null/undefined as ""; convert numbers to string
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

        // If set returns undefined, fall back to normal setting
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val :
          // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
            option,
            i,
            options = elem.options,
            index = elem.selectedIndex,
            one = elem.type === "select-one",
            values = one ? null : [],
            max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }

          // Loop through all the selected options
          for (; i < max; i++) {
            option = options[i];

            // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)
            if ((option.selected || i === index) &&
            // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val();

              // We don't need an array for one selects
              if (one) {
                return value;
              }

              // Multi-Selects return an array
              values.push(value);
            }
          }
          return values;
        },
        set: function set(elem, value) {
          var optionSet,
            option,
            options = elem.options,
            values = jQuery.makeArray(value),
            i = options.length;
          while (i--) {
            option = options[i];

            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }

            /* eslint-enable no-cond-assign */
          }

          // Force browsers to behave consistently when non-matching value is set
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }
  });

  // Radios and checkboxes getter/setter
  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/callbacks.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/callbacks.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/toType */ "./node_modules/jquery/src/core/toType.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, isFunction, rnothtmlwhite) {
  "use strict";

  // Convert String-formatted options into Object-formatted ones
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }

  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */
  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var
      // Flag to know if list is currently firing
      firing,
      // Last fire value for non-forgettable lists
      memory,
      // Flag to know if list was already fired
      _fired,
      // Flag to prevent firing
      _locked,
      // Actual callback list
      list = [],
      // Queue of execution data for repeatable lists
      queue = [],
      // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
      // Fire callbacks
      fire = function fire() {
        // Enforce single-firing
        _locked = _locked || options.once;

        // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes
        _fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        }

        // Forget the data if we're done with it
        if (!options.memory) {
          memory = false;
        }
        firing = false;

        // Clean up if we're done firing for good
        if (_locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = [];

            // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
      // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function add() {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                if (isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function remove() {
          jQuery.each(arguments, function (_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);

              // Handle firing indexes
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function has(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function empty() {
          if (list) {
            list = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function disable() {
          _locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function disabled() {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function lock() {
          _locked = queue = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function locked() {
          return !!_locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function fireWith(context, args) {
          if (!_locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function fire() {
          self.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function fired() {
          return !!_fired;
        }
      };
    return self;
  };
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core.js":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/core.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./var/arr */ "./node_modules/jquery/src/var/arr.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/getProto */ "./node_modules/jquery/src/var/getProto.js"), __webpack_require__(/*! ./var/slice */ "./node_modules/jquery/src/var/slice.js"), __webpack_require__(/*! ./var/concat */ "./node_modules/jquery/src/var/concat.js"), __webpack_require__(/*! ./var/push */ "./node_modules/jquery/src/var/push.js"), __webpack_require__(/*! ./var/indexOf */ "./node_modules/jquery/src/var/indexOf.js"), __webpack_require__(/*! ./var/class2type */ "./node_modules/jquery/src/var/class2type.js"), __webpack_require__(/*! ./var/toString */ "./node_modules/jquery/src/var/toString.js"), __webpack_require__(/*! ./var/hasOwn */ "./node_modules/jquery/src/var/hasOwn.js"), __webpack_require__(/*! ./var/fnToString */ "./node_modules/jquery/src/var/fnToString.js"), __webpack_require__(/*! ./var/ObjectFunctionString */ "./node_modules/jquery/src/var/ObjectFunctionString.js"), __webpack_require__(/*! ./var/support */ "./node_modules/jquery/src/var/support.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/isWindow */ "./node_modules/jquery/src/var/isWindow.js"), __webpack_require__(/*! ./core/DOMEval */ "./node_modules/jquery/src/core/DOMEval.js"), __webpack_require__(/*! ./core/toType */ "./node_modules/jquery/src/core/toType.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr, document, getProto, _slice, concat, push, indexOf, class2type, toString, hasOwn, fnToString, ObjectFunctionString, support, isFunction, isWindow, DOMEval, toType) {
  "use strict";

  var version = "3.3.1",
    // Define a local copy of jQuery
    jQuery = function jQuery(selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    },
    // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      }

      // Return just the one element from the set
      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);

      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;

      // Return the newly-formed element set
      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    eq: function eq(i) {
      var len = this.length,
        j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function () {
    var options,
      name,
      src,
      copy,
      copyIsArray,
      clone,
      target = arguments[0] || {},
      i = 1,
      length = arguments.length,
      deep = false;

    // Handle a deep copy situation
    if (typeof target === "boolean") {
      deep = target;

      // Skip the boolean and the target
      target = arguments[i] || {};
      i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    }

    // Extend jQuery itself if only one argument is passed
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];

          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }

          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);

            // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }

    // Return the modified object
    return target;
  };
  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor;

      // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);

      // Objects with no prototype (e.g., `Object.create( null )`) are plain
      if (!proto) {
        return true;
      }

      // Objects with prototype are plain iff they were constructed by a global Object function
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      /* eslint-disable no-unused-vars */
      // See https://github.com/eslint/eslint/issues/6125
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    // Evaluates a script in a global context
    globalEval: function globalEval(code) {
      DOMEval(code);
    },
    each: function each(obj, callback) {
      var length,
        i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    // Support: Android <=4.0 only
    trim: function trim(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
        j = 0,
        i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;

      // Go through the array, only saving the items
      // that pass the validator function
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
        value,
        i = 0,
        ret = [];

      // Go through the array, translating each of the items to their new values
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }

        // Go through every key on the object,
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }

      // Flatten any nested arrays
      return concat.apply([], ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }

  // Populate the class2type map
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
      type = toType(obj);
    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js")))

/***/ }),

/***/ "./node_modules/jquery/src/core/DOMEval.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/core/DOMEval.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document) {
  "use strict";

  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };
  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
      script = doc.createElement("script");
    script.text = code;
    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  return DOMEval;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/access.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/core/access.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/toType */ "./node_modules/jquery/src/core/toType.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, isFunction) {
  "use strict";

  // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function
  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
      len = elems.length,
      bulk = key == null;

    // Sets many values
    if (toType(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }

      // Sets one value
    } else if (value !== undefined) {
      chainable = true;
      if (!isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null;

          // ...except when executing function values
        } else {
          bulk = fn;
          fn = function fn(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }

    // Gets
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  return access;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/camelCase.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/core/camelCase.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // Matches dashed string for camelizing
  var rmsPrefix = /^-ms-/,
    rdashAlpha = /-([a-z])/g;

  // Used by camelCase as callback to replace()
  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  }

  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)
  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }
  return camelCase;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/init.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/core/init.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Initialize a jQuery object
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rsingleTag */ "./node_modules/jquery/src/core/var/rsingleTag.js"), __webpack_require__(/*! ../traversing/findFilter */ "./node_modules/jquery/src/traversing/findFilter.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, isFunction, rsingleTag) {
  "use strict";

  // A central reference to the root jQuery(document)
  var rootjQuery,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
    init = jQuery.fn.init = function (selector, context, root) {
      var match, elem;

      // HANDLE: $(""), $(null), $(undefined), $(false)
      if (!selector) {
        return this;
      }

      // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)
      root = root || rootjQuery;

      // Handle HTML strings
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }

        // Match html or make sure no context is specified for #id
        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;

            // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

            // HANDLE: $(html, props)
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (isFunction(this[match])) {
                  this[match](context[match]);

                  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;

            // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);
            if (elem) {
              // Inject the element directly into the jQuery object
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }

          // HANDLE: $(expr, $(...))
        } else if (!context || context.jquery) {
          return (context || root).find(selector);

          // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }

        // HANDLE: $(DOMElement)
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;

        // HANDLE: $(function)
        // Shortcut for document ready
      } else if (isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) :
        // Execute immediately if ready is not present
        selector(jQuery);
      }
      return jQuery.makeArray(selector, this);
    };

  // Give the init function the jQuery prototype for later instantiation
  init.prototype = jQuery.fn;

  // Initialize central reference
  rootjQuery = jQuery(document);
  return init;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/nodeName.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/core/nodeName.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }
  ;
  return nodeName;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/parseHTML.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/core/parseHTML.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/rsingleTag */ "./node_modules/jquery/src/core/var/rsingleTag.js"), __webpack_require__(/*! ../manipulation/buildFragment */ "./node_modules/jquery/src/manipulation/buildFragment.js"),
// This is the only module that needs core/support
__webpack_require__(/*! ./support */ "./node_modules/jquery/src/core/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, rsingleTag, buildFragment, support) {
  "use strict";

  // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string
  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base, parsed, scripts;
    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");

        // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];

    // Single tag
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  return jQuery.parseHTML;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/ready.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/core/ready.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../core/readyException */ "./node_modules/jquery/src/core/readyException.js"), __webpack_require__(/*! ../deferred */ "./node_modules/jquery/src/deferred.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document) {
  "use strict";

  // The deferred used on DOM ready
  var readyList = jQuery.Deferred();
  jQuery.fn.ready = function (fn) {
    readyList.then(fn)

    // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    ["catch"](function (error) {
      jQuery.readyException(error);
    });
    return this;
  };
  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }

      // Remember that the DOM is ready
      jQuery.isReady = true;

      // If a normal DOM Ready event fired, decrement, and wait if need be
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }

      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then;

  // The ready event handler and self cleanup method
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }

  // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon
  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed);

    // A fallback to window.onload, that will always work
    window.addEventListener("load", completed);
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/readyException.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/core/readyException.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/stripAndCollapse.js":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/core/stripAndCollapse.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (rnothtmlwhite) {
  "use strict";

  // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  return stripAndCollapse;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/support.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/core/support.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict";

  // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337
  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }();
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/toType.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/core/toType.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/class2type */ "./node_modules/jquery/src/var/class2type.js"), __webpack_require__(/*! ../var/toString */ "./node_modules/jquery/src/var/toString.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type, toString) {
  "use strict";

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    }

    // Support: Android <=2.3 only (functionish RegExp)
    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  return toType;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/core/var/rsingleTag.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/core/var/rsingleTag.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // Match a standalone tag
  return /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css.js":
/*!****************************************!*\
  !*** ./node_modules/jquery/src/css.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/pnum */ "./node_modules/jquery/src/var/pnum.js"), __webpack_require__(/*! ./core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./core/camelCase */ "./node_modules/jquery/src/core/camelCase.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/rcssNum */ "./node_modules/jquery/src/var/rcssNum.js"), __webpack_require__(/*! ./css/var/rnumnonpx */ "./node_modules/jquery/src/css/var/rnumnonpx.js"), __webpack_require__(/*! ./css/var/cssExpand */ "./node_modules/jquery/src/css/var/cssExpand.js"), __webpack_require__(/*! ./css/var/getStyles */ "./node_modules/jquery/src/css/var/getStyles.js"), __webpack_require__(/*! ./css/var/swap */ "./node_modules/jquery/src/css/var/swap.js"), __webpack_require__(/*! ./css/curCSS */ "./node_modules/jquery/src/css/curCSS.js"), __webpack_require__(/*! ./css/adjustCSS */ "./node_modules/jquery/src/css/adjustCSS.js"), __webpack_require__(/*! ./css/addGetHookIf */ "./node_modules/jquery/src/css/addGetHookIf.js"), __webpack_require__(/*! ./css/support */ "./node_modules/jquery/src/css/support.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./core/ready */ "./node_modules/jquery/src/core/ready.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js") // contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, pnum, access, camelCase, document, rcssNum, rnumnonpx, cssExpand, getStyles, swap, curCSS, adjustCSS, addGetHookIf, support) {
  "use strict";

  var
    // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rcustomProp = /^--/,
    cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    cssPrefixes = ["Webkit", "Moz", "ms"],
    emptyStyle = document.createElement("div").style;

  // Return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(name) {
    // Shortcut for names that are not vendor prefixed
    if (name in emptyStyle) {
      return name;
    }

    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
      i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }

  // Return a property mapped along what jQuery.cssProps suggests or to
  // a vendor prefixed property.
  function finalPropName(name) {
    var ret = jQuery.cssProps[name];
    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }
    return ret;
  }
  function setPositiveNumber(elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ?
    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
      extra = 0,
      delta = 0;

    // Adjustment may not be necessary
    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }
    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      }

      // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

        // For "border" or "margin", add border
        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);

          // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }

        // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"
      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }

        // For "content" or "padding", subtract border
        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }

    // Account for positive content-box scroll gutter when requested by providing computedVal
    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }
    return delta;
  }
  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
      val = curCSS(elem, dimension, styles),
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
      valueIsBorderBox = isBorderBox;

    // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.
    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }
      val = "auto";
    }

    // Check for style in case a browser which returns unreliable values
    // for getComputedStyle silently falls back to the reliable elem.style
    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);

    // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];

      // offsetWidth/offsetHeight provide border-box values
      valueIsBorderBox = true;
    }

    // Normalize "" and auto
    val = parseFloat(val) || 0;

    // Adjust for the element's box model
    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles,
    // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }
  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }

      // Make sure that we're working with the right name
      var ret,
        type,
        hooks,
        origName = camelCase(name),
        isCustomProp = rcustomProp.test(name),
        style = elem.style;

      // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.
      if (!isCustomProp) {
        name = finalPropName(origName);
      }

      // Gets hook for the prefixed version, then unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // Check if we're setting a value
      if (value !== undefined) {
        type = _typeof(value);

        // Convert "+=" or "-=" to relative numbers (#7345)
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);

          // Fixes bug #9237
          type = "number";
        }

        // Make sure that null and NaN values aren't set (#7116)
        if (value == null || value !== value) {
          return;
        }

        // If a number was passed in, add the unit (except for certain CSS properties)
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }

        // background-* props affect original clone's values
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }

        // If a hook was provided, use that value, otherwise just set the specified value
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }

        // Otherwise just get the value from the style object
        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
        num,
        hooks,
        origName = camelCase(name),
        isCustomProp = rcustomProp.test(name);

      // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.
      if (!isCustomProp) {
        name = finalPropName(origName);
      }

      // Try prefixed name followed by the unprefixed name
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

      // If a hook was provided get the computed value from there
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }

      // Otherwise, if a way to get the computed value exists, use that
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }

      // Convert "normal" to computed value
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }

      // Make numeric if forced or a qualifier was provided and val looks numeric
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function (i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && (
          // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
          styles = getStyles(elem),
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
          subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);

        // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)
        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        }

        // Convert to pixels if value adjustment is needed
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });

  // These hooks are used by animate to expand properties
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
          expanded = {},
          // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
          len,
          map = {},
          i = 0;
        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/addGetHookIf.js":
/*!*****************************************************!*\
  !*** ./node_modules/jquery/src/css/addGetHookIf.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        }

        // Hook needed; redefine it so that the support test is not executed again.
        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }
  return addGetHookIf;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/adjustCSS.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/css/adjustCSS.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/rcssNum */ "./node_modules/jquery/src/var/rcssNum.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, rcssNum) {
  "use strict";

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
      scale,
      maxIterations = 20,
      currentValue = tween ? function () {
        return tween.cur();
      } : function () {
        return jQuery.css(elem, prop, "");
      },
      initial = currentValue(),
      unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
      // Starting value computation is required for potential unit mismatches
      initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2;

      // Trust units reported by jQuery.css
      unit = unit || initialInUnit[3];

      // Iteratively approximate from a nonzero starting point
      initialInUnit = +initial || 1;
      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);
        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;
      }
      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit);

      // Make sure we update the tween properties later on
      valueParts = valueParts || [];
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;

      // Apply relative offset (+=/-=) if specified
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  return adjustCSS;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/curCSS.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/css/curCSS.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/rboxStyle */ "./node_modules/jquery/src/css/var/rboxStyle.js"), __webpack_require__(/*! ./var/rnumnonpx */ "./node_modules/jquery/src/css/var/rnumnonpx.js"), __webpack_require__(/*! ./var/getStyles */ "./node_modules/jquery/src/css/var/getStyles.js"), __webpack_require__(/*! ./support */ "./node_modules/jquery/src/css/support.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js") // Get jQuery.contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, rboxStyle, rnumnonpx, getStyles, support) {
  "use strict";

  function curCSS(elem, name, computed) {
    var width,
      minWidth,
      maxWidth,
      ret,
      // Support: Firefox 51+
      // Retrieving style before computed somehow
      // fixes an issue with getting wrong values
      // on detached elements
      style = elem.style;
    computed = computed || getStyles(elem);

    // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }

      // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values
      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;

        // Put in the new values to get a computed value out
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;

        // Revert the changed values
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ?
    // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }
  return curCSS;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/hiddenVisibleSelectors.js":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/css/hiddenVisibleSelectors.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/showHide.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/css/showHide.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ../css/var/isHiddenWithinTree */ "./node_modules/jquery/src/css/var/isHiddenWithinTree.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv, isHiddenWithinTree) {
  "use strict";

  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
      doc = elem.ownerDocument,
      nodeName = elem.nodeName,
      display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
      elem,
      values = [],
      index = 0,
      length = elements.length;

    // Determine new display value for elements that need to change
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";

          // Remember what we're overwriting
          dataPriv.set(elem, "display", display);
        }
      }
    }

    // Set the display of the elements in a second loop to avoid constant reflow
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  return showHide;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/support.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/css/support.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../var/documentElement */ "./node_modules/jquery/src/var/documentElement.js"), __webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, documentElement, support) {
  "use strict";

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }
      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";

      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;

      // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't
      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;

      // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements
      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;

      // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container);

      // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed
      div = null;
    }
    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }
    var pixelPositionVal,
      boxSizingReliableVal,
      scrollboxSizeVal,
      pixelBoxStylesVal,
      reliableMarginLeftVal,
      container = document.createElement("div"),
      div = document.createElement("div");

    // Finish early in limited (non-browser) environments
    if (!div.style) {
      return;
    }

    // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/cssExpand.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/cssExpand.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return ["Top", "Right", "Bottom", "Left"];
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/getStyles.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/getStyles.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function (elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/isHiddenWithinTree.js":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/css/var/isHiddenWithinTree.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../../selector */ "./node_modules/jquery/src/selector.js")

// css is assumed
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // isHiddenWithinTree reports if an element has a non-"none" display style (inline and/or
  // through the CSS cascade), which is useful in deciding whether or not to make it visible.
  // It differs from the :hidden selector (jQuery.expr.pseudos.hidden) in two important ways:
  // * A hidden ancestor does not force an element to be classified as hidden.
  // * Being disconnected from the document does not force an element to be classified as hidden.
  // These differences improve the behavior of .toggle() et al. when applied to elements that are
  // detached or contained within hidden ancestors (gh-2404, gh-2863).
  return function (elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;

    // Inline style trumps all
    return elem.style.display === "none" || elem.style.display === "" &&
    // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/rboxStyle.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/rboxStyle.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./cssExpand */ "./node_modules/jquery/src/css/var/cssExpand.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (cssExpand) {
  "use strict";

  return new RegExp(cssExpand.join("|"), "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/rnumnonpx.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/css/var/rnumnonpx.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../var/pnum */ "./node_modules/jquery/src/var/pnum.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (pnum) {
  "use strict";

  return new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/css/var/swap.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/css/var/swap.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // A method for quickly swapping in/out CSS properties to get correct calculations.
  return function (elem, options, callback, args) {
    var ret,
      name,
      old = {};

    // Remember the old values, and insert the new ones
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);

    // Revert the old values
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/data.js":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/data.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./core/camelCase */ "./node_modules/jquery/src/core/camelCase.js"), __webpack_require__(/*! ./data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./data/var/dataUser */ "./node_modules/jquery/src/data/var/dataUser.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, camelCase, dataPriv, dataUser) {
  "use strict";

  //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }

    // Only convert to a number if it doesn't change the string
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;

    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}

        // Make sure we set the data so it isn't changed later
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
        name,
        data,
        elem = this[0],
        attrs = elem && elem.attributes;

      // Gets all values
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }

      // Sets multiple values
      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }
      return access(this, function (value) {
        var data;

        // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.
        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }

          // Attempt to "discover" the data in
          // HTML5 custom data-* attrs
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }

          // We tried really hard, but the data doesn't exist.
          return;
        }

        // Set the data...
        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/data/Data.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/data/Data.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/camelCase */ "./node_modules/jquery/src/core/camelCase.js"), __webpack_require__(/*! ../var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ./var/acceptData */ "./node_modules/jquery/src/data/var/acceptData.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, camelCase, rnothtmlwhite, acceptData) {
  "use strict";

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando];

      // If not, create one
      if (!value) {
        value = {};

        // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.
        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value;

            // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function set(owner, data, value) {
      var prop,
        cache = this.cache(owner);

      // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)
      if (typeof data === "string") {
        cache[camelCase(data)] = value;

        // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) :
      // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      }

      // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //
      this.set(owner, key, value);

      // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]
      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
        cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key);

          // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace
          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }

      // Remove the expando if there's no more data
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  return Data;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/data/var/acceptData.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/data/var/acceptData.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  /**
   * Determines whether an object can have data
   */
  return function (owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/data/var/dataPriv.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/data/var/dataPriv.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../Data */ "./node_modules/jquery/src/data/Data.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Data) {
  "use strict";

  return new Data();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/data/var/dataUser.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/data/var/dataUser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../Data */ "./node_modules/jquery/src/data/Data.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Data) {
  "use strict";

  return new Data();
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/deferred.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/deferred.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/slice */ "./node_modules/jquery/src/var/slice.js"), __webpack_require__(/*! ./callbacks */ "./node_modules/jquery/src/callbacks.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction, slice) {
  "use strict";

  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject, noValue) {
    var method;
    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject);

        // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject);

        // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      }

      // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.
    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }
  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [
        // action, add listener, callbacks,
        // ... .then handlers, argument index, [final state]
        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
        _state = "pending",
        _promise = {
          state: function state() {
            return _state;
          },
          always: function always() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function _catch(fn) {
            return _promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function pipe( /* fnDone, fnFail, fnProgress */
          ) {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];

                // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function then(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred, handler, special) {
              return function () {
                var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                    var returned, then;

                    // Support: Promises/A+ section 2.3.3.3.3
                    // https://promisesaplus.com/#point-59
                    // Ignore double-resolution attempts
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);

                    // Support: Promises/A+ section 2.3.1
                    // https://promisesaplus.com/#point-48
                    if (returned === deferred.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }

                    // Support: Promises/A+ sections 2.3.3.1, 3.5
                    // https://promisesaplus.com/#point-54
                    // https://promisesaplus.com/#point-75
                    // Retrieve `then` only once
                    then = returned && (
                    // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    _typeof(returned) === "object" || typeof returned === "function") && returned.then;

                    // Handle a returned thenable
                    if (isFunction(then)) {
                      // Special processors (notify) just wait for resolution
                      if (special) {
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));

                        // Normal processors (resolve) also hook into progress
                      } else {
                        // ...and disregard older resolution values
                        maxDepth++;
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                      }

                      // Handle all other returned values
                    } else {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Identity) {
                        that = undefined;
                        args = [returned];
                      }

                      // Process the value(s)
                      // Default process is resolve
                      (special || deferred.resolveWith)(that, args);
                    }
                  },
                  // Only normal processors (resolve) catch and reject exceptions
                  process = special ? mightThrow : function () {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(e, process.stackTrace);
                      }

                      // Support: Promises/A+ section 2.3.3.3.4.1
                      // https://promisesaplus.com/#point-61
                      // Ignore post-resolution exceptions
                      if (depth + 1 >= maxDepth) {
                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if (handler !== Thrower) {
                          that = undefined;
                          args = [e];
                        }
                        deferred.rejectWith(that, args);
                      }
                    }
                  };

                // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors
                if (depth) {
                  process();
                } else {
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window.setTimeout(process);
                }
              };
            }
            return jQuery.Deferred(function (newDefer) {
              // progress_handlers.add( ... )
              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));

              // fulfilled_handlers.add( ... )
              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));

              // rejected_handlers.add( ... )
              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function promise(obj) {
            return obj != null ? jQuery.extend(obj, _promise) : _promise;
          }
        },
        deferred = {};

      // Add list-specific methods
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
          stateString = tuple[5];

        // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add
        _promise[tuple[1]] = list.add;

        // Handle state
        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          },
          // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable,
          // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable,
          // progress_callbacks.lock
          tuples[0][2].lock,
          // progress_handlers.lock
          tuples[0][3].lock);
        }

        // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire
        list.add(tuple[3].fire);

        // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };

        // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith
        deferred[tuple[0] + "With"] = list.fireWith;
      });

      // Make the deferred a promise
      _promise.promise(deferred);

      // Call given func if any
      if (func) {
        func.call(deferred, deferred);
      }

      // All done!
      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var
        // count of uncompleted subordinates
        remaining = arguments.length,
        // count of unprocessed arguments
        i = remaining,
        // subordinate fulfillment data
        resolveContexts = Array(i),
        resolveValues = slice.call(arguments),
        // the master Deferred
        master = jQuery.Deferred(),
        // subordinate callback factory
        updateFunc = function updateFunc(i) {
          return function (value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
            if (! --remaining) {
              master.resolveWith(resolveContexts, resolveValues);
            }
          };
        };

      // Single- and empty arguments are adopted like Promise.resolve
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);

        // Use .then() to unwrap secondary thenables (cf. gh-3000)
        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }

      // Multiple arguments are aggregated like Promise.all array elements
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/deferred/exceptionHook.js":
/*!***********************************************************!*\
  !*** ./node_modules/jquery/src/deferred/exceptionHook.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../deferred */ "./node_modules/jquery/src/deferred.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/deprecated.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/deprecated.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ./core/camelCase */ "./node_modules/jquery/src/core/camelCase.js"), __webpack_require__(/*! ./core/toType */ "./node_modules/jquery/src/core/toType.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/isWindow */ "./node_modules/jquery/src/var/isWindow.js"), __webpack_require__(/*! ./var/slice */ "./node_modules/jquery/src/var/slice.js"), __webpack_require__(/*! ./event/alias */ "./node_modules/jquery/src/event/alias.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, nodeName, camelCase, toType, isFunction, isWindow, slice) {
  "use strict";

  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });

  // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon
  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;
    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }

    // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.
    if (!isFunction(fn)) {
      return undefined;
    }

    // Simulated bind
    args = slice.call(arguments, 2);
    proxy = function proxy() {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    };

    // Set the guid of unique handler to the same of original handler, so it can be removed
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };
  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;
  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") &&
    // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/dimensions.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/dimensions.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./var/isWindow */ "./node_modules/jquery/src/var/isWindow.js"), __webpack_require__(/*! ./css */ "./node_modules/jquery/src/css.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, isWindow) {
  "use strict";

  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
          extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;
          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }

          // Get document width or height
          if (elem.nodeType === 9) {
            doc = elem.documentElement;

            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ?
          // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) :
          // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/effects.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/src/effects.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/camelCase */ "./node_modules/jquery/src/core/camelCase.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rcssNum */ "./node_modules/jquery/src/var/rcssNum.js"), __webpack_require__(/*! ./var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ./css/var/cssExpand */ "./node_modules/jquery/src/css/var/cssExpand.js"), __webpack_require__(/*! ./css/var/isHiddenWithinTree */ "./node_modules/jquery/src/css/var/isHiddenWithinTree.js"), __webpack_require__(/*! ./css/var/swap */ "./node_modules/jquery/src/css/var/swap.js"), __webpack_require__(/*! ./css/adjustCSS */ "./node_modules/jquery/src/css/adjustCSS.js"), __webpack_require__(/*! ./data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./css/showHide */ "./node_modules/jquery/src/css/showHide.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./queue */ "./node_modules/jquery/src/queue.js"), __webpack_require__(/*! ./deferred */ "./node_modules/jquery/src/deferred.js"), __webpack_require__(/*! ./traversing */ "./node_modules/jquery/src/traversing.js"), __webpack_require__(/*! ./manipulation */ "./node_modules/jquery/src/manipulation.js"), __webpack_require__(/*! ./css */ "./node_modules/jquery/src/css.js"), __webpack_require__(/*! ./effects/Tween */ "./node_modules/jquery/src/effects/Tween.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, camelCase, document, isFunction, rcssNum, rnothtmlwhite, cssExpand, isHiddenWithinTree, swap, adjustCSS, dataPriv, showHide) {
  "use strict";

  var fxNow,
    inProgress,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rrun = /queueHooks$/;
  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }
      jQuery.fx.tick();
    }
  }

  // Animations created synchronously will run synchronously
  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  }

  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which,
      i = 0,
      attrs = {
        height: type
      };

    // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
      index = 0,
      length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
      value,
      toggle,
      hooks,
      oldfire,
      propTween,
      restoreDisplay,
      display,
      isBox = "width" in props || "height" in props,
      anim = this,
      orig = {},
      style = elem.style,
      hidden = elem.nodeType && isHiddenWithinTree(elem),
      dataShow = dataPriv.get(elem, "fxshow");

    // Queue-skipping animations hijack the fx hooks
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }

    // Detect show/hide animations
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;

            // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }

    // Bail out if this is a no-op like .hide().hide()
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }

    // Restrict "overflow" and "display" styles during box animations
    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];

      // Identify a display type, preferring old show/hide data over the CSS cascade
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }

      // Animate inline elements as inline-block
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }

    // Implement show/hide animations
    propTween = false;
    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        }

        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
        if (toggle) {
          dataShow.hidden = !hidden;
        }

        // Show elements before animating them
        if (hidden) {
          showHide([elem], true);
        }

        /* eslint-disable no-loop-func */

        anim.done(function () {
          /* eslint-enable no-loop-func */

          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }

      // Per-property setup
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];

        // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
      stopped,
      index = 0,
      length = Animation.prefilters.length,
      deferred = jQuery.Deferred().always(function () {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }),
      tick = function tick() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);

        // If there's more to do, yield
        if (percent < 1 && length) {
          return remaining;
        }

        // If this was an empty animation, synthesize a final progress notification
        if (!length) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }

        // Resolve the animation and report its conclusion
        deferred.resolveWith(elem, [animation]);
        return false;
      },
      animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function createTween(prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function stop(gotoEnd) {
          var index = 0,
            // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }

          // Resolve when we played the last frame; otherwise, reject
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }),
      props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    // Attach callbacks from options
    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
        index = 0,
        length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    };

    // Go to the end state if fx are off
    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }

    // Normalize opt.queue - true/undefined/null -> "fx"
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;
    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show()

      // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
        optall = jQuery.speed(speed, easing, callback),
        doAnimation = function doAnimation() {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);

          // Empty animations, or finishing resolves immediately
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function () {
        var dequeue = true,
          index = type != null && type + "queueHooks",
          timers = jQuery.timers,
          data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }

        // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function () {
        var index,
          data = dataPriv.get(this),
          queue = data[type + "queue"],
          hooks = data[type + "queueHooks"],
          timers = jQuery.timers,
          length = queue ? queue.length : 0;

        // Enable finishing flag on private data
        data.finish = true;

        // Empty the queue first
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }

        // Look for any active animations, and finish them
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }

        // Look for any animations in the old queue and finish them
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }

        // Turn off finishing flag
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });

  // Generate shortcuts for custom animations
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function () {
    var timer,
      i = 0,
      timers = jQuery.timers;
    fxNow = Date.now();
    for (; i < timers.length; i++) {
      timer = timers[i];

      // Run the timer and safely remove it when done (allowing for external removal)
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }
    inProgress = true;
    schedule();
  };
  jQuery.fx.stop = function () {
    inProgress = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  };
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/effects/Tween.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/effects/Tween.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../css */ "./node_modules/jquery/src/css.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
        hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result;

        // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }

        // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.
        result = jQuery.css(tween.elem, tween.prop, "");

        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };

  // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;

  // Back compat <1.8 extension point
  jQuery.fx.step = {};
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/effects/animatedSelector.js":
/*!*************************************************************!*\
  !*** ./node_modules/jquery/src/effects/animatedSelector.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js"), __webpack_require__(/*! ../effects */ "./node_modules/jquery/src/effects.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event.js":
/*!******************************************!*\
  !*** ./node_modules/jquery/src/event.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/documentElement */ "./node_modules/jquery/src/var/documentElement.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rnothtmlwhite */ "./node_modules/jquery/src/var/rnothtmlwhite.js"), __webpack_require__(/*! ./var/slice */ "./node_modules/jquery/src/var/slice.js"), __webpack_require__(/*! ./data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, documentElement, isFunction, rnothtmlwhite, slice, dataPriv, nodeName) {
  "use strict";

  var rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }

  // Support: IE <=9 only
  // See #13393 for more info
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function _on(elem, types, selector, data, fn, one) {
    var origFn, type;

    // Types can be a map of types/handlers
    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };

      // Use same guid so caller can remove using origFn
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }

  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */
  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
        eventHandle,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.get(elem);

      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if (!elemData) {
        return;
      }

      // Caller can pass in an object of custom data in lieu of the handler
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }

      // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }

      // Make sure that the handler has a unique ID, used to find/remove it later
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }

      // Init the element's event structure and main handler, if this is the first
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }

      // Handle multiple events separated by a space
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // There *must* be a type, no attaching namespace-only handlers
        if (!type) {
          continue;
        }

        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};

        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;

        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};

        // handleObj is passed to all event handlers
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);

        // Init the event handler queue if we're the first
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;

          // Only use addEventListener if the special events handler returns false
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }

        // Add to the element's handler list, delegates in front
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }

        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
        origCount,
        tmp,
        events,
        t,
        handleObj,
        special,
        handlers,
        type,
        namespaces,
        origType,
        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }

      // Once for each type.namespace in types; type may be omitted
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();

        // Unbind all events (on this namespace, if provided) for the element
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

        // Remove matching events
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }

        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }

      // Remove data and the expando if it's no longer used
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      // Make a writable jQuery.Event from the native event object
      var event = jQuery.event.fix(nativeEvent);
      var i,
        j,
        ret,
        matched,
        handleObj,
        handlerQueue,
        args = new Array(arguments.length),
        handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
        special = jQuery.event.special[event.type] || {};

      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;

      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }

      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);

      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or 2) have namespace(s)
          // a subset or equal to those in the bound event (both can have no namespace).
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }

      // Call the postDispatch hook for the mapped type
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
        handleObj,
        sel,
        matchedHandlers,
        matchedSelectors,
        handlerQueue = [],
        delegateCount = _handlers.delegateCount,
        cur = event.target;

      // Find delegate handlers
      if (delegateCount &&
      // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType &&
      // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i];

              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }

      // Add the remaining (directly-bound) handlers
      cur = this;
      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function trigger() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function trigger() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function trigger() {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        // For cross-browser consistency, don't fire native .click() on links
        _default: function _default(event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }

    // Event object
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
      // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse;

      // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)
      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;

      // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if (props) {
      jQuery.extend(this, props);
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || Date.now();

    // Mark it as fixed
    this[jQuery.expando] = true;
  };

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };

  // Includes all common event props including KeyEvent and MouseEvent specific props
  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function which(event) {
      var button = event.button;

      // Add which for key events
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }

      // Add which for click: 1 === left; 2 === middle; 3 === right
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, jQuery.event.addProp);

  // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
          target = this,
          related = event.relatedTarget,
          handleObj = event.handleObj;

        // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event/ajax.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/event/ajax.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../event */ "./node_modules/jquery/src/event.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // Attach a bunch of functions for handling common AJAX events
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event/alias.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/event/alias.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../event */ "./node_modules/jquery/src/event.js"), __webpack_require__(/*! ./trigger */ "./node_modules/jquery/src/event/trigger.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event/focusin.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/focusin.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./support */ "./node_modules/jquery/src/event/support.js"), __webpack_require__(/*! ../event */ "./node_modules/jquery/src/event.js"), __webpack_require__(/*! ./trigger */ "./node_modules/jquery/src/event/trigger.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv, support) {
  "use strict";

  // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function setup() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this,
            attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event/support.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/support.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (support) {
  "use strict";

  support.focusin = "onfocusin" in window;
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/event/trigger.js":
/*!**************************************************!*\
  !*** ./node_modules/jquery/src/event/trigger.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ../data/var/acceptData */ "./node_modules/jquery/src/data/var/acceptData.js"), __webpack_require__(/*! ../var/hasOwn */ "./node_modules/jquery/src/var/hasOwn.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ../var/isWindow */ "./node_modules/jquery/src/var/isWindow.js"), __webpack_require__(/*! ../event */ "./node_modules/jquery/src/event.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, document, dataPriv, acceptData, hasOwn, isFunction, isWindow) {
  "use strict";

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    stopPropagationCallback = function stopPropagationCallback(e) {
      e.stopPropagation();
    };
  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
        cur,
        tmp,
        bubbleType,
        ontype,
        handle,
        special,
        lastElement,
        eventPath = [elem || document],
        type = hasOwn.call(event, "type") ? event.type : event,
        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document;

      // Don't do events on text and comment nodes
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }

      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;

      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event);

      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

      // Clean up the event in case it is being reused
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }

      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] : jQuery.makeArray(data, [event]);

      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }

      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }

        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }

      // Fire handlers on the event path
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type;

        // jQuery handler
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }

        // Native handler
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;

      // If nobody prevented the default action, do it now
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }

            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }
            elem[type]();
            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/exports/amd.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/exports/amd.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.

  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/exports/global.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/exports/global.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, noGlobal) {
  "use strict";

  var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
    // Map over the $ in case of overwrite
    _$ = window.$;
  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };

  // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/jquery.js":
/*!*******************************************!*\
  !*** ./node_modules/jquery/src/jquery.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js"), __webpack_require__(/*! ./traversing */ "./node_modules/jquery/src/traversing.js"), __webpack_require__(/*! ./callbacks */ "./node_modules/jquery/src/callbacks.js"), __webpack_require__(/*! ./deferred */ "./node_modules/jquery/src/deferred.js"), __webpack_require__(/*! ./deferred/exceptionHook */ "./node_modules/jquery/src/deferred/exceptionHook.js"), __webpack_require__(/*! ./core/ready */ "./node_modules/jquery/src/core/ready.js"), __webpack_require__(/*! ./data */ "./node_modules/jquery/src/data.js"), __webpack_require__(/*! ./queue */ "./node_modules/jquery/src/queue.js"), __webpack_require__(/*! ./queue/delay */ "./node_modules/jquery/src/queue/delay.js"), __webpack_require__(/*! ./attributes */ "./node_modules/jquery/src/attributes.js"), __webpack_require__(/*! ./event */ "./node_modules/jquery/src/event.js"), __webpack_require__(/*! ./event/focusin */ "./node_modules/jquery/src/event/focusin.js"), __webpack_require__(/*! ./manipulation */ "./node_modules/jquery/src/manipulation.js"), __webpack_require__(/*! ./manipulation/_evalUrl */ "./node_modules/jquery/src/manipulation/_evalUrl.js"), __webpack_require__(/*! ./wrap */ "./node_modules/jquery/src/wrap.js"), __webpack_require__(/*! ./css */ "./node_modules/jquery/src/css.js"), __webpack_require__(/*! ./css/hiddenVisibleSelectors */ "./node_modules/jquery/src/css/hiddenVisibleSelectors.js"), __webpack_require__(/*! ./serialize */ "./node_modules/jquery/src/serialize.js"), __webpack_require__(/*! ./ajax */ "./node_modules/jquery/src/ajax.js"), __webpack_require__(/*! ./ajax/xhr */ "./node_modules/jquery/src/ajax/xhr.js"), __webpack_require__(/*! ./ajax/script */ "./node_modules/jquery/src/ajax/script.js"), __webpack_require__(/*! ./ajax/jsonp */ "./node_modules/jquery/src/ajax/jsonp.js"), __webpack_require__(/*! ./ajax/load */ "./node_modules/jquery/src/ajax/load.js"), __webpack_require__(/*! ./event/ajax */ "./node_modules/jquery/src/event/ajax.js"), __webpack_require__(/*! ./effects */ "./node_modules/jquery/src/effects.js"), __webpack_require__(/*! ./effects/animatedSelector */ "./node_modules/jquery/src/effects/animatedSelector.js"), __webpack_require__(/*! ./offset */ "./node_modules/jquery/src/offset.js"), __webpack_require__(/*! ./dimensions */ "./node_modules/jquery/src/dimensions.js"), __webpack_require__(/*! ./deprecated */ "./node_modules/jquery/src/deprecated.js"), __webpack_require__(/*! ./exports/amd */ "./node_modules/jquery/src/exports/amd.js"), __webpack_require__(/*! ./exports/global */ "./node_modules/jquery/src/exports/global.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/manipulation.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/concat */ "./node_modules/jquery/src/var/concat.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/push */ "./node_modules/jquery/src/var/push.js"), __webpack_require__(/*! ./core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./manipulation/var/rcheckableType */ "./node_modules/jquery/src/manipulation/var/rcheckableType.js"), __webpack_require__(/*! ./manipulation/var/rtagName */ "./node_modules/jquery/src/manipulation/var/rtagName.js"), __webpack_require__(/*! ./manipulation/var/rscriptType */ "./node_modules/jquery/src/manipulation/var/rscriptType.js"), __webpack_require__(/*! ./manipulation/wrapMap */ "./node_modules/jquery/src/manipulation/wrapMap.js"), __webpack_require__(/*! ./manipulation/getAll */ "./node_modules/jquery/src/manipulation/getAll.js"), __webpack_require__(/*! ./manipulation/setGlobalEval */ "./node_modules/jquery/src/manipulation/setGlobalEval.js"), __webpack_require__(/*! ./manipulation/buildFragment */ "./node_modules/jquery/src/manipulation/buildFragment.js"), __webpack_require__(/*! ./manipulation/support */ "./node_modules/jquery/src/manipulation/support.js"), __webpack_require__(/*! ./data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./data/var/dataUser */ "./node_modules/jquery/src/data/var/dataUser.js"), __webpack_require__(/*! ./data/var/acceptData */ "./node_modules/jquery/src/data/var/acceptData.js"), __webpack_require__(/*! ./core/DOMEval */ "./node_modules/jquery/src/core/DOMEval.js"), __webpack_require__(/*! ./core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./traversing */ "./node_modules/jquery/src/traversing.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js"), __webpack_require__(/*! ./event */ "./node_modules/jquery/src/event.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, concat, isFunction, push, access, rcheckableType, rtagName, rscriptType, wrapMap, getAll, setGlobalEval, buildFragment, support, dataPriv, dataUser, acceptData, DOMEval, nodeName) {
  "use strict";

  var /* eslint-disable max-len */

    // See https://github.com/eslint/eslint/issues/3229
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
    /* eslint-enable */

    // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

  // Prefer a tbody over its parent table for containing new rows
  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }
    return elem;
  }

  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }

    // 1. Copy private data: events, handlers, etc.
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }

    // 2. Copy user data
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }

  // Fix IE bugs, see support tests
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();

    // Fails to persist the checked state of a cloned checkbox or radio button.
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;

      // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = concat.apply([], args);
    var fragment,
      first,
      scripts,
      hasScripts,
      node,
      doc,
      i = 0,
      l = collection.length,
      iNoClone = l - 1,
      value = args[0],
      valueIsFunction = isFunction(value);

    // We can't cloneNode fragments that contain checked, in WebKit
    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);
        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }

      // Require either new content or an interest in ignored elements to invoke the callback
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;

        // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);

            // Keep references to cloned scripts for later restoration
            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;

          // Reenable scripts
          jQuery.map(scripts, restoreScript);

          // Evaluate executable scripts on first document insertion
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function _remove(elem, selector, keepData) {
    var node,
      nodes = selector ? jQuery.filter(selector, elem) : elem,
      i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
        l,
        srcElements,
        destElements,
        clone = elem.cloneNode(true),
        inPage = jQuery.contains(elem.ownerDocument, elem);

      // Fix IE cloning issues
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }

      // Copy the events from the original to the clone
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }

      // Preserve script evaluation history
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }

      // Return the cloned set
      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
        elem,
        type,
        special = jQuery.event.special,
        i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);

                  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }

            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
        i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false));

          // Remove any remaining nodes
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
          i = 0,
          l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }

        // See if we can take a shortcut and just use innerHTML
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};

              // Remove element nodes and prevent memory leaks
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;

            // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = [];

      // Make the changes, replacing each non-ignored context element with the new content
      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }

        // Force callback invocation
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
        ret = [],
        insert = jQuery(selector),
        last = insert.length - 1,
        i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);

        // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/_evalUrl.js":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/_evalUrl.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../ajax */ "./node_modules/jquery/src/ajax.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  return jQuery._evalUrl;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/buildFragment.js":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/buildFragment.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/toType */ "./node_modules/jquery/src/core/toType.js"), __webpack_require__(/*! ./var/rtagName */ "./node_modules/jquery/src/manipulation/var/rtagName.js"), __webpack_require__(/*! ./var/rscriptType */ "./node_modules/jquery/src/manipulation/var/rscriptType.js"), __webpack_require__(/*! ./wrapMap */ "./node_modules/jquery/src/manipulation/wrapMap.js"), __webpack_require__(/*! ./getAll */ "./node_modules/jquery/src/manipulation/getAll.js"), __webpack_require__(/*! ./setGlobalEval */ "./node_modules/jquery/src/manipulation/setGlobalEval.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, rtagName, rscriptType, wrapMap, getAll, setGlobalEval) {
  "use strict";

  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
      tmp,
      tag,
      wrap,
      contains,
      j,
      fragment = context.createDocumentFragment(),
      nodes = [],
      i = 0,
      l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

          // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));

          // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));

          // Deserialize a standard representation
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

          // Descend through wrappers to the right content
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }

          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, tmp.childNodes);

          // Remember the top-level container
          tmp = fragment.firstChild;

          // Ensure the created nodes are orphaned (#12392)
          tmp.textContent = "";
        }
      }
    }

    // Remove wrapper from fragment
    fragment.textContent = "";
    i = 0;
    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);

      // Append to fragment
      tmp = getAll(fragment.appendChild(elem), "script");

      // Preserve script evaluation history
      if (contains) {
        setGlobalEval(tmp);
      }

      // Capture executables
      if (scripts) {
        j = 0;
        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  return buildFragment;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/getAll.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/getAll.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../core/nodeName */ "./node_modules/jquery/src/core/nodeName.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, nodeName) {
  "use strict";

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }
    return ret;
  }
  return getAll;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/setGlobalEval.js":
/*!***************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/setGlobalEval.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (dataPriv) {
  "use strict";

  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var i = 0,
      l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  return setGlobalEval;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/support.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/support.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ../var/support */ "./node_modules/jquery/src/var/support.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document, support) {
  "use strict";

  (function () {
    var fragment = document.createDocumentFragment(),
      div = fragment.appendChild(document.createElement("div")),
      input = document.createElement("input");

    // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);

    // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

    // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  return support;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/var/rcheckableType.js":
/*!********************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rcheckableType.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /^(?:checkbox|radio)$/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/var/rscriptType.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rscriptType.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /^$|^module$|\/(?:java|ecma)script/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/var/rtagName.js":
/*!**************************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/var/rtagName.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/manipulation/wrapMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/jquery/src/manipulation/wrapMap.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // We have to close these tags to support XHTML (#13200)
  var wrapMap = {
    // Support: IE <=9 only
    option: [1, "<select multiple='multiple'>", "</select>"],
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };

  // Support: IE <=9 only
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  return wrapMap;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/offset.js":
/*!*******************************************!*\
  !*** ./node_modules/jquery/src/offset.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/access */ "./node_modules/jquery/src/core/access.js"), __webpack_require__(/*! ./var/document */ "./node_modules/jquery/src/var/document.js"), __webpack_require__(/*! ./var/documentElement */ "./node_modules/jquery/src/var/documentElement.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./css/var/rnumnonpx */ "./node_modules/jquery/src/css/var/rnumnonpx.js"), __webpack_require__(/*! ./css/curCSS */ "./node_modules/jquery/src/css/curCSS.js"), __webpack_require__(/*! ./css/addGetHookIf */ "./node_modules/jquery/src/css/addGetHookIf.js"), __webpack_require__(/*! ./css/support */ "./node_modules/jquery/src/css/support.js"), __webpack_require__(/*! ./var/isWindow */ "./node_modules/jquery/src/var/isWindow.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./css */ "./node_modules/jquery/src/css.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js") // contains
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, access, document, documentElement, isFunction, rnumnonpx, curCSS, addGetHookIf, support, isWindow) {
  "use strict";

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
        curLeft,
        curCSSTop,
        curTop,
        curOffset,
        curCSSLeft,
        calculatePosition,
        position = jQuery.css(elem, "position"),
        curElem = jQuery(elem),
        props = {};

      // Set position first, in-case top/left are set even on static elem
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

      // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var rect,
        win,
        elem = this[0];
      if (!elem) {
        return;
      }

      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }

      // Get document-relative position by adding viewport scroll to viewport-relative gBCR
      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
        offset,
        doc,
        elem = this[0],
        parentOffset = {
          top: 0,
          left: 0
        };

      // position:fixed elements are offset from the viewport, which itself always has zero offset
      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset();

        // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      }

      // Subtract parent offsets and element margins
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });

  // Create scrollLeft and scrollTop methods
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;
        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });

  // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here
  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);

        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/queue.js":
/*!******************************************!*\
  !*** ./node_modules/jquery/src/queue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./data/var/dataPriv */ "./node_modules/jquery/src/data/var/dataPriv.js"), __webpack_require__(/*! ./deferred */ "./node_modules/jquery/src/deferred.js"), __webpack_require__(/*! ./callbacks */ "./node_modules/jquery/src/callbacks.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, dataPriv) {
  "use strict";

  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);

        // Speed up dequeue by getting out quickly if this is just a lookup
        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
        startLength = queue.length,
        fn = queue.shift(),
        hooks = jQuery._queueHooks(elem, type),
        next = function next() {
          jQuery.dequeue(elem, type);
        };

      // If the fx queue is dequeued, always remove the progress sentinel
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        }

        // Clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);

        // Ensure a hooks for this queue
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function resolve() {
          if (! --count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/queue/delay.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/queue/delay.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../queue */ "./node_modules/jquery/src/queue.js"), __webpack_require__(/*! ../effects */ "./node_modules/jquery/src/effects.js") // Delay is optional because of this dependency
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };
  return jQuery.fn.delay;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/selector-sizzle.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery/src/selector-sizzle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../external/sizzle/dist/sizzle */ "./node_modules/jquery/external/sizzle/dist/sizzle.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, Sizzle) {
  "use strict";

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;

  // Deprecated
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/selector.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/selector.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./selector-sizzle */ "./node_modules/jquery/src/selector-sizzle.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/serialize.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/serialize.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./core/toType */ "./node_modules/jquery/src/core/toType.js"), __webpack_require__(/*! ./manipulation/var/rcheckableType */ "./node_modules/jquery/src/manipulation/var/rcheckableType.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./traversing */ "./node_modules/jquery/src/traversing.js"),
// filter
__webpack_require__(/*! ./attributes/prop */ "./node_modules/jquery/src/attributes/prop.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, toType, rcheckableType, isFunction) {
  "use strict";

  var rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }

  // Serialize an array of form elements or a set of
  // key/values into a query string
  jQuery.param = function (a, traditional) {
    var prefix,
      s = [],
      add = function add(key, valueOrFunction) {
        // If value is a function, invoke it and use its return value
        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };

    // If an array was passed in, assume that it is an array of form elements.
    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }

    // Return the resulting serialization
    return s.join("&");
  };
  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;

        // Use .is( ":disabled" ) so that fieldset[disabled] works
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        if (val == null) {
          return null;
        }
        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/traversing.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/traversing.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/indexOf */ "./node_modules/jquery/src/var/indexOf.js"), __webpack_require__(/*! ./traversing/var/dir */ "./node_modules/jquery/src/traversing/var/dir.js"), __webpack_require__(/*! ./traversing/var/siblings */ "./node_modules/jquery/src/traversing/var/siblings.js"), __webpack_require__(/*! ./traversing/var/rneedsContext */ "./node_modules/jquery/src/traversing/var/rneedsContext.js"), __webpack_require__(/*! ./core/nodeName */ "./node_modules/jquery/src/core/nodeName.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./traversing/findFilter */ "./node_modules/jquery/src/traversing/findFilter.js"), __webpack_require__(/*! ./selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, indexOf, dir, _siblings, rneedsContext, nodeName) {
  "use strict";

  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
        l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
        i = 0,
        l = this.length,
        matched = [],
        targets = typeof selectors !== "string" && jQuery(selectors);

      // Positional selectors never match, since there's no _selection_ context
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :
            // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }

      // Index in selector
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }

      // Locate the position of the desired element
      return indexOf.call(this,
      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      }

      // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.
      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }
      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }

        // Reverse order for parents* and prev-derivatives
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/traversing/findFilter.js":
/*!**********************************************************!*\
  !*** ./node_modules/jquery/src/traversing/findFilter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../var/indexOf */ "./node_modules/jquery/src/var/indexOf.js"), __webpack_require__(/*! ../var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./var/rneedsContext */ "./node_modules/jquery/src/traversing/var/rneedsContext.js"), __webpack_require__(/*! ../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, indexOf, isFunction, rneedsContext) {
  "use strict";

  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }

    // Single element
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }

    // Arraylike of elements (jQuery, arguments, Array)
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    }

    // Filtered directly for both simple and complex selectors
    return jQuery.filter(qualifier, elements, not);
  }
  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function find(selector) {
      var i,
        ret,
        len = this.length,
        self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this,
      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/traversing/var/dir.js":
/*!*******************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/dir.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "./node_modules/jquery/src/core.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return function (elem, dir, until) {
    var matched = [],
      truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/traversing/var/rneedsContext.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/rneedsContext.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../../core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ../../selector */ "./node_modules/jquery/src/selector.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery) {
  "use strict";

  return jQuery.expr.match.needsContext;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/traversing/var/siblings.js":
/*!************************************************************!*\
  !*** ./node_modules/jquery/src/traversing/var/siblings.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function (n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/ObjectFunctionString.js":
/*!*************************************************************!*\
  !*** ./node_modules/jquery/src/var/ObjectFunctionString.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./fnToString */ "./node_modules/jquery/src/var/fnToString.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (fnToString) {
  "use strict";

  return fnToString.call(Object);
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/arr.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/src/var/arr.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return [];
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/class2type.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/class2type.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // [[Class]] -> type pairs
  return {};
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/concat.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/var/concat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "./node_modules/jquery/src/var/arr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.concat;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/document.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/document.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return window.document;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/documentElement.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery/src/var/documentElement.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./document */ "./node_modules/jquery/src/var/document.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (document) {
  "use strict";

  return document.documentElement;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/fnToString.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/fnToString.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./hasOwn */ "./node_modules/jquery/src/var/hasOwn.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (hasOwn) {
  "use strict";

  return hasOwn.toString;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/getProto.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/getProto.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return Object.getPrototypeOf;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/hasOwn.js":
/*!***********************************************!*\
  !*** ./node_modules/jquery/src/var/hasOwn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./class2type */ "./node_modules/jquery/src/var/class2type.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type) {
  "use strict";

  return class2type.hasOwnProperty;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/indexOf.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/indexOf.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "./node_modules/jquery/src/var/arr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.indexOf;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/isFunction.js":
/*!***************************************************!*\
  !*** ./node_modules/jquery/src/var/isFunction.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/isWindow.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/isWindow.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return function isWindow(obj) {
    return obj != null && obj === obj.window;
  };
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/pnum.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/var/pnum.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  return /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/push.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery/src/var/push.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "./node_modules/jquery/src/var/arr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.push;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/rcssNum.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/rcssNum.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../var/pnum */ "./node_modules/jquery/src/var/pnum.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (pnum) {
  "use strict";

  return new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/rnothtmlwhite.js":
/*!******************************************************!*\
  !*** ./node_modules/jquery/src/var/rnothtmlwhite.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // Only count HTML whitespace
  // Other whitespace should count in values
  // https://infra.spec.whatwg.org/#ascii-whitespace
  return /[^\x20\t\r\n\f]+/g;
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/slice.js":
/*!**********************************************!*\
  !*** ./node_modules/jquery/src/var/slice.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./arr */ "./node_modules/jquery/src/var/arr.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (arr) {
  "use strict";

  return arr.slice;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/support.js":
/*!************************************************!*\
  !*** ./node_modules/jquery/src/var/support.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  "use strict";

  // All support tests are defined in their respective modules.
  return {};
}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/var/toString.js":
/*!*************************************************!*\
  !*** ./node_modules/jquery/src/var/toString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./class2type */ "./node_modules/jquery/src/var/class2type.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (class2type) {
  "use strict";

  return class2type.toString;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jquery/src/wrap.js":
/*!*****************************************!*\
  !*** ./node_modules/jquery/src/wrap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./core */ "./node_modules/jquery/src/core.js"), __webpack_require__(/*! ./var/isFunction */ "./node_modules/jquery/src/var/isFunction.js"), __webpack_require__(/*! ./core/init */ "./node_modules/jquery/src/core/init.js"), __webpack_require__(/*! ./manipulation */ "./node_modules/jquery/src/manipulation.js"),
// clone
__webpack_require__(/*! ./traversing */ "./node_modules/jquery/src/traversing.js") // parent, contents
], __WEBPACK_AMD_DEFINE_RESULT__ = (function (jQuery, isFunction) {
  "use strict";

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;
      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        }

        // The elements to wrap the target around
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this),
          contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  return jQuery;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./node_modules/jsgrid/dist/jsgrid.js":
/*!********************************************!*\
  !*** ./node_modules/jsgrid/dist/jsgrid.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/*
 * jsGrid v1.5.3 (http://js-grid.com)
 * (c) 2016 Artem Tabalin
 * Licensed under MIT (https://github.com/tabalinas/jsgrid/blob/master/LICENSE)
 */

(function (window, $, undefined) {
  var JSGRID = "JSGrid",
    JSGRID_DATA_KEY = JSGRID,
    JSGRID_ROW_DATA_KEY = "JSGridItem",
    JSGRID_EDIT_ROW_DATA_KEY = "JSGridEditRow",
    SORT_ORDER_ASC = "asc",
    SORT_ORDER_DESC = "desc",
    FIRST_PAGE_PLACEHOLDER = "{first}",
    PAGES_PLACEHOLDER = "{pages}",
    PREV_PAGE_PLACEHOLDER = "{prev}",
    NEXT_PAGE_PLACEHOLDER = "{next}",
    LAST_PAGE_PLACEHOLDER = "{last}",
    PAGE_INDEX_PLACEHOLDER = "{pageIndex}",
    PAGE_COUNT_PLACEHOLDER = "{pageCount}",
    ITEM_COUNT_PLACEHOLDER = "{itemCount}",
    EMPTY_HREF = "javascript:void(0);";
  var getOrApply = function getOrApply(value, context) {
    if ($.isFunction(value)) {
      return value.apply(context, $.makeArray(arguments).slice(2));
    }
    return value;
  };
  var normalizePromise = function normalizePromise(promise) {
    var d = $.Deferred();
    if (promise && promise.then) {
      promise.then(function () {
        d.resolve.apply(d, arguments);
      }, function () {
        d.reject.apply(d, arguments);
      });
    } else {
      d.resolve(promise);
    }
    return d.promise();
  };
  var defaultController = {
    loadData: $.noop,
    insertItem: $.noop,
    updateItem: $.noop,
    deleteItem: $.noop
  };
  function Grid(element, config) {
    var $element = $(element);
    $element.data(JSGRID_DATA_KEY, this);
    this._container = $element;
    this.data = [];
    this.fields = [];
    this._editingRow = null;
    this._sortField = null;
    this._sortOrder = SORT_ORDER_ASC;
    this._firstDisplayingPage = 1;
    this._init(config);
    this.render();
  }
  Grid.prototype = {
    width: "auto",
    height: "auto",
    updateOnResize: true,
    rowClass: $.noop,
    rowRenderer: null,
    rowClick: function rowClick(args) {
      if (this.editing) {
        this.editItem($(args.event.target).closest("tr"));
      }
    },
    rowDoubleClick: $.noop,
    noDataContent: "Not found",
    noDataRowClass: "jsgrid-nodata-row",
    heading: true,
    headerRowRenderer: null,
    headerRowClass: "jsgrid-header-row",
    headerCellClass: "jsgrid-header-cell",
    filtering: false,
    filterRowRenderer: null,
    filterRowClass: "jsgrid-filter-row",
    inserting: false,
    insertRowRenderer: null,
    insertRowClass: "jsgrid-insert-row",
    editing: false,
    editRowRenderer: null,
    editRowClass: "jsgrid-edit-row",
    confirmDeleting: true,
    deleteConfirm: "Are you sure?",
    selecting: true,
    selectedRowClass: "jsgrid-selected-row",
    oddRowClass: "jsgrid-row",
    evenRowClass: "jsgrid-alt-row",
    cellClass: "jsgrid-cell",
    sorting: false,
    sortableClass: "jsgrid-header-sortable",
    sortAscClass: "jsgrid-header-sort jsgrid-header-sort-asc",
    sortDescClass: "jsgrid-header-sort jsgrid-header-sort-desc",
    paging: false,
    pagerContainer: null,
    pageIndex: 1,
    pageSize: 20,
    pageButtonCount: 15,
    pagerFormat: "Pages: {first} {prev} {pages} {next} {last} &nbsp;&nbsp; {pageIndex} of {pageCount}",
    pagePrevText: "Prev",
    pageNextText: "Next",
    pageFirstText: "First",
    pageLastText: "Last",
    pageNavigatorNextText: "...",
    pageNavigatorPrevText: "...",
    pagerContainerClass: "jsgrid-pager-container",
    pagerClass: "jsgrid-pager",
    pagerNavButtonClass: "jsgrid-pager-nav-button",
    pagerNavButtonInactiveClass: "jsgrid-pager-nav-inactive-button",
    pageClass: "jsgrid-pager-page",
    currentPageClass: "jsgrid-pager-current-page",
    customLoading: false,
    pageLoading: false,
    autoload: false,
    controller: defaultController,
    loadIndication: true,
    loadIndicationDelay: 500,
    loadMessage: "Please, wait...",
    loadShading: true,
    invalidMessage: "Invalid data entered!",
    invalidNotify: function invalidNotify(args) {
      var messages = $.map(args.errors, function (error) {
        return error.message || null;
      });
      window.alert([this.invalidMessage].concat(messages).join("\n"));
    },
    onInit: $.noop,
    onRefreshing: $.noop,
    onRefreshed: $.noop,
    onPageChanged: $.noop,
    onItemDeleting: $.noop,
    onItemDeleted: $.noop,
    onItemInserting: $.noop,
    onItemInserted: $.noop,
    onItemEditing: $.noop,
    onItemUpdating: $.noop,
    onItemUpdated: $.noop,
    onItemInvalid: $.noop,
    onDataLoading: $.noop,
    onDataLoaded: $.noop,
    onOptionChanging: $.noop,
    onOptionChanged: $.noop,
    onError: $.noop,
    invalidClass: "jsgrid-invalid",
    containerClass: "jsgrid",
    tableClass: "jsgrid-table",
    gridHeaderClass: "jsgrid-grid-header",
    gridBodyClass: "jsgrid-grid-body",
    _init: function _init(config) {
      $.extend(this, config);
      this._initLoadStrategy();
      this._initController();
      this._initFields();
      this._attachWindowLoadResize();
      this._attachWindowResizeCallback();
      this._callEventHandler(this.onInit);
    },
    loadStrategy: function loadStrategy() {
      return this.pageLoading ? new jsGrid.loadStrategies.PageLoadingStrategy(this) : new jsGrid.loadStrategies.DirectLoadingStrategy(this);
    },
    _initLoadStrategy: function _initLoadStrategy() {
      this._loadStrategy = getOrApply(this.loadStrategy, this);
    },
    _initController: function _initController() {
      this._controller = $.extend({}, defaultController, getOrApply(this.controller, this));
    },
    renderTemplate: function renderTemplate(source, context, config) {
      args = [];
      for (var key in config) {
        args.push(config[key]);
      }
      args.unshift(source, context);
      source = getOrApply.apply(null, args);
      return source === undefined || source === null ? "" : source;
    },
    loadIndicator: function loadIndicator(config) {
      return new jsGrid.LoadIndicator(config);
    },
    validation: function validation(config) {
      return jsGrid.Validation && new jsGrid.Validation(config);
    },
    _initFields: function _initFields() {
      var self = this;
      self.fields = $.map(self.fields, function (field) {
        if ($.isPlainObject(field)) {
          var fieldConstructor = field.type && jsGrid.fields[field.type] || jsGrid.Field;
          field = new fieldConstructor(field);
        }
        field._grid = self;
        return field;
      });
    },
    _attachWindowLoadResize: function _attachWindowLoadResize() {
      $(window).on("load", $.proxy(this._refreshSize, this));
    },
    _attachWindowResizeCallback: function _attachWindowResizeCallback() {
      if (this.updateOnResize) {
        $(window).on("resize", $.proxy(this._refreshSize, this));
      }
    },
    _detachWindowResizeCallback: function _detachWindowResizeCallback() {
      $(window).off("resize", this._refreshSize);
    },
    option: function option(key, value) {
      var optionChangingEventArgs, optionChangedEventArgs;
      if (arguments.length === 1) return this[key];
      optionChangingEventArgs = {
        option: key,
        oldValue: this[key],
        newValue: value
      };
      this._callEventHandler(this.onOptionChanging, optionChangingEventArgs);
      this._handleOptionChange(optionChangingEventArgs.option, optionChangingEventArgs.newValue);
      optionChangedEventArgs = {
        option: optionChangingEventArgs.option,
        value: optionChangingEventArgs.newValue
      };
      this._callEventHandler(this.onOptionChanged, optionChangedEventArgs);
    },
    fieldOption: function fieldOption(field, key, value) {
      field = this._normalizeField(field);
      if (arguments.length === 2) return field[key];
      field[key] = value;
      this._renderGrid();
    },
    _handleOptionChange: function _handleOptionChange(name, value) {
      this[name] = value;
      switch (name) {
        case "width":
        case "height":
          this._refreshSize();
          break;
        case "rowClass":
        case "rowRenderer":
        case "rowClick":
        case "rowDoubleClick":
        case "noDataRowClass":
        case "noDataContent":
        case "selecting":
        case "selectedRowClass":
        case "oddRowClass":
        case "evenRowClass":
          this._refreshContent();
          break;
        case "pageButtonCount":
        case "pagerFormat":
        case "pagePrevText":
        case "pageNextText":
        case "pageFirstText":
        case "pageLastText":
        case "pageNavigatorNextText":
        case "pageNavigatorPrevText":
        case "pagerClass":
        case "pagerNavButtonClass":
        case "pageClass":
        case "currentPageClass":
        case "pagerRenderer":
          this._refreshPager();
          break;
        case "fields":
          this._initFields();
          this.render();
          break;
        case "data":
        case "editing":
        case "heading":
        case "filtering":
        case "inserting":
        case "paging":
          this.refresh();
          break;
        case "loadStrategy":
        case "pageLoading":
          this._initLoadStrategy();
          this.search();
          break;
        case "pageIndex":
          this.openPage(value);
          break;
        case "pageSize":
          this.refresh();
          this.search();
          break;
        case "editRowRenderer":
        case "editRowClass":
          this.cancelEdit();
          break;
        case "updateOnResize":
          this._detachWindowResizeCallback();
          this._attachWindowResizeCallback();
          break;
        case "invalidNotify":
        case "invalidMessage":
          break;
        default:
          this.render();
          break;
      }
    },
    destroy: function destroy() {
      this._detachWindowResizeCallback();
      this._clear();
      this._container.removeData(JSGRID_DATA_KEY);
    },
    render: function render() {
      this._renderGrid();
      return this.autoload ? this.loadData() : $.Deferred().resolve().promise();
    },
    _renderGrid: function _renderGrid() {
      this._clear();
      this._container.addClass(this.containerClass).css("position", "relative").append(this._createHeader()).append(this._createBody());
      this._pagerContainer = this._createPagerContainer();
      this._loadIndicator = this._createLoadIndicator();
      this._validation = this._createValidation();
      this.refresh();
    },
    _createLoadIndicator: function _createLoadIndicator() {
      return getOrApply(this.loadIndicator, this, {
        message: this.loadMessage,
        shading: this.loadShading,
        container: this._container
      });
    },
    _createValidation: function _createValidation() {
      return getOrApply(this.validation, this);
    },
    _clear: function _clear() {
      this.cancelEdit();
      clearTimeout(this._loadingTimer);
      this._pagerContainer && this._pagerContainer.empty();
      this._container.empty().css({
        position: "",
        width: "",
        height: ""
      });
    },
    _createHeader: function _createHeader() {
      var $headerRow = this._headerRow = this._createHeaderRow(),
        $filterRow = this._filterRow = this._createFilterRow(),
        $insertRow = this._insertRow = this._createInsertRow();
      var $headerGrid = this._headerGrid = $("<table>").addClass(this.tableClass).append($headerRow).append($filterRow).append($insertRow);
      var $header = this._header = $("<div>").addClass(this.gridHeaderClass).addClass(this._scrollBarWidth() ? "jsgrid-header-scrollbar" : "").append($headerGrid);
      return $header;
    },
    _createBody: function _createBody() {
      var $content = this._content = $("<tbody>");
      var $bodyGrid = this._bodyGrid = $("<table>").addClass(this.tableClass).append($content);
      var $body = this._body = $("<div>").addClass(this.gridBodyClass).append($bodyGrid).on("scroll", $.proxy(function (e) {
        this._header.scrollLeft(e.target.scrollLeft);
      }, this));
      return $body;
    },
    _createPagerContainer: function _createPagerContainer() {
      var pagerContainer = this.pagerContainer || $("<div>").appendTo(this._container);
      return $(pagerContainer).addClass(this.pagerContainerClass);
    },
    _eachField: function _eachField(callBack) {
      var self = this;
      $.each(this.fields, function (index, field) {
        if (field.visible) {
          callBack.call(self, field, index);
        }
      });
    },
    _createHeaderRow: function _createHeaderRow() {
      if ($.isFunction(this.headerRowRenderer)) return $(this.renderTemplate(this.headerRowRenderer, this));
      var $result = $("<tr>").addClass(this.headerRowClass);
      this._eachField(function (field, index) {
        var $th = this._prepareCell("<th>", field, "headercss", this.headerCellClass).append(this.renderTemplate(field.headerTemplate, field)).appendTo($result);
        if (this.sorting && field.sorting) {
          $th.addClass(this.sortableClass).on("click", $.proxy(function () {
            this.sort(index);
          }, this));
        }
      });
      return $result;
    },
    _prepareCell: function _prepareCell(cell, field, cssprop, cellClass) {
      return $(cell).css("width", field.width).addClass(cellClass || this.cellClass).addClass(cssprop && field[cssprop] || field.css).addClass(field.align ? "jsgrid-align-" + field.align : "");
    },
    _createFilterRow: function _createFilterRow() {
      if ($.isFunction(this.filterRowRenderer)) return $(this.renderTemplate(this.filterRowRenderer, this));
      var $result = $("<tr>").addClass(this.filterRowClass);
      this._eachField(function (field) {
        this._prepareCell("<td>", field, "filtercss").append(this.renderTemplate(field.filterTemplate, field)).appendTo($result);
      });
      return $result;
    },
    _createInsertRow: function _createInsertRow() {
      if ($.isFunction(this.insertRowRenderer)) return $(this.renderTemplate(this.insertRowRenderer, this));
      var $result = $("<tr>").addClass(this.insertRowClass);
      this._eachField(function (field) {
        this._prepareCell("<td>", field, "insertcss").append(this.renderTemplate(field.insertTemplate, field)).appendTo($result);
      });
      return $result;
    },
    _callEventHandler: function _callEventHandler(handler, eventParams) {
      handler.call(this, $.extend(eventParams, {
        grid: this
      }));
      return eventParams;
    },
    reset: function reset() {
      this._resetSorting();
      this._resetPager();
      return this._loadStrategy.reset();
    },
    _resetPager: function _resetPager() {
      this._firstDisplayingPage = 1;
      this._setPage(1);
    },
    _resetSorting: function _resetSorting() {
      this._sortField = null;
      this._sortOrder = SORT_ORDER_ASC;
      this._clearSortingCss();
    },
    refresh: function refresh() {
      this._callEventHandler(this.onRefreshing);
      this.cancelEdit();
      this._refreshHeading();
      this._refreshFiltering();
      this._refreshInserting();
      this._refreshContent();
      this._refreshPager();
      this._refreshSize();
      this._callEventHandler(this.onRefreshed);
    },
    _refreshHeading: function _refreshHeading() {
      this._headerRow.toggle(this.heading);
    },
    _refreshFiltering: function _refreshFiltering() {
      this._filterRow.toggle(this.filtering);
    },
    _refreshInserting: function _refreshInserting() {
      this._insertRow.toggle(this.inserting);
    },
    _refreshContent: function _refreshContent() {
      var $content = this._content;
      $content.empty();
      if (!this.data.length) {
        $content.append(this._createNoDataRow());
        return this;
      }
      var indexFrom = this._loadStrategy.firstDisplayIndex();
      var indexTo = this._loadStrategy.lastDisplayIndex();
      for (var itemIndex = indexFrom; itemIndex < indexTo; itemIndex++) {
        var item = this.data[itemIndex];
        $content.append(this._createRow(item, itemIndex));
      }
    },
    _createNoDataRow: function _createNoDataRow() {
      var amountOfFields = 0;
      this._eachField(function () {
        amountOfFields++;
      });
      return $("<tr>").addClass(this.noDataRowClass).append($("<td>").addClass(this.cellClass).attr("colspan", amountOfFields).append(this.renderTemplate(this.noDataContent, this)));
    },
    _createRow: function _createRow(item, itemIndex) {
      var $result;
      if ($.isFunction(this.rowRenderer)) {
        $result = this.renderTemplate(this.rowRenderer, this, {
          item: item,
          itemIndex: itemIndex
        });
      } else {
        $result = $("<tr>");
        this._renderCells($result, item);
      }
      $result.addClass(this._getRowClasses(item, itemIndex)).data(JSGRID_ROW_DATA_KEY, item).on("click", $.proxy(function (e) {
        this.rowClick({
          item: item,
          itemIndex: itemIndex,
          event: e
        });
      }, this)).on("dblclick", $.proxy(function (e) {
        this.rowDoubleClick({
          item: item,
          itemIndex: itemIndex,
          event: e
        });
      }, this));
      if (this.selecting) {
        this._attachRowHover($result);
      }
      return $result;
    },
    _getRowClasses: function _getRowClasses(item, itemIndex) {
      var classes = [];
      classes.push((itemIndex + 1) % 2 ? this.oddRowClass : this.evenRowClass);
      classes.push(getOrApply(this.rowClass, this, item, itemIndex));
      return classes.join(" ");
    },
    _attachRowHover: function _attachRowHover($row) {
      var selectedRowClass = this.selectedRowClass;
      $row.hover(function () {
        $(this).addClass(selectedRowClass);
      }, function () {
        $(this).removeClass(selectedRowClass);
      });
    },
    _renderCells: function _renderCells($row, item) {
      this._eachField(function (field) {
        $row.append(this._createCell(item, field));
      });
      return this;
    },
    _createCell: function _createCell(item, field) {
      var $result;
      var fieldValue = this._getItemFieldValue(item, field);
      var args = {
        value: fieldValue,
        item: item
      };
      if ($.isFunction(field.cellRenderer)) {
        $result = this.renderTemplate(field.cellRenderer, field, args);
      } else {
        $result = $("<td>").append(this.renderTemplate(field.itemTemplate || fieldValue, field, args));
      }
      return this._prepareCell($result, field);
    },
    _getItemFieldValue: function _getItemFieldValue(item, field) {
      var props = field.name.split('.');
      var result = item[props.shift()];
      while (result && props.length) {
        result = result[props.shift()];
      }
      return result;
    },
    _setItemFieldValue: function _setItemFieldValue(item, field, value) {
      var props = field.name.split('.');
      var current = item;
      var prop = props[0];
      while (current && props.length) {
        item = current;
        prop = props.shift();
        current = item[prop];
      }
      if (!current) {
        while (props.length) {
          item = item[prop] = {};
          prop = props.shift();
        }
      }
      item[prop] = value;
    },
    sort: function sort(field, order) {
      if ($.isPlainObject(field)) {
        order = field.order;
        field = field.field;
      }
      this._clearSortingCss();
      this._setSortingParams(field, order);
      this._setSortingCss();
      return this._loadStrategy.sort();
    },
    _clearSortingCss: function _clearSortingCss() {
      this._headerRow.find("th").removeClass(this.sortAscClass).removeClass(this.sortDescClass);
    },
    _setSortingParams: function _setSortingParams(field, order) {
      field = this._normalizeField(field);
      order = order || (this._sortField === field ? this._reversedSortOrder(this._sortOrder) : SORT_ORDER_ASC);
      this._sortField = field;
      this._sortOrder = order;
    },
    _normalizeField: function _normalizeField(field) {
      if ($.isNumeric(field)) {
        return this.fields[field];
      }
      if (typeof field === "string") {
        return $.grep(this.fields, function (f) {
          return f.name === field;
        })[0];
      }
      return field;
    },
    _reversedSortOrder: function _reversedSortOrder(order) {
      return order === SORT_ORDER_ASC ? SORT_ORDER_DESC : SORT_ORDER_ASC;
    },
    _setSortingCss: function _setSortingCss() {
      var fieldIndex = this._visibleFieldIndex(this._sortField);
      this._headerRow.find("th").eq(fieldIndex).addClass(this._sortOrder === SORT_ORDER_ASC ? this.sortAscClass : this.sortDescClass);
    },
    _visibleFieldIndex: function _visibleFieldIndex(field) {
      return $.inArray(field, $.grep(this.fields, function (f) {
        return f.visible;
      }));
    },
    _sortData: function _sortData() {
      var sortFactor = this._sortFactor(),
        sortField = this._sortField;
      if (sortField) {
        this.data.sort(function (item1, item2) {
          return sortFactor * sortField.sortingFunc(item1[sortField.name], item2[sortField.name]);
        });
      }
    },
    _sortFactor: function _sortFactor() {
      return this._sortOrder === SORT_ORDER_ASC ? 1 : -1;
    },
    _itemsCount: function _itemsCount() {
      return this._loadStrategy.itemsCount();
    },
    _pagesCount: function _pagesCount() {
      var itemsCount = this._itemsCount(),
        pageSize = this.pageSize;
      return Math.floor(itemsCount / pageSize) + (itemsCount % pageSize ? 1 : 0);
    },
    _refreshPager: function _refreshPager() {
      var $pagerContainer = this._pagerContainer;
      $pagerContainer.empty();
      if (this.paging) {
        $pagerContainer.append(this._createPager());
      }
      var showPager = this.paging && this._pagesCount() > 1;
      $pagerContainer.toggle(showPager);
    },
    _createPager: function _createPager() {
      var $result;
      if ($.isFunction(this.pagerRenderer)) {
        $result = $(this.pagerRenderer({
          pageIndex: this.pageIndex,
          pageCount: this._pagesCount()
        }));
      } else {
        $result = $("<div>").append(this._createPagerByFormat());
      }
      $result.addClass(this.pagerClass);
      return $result;
    },
    _createPagerByFormat: function _createPagerByFormat() {
      var pageIndex = this.pageIndex,
        pageCount = this._pagesCount(),
        itemCount = this._itemsCount(),
        pagerParts = this.pagerFormat.split(" ");
      return $.map(pagerParts, $.proxy(function (pagerPart) {
        var result = pagerPart;
        if (pagerPart === PAGES_PLACEHOLDER) {
          result = this._createPages();
        } else if (pagerPart === FIRST_PAGE_PLACEHOLDER) {
          result = this._createPagerNavButton(this.pageFirstText, 1, pageIndex > 1);
        } else if (pagerPart === PREV_PAGE_PLACEHOLDER) {
          result = this._createPagerNavButton(this.pagePrevText, pageIndex - 1, pageIndex > 1);
        } else if (pagerPart === NEXT_PAGE_PLACEHOLDER) {
          result = this._createPagerNavButton(this.pageNextText, pageIndex + 1, pageIndex < pageCount);
        } else if (pagerPart === LAST_PAGE_PLACEHOLDER) {
          result = this._createPagerNavButton(this.pageLastText, pageCount, pageIndex < pageCount);
        } else if (pagerPart === PAGE_INDEX_PLACEHOLDER) {
          result = pageIndex;
        } else if (pagerPart === PAGE_COUNT_PLACEHOLDER) {
          result = pageCount;
        } else if (pagerPart === ITEM_COUNT_PLACEHOLDER) {
          result = itemCount;
        }
        return $.isArray(result) ? result.concat([" "]) : [result, " "];
      }, this));
    },
    _createPages: function _createPages() {
      var pageCount = this._pagesCount(),
        pageButtonCount = this.pageButtonCount,
        firstDisplayingPage = this._firstDisplayingPage,
        pages = [];
      if (firstDisplayingPage > 1) {
        pages.push(this._createPagerPageNavButton(this.pageNavigatorPrevText, this.showPrevPages));
      }
      for (var i = 0, pageNumber = firstDisplayingPage; i < pageButtonCount && pageNumber <= pageCount; i++, pageNumber++) {
        pages.push(pageNumber === this.pageIndex ? this._createPagerCurrentPage() : this._createPagerPage(pageNumber));
      }
      if (firstDisplayingPage + pageButtonCount - 1 < pageCount) {
        pages.push(this._createPagerPageNavButton(this.pageNavigatorNextText, this.showNextPages));
      }
      return pages;
    },
    _createPagerNavButton: function _createPagerNavButton(text, pageIndex, isActive) {
      return this._createPagerButton(text, this.pagerNavButtonClass + (isActive ? "" : " " + this.pagerNavButtonInactiveClass), isActive ? function () {
        this.openPage(pageIndex);
      } : $.noop);
    },
    _createPagerPageNavButton: function _createPagerPageNavButton(text, handler) {
      return this._createPagerButton(text, this.pagerNavButtonClass, handler);
    },
    _createPagerPage: function _createPagerPage(pageIndex) {
      return this._createPagerButton(pageIndex, this.pageClass, function () {
        this.openPage(pageIndex);
      });
    },
    _createPagerButton: function _createPagerButton(text, css, handler) {
      var $link = $("<a>").attr("href", EMPTY_HREF).html(text).on("click", $.proxy(handler, this));
      return $("<span>").addClass(css).append($link);
    },
    _createPagerCurrentPage: function _createPagerCurrentPage() {
      return $("<span>").addClass(this.pageClass).addClass(this.currentPageClass).text(this.pageIndex);
    },
    _refreshSize: function _refreshSize() {
      this._refreshHeight();
      this._refreshWidth();
    },
    _refreshWidth: function _refreshWidth() {
      var width = this.width === "auto" ? this._getAutoWidth() : this.width;
      this._container.width(width);
    },
    _getAutoWidth: function _getAutoWidth() {
      var $headerGrid = this._headerGrid,
        $header = this._header;
      $headerGrid.width("auto");
      var contentWidth = $headerGrid.outerWidth();
      var borderWidth = $header.outerWidth() - $header.innerWidth();
      $headerGrid.width("");
      return contentWidth + borderWidth;
    },
    _scrollBarWidth: function () {
      var result;
      return function () {
        if (result === undefined) {
          var $ghostContainer = $("<div style='width:50px;height:50px;overflow:hidden;position:absolute;top:-10000px;left:-10000px;'></div>");
          var $ghostContent = $("<div style='height:100px;'></div>");
          $ghostContainer.append($ghostContent).appendTo("body");
          var width = $ghostContent.innerWidth();
          $ghostContainer.css("overflow-y", "auto");
          var widthExcludingScrollBar = $ghostContent.innerWidth();
          $ghostContainer.remove();
          result = width - widthExcludingScrollBar;
        }
        return result;
      };
    }(),
    _refreshHeight: function _refreshHeight() {
      var container = this._container,
        pagerContainer = this._pagerContainer,
        height = this.height,
        nonBodyHeight;
      container.height(height);
      if (height !== "auto") {
        height = container.height();
        nonBodyHeight = this._header.outerHeight(true);
        if (pagerContainer.parents(container).length) {
          nonBodyHeight += pagerContainer.outerHeight(true);
        }
        this._body.outerHeight(height - nonBodyHeight);
      }
    },
    showPrevPages: function showPrevPages() {
      var firstDisplayingPage = this._firstDisplayingPage,
        pageButtonCount = this.pageButtonCount;
      this._firstDisplayingPage = firstDisplayingPage > pageButtonCount ? firstDisplayingPage - pageButtonCount : 1;
      this._refreshPager();
    },
    showNextPages: function showNextPages() {
      var firstDisplayingPage = this._firstDisplayingPage,
        pageButtonCount = this.pageButtonCount,
        pageCount = this._pagesCount();
      this._firstDisplayingPage = firstDisplayingPage + 2 * pageButtonCount > pageCount ? pageCount - pageButtonCount + 1 : firstDisplayingPage + pageButtonCount;
      this._refreshPager();
    },
    openPage: function openPage(pageIndex) {
      if (pageIndex < 1 || pageIndex > this._pagesCount()) return;
      this._setPage(pageIndex);
      this._loadStrategy.openPage(pageIndex);
    },
    _setPage: function _setPage(pageIndex) {
      var firstDisplayingPage = this._firstDisplayingPage,
        pageButtonCount = this.pageButtonCount;
      this.pageIndex = pageIndex;
      if (pageIndex < firstDisplayingPage) {
        this._firstDisplayingPage = pageIndex;
      }
      if (pageIndex > firstDisplayingPage + pageButtonCount - 1) {
        this._firstDisplayingPage = pageIndex - pageButtonCount + 1;
      }
      this._callEventHandler(this.onPageChanged, {
        pageIndex: pageIndex
      });
    },
    _controllerCall: function _controllerCall(method, param, isCanceled, doneCallback) {
      if (isCanceled) return $.Deferred().reject().promise();
      this._showLoading();
      var controller = this._controller;
      if (!controller || !controller[method]) {
        throw Error("controller has no method '" + method + "'");
      }
      return normalizePromise(controller[method](param)).done($.proxy(doneCallback, this)).fail($.proxy(this._errorHandler, this)).always($.proxy(this._hideLoading, this));
    },
    _errorHandler: function _errorHandler() {
      this._callEventHandler(this.onError, {
        args: $.makeArray(arguments)
      });
    },
    _showLoading: function _showLoading() {
      if (!this.loadIndication) return;
      clearTimeout(this._loadingTimer);
      this._loadingTimer = setTimeout($.proxy(function () {
        this._loadIndicator.show();
      }, this), this.loadIndicationDelay);
    },
    _hideLoading: function _hideLoading() {
      if (!this.loadIndication) return;
      clearTimeout(this._loadingTimer);
      this._loadIndicator.hide();
    },
    search: function search(filter) {
      this._resetSorting();
      this._resetPager();
      return this.loadData(filter);
    },
    loadData: function loadData(filter) {
      filter = filter || (this.filtering ? this.getFilter() : {});
      $.extend(filter, this._loadStrategy.loadParams(), this._sortingParams());
      var args = this._callEventHandler(this.onDataLoading, {
        filter: filter
      });
      return this._controllerCall("loadData", filter, args.cancel, function (loadedData) {
        if (!loadedData) return;
        this._loadStrategy.finishLoad(loadedData);
        this._callEventHandler(this.onDataLoaded, {
          data: loadedData
        });
      });
    },
    getFilter: function getFilter() {
      var result = {};
      this._eachField(function (field) {
        if (field.filtering) {
          this._setItemFieldValue(result, field, field.filterValue());
        }
      });
      return result;
    },
    _sortingParams: function _sortingParams() {
      if (this.sorting && this._sortField) {
        return {
          sortField: this._sortField.name,
          sortOrder: this._sortOrder
        };
      }
      return {};
    },
    getSorting: function getSorting() {
      var sortingParams = this._sortingParams();
      return {
        field: sortingParams.sortField,
        order: sortingParams.sortOrder
      };
    },
    clearFilter: function clearFilter() {
      var $filterRow = this._createFilterRow();
      this._filterRow.replaceWith($filterRow);
      this._filterRow = $filterRow;
      return this.search();
    },
    insertItem: function insertItem(item) {
      var insertingItem = item || this._getValidatedInsertItem();
      if (!insertingItem) return $.Deferred().reject().promise();
      var args = this._callEventHandler(this.onItemInserting, {
        item: insertingItem
      });
      return this._controllerCall("insertItem", insertingItem, args.cancel, function (insertedItem) {
        insertedItem = insertedItem || insertingItem;
        this._loadStrategy.finishInsert(insertedItem);
        this._callEventHandler(this.onItemInserted, {
          item: insertedItem
        });
      });
    },
    _getValidatedInsertItem: function _getValidatedInsertItem() {
      var item = this._getInsertItem();
      return this._validateItem(item, this._insertRow) ? item : null;
    },
    _getInsertItem: function _getInsertItem() {
      var result = {};
      this._eachField(function (field) {
        if (field.inserting) {
          this._setItemFieldValue(result, field, field.insertValue());
        }
      });
      return result;
    },
    _validateItem: function _validateItem(item, $row) {
      var validationErrors = [];
      var args = {
        item: item,
        itemIndex: this._rowIndex($row),
        row: $row
      };
      this._eachField(function (field) {
        if (!field.validate || $row === this._insertRow && !field.inserting || $row === this._getEditRow() && !field.editing) return;
        var fieldValue = this._getItemFieldValue(item, field);
        var errors = this._validation.validate($.extend({
          value: fieldValue,
          rules: field.validate
        }, args));
        this._setCellValidity($row.children().eq(this._visibleFieldIndex(field)), errors);
        if (!errors.length) return;
        validationErrors.push.apply(validationErrors, $.map(errors, function (message) {
          return {
            field: field,
            message: message
          };
        }));
      });
      if (!validationErrors.length) return true;
      var invalidArgs = $.extend({
        errors: validationErrors
      }, args);
      this._callEventHandler(this.onItemInvalid, invalidArgs);
      this.invalidNotify(invalidArgs);
      return false;
    },
    _setCellValidity: function _setCellValidity($cell, errors) {
      $cell.toggleClass(this.invalidClass, !!errors.length).attr("title", errors.join("\n"));
    },
    clearInsert: function clearInsert() {
      var insertRow = this._createInsertRow();
      this._insertRow.replaceWith(insertRow);
      this._insertRow = insertRow;
      this.refresh();
    },
    editItem: function editItem(item) {
      var $row = this.rowByItem(item);
      if ($row.length) {
        this._editRow($row);
      }
    },
    rowByItem: function rowByItem(item) {
      if (item.jquery || item.nodeType) return $(item);
      return this._content.find("tr").filter(function () {
        return $.data(this, JSGRID_ROW_DATA_KEY) === item;
      });
    },
    _editRow: function _editRow($row) {
      if (!this.editing) return;
      var item = $row.data(JSGRID_ROW_DATA_KEY);
      var args = this._callEventHandler(this.onItemEditing, {
        row: $row,
        item: item,
        itemIndex: this._itemIndex(item)
      });
      if (args.cancel) return;
      if (this._editingRow) {
        this.cancelEdit();
      }
      var $editRow = this._createEditRow(item);
      this._editingRow = $row;
      $row.hide();
      $editRow.insertBefore($row);
      $row.data(JSGRID_EDIT_ROW_DATA_KEY, $editRow);
    },
    _createEditRow: function _createEditRow(item) {
      if ($.isFunction(this.editRowRenderer)) {
        return $(this.renderTemplate(this.editRowRenderer, this, {
          item: item,
          itemIndex: this._itemIndex(item)
        }));
      }
      var $result = $("<tr>").addClass(this.editRowClass);
      this._eachField(function (field) {
        var fieldValue = this._getItemFieldValue(item, field);
        this._prepareCell("<td>", field, "editcss").append(this.renderTemplate(field.editTemplate || "", field, {
          value: fieldValue,
          item: item
        })).appendTo($result);
      });
      return $result;
    },
    updateItem: function updateItem(item, editedItem) {
      if (arguments.length === 1) {
        editedItem = item;
      }
      var $row = item ? this.rowByItem(item) : this._editingRow;
      editedItem = editedItem || this._getValidatedEditedItem();
      if (!editedItem) return;
      return this._updateRow($row, editedItem);
    },
    _getValidatedEditedItem: function _getValidatedEditedItem() {
      var item = this._getEditedItem();
      return this._validateItem(item, this._getEditRow()) ? item : null;
    },
    _updateRow: function _updateRow($updatingRow, editedItem) {
      var updatingItem = $updatingRow.data(JSGRID_ROW_DATA_KEY),
        updatingItemIndex = this._itemIndex(updatingItem),
        updatedItem = $.extend(true, {}, updatingItem, editedItem);
      var args = this._callEventHandler(this.onItemUpdating, {
        row: $updatingRow,
        item: updatedItem,
        itemIndex: updatingItemIndex,
        previousItem: updatingItem
      });
      return this._controllerCall("updateItem", updatedItem, args.cancel, function (loadedUpdatedItem) {
        var previousItem = $.extend(true, {}, updatingItem);
        updatedItem = loadedUpdatedItem || $.extend(true, updatingItem, editedItem);
        var $updatedRow = this._finishUpdate($updatingRow, updatedItem, updatingItemIndex);
        this._callEventHandler(this.onItemUpdated, {
          row: $updatedRow,
          item: updatedItem,
          itemIndex: updatingItemIndex,
          previousItem: previousItem
        });
      });
    },
    _rowIndex: function _rowIndex(row) {
      return this._content.children().index($(row));
    },
    _itemIndex: function _itemIndex(item) {
      return $.inArray(item, this.data);
    },
    _finishUpdate: function _finishUpdate($updatingRow, updatedItem, updatedItemIndex) {
      this.cancelEdit();
      this.data[updatedItemIndex] = updatedItem;
      var $updatedRow = this._createRow(updatedItem, updatedItemIndex);
      $updatingRow.replaceWith($updatedRow);
      return $updatedRow;
    },
    _getEditedItem: function _getEditedItem() {
      var result = {};
      this._eachField(function (field) {
        if (field.editing) {
          this._setItemFieldValue(result, field, field.editValue());
        }
      });
      return result;
    },
    cancelEdit: function cancelEdit() {
      if (!this._editingRow) return;
      this._getEditRow().remove();
      this._editingRow.show();
      this._editingRow = null;
    },
    _getEditRow: function _getEditRow() {
      return this._editingRow && this._editingRow.data(JSGRID_EDIT_ROW_DATA_KEY);
    },
    deleteItem: function deleteItem(item) {
      var $row = this.rowByItem(item);
      if (!$row.length) return;
      if (this.confirmDeleting && !window.confirm(getOrApply(this.deleteConfirm, this, $row.data(JSGRID_ROW_DATA_KEY)))) return;
      return this._deleteRow($row);
    },
    _deleteRow: function _deleteRow($row) {
      var deletingItem = $row.data(JSGRID_ROW_DATA_KEY),
        deletingItemIndex = this._itemIndex(deletingItem);
      var args = this._callEventHandler(this.onItemDeleting, {
        row: $row,
        item: deletingItem,
        itemIndex: deletingItemIndex
      });
      return this._controllerCall("deleteItem", deletingItem, args.cancel, function () {
        this._loadStrategy.finishDelete(deletingItem, deletingItemIndex);
        this._callEventHandler(this.onItemDeleted, {
          row: $row,
          item: deletingItem,
          itemIndex: deletingItemIndex
        });
      });
    }
  };
  $.fn.jsGrid = function (config) {
    var args = $.makeArray(arguments),
      methodArgs = args.slice(1),
      result = this;
    this.each(function () {
      var $element = $(this),
        instance = $element.data(JSGRID_DATA_KEY),
        methodResult;
      if (instance) {
        if (typeof config === "string") {
          methodResult = instance[config].apply(instance, methodArgs);
          if (methodResult !== undefined && methodResult !== instance) {
            result = methodResult;
            return false;
          }
        } else {
          instance._detachWindowResizeCallback();
          instance._init(config);
          instance.render();
        }
      } else {
        new Grid($element, config);
      }
    });
    return result;
  };
  var fields = {};
  var setDefaults = function setDefaults(config) {
    var componentPrototype;
    if ($.isPlainObject(config)) {
      componentPrototype = Grid.prototype;
    } else {
      componentPrototype = fields[config].prototype;
      config = arguments[1] || {};
    }
    $.extend(componentPrototype, config);
  };
  var locales = {};
  var locale = function locale(lang) {
    var localeConfig = $.isPlainObject(lang) ? lang : locales[lang];
    if (!localeConfig) throw Error("unknown locale " + lang);
    setLocale(jsGrid, localeConfig);
  };
  var setLocale = function setLocale(obj, localeConfig) {
    $.each(localeConfig, function (field, value) {
      if ($.isPlainObject(value)) {
        setLocale(obj[field] || obj[field[0].toUpperCase() + field.slice(1)], value);
        return;
      }
      if (obj.hasOwnProperty(field)) {
        obj[field] = value;
      } else {
        obj.prototype[field] = value;
      }
    });
  };
  window.jsGrid = {
    Grid: Grid,
    fields: fields,
    setDefaults: setDefaults,
    locales: locales,
    locale: locale,
    version: '1.5.3'
  };
})(window, jQuery);
(function (jsGrid, $, undefined) {
  function LoadIndicator(config) {
    this._init(config);
  }
  LoadIndicator.prototype = {
    container: "body",
    message: "Loading...",
    shading: true,
    zIndex: 1000,
    shaderClass: "jsgrid-load-shader",
    loadPanelClass: "jsgrid-load-panel",
    _init: function _init(config) {
      $.extend(true, this, config);
      this._initContainer();
      this._initShader();
      this._initLoadPanel();
    },
    _initContainer: function _initContainer() {
      this._container = $(this.container);
    },
    _initShader: function _initShader() {
      if (!this.shading) return;
      this._shader = $("<div>").addClass(this.shaderClass).hide().css({
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        zIndex: this.zIndex
      }).appendTo(this._container);
    },
    _initLoadPanel: function _initLoadPanel() {
      this._loadPanel = $("<div>").addClass(this.loadPanelClass).text(this.message).hide().css({
        position: "absolute",
        top: "50%",
        left: "50%",
        zIndex: this.zIndex
      }).appendTo(this._container);
    },
    show: function show() {
      var $loadPanel = this._loadPanel.show();
      var actualWidth = $loadPanel.outerWidth();
      var actualHeight = $loadPanel.outerHeight();
      $loadPanel.css({
        marginTop: -actualHeight / 2,
        marginLeft: -actualWidth / 2
      });
      this._shader.show();
    },
    hide: function hide() {
      this._loadPanel.hide();
      this._shader.hide();
    }
  };
  jsGrid.LoadIndicator = LoadIndicator;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  function DirectLoadingStrategy(grid) {
    this._grid = grid;
  }
  DirectLoadingStrategy.prototype = {
    firstDisplayIndex: function firstDisplayIndex() {
      var grid = this._grid;
      return grid.option("paging") ? (grid.option("pageIndex") - 1) * grid.option("pageSize") : 0;
    },
    lastDisplayIndex: function lastDisplayIndex() {
      var grid = this._grid;
      var itemsCount = grid.option("data").length;
      return grid.option("paging") ? Math.min(grid.option("pageIndex") * grid.option("pageSize"), itemsCount) : itemsCount;
    },
    itemsCount: function itemsCount() {
      return this._grid.option("data").length;
    },
    openPage: function openPage(index) {
      this._grid.refresh();
    },
    loadParams: function loadParams() {
      return {};
    },
    sort: function sort() {
      this._grid._sortData();
      this._grid.refresh();
      return $.Deferred().resolve().promise();
    },
    reset: function reset() {
      this._grid.refresh();
      return $.Deferred().resolve().promise();
    },
    finishLoad: function finishLoad(loadedData) {
      this._grid.option("data", loadedData);
    },
    finishInsert: function finishInsert(insertedItem) {
      var grid = this._grid;
      grid.option("data").push(insertedItem);
      grid.refresh();
    },
    finishDelete: function finishDelete(deletedItem, deletedItemIndex) {
      var grid = this._grid;
      grid.option("data").splice(deletedItemIndex, 1);
      grid.reset();
    }
  };
  function PageLoadingStrategy(grid) {
    this._grid = grid;
    this._itemsCount = 0;
  }
  PageLoadingStrategy.prototype = {
    firstDisplayIndex: function firstDisplayIndex() {
      return 0;
    },
    lastDisplayIndex: function lastDisplayIndex() {
      return this._grid.option("data").length;
    },
    itemsCount: function itemsCount() {
      return this._itemsCount;
    },
    openPage: function openPage(index) {
      this._grid.loadData();
    },
    loadParams: function loadParams() {
      var grid = this._grid;
      return {
        pageIndex: grid.option("pageIndex"),
        pageSize: grid.option("pageSize")
      };
    },
    reset: function reset() {
      return this._grid.loadData();
    },
    sort: function sort() {
      return this._grid.loadData();
    },
    finishLoad: function finishLoad(loadedData) {
      this._itemsCount = loadedData.itemsCount;
      this._grid.option("data", loadedData.data);
    },
    finishInsert: function finishInsert(insertedItem) {
      this._grid.search();
    },
    finishDelete: function finishDelete(deletedItem, deletedItemIndex) {
      this._grid.search();
    }
  };
  jsGrid.loadStrategies = {
    DirectLoadingStrategy: DirectLoadingStrategy,
    PageLoadingStrategy: PageLoadingStrategy
  };
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var isDefined = function isDefined(val) {
    return typeof val !== "undefined" && val !== null;
  };
  var sortStrategies = {
    string: function string(str1, str2) {
      if (!isDefined(str1) && !isDefined(str2)) return 0;
      if (!isDefined(str1)) return -1;
      if (!isDefined(str2)) return 1;
      return ("" + str1).localeCompare("" + str2);
    },
    number: function number(n1, n2) {
      return n1 - n2;
    },
    date: function date(dt1, dt2) {
      return dt1 - dt2;
    },
    numberAsString: function numberAsString(n1, n2) {
      return parseFloat(n1) - parseFloat(n2);
    }
  };
  jsGrid.sortStrategies = sortStrategies;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  function Validation(config) {
    this._init(config);
  }
  Validation.prototype = {
    _init: function _init(config) {
      $.extend(true, this, config);
    },
    validate: function validate(args) {
      var errors = [];
      $.each(this._normalizeRules(args.rules), function (_, rule) {
        if (rule.validator(args.value, args.item, rule.param)) return;
        var errorMessage = $.isFunction(rule.message) ? rule.message(args.value, args.item) : rule.message;
        errors.push(errorMessage);
      });
      return errors;
    },
    _normalizeRules: function _normalizeRules(rules) {
      if (!$.isArray(rules)) rules = [rules];
      return $.map(rules, $.proxy(function (rule) {
        return this._normalizeRule(rule);
      }, this));
    },
    _normalizeRule: function _normalizeRule(rule) {
      if (typeof rule === "string") rule = {
        validator: rule
      };
      if ($.isFunction(rule)) rule = {
        validator: rule
      };
      if ($.isPlainObject(rule)) rule = $.extend({}, rule);else throw Error("wrong validation config specified");
      if ($.isFunction(rule.validator)) return rule;
      return this._applyNamedValidator(rule, rule.validator);
    },
    _applyNamedValidator: function _applyNamedValidator(rule, validatorName) {
      delete rule.validator;
      var validator = validators[validatorName];
      if (!validator) throw Error("unknown validator \"" + validatorName + "\"");
      if ($.isFunction(validator)) {
        validator = {
          validator: validator
        };
      }
      return $.extend({}, validator, rule);
    }
  };
  jsGrid.Validation = Validation;
  var validators = {
    required: {
      message: "Field is required",
      validator: function validator(value) {
        return value !== undefined && value !== null && value !== "";
      }
    },
    rangeLength: {
      message: "Field value length is out of the defined range",
      validator: function validator(value, _, param) {
        return value.length >= param[0] && value.length <= param[1];
      }
    },
    minLength: {
      message: "Field value is too short",
      validator: function validator(value, _, param) {
        return value.length >= param;
      }
    },
    maxLength: {
      message: "Field value is too long",
      validator: function validator(value, _, param) {
        return value.length <= param;
      }
    },
    pattern: {
      message: "Field value is not matching the defined pattern",
      validator: function validator(value, _, param) {
        if (typeof param === "string") {
          param = new RegExp("^(?:" + param + ")$");
        }
        return param.test(value);
      }
    },
    range: {
      message: "Field value is out of the defined range",
      validator: function validator(value, _, param) {
        return value >= param[0] && value <= param[1];
      }
    },
    min: {
      message: "Field value is too small",
      validator: function validator(value, _, param) {
        return value >= param;
      }
    },
    max: {
      message: "Field value is too large",
      validator: function validator(value, _, param) {
        return value <= param;
      }
    }
  };
  jsGrid.validators = validators;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  function Field(config) {
    $.extend(true, this, config);
    this.sortingFunc = this._getSortingFunc();
  }
  Field.prototype = {
    name: "",
    title: null,
    css: "",
    align: "",
    width: 100,
    visible: true,
    filtering: true,
    inserting: true,
    editing: true,
    sorting: true,
    sorter: "string",
    // name of SortStrategy or function to compare elements

    headerTemplate: function headerTemplate() {
      return this.title === undefined || this.title === null ? this.name : this.title;
    },
    itemTemplate: function itemTemplate(value, item) {
      return value;
    },
    filterTemplate: function filterTemplate() {
      return "";
    },
    insertTemplate: function insertTemplate() {
      return "";
    },
    editTemplate: function editTemplate(value, item) {
      this._value = value;
      return this.itemTemplate(value, item);
    },
    filterValue: function filterValue() {
      return "";
    },
    insertValue: function insertValue() {
      return "";
    },
    editValue: function editValue() {
      return this._value;
    },
    _getSortingFunc: function _getSortingFunc() {
      var sorter = this.sorter;
      if ($.isFunction(sorter)) {
        return sorter;
      }
      if (typeof sorter === "string") {
        return jsGrid.sortStrategies[sorter];
      }
      throw Error("wrong sorter for the field \"" + this.name + "\"!");
    }
  };
  jsGrid.Field = Field;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var Field = jsGrid.Field;
  function TextField(config) {
    Field.call(this, config);
  }
  TextField.prototype = new Field({
    autosearch: true,
    readOnly: false,
    filterTemplate: function filterTemplate() {
      if (!this.filtering) return "";
      var grid = this._grid,
        $result = this.filterControl = this._createTextBox();
      if (this.autosearch) {
        $result.on("keypress", function (e) {
          if (e.which === 13) {
            grid.search();
            e.preventDefault();
          }
        });
      }
      return $result;
    },
    insertTemplate: function insertTemplate() {
      if (!this.inserting) return "";
      return this.insertControl = this._createTextBox();
    },
    editTemplate: function editTemplate(value) {
      if (!this.editing) return this.itemTemplate.apply(this, arguments);
      var $result = this.editControl = this._createTextBox();
      $result.val(value);
      return $result;
    },
    filterValue: function filterValue() {
      return this.filterControl.val();
    },
    insertValue: function insertValue() {
      return this.insertControl.val();
    },
    editValue: function editValue() {
      return this.editControl.val();
    },
    _createTextBox: function _createTextBox() {
      return $("<input>").attr("type", "text").prop("readonly", !!this.readOnly);
    }
  });
  jsGrid.fields.text = jsGrid.TextField = TextField;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var TextField = jsGrid.TextField;
  function NumberField(config) {
    TextField.call(this, config);
  }
  NumberField.prototype = new TextField({
    sorter: "number",
    align: "right",
    readOnly: false,
    filterValue: function filterValue() {
      return this.filterControl.val() ? parseInt(this.filterControl.val() || 0, 10) : undefined;
    },
    insertValue: function insertValue() {
      return this.insertControl.val() ? parseInt(this.insertControl.val() || 0, 10) : undefined;
    },
    editValue: function editValue() {
      return this.editControl.val() ? parseInt(this.editControl.val() || 0, 10) : undefined;
    },
    _createTextBox: function _createTextBox() {
      return $("<input>").attr("type", "number").prop("readonly", !!this.readOnly);
    }
  });
  jsGrid.fields.number = jsGrid.NumberField = NumberField;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var TextField = jsGrid.TextField;
  function TextAreaField(config) {
    TextField.call(this, config);
  }
  TextAreaField.prototype = new TextField({
    insertTemplate: function insertTemplate() {
      if (!this.inserting) return "";
      return this.insertControl = this._createTextArea();
    },
    editTemplate: function editTemplate(value) {
      if (!this.editing) return this.itemTemplate.apply(this, arguments);
      var $result = this.editControl = this._createTextArea();
      $result.val(value);
      return $result;
    },
    _createTextArea: function _createTextArea() {
      return $("<textarea>").prop("readonly", !!this.readOnly);
    }
  });
  jsGrid.fields.textarea = jsGrid.TextAreaField = TextAreaField;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var NumberField = jsGrid.NumberField;
  var numberValueType = "number";
  var stringValueType = "string";
  function SelectField(config) {
    this.items = [];
    this.selectedIndex = -1;
    this.valueField = "";
    this.textField = "";
    if (config.valueField && config.items.length) {
      var firstItemValue = config.items[0][config.valueField];
      this.valueType = _typeof(firstItemValue) === numberValueType ? numberValueType : stringValueType;
    }
    this.sorter = this.valueType;
    NumberField.call(this, config);
  }
  SelectField.prototype = new NumberField({
    align: "center",
    valueType: numberValueType,
    itemTemplate: function itemTemplate(value) {
      var items = this.items,
        valueField = this.valueField,
        textField = this.textField,
        resultItem;
      if (valueField) {
        resultItem = $.grep(items, function (item, index) {
          return item[valueField] === value;
        })[0] || {};
      } else {
        resultItem = items[value];
      }
      var result = textField ? resultItem[textField] : resultItem;
      return result === undefined || result === null ? "" : result;
    },
    filterTemplate: function filterTemplate() {
      if (!this.filtering) return "";
      var grid = this._grid,
        $result = this.filterControl = this._createSelect();
      if (this.autosearch) {
        $result.on("change", function (e) {
          grid.search();
        });
      }
      return $result;
    },
    insertTemplate: function insertTemplate() {
      if (!this.inserting) return "";
      return this.insertControl = this._createSelect();
    },
    editTemplate: function editTemplate(value) {
      if (!this.editing) return this.itemTemplate.apply(this, arguments);
      var $result = this.editControl = this._createSelect();
      value !== undefined && $result.val(value);
      return $result;
    },
    filterValue: function filterValue() {
      var val = this.filterControl.val();
      return this.valueType === numberValueType ? parseInt(val || 0, 10) : val;
    },
    insertValue: function insertValue() {
      var val = this.insertControl.val();
      return this.valueType === numberValueType ? parseInt(val || 0, 10) : val;
    },
    editValue: function editValue() {
      var val = this.editControl.val();
      return this.valueType === numberValueType ? parseInt(val || 0, 10) : val;
    },
    _createSelect: function _createSelect() {
      var $result = $("<select>"),
        valueField = this.valueField,
        textField = this.textField,
        selectedIndex = this.selectedIndex;
      $.each(this.items, function (index, item) {
        var value = valueField ? item[valueField] : index,
          text = textField ? item[textField] : item;
        var $option = $("<option>").attr("value", value).text(text).appendTo($result);
        $option.prop("selected", selectedIndex === index);
      });
      $result.prop("disabled", !!this.readOnly);
      return $result;
    }
  });
  jsGrid.fields.select = jsGrid.SelectField = SelectField;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var Field = jsGrid.Field;
  function CheckboxField(config) {
    Field.call(this, config);
  }
  CheckboxField.prototype = new Field({
    sorter: "number",
    align: "center",
    autosearch: true,
    itemTemplate: function itemTemplate(value) {
      return this._createCheckbox().prop({
        checked: value,
        disabled: true
      });
    },
    filterTemplate: function filterTemplate() {
      if (!this.filtering) return "";
      var grid = this._grid,
        $result = this.filterControl = this._createCheckbox();
      $result.prop({
        readOnly: true,
        indeterminate: true
      });
      $result.on("click", function () {
        var $cb = $(this);
        if ($cb.prop("readOnly")) {
          $cb.prop({
            checked: false,
            readOnly: false
          });
        } else if (!$cb.prop("checked")) {
          $cb.prop({
            readOnly: true,
            indeterminate: true
          });
        }
      });
      if (this.autosearch) {
        $result.on("click", function () {
          grid.search();
        });
      }
      return $result;
    },
    insertTemplate: function insertTemplate() {
      if (!this.inserting) return "";
      return this.insertControl = this._createCheckbox();
    },
    editTemplate: function editTemplate(value) {
      if (!this.editing) return this.itemTemplate.apply(this, arguments);
      var $result = this.editControl = this._createCheckbox();
      $result.prop("checked", value);
      return $result;
    },
    filterValue: function filterValue() {
      return this.filterControl.get(0).indeterminate ? undefined : this.filterControl.is(":checked");
    },
    insertValue: function insertValue() {
      return this.insertControl.is(":checked");
    },
    editValue: function editValue() {
      return this.editControl.is(":checked");
    },
    _createCheckbox: function _createCheckbox() {
      return $("<input>").attr("type", "checkbox");
    }
  });
  jsGrid.fields.checkbox = jsGrid.CheckboxField = CheckboxField;
})(jsGrid, jQuery);
(function (jsGrid, $, undefined) {
  var Field = jsGrid.Field;
  function ControlField(config) {
    Field.call(this, config);
    this._configInitialized = false;
  }
  ControlField.prototype = new Field({
    css: "jsgrid-control-field",
    align: "center",
    width: 50,
    filtering: false,
    inserting: false,
    editing: false,
    sorting: false,
    buttonClass: "jsgrid-button",
    modeButtonClass: "jsgrid-mode-button",
    modeOnButtonClass: "jsgrid-mode-on-button",
    searchModeButtonClass: "jsgrid-search-mode-button",
    insertModeButtonClass: "jsgrid-insert-mode-button",
    editButtonClass: "jsgrid-edit-button",
    deleteButtonClass: "jsgrid-delete-button",
    searchButtonClass: "jsgrid-search-button",
    clearFilterButtonClass: "jsgrid-clear-filter-button",
    insertButtonClass: "jsgrid-insert-button",
    updateButtonClass: "jsgrid-update-button",
    cancelEditButtonClass: "jsgrid-cancel-edit-button",
    searchModeButtonTooltip: "Switch to searching",
    insertModeButtonTooltip: "Switch to inserting",
    editButtonTooltip: "Edit",
    deleteButtonTooltip: "Delete",
    searchButtonTooltip: "Search",
    clearFilterButtonTooltip: "Clear filter",
    insertButtonTooltip: "Insert",
    updateButtonTooltip: "Update",
    cancelEditButtonTooltip: "Cancel edit",
    editButton: true,
    deleteButton: true,
    clearFilterButton: true,
    modeSwitchButton: true,
    _initConfig: function _initConfig() {
      this._hasFiltering = this._grid.filtering;
      this._hasInserting = this._grid.inserting;
      if (this._hasInserting && this.modeSwitchButton) {
        this._grid.inserting = false;
      }
      this._configInitialized = true;
    },
    headerTemplate: function headerTemplate() {
      if (!this._configInitialized) {
        this._initConfig();
      }
      var hasFiltering = this._hasFiltering;
      var hasInserting = this._hasInserting;
      if (!this.modeSwitchButton || !hasFiltering && !hasInserting) return "";
      if (hasFiltering && !hasInserting) return this._createFilterSwitchButton();
      if (hasInserting && !hasFiltering) return this._createInsertSwitchButton();
      return this._createModeSwitchButton();
    },
    itemTemplate: function itemTemplate(value, item) {
      var $result = $([]);
      if (this.editButton) {
        $result = $result.add(this._createEditButton(item));
      }
      if (this.deleteButton) {
        $result = $result.add(this._createDeleteButton(item));
      }
      return $result;
    },
    filterTemplate: function filterTemplate() {
      var $result = this._createSearchButton();
      return this.clearFilterButton ? $result.add(this._createClearFilterButton()) : $result;
    },
    insertTemplate: function insertTemplate() {
      return this._createInsertButton();
    },
    editTemplate: function editTemplate() {
      return this._createUpdateButton().add(this._createCancelEditButton());
    },
    _createFilterSwitchButton: function _createFilterSwitchButton() {
      return this._createOnOffSwitchButton("filtering", this.searchModeButtonClass, true);
    },
    _createInsertSwitchButton: function _createInsertSwitchButton() {
      return this._createOnOffSwitchButton("inserting", this.insertModeButtonClass, false);
    },
    _createOnOffSwitchButton: function _createOnOffSwitchButton(option, cssClass, isOnInitially) {
      var isOn = isOnInitially;
      var updateButtonState = $.proxy(function () {
        $button.toggleClass(this.modeOnButtonClass, isOn);
      }, this);
      var $button = this._createGridButton(this.modeButtonClass + " " + cssClass, "", function (grid) {
        isOn = !isOn;
        grid.option(option, isOn);
        updateButtonState();
      });
      updateButtonState();
      return $button;
    },
    _createModeSwitchButton: function _createModeSwitchButton() {
      var isInserting = false;
      var updateButtonState = $.proxy(function () {
        $button.attr("title", isInserting ? this.searchModeButtonTooltip : this.insertModeButtonTooltip).toggleClass(this.insertModeButtonClass, !isInserting).toggleClass(this.searchModeButtonClass, isInserting);
      }, this);
      var $button = this._createGridButton(this.modeButtonClass, "", function (grid) {
        isInserting = !isInserting;
        grid.option("inserting", isInserting);
        grid.option("filtering", !isInserting);
        updateButtonState();
      });
      updateButtonState();
      return $button;
    },
    _createEditButton: function _createEditButton(item) {
      return this._createGridButton(this.editButtonClass, this.editButtonTooltip, function (grid, e) {
        grid.editItem(item);
        e.stopPropagation();
      });
    },
    _createDeleteButton: function _createDeleteButton(item) {
      return this._createGridButton(this.deleteButtonClass, this.deleteButtonTooltip, function (grid, e) {
        grid.deleteItem(item);
        e.stopPropagation();
      });
    },
    _createSearchButton: function _createSearchButton() {
      return this._createGridButton(this.searchButtonClass, this.searchButtonTooltip, function (grid) {
        grid.search();
      });
    },
    _createClearFilterButton: function _createClearFilterButton() {
      return this._createGridButton(this.clearFilterButtonClass, this.clearFilterButtonTooltip, function (grid) {
        grid.clearFilter();
      });
    },
    _createInsertButton: function _createInsertButton() {
      return this._createGridButton(this.insertButtonClass, this.insertButtonTooltip, function (grid) {
        grid.insertItem().done(function () {
          grid.clearInsert();
        });
      });
    },
    _createUpdateButton: function _createUpdateButton() {
      return this._createGridButton(this.updateButtonClass, this.updateButtonTooltip, function (grid, e) {
        grid.updateItem();
        e.stopPropagation();
      });
    },
    _createCancelEditButton: function _createCancelEditButton() {
      return this._createGridButton(this.cancelEditButtonClass, this.cancelEditButtonTooltip, function (grid, e) {
        grid.cancelEdit();
        e.stopPropagation();
      });
    },
    _createGridButton: function _createGridButton(cls, tooltip, clickHandler) {
      var grid = this._grid;
      return $("<input>").addClass(this.buttonClass).addClass(cls).attr({
        type: "button",
        title: tooltip
      }).on("click", function (e) {
        clickHandler(grid, e);
      });
    },
    editValue: function editValue() {
      return "";
    }
  });
  jsGrid.fields.control = jsGrid.ControlField = ControlField;
})(jsGrid, jQuery);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js")))

/***/ }),

/***/ "./node_modules/koala-js/index.js":
/*!****************************************!*\
  !*** ./node_modules/koala-js/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var koalajs = {};

// pass an alternative default value
koalajs.d = koalajs.defaultValue = function defaultValue(obj, defValue) {
  if (obj === undefined) {
    if (typeof obj === "function") {
      return defValue();
    }
    return defValue;
  }
  return obj;
};

// alias for getElementById
koalajs.id = function mk(el) {
  return document.getElementById(el);
};

// alias for createElement
koalajs.mk = function mk(el) {
  return document.createElement(el);
};
if (module !== undefined && module.exports !== undefined) {
  module.exports = koalajs;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/menu-builder/index.js":
/*!********************************************!*\
  !*** ./node_modules/menu-builder/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/menubuilder */ "./node_modules/menu-builder/lib/menubuilder.js");

/***/ }),

/***/ "./node_modules/menu-builder/lib/menubuilder.js":
/*!******************************************************!*\
  !*** ./node_modules/menu-builder/lib/menubuilder.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MenuBuilder, jbone, view;
jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
module.exports = MenuBuilder = view.extend({
  initialize: function initialize(opts) {
    this._nodes = [];
    this.name = opts.name || "";
    this.el.className += "smenubar";
  },
  render: function render() {
    // remove all childs
    var fc = this.el.firstChild;
    while (fc) {
      this.el.removeChild(fc);
      fc = this.el.firstChild;
    }

    // replace child
    this.el.appendChild(this.buildDOM());
  },
  setName: function setName(name) {
    this.name = name;
  },
  addNode: function addNode(label, callback, opts) {
    var style;
    if (opts != null) {
      style = opts.style;
    }
    if (this._nodes == null) {
      this._nodes = [];
    }
    this._nodes.push({
      label: label,
      callback: callback,
      style: style
    });
  },
  getNode: function getNode(label) {
    var rNode = undefined;
    this._nodes.forEach(function (el) {
      if (el.label === label) {
        rNode = el;
      }
    });
    return rNode;
  },
  modifyNode: function modifyNode(label, callback, opts) {
    var node = this.getNode(label);
    node.callback = callback || node.callback;
    opts = opts || {};
    node.style = opts.style || node.style;
  },
  renameNode: function renameNode(label, newLabel) {
    var node = this.getNode(label);
    node.label = newLabel || node.label;
  },
  removeNode: function removeNode(label) {
    var node = this.getNode(label);
    this._nodes.splice(this._nodes.indexOf(node), 1);
  },
  removeAllNodes: function removeAllNodes() {
    this._nodes = [];
  },
  buildDOM: function buildDOM() {
    var span = document.createElement("span");
    span.appendChild(this._buildM({
      nodes: this._nodes,
      name: this.name
    }));
    return span;
  },
  _buildM: function _buildM(data) {
    var displayedButton, frag, key, li, node, style, _ref;
    var nodes = data.nodes;
    var name = data.name;
    var menu = document.createElement("div");
    menu.className = "smenu-dropdown smenu-dropdown-tip";
    menu.style.display = "none";
    var menuUl = document.createElement("ul");
    menuUl.className = "smenu-dropdown-menu";

    // currently we support one-level
    for (var i = 0, _len = nodes.length; i < _len; i++) {
      node = nodes[i];
      li = document.createElement("li");
      li.textContent = node.label;
      _ref = node.style;
      for (key in _ref) {
        style = _ref[key];
        li.style[key] = style;
      }
      li.addEventListener("click", node.callback);
      this.trigger("new:node", li);
      menuUl.appendChild(li);
    }
    this.trigger("new:menu", menuUl);
    menu.appendChild(menuUl);
    displayedButton = document.createElement("a");
    displayedButton.textContent = name;
    displayedButton.className = "smenubar_alink";
    this.trigger("new:button", displayedButton);

    // HACK to be able to hide the submenu
    // listens globally for click events
    jbone(displayedButton).on("click", function (_this) {
      return function (e) {
        _this._showMenu(e, menu, displayedButton);
        return window.setTimeout(function () {
          return jbone(document.body).one("click", function (e) {
            return menu.style.display = "none";
          });
        }, 5);
      };
    }(this));
    frag = document.createDocumentFragment();
    frag.appendChild(menu);
    frag.appendChild(displayedButton);
    return frag;
  },
  // internal method to display the lower menu on a click
  _showMenu: function _showMenu(e, menu, target) {
    var rect;
    menu.style.display = "block";
    menu.style.position = "absolute";
    rect = target.getBoundingClientRect();
    menu.style.left = rect.left + "px";
    menu.style.top = rect.top + target.offsetHeight + "px";
  }
});

/***/ }),

/***/ "./node_modules/moment/locale sync recursive ^\\.\\/.*$":
/*!**************************************************!*\
  !*** ./node_modules/moment/locale sync ^\.\/.*$ ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-SG": "./node_modules/moment/locale/en-SG.js",
	"./en-SG.js": "./node_modules/moment/locale/en-SG.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-il": "./node_modules/moment/locale/en-il.js",
	"./en-il.js": "./node_modules/moment/locale/en-il.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./ga": "./node_modules/moment/locale/ga.js",
	"./ga.js": "./node_modules/moment/locale/ga.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it-ch": "./node_modules/moment/locale/it-ch.js",
	"./it-ch.js": "./node_modules/moment/locale/it-ch.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ku": "./node_modules/moment/locale/ku.js",
	"./ku.js": "./node_modules/moment/locale/ku.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mn": "./node_modules/moment/locale/mn.js",
	"./mn.js": "./node_modules/moment/locale/mn.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./mt": "./node_modules/moment/locale/mt.js",
	"./mt.js": "./node_modules/moment/locale/mt.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./tg": "./node_modules/moment/locale/tg.js",
	"./tg.js": "./node_modules/moment/locale/tg.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./ug-cn": "./node_modules/moment/locale/ug-cn.js",
	"./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/moment/locale/af.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/af.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var af = moment.defineLocale('af', {
    months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM: function isPM(input) {
      return /^nm$/i.test(input);
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'vm' : 'VM';
      } else {
        return isLower ? 'nm' : 'NM';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Vandag om] LT',
      nextDay: '[Mre om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[Gister om] LT',
      lastWeek: '[Laas] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oor %s',
      past: '%s gelede',
      s: '\'n paar sekondes',
      ss: '%d sekondes',
      m: '\'n minuut',
      mm: '%d minute',
      h: '\'n uur',
      hh: '%d ure',
      d: '\'n dag',
      dd: '%d dae',
      M: '\'n maand',
      MM: '%d maande',
      y: '\'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week: {
      dow: 1,
      // Maandag is die eerste dag van die week.
      doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
  });
  return af;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-dz.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-dz.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var arDz = moment.defineLocale('ar-dz', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return arDz;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-kw.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-kw.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var arKw = moment.defineLocale('ar-kw', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return arKw;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-ly.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ly.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '1',
      '2': '2',
      '3': '3',
      '4': '4',
      '5': '5',
      '6': '6',
      '7': '7',
      '8': '8',
      '9': '9',
      '0': '0'
    },
    pluralForm = function pluralForm(n) {
      return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    },
    plurals = {
      s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    },
    pluralize = function pluralize(u) {
      return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    },
    months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var arLy = moment.defineLocale('ar-ly', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: "D/\u200FM/\u200FYYYY",
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return arLy;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-ma.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ma.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var arMa = moment.defineLocale('ar-ma', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return arMa;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-sa.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-sa.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var arSa = moment.defineLocale('ar-sa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return arSa;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar-tn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-tn.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return arTn;
});

/***/ }),

/***/ "./node_modules/moment/locale/ar.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ar.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    },
    pluralForm = function pluralForm(n) {
      return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    },
    plurals = {
      s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
      y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    },
    pluralize = function pluralize(u) {
      return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    },
    months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var ar = moment.defineLocale('ar', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: "D/\u200FM/\u200FYYYY",
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return ar;
});

/***/ }),

/***/ "./node_modules/moment/locale/az.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/az.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
  };
  var az = moment.defineLocale('az', {
    months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[sabah saat] LT',
      nextWeek: '[gln hft] dddd [saat] LT',
      lastDay: '[dnn] LT',
      lastWeek: '[ken hft] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s vvl',
      s: 'birne saniy',
      ss: '%d saniy',
      m: 'bir dqiq',
      mm: '%d dqiq',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir il',
      yy: '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM: function isPM(input) {
      return /^(gndz|axam)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return 'gec';
      } else if (hour < 12) {
        return 'shr';
      } else if (hour < 17) {
        return 'gndz';
      } else {
        return 'axam';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal: function ordinal(number) {
      if (number === 0) {
        // special case for zero
        return number + '-nc';
      }
      var a = number % 10,
        b = number % 100 - a,
        c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return az;
});

/***/ }),

/***/ "./node_modules/moment/locale/be.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/be.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? '__' : '__',
      'mm': withoutSuffix ? '__' : '__',
      'hh': withoutSuffix ? '__' : '__',
      'dd': '__',
      'MM': '__',
      'yy': '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  var be = moment.defineLocale('be', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: {
      format: '______'.split('_'),
      standalone: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: function nextWeek() {
        return '[] dddd [] LT';
      },
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return '[ ] dddd [] LT';
          case 1:
          case 2:
          case 4:
            return '[ ] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-' : number + '-';
        case 'D':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return be;
});

/***/ }),

/***/ "./node_modules/moment/locale/bg.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bg.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var bg = moment.defineLocale('bg', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[ ] dddd [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[ ] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function ordinal(number) {
      var lastDigit = number % 10,
        last2Digits = number % 100;
      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return bg;
});

/***/ }),

/***/ "./node_modules/moment/locale/bm.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bm.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var bm = moment.defineLocale('bm', {
    months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'MMMM [tile] D [san] YYYY',
      LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
      LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar: {
      sameDay: '[Bi lr] LT',
      nextDay: '[Sini lr] LT',
      nextWeek: 'dddd [don lr] LT',
      lastDay: '[Kunu lr] LT',
      lastWeek: 'dddd [tmnen lr] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s kn',
      past: 'a b %s b',
      s: 'sanga dama dama',
      ss: 'sekondi %d',
      m: 'miniti kelen',
      mm: 'miniti %d',
      h: 'lr kelen',
      hh: 'lr %d',
      d: 'tile kelen',
      dd: 'tile %d',
      M: 'kalo kelen',
      MM: 'kalo %d',
      y: 'san kelen',
      yy: 'san %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return bm;
});

/***/ }),

/***/ "./node_modules/moment/locale/bn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var bn = moment.defineLocale('bn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return bn;
});

/***/ }),

/***/ "./node_modules/moment/locale/bo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var bo = moment.defineLocale('bo', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[], LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return bo;
});

/***/ }),

/***/ "./node_modules/moment/locale/br.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/br.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
      'mm': 'munutenn',
      'MM': 'miz',
      'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
  }
  function specialMutationForYears(number) {
    switch (lastNumber(number)) {
      case 1:
      case 3:
      case 4:
      case 5:
      case 9:
        return number + ' bloaz';
      default:
        return number + ' vloaz';
    }
  }
  function lastNumber(number) {
    if (number > 9) {
      return lastNumber(number % 10);
    }
    return number;
  }
  function mutation(text, number) {
    if (number === 2) {
      return softMutation(text);
    }
    return text;
  }
  function softMutation(text) {
    var mutationTable = {
      'm': 'v',
      'b': 'v',
      'd': 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
      return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
  }
  var br = moment.defineLocale('br', {
    months: 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort: 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays: 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h[e]mm A',
      LTS: 'h[e]mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [a viz] MMMM YYYY',
      LLL: 'D [a viz] MMMM YYYY h[e]mm A',
      LLLL: 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar: {
      sameDay: '[Hiziv da] LT',
      nextDay: '[Warc\'hoazh da] LT',
      nextWeek: 'dddd [da] LT',
      lastDay: '[Dec\'h da] LT',
      lastWeek: 'dddd [paset da] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'a-benn %s',
      past: '%s \'zo',
      s: 'un nebeud segondenno',
      ss: '%d eilenn',
      m: 'ur vunutenn',
      mm: relativeTimeWithMutation,
      h: 'un eur',
      hh: '%d eur',
      d: 'un devezh',
      dd: relativeTimeWithMutation,
      M: 'ur miz',
      MM: relativeTimeWithMutation,
      y: 'ur bloaz',
      yy: specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'a' : 'vet';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return br;
});

/***/ }),

/***/ "./node_modules/moment/locale/bs.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bs.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';
      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }
        return result;
      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }
        return result;
      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }
        return result;
      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }
        return result;
    }
  }
  var bs = moment.defineLocale('bs', {
    months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prolu] dddd [u] LT';
          case 6:
            return '[prole] [subote] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return bs;
});

/***/ }),

/***/ "./node_modules/moment/locale/ca.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ca.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ca = moment.defineLocale('ca', {
    months: {
      standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
      format: 'de gener_de febrer_de mar_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a les] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextDay: function nextDay() {
        return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'd\'aqu %s',
      past: 'fa %s',
      s: 'uns segons',
      ss: '%d segons',
      m: 'un minut',
      mm: '%d minuts',
      h: 'una hora',
      hh: '%d hores',
      d: 'un dia',
      dd: '%d dies',
      M: 'un mes',
      MM: '%d mesos',
      y: 'un any',
      yy: '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function ordinal(number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';
      if (period === 'w' || period === 'W') {
        output = 'a';
      }
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ca;
});

/***/ }),

/***/ "./node_modules/moment/locale/cs.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cs.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
    monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
  var monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i];
  // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
  // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
  var monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
  function plural(n) {
    return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';
      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekund');
        } else {
          return result + 'sekundami';
        }
        break;
      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minuty' : 'minut');
        } else {
          return result + 'minutami';
        }
        break;
      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodin');
        } else {
          return result + 'hodinami';
        }
        break;
      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'den' : 'dnem';
      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dny' : 'dn');
        } else {
          return result + 'dny';
        }
        break;
      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'msc' : 'mscem';
      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'msce' : 'msc');
        } else {
          return result + 'msci';
        }
        break;
      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokem';
      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'let');
        } else {
          return result + 'lety';
        }
        break;
    }
  }
  var cs = moment.defineLocale('cs', {
    months: months,
    monthsShort: monthsShort,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
    monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm',
      l: 'D. M. YYYY'
    },
    calendar: {
      sameDay: '[dnes v] LT',
      nextDay: '[ztra v] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v nedli v] LT';
          case 1:
          case 2:
            return '[v] dddd [v] LT';
          case 3:
            return '[ve stedu v] LT';
          case 4:
            return '[ve tvrtek v] LT';
          case 5:
            return '[v ptek v] LT';
          case 6:
            return '[v sobotu v] LT';
        }
      },
      lastDay: '[vera v] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[minulou nedli v] LT';
          case 1:
          case 2:
            return '[minul] dddd [v] LT';
          case 3:
            return '[minulou stedu v] LT';
          case 4:
          case 5:
            return '[minul] dddd [v] LT';
          case 6:
            return '[minulou sobotu v] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'ped %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return cs;
});

/***/ }),

/***/ "./node_modules/moment/locale/cv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var cv = moment.defineLocale('cv', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'YYYY [] MMMM [] D[-]',
      LLL: 'YYYY [] MMMM [] D[-], HH:mm',
      LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar: {
      sameDay: '[] LT []',
      nextDay: '[] LT []',
      lastDay: '[] LT []',
      nextWeek: '[] dddd LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(output) {
        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
        return output + affix;
      },
      past: '%s ',
      s: '- ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal: '%d-',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return cv;
});

/***/ }),

/***/ "./node_modules/moment/locale/cy.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cy.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    // time formats are the same as en-gb
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Heddiw am] LT',
      nextDay: '[Yfory am] LT',
      nextWeek: 'dddd [am] LT',
      lastDay: '[Ddoe am] LT',
      lastWeek: 'dddd [diwethaf am] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'mewn %s',
      past: '%s yn l',
      s: 'ychydig eiliadau',
      ss: '%d eiliad',
      m: 'munud',
      mm: '%d munud',
      h: 'awr',
      hh: '%d awr',
      d: 'diwrnod',
      dd: '%d diwrnod',
      M: 'mis',
      MM: '%d mis',
      y: 'blwyddyn',
      yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function ordinal(number) {
      var b = number,
        output = '',
        lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed',
        // 1af to 10fed
        'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
        ];
      if (b > 20) {
        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
          output = 'fed'; // not 30ain, 70ain or 90ain
        } else {
          output = 'ain';
        }
      } else if (b > 0) {
        output = lookup[b];
      }
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return cy;
});

/***/ }),

/***/ "./node_modules/moment/locale/da.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/da.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var da = moment.defineLocale('da', {
    months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'p dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[i] dddd[s kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'f sekunder',
      ss: '%d sekunder',
      m: 'et minut',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dage',
      M: 'en mned',
      MM: '%d mneder',
      y: 'et r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return da;
});

/***/ }),

/***/ "./node_modules/moment/locale/de-at.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-at.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var deAt = moment.defineLocale('de-at', {
    months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return deAt;
});

/***/ }),

/***/ "./node_modules/moment/locale/de-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-ch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var deCh = moment.defineLocale('de-ch', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return deCh;
});

/***/ }),

/***/ "./node_modules/moment/locale/de.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/de.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eine Minute', 'einer Minute'],
      'h': ['eine Stunde', 'einer Stunde'],
      'd': ['ein Tag', 'einem Tag'],
      'dd': [number + ' Tage', number + ' Tagen'],
      'M': ['ein Monat', 'einem Monat'],
      'MM': [number + ' Monate', number + ' Monaten'],
      'y': ['ein Jahr', 'einem Jahr'],
      'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var de = moment.defineLocale('de', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return de;
});

/***/ }),

/***/ "./node_modules/moment/locale/dv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/dv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
    weekdays = ['', '', '', '', '', '', ''];
  var dv = moment.defineLocale('dv', {
    months: months,
    monthsShort: months,
    weekdays: weekdays,
    weekdaysShort: weekdays,
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/M/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: 'd% ',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 7,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return dv;
});

/***/ }),

/***/ "./node_modules/moment/locale/el.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/el.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  var el = moment.defineLocale('el', {
    monthsNominativeEl: '___________'.split('_'),
    monthsGenitiveEl: '___________'.split('_'),
    months: function months(momentToFormat, format) {
      if (!momentToFormat) {
        return this._monthsNominativeEl;
      } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) {
        // if there is a day number before 'MMMM'
        return this._monthsGenitiveEl[momentToFormat.month()];
      } else {
        return this._monthsNominativeEl[momentToFormat.month()];
      }
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '' : '';
      } else {
        return isLower ? '' : '';
      }
    },
    isPM: function isPM(input) {
      return (input + '').toLowerCase()[0] === '';
    },
    meridiemParse: /[]\.??\.?/i,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl: {
      sameDay: '[ {}] LT',
      nextDay: '[ {}] LT',
      nextWeek: 'dddd [{}] LT',
      lastDay: '[ {}] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 6:
            return '[ ] dddd [{}] LT';
          default:
            return '[ ] dddd [{}] LT';
        }
      },
      sameElse: 'L'
    },
    calendar: function calendar(key, mom) {
      var output = this._calendarEl[key],
        hours = mom && mom.hours();
      if (isFunction(output)) {
        output = output.apply(mom);
      }
      return output.replace('{}', hours % 12 === 1 ? '' : '');
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4st is the first week of the year.
    }
  });
  return el;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-SG.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-SG.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enSG = moment.defineLocale('en-SG', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enSG;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-au.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-au.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enAu = moment.defineLocale('en-au', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enAu;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-ca.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ca.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enCa = moment.defineLocale('en-ca', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'YYYY-MM-DD',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enCa;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-gb.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-gb.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enGb = moment.defineLocale('en-gb', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enGb;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-ie.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ie.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enIe = moment.defineLocale('en-ie', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enIe;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-il.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-il.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enIl = moment.defineLocale('en-il', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enIl;
});

/***/ }),

/***/ "./node_modules/moment/locale/en-nz.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-nz.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var enNz = moment.defineLocale('en-nz', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return enNz;
});

/***/ }),

/***/ "./node_modules/moment/locale/eo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/eo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var eo = moment.defineLocale('eo', {
    months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
    weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D[-a de] MMMM, YYYY',
      LLL: 'D[-a de] MMMM, YYYY HH:mm',
      LLLL: 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function isPM(input) {
      return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'p.t.m.' : 'P.T.M.';
      } else {
        return isLower ? 'a.t.m.' : 'A.T.M.';
      }
    },
    calendar: {
      sameDay: '[Hodia je] LT',
      nextDay: '[Morga je] LT',
      nextWeek: 'dddd [je] LT',
      lastDay: '[Hiera je] LT',
      lastWeek: '[pasinta] dddd [je] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'post %s',
      past: 'anta %s',
      s: 'sekundoj',
      ss: '%d sekundoj',
      m: 'minuto',
      mm: '%d minutoj',
      h: 'horo',
      hh: '%d horoj',
      d: 'tago',
      //ne 'diurno', ar estas uzita por proksimumo
      dd: '%d tagoj',
      M: 'monato',
      MM: '%d monatoj',
      y: 'jaro',
      yy: '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal: '%da',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return eo;
});

/***/ }),

/***/ "./node_modules/moment/locale/es-do.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-do.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
  var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esDo = moment.defineLocale('es-do', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return esDo;
});

/***/ }),

/***/ "./node_modules/moment/locale/es-us.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-us.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
  var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esUs = moment.defineLocale('es-us', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'MM/DD/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return esUs;
});

/***/ }),

/***/ "./node_modules/moment/locale/es.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/es.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
    _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
  var monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i];
  var monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var es = moment.defineLocale('es', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return es;
});

/***/ }),

/***/ "./node_modules/moment/locale/et.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/et.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['mne sekundi', 'mni sekund', 'paar sekundit'],
      'ss': [number + 'sekundi', number + 'sekundit'],
      'm': ['he minuti', 'ks minut'],
      'mm': [number + ' minuti', number + ' minutit'],
      'h': ['he tunni', 'tund aega', 'ks tund'],
      'hh': [number + ' tunni', number + ' tundi'],
      'd': ['he peva', 'ks pev'],
      'M': ['kuu aja', 'kuu aega', 'ks kuu'],
      'MM': [number + ' kuu', number + ' kuud'],
      'y': ['he aasta', 'aasta', 'ks aasta'],
      'yy': [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
      return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
  }
  var et = moment.defineLocale('et', {
    months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Tna,] LT',
      nextDay: '[Homme,] LT',
      nextWeek: '[Jrgmine] dddd LT',
      lastDay: '[Eile,] LT',
      lastWeek: '[Eelmine] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s prast',
      past: '%s tagasi',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: '%d peva',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return et;
});

/***/ }),

/***/ "./node_modules/moment/locale/eu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/eu.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var eu = moment.defineLocale('eu', {
    months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact: true,
    weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY[ko] MMMM[ren] D[a]',
      LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
      LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
      l: 'YYYY-M-D',
      ll: 'YYYY[ko] MMM D[a]',
      lll: 'YYYY[ko] MMM D[a] HH:mm',
      llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar: {
      sameDay: '[gaur] LT[etan]',
      nextDay: '[bihar] LT[etan]',
      nextWeek: 'dddd LT[etan]',
      lastDay: '[atzo] LT[etan]',
      lastWeek: '[aurreko] dddd LT[etan]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s barru',
      past: 'duela %s',
      s: 'segundo batzuk',
      ss: '%d segundo',
      m: 'minutu bat',
      mm: '%d minutu',
      h: 'ordu bat',
      hh: '%d ordu',
      d: 'egun bat',
      dd: '%d egun',
      M: 'hilabete bat',
      MM: '%d hilabete',
      y: 'urte bat',
      yy: '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return eu;
});

/***/ }),

/***/ "./node_modules/moment/locale/fa.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fa.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var fa = moment.defineLocale('fa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
    weekdaysShort: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function isPM(input) {
      return /  /.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '  ';
      } else {
        return '  ';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: ' d%',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[-]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return fa;
});

/***/ }),

/***/ "./node_modules/moment/locale/fi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fi.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
    numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];
  function translate(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
      case 's':
        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
      case 'ss':
        return isFuture ? 'sekunnin' : 'sekuntia';
      case 'm':
        return isFuture ? 'minuutin' : 'minuutti';
      case 'mm':
        result = isFuture ? 'minuutin' : 'minuuttia';
        break;
      case 'h':
        return isFuture ? 'tunnin' : 'tunti';
      case 'hh':
        result = isFuture ? 'tunnin' : 'tuntia';
        break;
      case 'd':
        return isFuture ? 'pivn' : 'piv';
      case 'dd':
        result = isFuture ? 'pivn' : 'piv';
        break;
      case 'M':
        return isFuture ? 'kuukauden' : 'kuukausi';
      case 'MM':
        result = isFuture ? 'kuukauden' : 'kuukautta';
        break;
      case 'y':
        return isFuture ? 'vuoden' : 'vuosi';
      case 'yy':
        result = isFuture ? 'vuoden' : 'vuotta';
        break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
  }
  function verbalNumber(number, isFuture) {
    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
  }
  var fi = moment.defineLocale('fi', {
    months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM[ta] YYYY',
      LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
      LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
      l: 'D.M.YYYY',
      ll: 'Do MMM YYYY',
      lll: 'Do MMM YYYY, [klo] HH.mm',
      llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar: {
      sameDay: '[tnn] [klo] LT',
      nextDay: '[huomenna] [klo] LT',
      nextWeek: 'dddd [klo] LT',
      lastDay: '[eilen] [klo] LT',
      lastWeek: '[viime] dddd[na] [klo] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s pst',
      past: '%s sitten',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fi;
});

/***/ }),

/***/ "./node_modules/moment/locale/fo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var fo = moment.defineLocale('fo', {
    months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgin kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gjr kl.] LT',
      lastWeek: '[sstu] dddd [kl] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'um %s',
      past: '%s sani',
      s: 'f sekund',
      ss: '%d sekundir',
      m: 'ein minuttur',
      mm: '%d minuttir',
      h: 'ein tmi',
      hh: '%d tmar',
      d: 'ein dagur',
      dd: '%d dagar',
      M: 'ein mnaur',
      MM: '%d mnair',
      y: 'eitt r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fo;
});

/***/ }),

/***/ "./node_modules/moment/locale/fr-ca.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ca.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var frCa = moment.defineLocale('fr-ca', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    }
  });
  return frCa;
});

/***/ }),

/***/ "./node_modules/moment/locale/fr-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var frCh = moment.defineLocale('fr-ch', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return frCh;
});

/***/ }),

/***/ "./node_modules/moment/locale/fr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var fr = moment.defineLocale('fr', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // TODO: Return 'e' when day of month > 1. Move this case inside
        // block for masculine words below.
        // See https://github.com/moment/moment/issues/3375
        case 'D':
          return number + (number === 1 ? 'er' : '');

        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');

        // Words with feminine grammatical gender: semaine
        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fr;
});

/***/ }),

/***/ "./node_modules/moment/locale/fy.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fy.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
  var fy = moment.defineLocale('fy', {
    months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[hjoed om] LT',
      nextDay: '[moarn om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[juster om] LT',
      lastWeek: '[frne] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oer %s',
      past: '%s lyn',
      s: 'in pear sekonden',
      ss: '%d sekonden',
      m: 'ien mint',
      mm: '%d minuten',
      h: 'ien oere',
      hh: '%d oeren',
      d: 'ien dei',
      dd: '%d dagen',
      M: 'ien moanne',
      MM: '%d moannen',
      y: 'ien jier',
      yy: '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return fy;
});

/***/ }),

/***/ "./node_modules/moment/locale/ga.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ga.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = ['Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Mitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deaireadh Fmhair', 'Samhain', 'Nollaig'];
  var monthsShort = ['Ean', 'Feab', 'Mrt', 'Aibr', 'Beal', 'Mit', 'Iil', 'Lna', 'Men', 'Deai', 'Samh', 'Noll'];
  var weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Satharn'];
  var weekdaysShort = ['Dom', 'Lua', 'Mi', 'Ca', 'Da', 'hAo', 'Sat'];
  var weekdaysMin = ['Do', 'Lu', 'M', 'Ce', 'D', 'hA', 'Sa'];
  var ga = moment.defineLocale('ga', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Inniu ag] LT',
      nextDay: '[Amrach ag] LT',
      nextWeek: 'dddd [ag] LT',
      lastDay: '[Inn aig] LT',
      lastWeek: 'dddd [seo caite] [ag] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i %s',
      past: '%s  shin',
      s: 'cpla soicind',
      ss: '%d soicind',
      m: 'nimad',
      mm: '%d nimad',
      h: 'uair an chloig',
      hh: '%d uair an chloig',
      d: 'l',
      dd: '%d l',
      M: 'm',
      MM: '%d m',
      y: 'bliain',
      yy: '%d bliain'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ga;
});

/***/ }),

/***/ "./node_modules/moment/locale/gd.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gd.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = ['Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'];
  var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];
  var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
  var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
  var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
  var gd = moment.defineLocale('gd', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[An-diugh aig] LT',
      nextDay: '[A-mireach aig] LT',
      nextWeek: 'dddd [aig] LT',
      lastDay: '[An-d aig] LT',
      lastWeek: 'dddd [seo chaidh] [aig] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ann an %s',
      past: 'bho chionn %s',
      s: 'beagan diogan',
      ss: '%d diogan',
      m: 'mionaid',
      mm: '%d mionaidean',
      h: 'uair',
      hh: '%d uairean',
      d: 'latha',
      dd: '%d latha',
      M: 'mos',
      MM: '%d mosan',
      y: 'bliadhna',
      yy: '%d bliadhna'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return gd;
});

/***/ }),

/***/ "./node_modules/moment/locale/gl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var gl = moment.defineLocale('gl', {
    months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      lastDay: function lastDay() {
        return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(str) {
        if (str.indexOf('un') === 0) {
          return 'n' + str;
        }
        return 'en ' + str;
      },
      past: 'hai %s',
      s: 'uns segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'unha hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return gl;
});

/***/ }),

/***/ "./node_modules/moment/locale/gom-latn.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/gom-latn.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['thodde secondanim', 'thodde second'],
      'ss': [number + ' secondanim', number + ' second'],
      'm': ['eka mintan', 'ek minute'],
      'mm': [number + ' mintanim', number + ' mintam'],
      'h': ['eka voran', 'ek vor'],
      'hh': [number + ' voranim', number + ' voram'],
      'd': ['eka disan', 'ek dis'],
      'dd': [number + ' disanim', number + ' dis'],
      'M': ['eka mhoinean', 'ek mhoino'],
      'MM': [number + ' mhoineanim', number + ' mhoine'],
      'y': ['eka vorsan', 'ek voros'],
      'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  var gomLatn = moment.defineLocale('gom-latn', {
    months: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm [vazta]',
      LTS: 'A h:mm:ss [vazta]',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm [vazta]',
      LLLL: 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
      llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar: {
      sameDay: '[Aiz] LT',
      nextDay: '[Faleam] LT',
      nextWeek: '[Ieta to] dddd[,] LT',
      lastDay: '[Kal] LT',
      lastWeek: '[Fatlo] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s adim',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // the ordinal 'er' only applies to day of the month
        case 'D':
          return number + 'er';
        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'rati') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'sokalli') {
        return hour;
      } else if (meridiem === 'donparam') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === 'sanje') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return 'rati';
      } else if (hour < 12) {
        return 'sokalli';
      } else if (hour < 16) {
        return 'donparam';
      } else if (hour < 20) {
        return 'sanje';
      } else {
        return 'rati';
      }
    }
  });
  return gomLatn;
});

/***/ }),

/***/ "./node_modules/moment/locale/gu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gu.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return gu;
});

/***/ }),

/***/ "./node_modules/moment/locale/he.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/he.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var he = moment.defineLocale('he', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D []MMMM YYYY',
      LLL: 'D []MMMM YYYY HH:mm',
      LLLL: 'dddd, D []MMMM YYYY HH:mm',
      l: 'D/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ]LT',
      nextDay: '[ ]LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ]LT',
      lastWeek: '[] dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: function hh(number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      d: '',
      dd: function dd(number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      M: '',
      MM: function MM(number) {
        if (number === 2) {
          return '';
        }
        return number + ' ';
      },
      y: '',
      yy: function yy(number) {
        if (number === 2) {
          return '';
        } else if (number % 10 === 0 && number !== 10) {
          return number + ' ';
        }
        return number + ' ';
      }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM: function isPM(input) {
      return /^("| |)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 5) {
        return ' ';
      } else if (hour < 10) {
        return '';
      } else if (hour < 12) {
        return isLower ? '"' : ' ';
      } else if (hour < 18) {
        return isLower ? '"' : ' ';
      } else {
        return '';
      }
    }
  });
  return he;
});

/***/ }),

/***/ "./node_modules/moment/locale/hi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hi.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var hi = moment.defineLocale('hi', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return hi;
});

/***/ }),

/***/ "./node_modules/moment/locale/hr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';
      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';
      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }
        return result;
      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }
        return result;
      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }
        return result;
      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }
        return result;
    }
  }
  var hr = moment.defineLocale('hr', {
    months: {
      format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
      standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prolu] dddd [u] LT';
          case 6:
            return '[prole] [subote] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return hr;
});

/***/ }),

/***/ "./node_modules/moment/locale/hu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hu.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
  function translate(number, withoutSuffix, key, isFuture) {
    var num = number;
    switch (key) {
      case 's':
        return isFuture || withoutSuffix ? 'nhny msodperc' : 'nhny msodperce';
      case 'ss':
        return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';
      case 'm':
        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
      case 'mm':
        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
      case 'h':
        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
      case 'hh':
        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
      case 'd':
        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
      case 'dd':
        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
      case 'M':
        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
      case 'MM':
        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
      case 'y':
        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
      case 'yy':
        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }
    return '';
  }
  function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
  }
  var hu = moment.defineLocale('hu', {
    months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort: 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
    weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY. MMMM D.',
      LLL: 'YYYY. MMMM D. H:mm',
      LLLL: 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function isPM(input) {
      return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower === true ? 'de' : 'DE';
      } else {
        return isLower === true ? 'du' : 'DU';
      }
    },
    calendar: {
      sameDay: '[ma] LT[-kor]',
      nextDay: '[holnap] LT[-kor]',
      nextWeek: function nextWeek() {
        return week.call(this, true);
      },
      lastDay: '[tegnap] LT[-kor]',
      lastWeek: function lastWeek() {
        return week.call(this, false);
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s mlva',
      past: '%s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return hu;
});

/***/ }),

/***/ "./node_modules/moment/locale/hy-am.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/hy-am.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var hyAm = moment.defineLocale('hy-am', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      lastDay: '[] LT',
      nextWeek: function nextWeek() {
        return 'dddd [ ] LT';
      },
      lastWeek: function lastWeek() {
        return '[] dddd [ ] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'DDD':
        case 'w':
        case 'W':
        case 'DDDo':
          if (number === 1) {
            return number + '-';
          }
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return hyAm;
});

/***/ }),

/***/ "./node_modules/moment/locale/id.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/id.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var id = moment.defineLocale('id', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'siang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sore' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'siang';
      } else if (hours < 19) {
        return 'sore';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Besok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kemarin pukul] LT',
      lastWeek: 'dddd [lalu pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lalu',
      s: 'beberapa detik',
      ss: '%d detik',
      m: 'semenit',
      mm: '%d menit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return id;
});

/***/ }),

/***/ "./node_modules/moment/locale/is.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/is.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function plural(n) {
    if (n % 100 === 11) {
      return true;
    } else if (n % 10 === 1) {
      return false;
    }
    return true;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
      case 'ss':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
        }
        return result + 'seknda';
      case 'm':
        return withoutSuffix ? 'mnta' : 'mntu';
      case 'mm':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
        } else if (withoutSuffix) {
          return result + 'mnta';
        }
        return result + 'mntu';
      case 'hh':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
        }
        return result + 'klukkustund';
      case 'd':
        if (withoutSuffix) {
          return 'dagur';
        }
        return isFuture ? 'dag' : 'degi';
      case 'dd':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'dagar';
          }
          return result + (isFuture ? 'daga' : 'dgum');
        } else if (withoutSuffix) {
          return result + 'dagur';
        }
        return result + (isFuture ? 'dag' : 'degi');
      case 'M':
        if (withoutSuffix) {
          return 'mnuur';
        }
        return isFuture ? 'mnu' : 'mnui';
      case 'MM':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'mnuir';
          }
          return result + (isFuture ? 'mnui' : 'mnuum');
        } else if (withoutSuffix) {
          return result + 'mnuur';
        }
        return result + (isFuture ? 'mnu' : 'mnui');
      case 'y':
        return withoutSuffix || isFuture ? 'r' : 'ri';
      case 'yy':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'r' : 'rum');
        }
        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
  }
  var is = moment.defineLocale('is', {
    months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgun kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gr kl.] LT',
      lastWeek: '[sasta] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'eftir %s',
      past: 'fyrir %s san',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: 'klukkustund',
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return is;
});

/***/ }),

/***/ "./node_modules/moment/locale/it-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/it-ch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var itCh = moment.defineLocale('it-ch', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';
          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: 'un\'ora',
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return itCh;
});

/***/ }),

/***/ "./node_modules/moment/locale/it.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/it.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var it = moment.defineLocale('it', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';
          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: 'un\'ora',
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return it;
});

/***/ }),

/***/ "./node_modules/moment/locale/ja.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ja.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ja = moment.defineLocale('ja', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMD dddd HH:mm',
      l: 'YYYY/MM/DD',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMD(ddd) HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: function nextWeek(now) {
        if (now.week() < this.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      lastDay: '[] LT',
      lastWeek: function lastWeek(now) {
        if (this.week() < now.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: '1',
      hh: '%d',
      d: '1',
      dd: '%d',
      M: '1',
      MM: '%d',
      y: '1',
      yy: '%d'
    }
  });
  return ja;
});

/***/ }),

/***/ "./node_modules/moment/locale/jv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/jv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var jv = moment.defineLocale('jv', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'enjing') {
        return hour;
      } else if (meridiem === 'siyang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'enjing';
      } else if (hours < 15) {
        return 'siyang';
      } else if (hours < 19) {
        return 'sonten';
      } else {
        return 'ndalu';
      }
    },
    calendar: {
      sameDay: '[Dinten puniko pukul] LT',
      nextDay: '[Mbenjang pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kala wingi pukul] LT',
      lastWeek: 'dddd [kepengker pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'wonten ing %s',
      past: '%s ingkang kepengker',
      s: 'sawetawis detik',
      ss: '%d detik',
      m: 'setunggal menit',
      mm: '%d menit',
      h: 'setunggal jam',
      hh: '%d jam',
      d: 'sedinten',
      dd: '%d dinten',
      M: 'sewulan',
      MM: '%d wulan',
      y: 'setaun',
      yy: '%d taun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return jv;
});

/***/ }),

/***/ "./node_modules/moment/locale/ka.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ka.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ka = moment.defineLocale('ka', {
    months: {
      standalone: '___________'.split('_'),
      format: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /(|)/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[] LT[-]',
      nextDay: '[] LT[-]',
      lastDay: '[] LT[-]',
      nextWeek: '[] dddd LT[-]',
      lastWeek: '[] dddd LT-',
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(s) {
        return /(|||)/.test(s) ? s.replace(/$/, '') : s + '';
      },
      past: function past(s) {
        if (/(||||)/.test(s)) {
          return s.replace(/(|)$/, ' ');
        }
        if (//.test(s)) {
          return s.replace(/$/, ' ');
        }
      },
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal: function ordinal(number) {
      if (number === 0) {
        return number;
      }
      if (number === 1) {
        return number + '-';
      }
      if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
        return '-' + number;
      }
      return number + '-';
    },
    week: {
      dow: 1,
      doy: 7
    }
  });
  return ka;
});

/***/ }),

/***/ "./node_modules/moment/locale/kk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/kk.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var kk = moment.defineLocale('kk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return kk;
});

/***/ }),

/***/ "./node_modules/moment/locale/km.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/km.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return km;
});

/***/ }),

/***/ "./node_modules/moment/locale/kn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/kn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var kn = moment.defineLocale('kn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function ordinal(number) {
      return number + '';
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return kn;
});

/***/ }),

/***/ "./node_modules/moment/locale/ko.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ko.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ko = moment.defineLocale('ko', {
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D A h:mm',
      LLLL: 'YYYY MMMM D dddd A h:mm',
      l: 'YYYY.MM.DD.',
      ll: 'YYYY MMMM D',
      lll: 'YYYY MMMM D A h:mm',
      llll: 'YYYY MMMM D dddd A h:mm'
    },
    calendar: {
      sameDay: ' LT',
      nextDay: ' LT',
      nextWeek: 'dddd LT',
      lastDay: ' LT',
      lastWeek: ' dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: ' ',
      hh: '%d',
      d: '',
      dd: '%d',
      M: ' ',
      MM: '%d',
      y: ' ',
      yy: '%d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    meridiemParse: /|/,
    isPM: function isPM(token) {
      return token === '';
    },
    meridiem: function meridiem(hour, minute, isUpper) {
      return hour < 12 ? '' : '';
    }
  });
  return ko;
});

/***/ }),

/***/ "./node_modules/moment/locale/ku.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ku.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    },
    months = [' ', '', '', '', '', '', '', '', '', ' ', ' ', ' '];
  var ku = moment.defineLocale('ku', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return //.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: ' ',
      ss: ' %d',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return ku;
});

/***/ }),

/***/ "./node_modules/moment/locale/ky.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ky.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var ky = moment.defineLocale('ky', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ky;
});

/***/ }),

/***/ "./node_modules/moment/locale/lb.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lb.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      'm': ['eng Minutt', 'enger Minutt'],
      'h': ['eng Stonn', 'enger Stonn'],
      'd': ['een Dag', 'engem Dag'],
      'M': ['ee Mount', 'engem Mount'],
      'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }
  function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
      return 'a ' + string;
    }
    return 'an ' + string;
  }
  function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
      return 'viru ' + string;
    }
    return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */
  function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
      return false;
    }
    if (number < 0) {
      // Negative Number --> always true
      return true;
    } else if (number < 10) {
      // Only 1 digit
      if (4 <= number && number <= 7) {
        return true;
      }
      return false;
    } else if (number < 100) {
      // 2 digits
      var lastDigit = number % 10,
        firstDigit = number / 10;
      if (lastDigit === 0) {
        return eifelerRegelAppliesToNumber(firstDigit);
      }
      return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
      // 3 or 4 digits --> recursively check first digit
      while (number >= 10) {
        number = number / 10;
      }
      return eifelerRegelAppliesToNumber(number);
    } else {
      // Anything larger than 4 digits: recursively check first n-3 digits
      number = number / 1000;
      return eifelerRegelAppliesToNumber(number);
    }
  }
  var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm [Auer]',
      LTS: 'H:mm:ss [Auer]',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm [Auer]',
      LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
      sameDay: '[Haut um] LT',
      sameElse: 'L',
      nextDay: '[Muer um] LT',
      nextWeek: 'dddd [um] LT',
      lastDay: '[Gschter um] LT',
      lastWeek: function lastWeek() {
        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
        switch (this.day()) {
          case 2:
          case 4:
            return '[Leschten] dddd [um] LT';
          default:
            return '[Leschte] dddd [um] LT';
        }
      }
    },
    relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: 'e puer Sekonnen',
      ss: '%d Sekonnen',
      m: processRelativeTime,
      mm: '%d Minutten',
      h: processRelativeTime,
      hh: '%d Stonnen',
      d: processRelativeTime,
      dd: '%d Deeg',
      M: processRelativeTime,
      MM: '%d Mint',
      y: processRelativeTime,
      yy: '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lb;
});

/***/ }),

/***/ "./node_modules/moment/locale/lo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var lo = moment.defineLocale('lo', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd[] LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd[] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal: function ordinal(number) {
      return '' + number;
    }
  });
  return lo;
});

/***/ }),

/***/ "./node_modules/moment/locale/lt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lt.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var units = {
    'ss': 'sekund_sekundi_sekundes',
    'm': 'minut_minuts_minut',
    'mm': 'minuts_minui_minutes',
    'h': 'valanda_valandos_valand',
    'hh': 'valandos_valand_valandas',
    'd': 'diena_dienos_dien',
    'dd': 'dienos_dien_dienas',
    'M': 'mnuo_mnesio_mnes',
    'MM': 'mnesiai_mnesi_mnesius',
    'y': 'metai_met_metus',
    'yy': 'metai_met_metus'
  };
  function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
      return 'kelios sekunds';
    } else {
      return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
  }
  function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
  }
  function special(number) {
    return number % 10 === 0 || number > 10 && number < 20;
  }
  function forms(key) {
    return units[key].split('_');
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
      return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
      return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
      if (isFuture) {
        return result + forms(key)[1];
      } else {
        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
      }
    }
  }
  var lt = moment.defineLocale('lt', {
    months: {
      format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
      standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays: {
      format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
      standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
      isFormat: /dddd HH:mm/
    },
    weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY [m.] MMMM D [d.]',
      LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
      l: 'YYYY-MM-DD',
      ll: 'YYYY [m.] MMMM D [d.]',
      lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar: {
      sameDay: '[iandien] LT',
      nextDay: '[Rytoj] LT',
      nextWeek: 'dddd LT',
      lastDay: '[Vakar] LT',
      lastWeek: '[Prajus] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'po %s',
      past: 'prie %s',
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal: function ordinal(number) {
      return number + '-oji';
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lt;
});

/***/ }),

/***/ "./node_modules/moment/locale/lv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var units = {
    'ss': 'sekundes_sekundm_sekunde_sekundes'.split('_'),
    'm': 'mintes_mintm_minte_mintes'.split('_'),
    'mm': 'mintes_mintm_minte_mintes'.split('_'),
    'h': 'stundas_stundm_stunda_stundas'.split('_'),
    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
    'd': 'dienas_dienm_diena_dienas'.split('_'),
    'dd': 'dienas_dienm_diena_dienas'.split('_'),
    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */
  function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
      // E.g. "21 minte", "3 mintes".
      return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
      // E.g. "21 mintes" as in "pc 21 mintes".
      // E.g. "3 mintm" as in "pc 3 mintm".
      return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
  }
  function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
  }
  function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
  }
  var lv = moment.defineLocale('lv', {
    months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY.',
      LL: 'YYYY. [gada] D. MMMM',
      LLL: 'YYYY. [gada] D. MMMM, HH:mm',
      LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar: {
      sameDay: '[odien pulksten] LT',
      nextDay: '[Rt pulksten] LT',
      nextWeek: 'dddd [pulksten] LT',
      lastDay: '[Vakar pulksten] LT',
      lastWeek: '[Pagju] dddd [pulksten] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'pc %s',
      past: 'pirms %s',
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return lv;
});

/***/ }),

/***/ "./node_modules/moment/locale/me.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/me.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekund', 'sekunda', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mjesec', 'mjeseca', 'mjeseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];
      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sjutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';
          case 3:
            return '[u] [srijedu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[prole] [nedjelje] [u] LT', '[prolog] [ponedjeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srijede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mjesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return me;
});

/***/ }),

/***/ "./node_modules/moment/locale/mi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mi.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [i] HH:mm',
      LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
      sameDay: '[i teie mahana, i] LT',
      nextDay: '[apopo i] LT',
      nextWeek: 'dddd [i] LT',
      lastDay: '[inanahi i] LT',
      lastWeek: 'dddd [whakamutunga i] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i roto i %s',
      past: '%s i mua',
      s: 'te hkona ruarua',
      ss: '%d hkona',
      m: 'he meneti',
      mm: '%d meneti',
      h: 'te haora',
      hh: '%d haora',
      d: 'he ra',
      dd: '%d ra',
      M: 'he marama',
      MM: '%d marama',
      y: 'he tau',
      yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return mi;
});

/***/ }),

/***/ "./node_modules/moment/locale/mk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mk.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var mk = moment.defineLocale('mk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: 'e_o_____a'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function ordinal(number) {
      var lastDigit = number % 10,
        last2Digits = number % 100;
      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return mk;
});

/***/ }),

/***/ "./node_modules/moment/locale/ml.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ml.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ml = moment.defineLocale('ml', {
    months: '___________'.split('_'),
    monthsShort: '._._._.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm -',
      LTS: 'A h:mm:ss -',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm -',
      LLLL: 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' && hour >= 4 || meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return ' ';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return ml;
});

/***/ }),

/***/ "./node_modules/moment/locale/mn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function translate(number, withoutSuffix, key, isFuture) {
    switch (key) {
      case 's':
        return withoutSuffix ? ' ' : ' ';
      case 'ss':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'm':
      case 'mm':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'h':
      case 'hh':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'd':
      case 'dd':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'M':
      case 'MM':
        return number + (withoutSuffix ? ' ' : ' ');
      case 'y':
      case 'yy':
        return number + (withoutSuffix ? ' ' : ' ');
      default:
        return number;
    }
  }
  var mn = moment.defineLocale('mn', {
    months: ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
    monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY  MMMM D',
      LLL: 'YYYY  MMMM D HH:mm',
      LLLL: 'dddd, YYYY  MMMM D HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + ' ';
        default:
          return number;
      }
    }
  });
  return mn;
});

/***/ }),

/***/ "./node_modules/moment/locale/mr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
    var output = '';
    if (withoutSuffix) {
      switch (string) {
        case 's':
          output = ' ';
          break;
        case 'ss':
          output = '%d ';
          break;
        case 'm':
          output = ' ';
          break;
        case 'mm':
          output = '%d ';
          break;
        case 'h':
          output = ' ';
          break;
        case 'hh':
          output = '%d ';
          break;
        case 'd':
          output = ' ';
          break;
        case 'dd':
          output = '%d ';
          break;
        case 'M':
          output = ' ';
          break;
        case 'MM':
          output = '%d ';
          break;
        case 'y':
          output = ' ';
          break;
        case 'yy':
          output = '%d ';
          break;
      }
    } else {
      switch (string) {
        case 's':
          output = ' ';
          break;
        case 'ss':
          output = '%d ';
          break;
        case 'm':
          output = ' ';
          break;
        case 'mm':
          output = '%d ';
          break;
        case 'h':
          output = ' ';
          break;
        case 'hh':
          output = '%d ';
          break;
        case 'd':
          output = ' ';
          break;
        case 'dd':
          output = '%d ';
          break;
        case 'M':
          output = ' ';
          break;
        case 'MM':
          output = '%d ';
          break;
        case 'y':
          output = ' ';
          break;
        case 'yy':
          output = '%d ';
          break;
      }
    }
    return output.replace(/%d/i, number);
  }
  var mr = moment.defineLocale('mr', {
    months: '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return mr;
});

/***/ }),

/***/ "./node_modules/moment/locale/ms-my.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ms-my.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var msMy = moment.defineLocale('ms-my', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return msMy;
});

/***/ }),

/***/ "./node_modules/moment/locale/ms.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ms.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ms = moment.defineLocale('ms', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ms;
});

/***/ }),

/***/ "./node_modules/moment/locale/mt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mt.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var mt = moment.defineLocale('mt', {
    months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
    monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
    weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
    weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
    weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Illum fil-]LT',
      nextDay: '[Gada fil-]LT',
      nextWeek: 'dddd [fil-]LT',
      lastDay: '[Il-biera fil-]LT',
      lastWeek: 'dddd [li gadda] [fil-]LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'f %s',
      past: '%s ilu',
      s: 'ftit sekondi',
      ss: '%d sekondi',
      m: 'minuta',
      mm: '%d minuti',
      h: 'siega',
      hh: '%d siegat',
      d: 'urnata',
      dd: '%d ranet',
      M: 'xahar',
      MM: '%d xhur',
      y: 'sena',
      yy: '%d sni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return mt;
});

/***/ }),

/***/ "./node_modules/moment/locale/my.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/my.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[.] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd LT []',
      lastDay: '[.] LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: ' %s ',
      s: '.',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return my;
});

/***/ }),

/***/ "./node_modules/moment/locale/nb.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nb.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var nb = moment.defineLocale('nb', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[forrige] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'noen sekunder',
      ss: '%d sekunder',
      m: 'ett minutt',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dager',
      M: 'en mned',
      MM: '%d mneder',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nb;
});

/***/ }),

/***/ "./node_modules/moment/locale/ne.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ne.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var ne = moment.defineLocale('ne', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 3) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return ne;
});

/***/ }),

/***/ "./node_modules/moment/locale/nl-be.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/nl-be.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
  var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
  var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nlBe = moment.defineLocale('nl-be', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nlBe;
});

/***/ }),

/***/ "./node_modules/moment/locale/nl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
  var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
  var monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nl = moment.defineLocale('nl', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nl;
});

/***/ }),

/***/ "./node_modules/moment/locale/nn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var nn = moment.defineLocale('nn', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort: 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin: 'su_m_ty_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[I dag klokka] LT',
      nextDay: '[I morgon klokka] LT',
      nextWeek: 'dddd [klokka] LT',
      lastDay: '[I gr klokka] LT',
      lastWeek: '[Fregande] dddd [klokka] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s sidan',
      s: 'nokre sekund',
      ss: '%d sekund',
      m: 'eit minutt',
      mm: '%d minutt',
      h: 'ein time',
      hh: '%d timar',
      d: 'ein dag',
      dd: '%d dagar',
      M: 'ein mnad',
      MM: '%d mnader',
      y: 'eit r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return nn;
});

/***/ }),

/***/ "./node_modules/moment/locale/pa-in.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pa-in.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return paIn;
});

/***/ }),

/***/ "./node_modules/moment/locale/pl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/pl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
    monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
  function plural(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }
  function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
      case 'ss':
        return result + (plural(number) ? 'sekundy' : 'sekund');
      case 'm':
        return withoutSuffix ? 'minuta' : 'minut';
      case 'mm':
        return result + (plural(number) ? 'minuty' : 'minut');
      case 'h':
        return withoutSuffix ? 'godzina' : 'godzin';
      case 'hh':
        return result + (plural(number) ? 'godziny' : 'godzin');
      case 'MM':
        return result + (plural(number) ? 'miesice' : 'miesicy');
      case 'yy':
        return result + (plural(number) ? 'lata' : 'lat');
    }
  }
  var pl = moment.defineLocale('pl', {
    months: function months(momentToFormat, format) {
      if (!momentToFormat) {
        return monthsNominative;
      } else if (format === '') {
        // Hack: if format empty we know this is used to generate
        // RegExp by moment. Give then back both valid forms of months
        // in RegExp ready format.
        return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
      } else if (/D MMMM/.test(format)) {
        return monthsSubjective[momentToFormat.month()];
      } else {
        return monthsNominative[momentToFormat.month()];
      }
    },
    monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Dzi o] LT',
      nextDay: '[Jutro o] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[W niedziel o] LT';
          case 2:
            return '[We wtorek o] LT';
          case 3:
            return '[W rod o] LT';
          case 6:
            return '[W sobot o] LT';
          default:
            return '[W] dddd [o] LT';
        }
      },
      lastDay: '[Wczoraj o] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[W zesz niedziel o] LT';
          case 3:
            return '[W zesz rod o] LT';
          case 6:
            return '[W zesz sobot o] LT';
          default:
            return '[W zeszy] dddd [o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: '%s temu',
      s: 'kilka sekund',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: '1 dzie',
      dd: '%d dni',
      M: 'miesic',
      MM: translate,
      y: 'rok',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return pl;
});

/***/ }),

/***/ "./node_modules/moment/locale/pt-br.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pt-br.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ptBr = moment.defineLocale('pt-br', {
    months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function lastWeek() {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' :
        // Saturday + Sunday
        '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'poucos segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d'
  });
  return ptBr;
});

/***/ }),

/***/ "./node_modules/moment/locale/pt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/pt.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var pt = moment.defineLocale('pt', {
    months: 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function lastWeek() {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' :
        // Saturday + Sunday
        '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return pt;
});

/***/ }),

/***/ "./node_modules/moment/locale/ro.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ro.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'ss': 'secunde',
        'mm': 'minute',
        'hh': 'ore',
        'dd': 'zile',
        'MM': 'luni',
        'yy': 'ani'
      },
      separator = ' ';
    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
      separator = ' de ';
    }
    return number + separator + format[key];
  }
  var ro = moment.defineLocale('ro', {
    months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort: 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[azi la] LT',
      nextDay: '[mine la] LT',
      nextWeek: 'dddd [la] LT',
      lastDay: '[ieri la] LT',
      lastWeek: '[fosta] dddd [la] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'peste %s',
      past: '%s n urm',
      s: 'cteva secunde',
      ss: relativeTimeWithPlural,
      m: 'un minut',
      mm: relativeTimeWithPlural,
      h: 'o or',
      hh: relativeTimeWithPlural,
      d: 'o zi',
      dd: relativeTimeWithPlural,
      M: 'o lun',
      MM: relativeTimeWithPlural,
      y: 'un an',
      yy: relativeTimeWithPlural
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return ro;
});

/***/ }),

/***/ "./node_modules/moment/locale/ru.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ru.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? '__' : '__',
      'mm': withoutSuffix ? '__' : '__',
      'hh': '__',
      'dd': '__',
      'MM': '__',
      'yy': '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];

  // http://new.gramota.ru/spravka/rules/139-prop :  103
  //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
  var ru = moment.defineLocale('ru', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: {
      //  CLDR  "."  ".",        ?
      format: '._._._.____._._._._.'.split('_'),
      standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., H:mm',
      LLLL: 'dddd, D MMMM YYYY ., H:mm'
    },
    calendar: {
      sameDay: '[, ] LT',
      nextDay: '[, ] LT',
      lastDay: '[, ] LT',
      nextWeek: function nextWeek(now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';
            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';
            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      lastWeek: function lastWeek(now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';
            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';
            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
          return number + '-';
        case 'D':
          return number + '-';
        case 'w':
        case 'W':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ru;
});

/***/ }),

/***/ "./node_modules/moment/locale/sd.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sd.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var days = ['', '', '', '', '', '', ''];
  var sd = moment.defineLocale('sd', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }
      return '';
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd [  ] LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sd;
});

/***/ }),

/***/ "./node_modules/moment/locale/se.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/se.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var se = moment.defineLocale('se', {
    months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'MMMM D. [b.] YYYY',
      LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
      LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar: {
      sameDay: '[otne ti] LT',
      nextDay: '[ihttin ti] LT',
      nextWeek: 'dddd [ti] LT',
      lastDay: '[ikte ti] LT',
      lastWeek: '[ovddit] dddd [ti] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s geaes',
      past: 'mait %s',
      s: 'moadde sekunddat',
      ss: '%d sekunddat',
      m: 'okta minuhta',
      mm: '%d minuhtat',
      h: 'okta diimmu',
      hh: '%d diimmut',
      d: 'okta beaivi',
      dd: '%d beaivvit',
      M: 'okta mnnu',
      MM: '%d mnut',
      y: 'okta jahki',
      yy: '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return se;
});

/***/ }),

/***/ "./node_modules/moment/locale/si.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/si.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  /*jshint -W100*/
  var si = moment.defineLocale('si', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'a h:mm',
      LTS: 'a h:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D, a h:mm',
      LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar: {
      sameDay: '[] LT[]',
      nextDay: '[] LT[]',
      nextWeek: 'dddd LT[]',
      lastDay: '[] LT[]',
      lastWeek: '[] dddd LT[]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: ' %d',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function ordinal(number) {
      return number + ' ';
    },
    meridiemParse: / | |.|../,
    isPM: function isPM(input) {
      return input === '..' || input === ' ';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '..' : ' ';
      } else {
        return isLower ? '..' : ' ';
      }
    }
  });
  return si;
});

/***/ }),

/***/ "./node_modules/moment/locale/sk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sk.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
    monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
  function plural(n) {
    return n > 1 && n < 5;
  }
  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';
      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'seknd');
        } else {
          return result + 'sekundami';
        }
        break;
      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';
      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minty' : 'mint');
        } else {
          return result + 'mintami';
        }
        break;
      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodn');
        } else {
          return result + 'hodinami';
        }
        break;
      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'de' : 'dom';
      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dni' : 'dn');
        } else {
          return result + 'dami';
        }
        break;
      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'mesiace' : 'mesiacov');
        } else {
          return result + 'mesiacmi';
        }
        break;
      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokom';
      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'rokov');
        } else {
          return result + 'rokmi';
        }
        break;
    }
  }
  var sk = moment.defineLocale('sk', {
    months: months,
    monthsShort: monthsShort,
    weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[dnes o] LT',
      nextDay: '[zajtra o] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v nedeu o] LT';
          case 1:
          case 2:
            return '[v] dddd [o] LT';
          case 3:
            return '[v stredu o] LT';
          case 4:
            return '[vo tvrtok o] LT';
          case 5:
            return '[v piatok o] LT';
          case 6:
            return '[v sobotu o] LT';
        }
      },
      lastDay: '[vera o] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[minul nedeu o] LT';
          case 1:
          case 2:
            return '[minul] dddd [o] LT';
          case 3:
            return '[minul stredu o] LT';
          case 4:
          case 5:
            return '[minul] dddd [o] LT';
          case 6:
            return '[minul sobotu o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pred %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sk;
});

/***/ }),

/***/ "./node_modules/moment/locale/sl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sl.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
      case 'ss':
        if (number === 1) {
          result += withoutSuffix ? 'sekundo' : 'sekundi';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
        } else {
          result += 'sekund';
        }
        return result;
      case 'm':
        return withoutSuffix ? 'ena minuta' : 'eno minuto';
      case 'mm':
        if (number === 1) {
          result += withoutSuffix ? 'minuta' : 'minuto';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'minute' : 'minutami';
        } else {
          result += withoutSuffix || isFuture ? 'minut' : 'minutami';
        }
        return result;
      case 'h':
        return withoutSuffix ? 'ena ura' : 'eno uro';
      case 'hh':
        if (number === 1) {
          result += withoutSuffix ? 'ura' : 'uro';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'uri' : 'urama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'ure' : 'urami';
        } else {
          result += withoutSuffix || isFuture ? 'ur' : 'urami';
        }
        return result;
      case 'd':
        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
      case 'dd':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'dan' : 'dnem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
        } else {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
        }
        return result;
      case 'M':
        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
      case 'MM':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
        } else {
          result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
        }
        return result;
      case 'y':
        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
      case 'yy':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'leto' : 'letom';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'leti' : 'letoma';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'leta' : 'leti';
        } else {
          result += withoutSuffix || isFuture ? 'let' : 'leti';
        }
        return result;
    }
  }
  var sl = moment.defineLocale('sl', {
    months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danes ob] LT',
      nextDay: '[jutri ob] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v] [nedeljo] [ob] LT';
          case 3:
            return '[v] [sredo] [ob] LT';
          case 6:
            return '[v] [soboto] [ob] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[v] dddd [ob] LT';
        }
      },
      lastDay: '[veraj ob] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[prejnjo] [nedeljo] [ob] LT';
          case 3:
            return '[prejnjo] [sredo] [ob] LT';
          case 6:
            return '[prejnjo] [soboto] [ob] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[prejnji] dddd [ob] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ez %s',
      past: 'pred %s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sl;
});

/***/ }),

/***/ "./node_modules/moment/locale/sq.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sq.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var sq = moment.defineLocale('sq', {
    months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /PD|MD/,
    isPM: function isPM(input) {
      return input.charAt(0) === 'M';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Sot n] LT',
      nextDay: '[Nesr n] LT',
      nextWeek: 'dddd [n] LT',
      lastDay: '[Dje n] LT',
      lastWeek: 'dddd [e kaluar n] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'n %s',
      past: '%s m par',
      s: 'disa sekonda',
      ss: '%d sekonda',
      m: 'nj minut',
      mm: '%d minuta',
      h: 'nj or',
      hh: '%d or',
      d: 'nj dit',
      dd: '%d dit',
      M: 'nj muaj',
      MM: '%d muaj',
      y: 'nj vit',
      yy: '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sq;
});

/***/ }),

/***/ "./node_modules/moment/locale/sr-cyrl.js":
/*!***********************************************!*\
  !*** ./node_modules/moment/locale/sr-cyrl.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['', '', ''],
      m: [' ', ' '],
      mm: ['', '', ''],
      h: [' ', ' '],
      hh: ['', '', ''],
      dd: ['', '', ''],
      MM: ['', '', ''],
      yy: ['', '', '']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];
      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[] [] [] LT';
          case 3:
            return '[] [] [] LT';
          case 6:
            return '[] [] [] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: '',
      dd: translator.translate,
      M: '',
      MM: translator.translate,
      y: '',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return srCyrl;
});

/***/ }),

/***/ "./node_modules/moment/locale/sr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekunda', 'sekunde', 'sekundi'],
      m: ['jedan minut', 'jedne minute'],
      mm: ['minut', 'minute', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mesec', 'meseca', 'meseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];
      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedelju] [u] LT';
          case 3:
            return '[u] [sredu] [u] LT';
          case 6:
            return '[u] [subotu] [u] LT';
          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[prole] [nedelje] [u] LT', '[prolog] [ponedeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pre %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sr;
});

/***/ }),

/***/ "./node_modules/moment/locale/ss.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ss.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ss = moment.defineLocale('ss', {
    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Namuhla nga] LT',
      nextDay: '[Kusasa nga] LT',
      nextWeek: 'dddd [nga] LT',
      lastDay: '[Itolo nga] LT',
      lastWeek: 'dddd [leliphelile] [nga] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'nga %s',
      past: 'wenteka nga %s',
      s: 'emizuzwana lomcane',
      ss: '%d mzuzwana',
      m: 'umzuzu',
      mm: '%d emizuzu',
      h: 'lihora',
      hh: '%d emahora',
      d: 'lilanga',
      dd: '%d emalanga',
      M: 'inyanga',
      MM: '%d tinyanga',
      y: 'umnyaka',
      yy: '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'ekuseni';
      } else if (hours < 15) {
        return 'emini';
      } else if (hours < 19) {
        return 'entsambama';
      } else {
        return 'ebusuku';
      }
    },
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === 'ekuseni') {
        return hour;
      } else if (meridiem === 'emini') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
        if (hour === 0) {
          return 0;
        }
        return hour + 12;
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ss;
});

/***/ }),

/***/ "./node_modules/moment/locale/sv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var sv = moment.defineLocale('sv', {
    months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Idag] LT',
      nextDay: '[Imorgon] LT',
      lastDay: '[Igr] LT',
      nextWeek: '[P] dddd LT',
      lastWeek: '[I] dddd[s] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: 'fr %s sedan',
      s: 'ngra sekunder',
      ss: '%d sekunder',
      m: 'en minut',
      mm: '%d minuter',
      h: 'en timme',
      hh: '%d timmar',
      d: 'en dag',
      dd: '%d dagar',
      M: 'en mnad',
      MM: '%d mnader',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'e' : b === 1 ? 'a' : b === 2 ? 'a' : b === 3 ? 'e' : 'e';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return sv;
});

/***/ }),

/***/ "./node_modules/moment/locale/sw.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sw.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var sw = moment.defineLocale('sw', {
    months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[leo saa] LT',
      nextDay: '[kesho saa] LT',
      nextWeek: '[wiki ijayo] dddd [saat] LT',
      lastDay: '[jana] LT',
      lastWeek: '[wiki iliyopita] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s baadaye',
      past: 'tokea %s',
      s: 'hivi punde',
      ss: 'sekunde %d',
      m: 'dakika moja',
      mm: 'dakika %d',
      h: 'saa limoja',
      hh: 'masaa %d',
      d: 'siku moja',
      dd: 'masiku %d',
      M: 'mwezi mmoja',
      MM: 'miezi %d',
      y: 'mwaka mmoja',
      yy: 'miaka %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return sw;
});

/***/ }),

/***/ "./node_modules/moment/locale/ta.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ta.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var symbolMap = {
      '1': '',
      '2': '',
      '3': '',
      '4': '',
      '5': '',
      '6': '',
      '7': '',
      '8': '',
      '9': '',
      '0': ''
    },
    numberMap = {
      '': '1',
      '': '2',
      '': '3',
      '': '4',
      '': '5',
      '': '6',
      '': '7',
      '': '8',
      '': '9',
      '': '0'
    };
  var ta = moment.defineLocale('ta', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, HH:mm',
      LLLL: 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: '  ',
      hh: '%d  ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number + '';
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 2) {
        return ' ';
      } else if (hour < 6) {
        return ' '; // 
      } else if (hour < 10) {
        return ' '; // 
      } else if (hour < 14) {
        return ' '; // 
      } else if (hour < 18) {
        return ' '; // 
      } else if (hour < 22) {
        return ' '; // 
      } else {
        return ' ';
      }
    },
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 2 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else {
        return hour + 12;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return ta;
});

/***/ }),

/***/ "./node_modules/moment/locale/te.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/te.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var te = moment.defineLocale('te', {
    months: '___________'.split('_'),
    monthsShort: '._.__.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.
    }
  });
  return te;
});

/***/ }),

/***/ "./node_modules/moment/locale/tet.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var tet = moment.defineLocale('tet', {
    months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
    weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
    weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Ohin iha] LT',
      nextDay: '[Aban iha] LT',
      nextWeek: 'dddd [iha] LT',
      lastDay: '[Horiseik iha] LT',
      lastWeek: 'dddd [semana kotuk] [iha] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'iha %s',
      past: '%s liuba',
      s: 'minutu balun',
      ss: 'minutu %d',
      m: 'minutu ida',
      mm: 'minutu %d',
      h: 'oras ida',
      hh: 'oras %d',
      d: 'loron ida',
      dd: 'loron %d',
      M: 'fulan ida',
      MM: 'fulan %d',
      y: 'tinan ida',
      yy: 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tet;
});

/***/ }),

/***/ "./node_modules/moment/locale/tg.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/tg.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    12: '-',
    13: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var tg = moment.defineLocale('tg', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: 'dddd[] [  ] LT',
      lastWeek: 'dddd[] [  ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 11) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 19) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
        b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1th is the first week of the year.
    }
  });
  return tg;
});

/***/ }),

/***/ "./node_modules/moment/locale/th.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/th.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var th = moment.defineLocale('th', {
    months: '___________'.split('_'),
    monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    // yes, three characters difference
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY  H:mm',
      LLLL: 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd[ ] LT',
      lastDay: '[ ] LT',
      lastWeek: '[]dddd[ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return th;
});

/***/ }),

/***/ "./node_modules/moment/locale/tl-ph.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/tl-ph.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var tlPh = moment.defineLocale('tl-ph', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tlPh;
});

/***/ }),

/***/ "./node_modules/moment/locale/tlh.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tlh.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
  function translateFuture(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
    return time;
  }
  function translatePast(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
    return time;
  }
  function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
      case 'ss':
        return numberNoun + ' lup';
      case 'mm':
        return numberNoun + ' tup';
      case 'hh':
        return numberNoun + ' rep';
      case 'dd':
        return numberNoun + ' jaj';
      case 'MM':
        return numberNoun + ' jar';
      case 'yy':
        return numberNoun + ' DIS';
    }
  }
  function numberAsNoun(number) {
    var hundred = Math.floor(number % 1000 / 100),
      ten = Math.floor(number % 100 / 10),
      one = number % 10,
      word = '';
    if (hundred > 0) {
      word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[one];
    }
    return word === '' ? 'pagh' : word;
  }
  var tlh = moment.defineLocale('tlh', {
    months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact: true,
    weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[DaHjaj] LT',
      nextDay: '[waleS] LT',
      nextWeek: 'LLL',
      lastDay: '[waHu] LT',
      lastWeek: 'LLL',
      sameElse: 'L'
    },
    relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: 'puS lup',
      ss: translate,
      m: 'wa tup',
      mm: translate,
      h: 'wa rep',
      hh: translate,
      d: 'wa jaj',
      dd: translate,
      M: 'wa jar',
      MM: translate,
      y: 'wa DIS',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return tlh;
});

/***/ }),

/***/ "./node_modules/moment/locale/tr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/tr.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var suffixes = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'nc',
    4: '\'nc',
    100: '\'nc',
    6: '\'nc',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'nc',
    90: '\'nc'
  };
  var tr = moment.defineLocale('tr', {
    months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
    weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[yarn saat] LT',
      nextWeek: '[gelecek] dddd [saat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s nce',
      s: 'birka saniye',
      ss: '%d saniye',
      m: 'bir dakika',
      mm: '%d dakika',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;
        default:
          if (number === 0) {
            // special case for zero
            return number + '\'nc';
          }
          var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return tr;
});

/***/ }),

/***/ "./node_modules/moment/locale/tzl.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzl.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.
  var tzl = moment.defineLocale('tzl', {
    months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM [dallas] YYYY',
      LLL: 'D. MMMM [dallas] YYYY HH.mm',
      LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM: function isPM(input) {
      return 'd\'o' === input.toLowerCase();
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'd\'o' : 'D\'O';
      } else {
        return isLower ? 'd\'a' : 'D\'A';
      }
    },
    calendar: {
      sameDay: '[oxhi ] LT',
      nextDay: '[dem ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ieiri ] LT',
      lastWeek: '[sr el] dddd [lasteu ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'osprei %s',
      past: 'ja%s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      's': ['viensas secunds', '\'iensas secunds'],
      'ss': [number + ' secunds', '' + number + ' secunds'],
      'm': ['\'n mut', '\'iens mut'],
      'mm': [number + ' muts', '' + number + ' muts'],
      'h': ['\'n ora', '\'iensa ora'],
      'hh': [number + ' oras', '' + number + ' oras'],
      'd': ['\'n ziua', '\'iensa ziua'],
      'dd': [number + ' ziuas', '' + number + ' ziuas'],
      'M': ['\'n mes', '\'iens mes'],
      'MM': [number + ' mesen', '' + number + ' mesen'],
      'y': ['\'n ar', '\'iens ar'],
      'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
  }
  return tzl;
});

/***/ }),

/***/ "./node_modules/moment/locale/tzm-latn.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/tzm-latn.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var tzmLatn = moment.defineLocale('tzm-latn', {
    months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[asdkh g] LT',
      nextDay: '[aska g] LT',
      nextWeek: 'dddd [g] LT',
      lastDay: '[assant g] LT',
      lastWeek: 'dddd [g] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dadkh s yan %s',
      past: 'yan %s',
      s: 'imik',
      ss: '%d imik',
      m: 'minu',
      mm: '%d minu',
      h: 'saa',
      hh: '%d tassain',
      d: 'ass',
      dd: '%d ossan',
      M: 'ayowr',
      MM: '%d iyyirn',
      y: 'asgas',
      yy: '%d isgasn'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return tzmLatn;
});

/***/ }),

/***/ "./node_modules/moment/locale/tzm.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzm.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var tzm = moment.defineLocale('tzm', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '   %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d o',
      M: 'o',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.
    }
  });
  return tzm;
});

/***/ }),

/***/ "./node_modules/moment/locale/ug-cn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ug-cn.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js language configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var ugCn = moment.defineLocale('ug-cn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY-M-D-',
      LLL: 'YYYY-M-D- HH:mm',
      LLLL: 'dddd YYYY-M-D- HH:mm'
    },
    meridiemParse: / || || |/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === ' ' || meridiem === '' || meridiem === ' ') {
        return hour;
      } else if (meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return ' ';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return ' ';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return ' ';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '-';
        case 'w':
        case 'W':
          return number + '-';
        default:
          return number;
      }
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.
    }
  });
  return ugCn;
});

/***/ }),

/***/ "./node_modules/moment/locale/uk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/uk.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }
  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      'ss': withoutSuffix ? '__' : '__',
      'mm': withoutSuffix ? '__' : '__',
      'hh': withoutSuffix ? '__' : '__',
      'dd': '__',
      'MM': '__',
      'yy': '__'
    };
    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }
  function weekdaysCaseReplace(m, format) {
    var weekdays = {
      'nominative': '______'.split('_'),
      'accusative': '______'.split('_'),
      'genitive': '______'.split('_')
    };
    if (m === true) {
      return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
    }
    if (!m) {
      return weekdays['nominative'];
    }
    var nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
    return weekdays[nounCase][m.day()];
  }
  function processHoursFunction(str) {
    return function () {
      return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
  }
  var uk = moment.defineLocale('uk', {
    months: {
      'format': '___________'.split('_'),
      'standalone': '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: weekdaysCaseReplace,
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: processHoursFunction('[ '),
      nextDay: processHoursFunction('[ '),
      lastDay: processHoursFunction('[ '),
      nextWeek: processHoursFunction('[] dddd ['),
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return processHoursFunction('[] dddd [').call(this);
          case 1:
          case 2:
          case 4:
            return processHoursFunction('[] dddd [').call(this);
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return number + '-';
        case 'D':
          return number + '-';
        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return uk;
});

/***/ }),

/***/ "./node_modules/moment/locale/ur.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ur.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''];
  var days = ['', '', '', '', '', '', ''];
  var ur = moment.defineLocale('ur', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }
      return '';
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[  ] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return ur;
});

/***/ }),

/***/ "./node_modules/moment/locale/uz-latn.js":
/*!***********************************************!*\
  !*** ./node_modules/moment/locale/uz-latn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var uzLatn = moment.defineLocale('uz-latn', {
    months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Bugun soat] LT [da]',
      nextDay: '[Ertaga] LT [da]',
      nextWeek: 'dddd [kuni soat] LT [da]',
      lastDay: '[Kecha soat] LT [da]',
      lastWeek: '[O\'tgan] dddd [kuni soat] LT [da]',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Yaqin %s ichida',
      past: 'Bir necha %s oldin',
      s: 'soniya',
      ss: '%d soniya',
      m: 'bir daqiqa',
      mm: '%d daqiqa',
      h: 'bir soat',
      hh: '%d soat',
      d: 'bir kun',
      dd: '%d kun',
      M: 'bir oy',
      MM: '%d oy',
      y: 'bir yil',
      yy: '%d yil'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.
    }
  });
  return uzLatn;
});

/***/ }),

/***/ "./node_modules/moment/locale/uz.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/uz.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var uz = moment.defineLocale('uz', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd [ ] LT []',
      lastDay: '[ ] LT []',
      lastWeek: '[] dddd [ ] LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: '  %s ',
      s: '',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return uz;
});

/***/ }),

/***/ "./node_modules/moment/locale/vi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/vi.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var vi = moment.defineLocale('vi', {
    months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact: true,
    weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /sa|ch/i,
    isPM: function isPM(input) {
      return /^ch$/i.test(input);
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'sa' : 'SA';
      } else {
        return isLower ? 'ch' : 'CH';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [nm] YYYY',
      LLL: 'D MMMM [nm] YYYY HH:mm',
      LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
      l: 'DD/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hm nay lc] LT',
      nextDay: '[Ngy mai lc] LT',
      nextWeek: 'dddd [tun ti lc] LT',
      lastDay: '[Hm qua lc] LT',
      lastWeek: 'dddd [tun ri lc] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ti',
      past: '%s trc',
      s: 'vi giy',
      ss: '%d giy',
      m: 'mt pht',
      mm: '%d pht',
      h: 'mt gi',
      hh: '%d gi',
      d: 'mt ngy',
      dd: '%d ngy',
      M: 'mt thng',
      MM: '%d thng',
      y: 'mt nm',
      yy: '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return vi;
});

/***/ }),

/***/ "./node_modules/moment/locale/x-pseudo.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/x-pseudo.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var xPseudo = moment.defineLocale('x-pseudo', {
    months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact: true,
    weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[T~d~ t] LT',
      nextDay: '[T~m~rr~w t] LT',
      nextWeek: 'dddd [t] LT',
      lastDay: '[~st~rd~ t] LT',
      lastWeek: '[L~st] dddd [t] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '~ %s',
      past: '%s ~g',
      s: ' ~fw ~sc~ds',
      ss: '%d s~c~ds',
      m: ' ~m~t',
      mm: '%d m~~ts',
      h: '~ h~r',
      hh: '%d h~rs',
      d: ' ~d',
      dd: '%d d~s',
      M: ' ~m~th',
      MM: '%d m~t~hs',
      y: ' ~r',
      yy: '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return xPseudo;
});

/***/ }),

/***/ "./node_modules/moment/locale/yo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/yo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var yo = moment.defineLocale('yo', {
    months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Oni ni] LT',
      nextDay: '[la ni] LT',
      nextWeek: 'dddd [s ton\'b] [ni] LT',
      lastDay: '[Ana ni] LT',
      lastWeek: 'dddd [s tol] [ni] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ni %s',
      past: '%s kja',
      s: 'isju aaya die',
      ss: 'aaya %d',
      m: 'isju kan',
      mm: 'isju %d',
      h: 'wakati kan',
      hh: 'wakati %d',
      d: 'j kan',
      dd: 'j %d',
      M: 'osu kan',
      MM: 'osu %d',
      y: 'dun kan',
      yy: 'dun %d'
    },
    dayOfMonthOrdinalParse: /j\s\d{1,2}/,
    ordinal: 'j %d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return yo;
});

/***/ }),

/***/ "./node_modules/moment/locale/zh-cn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-cn.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var zhCn = moment.defineLocale('zh-cn', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMDAhmm',
      LLLL: 'YYYYMDddddAhmm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      } else {
        // ''
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: '[]ddddLT',
      lastDay: '[]LT',
      lastWeek: '[]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
  });
  return zhCn;
});

/***/ }),

/***/ "./node_modules/moment/locale/zh-hk.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-hk.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var zhHk = moment.defineLocale('zh-hk', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: '[]ddddLT',
      lastDay: '[]LT',
      lastWeek: '[]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhHk;
});

/***/ }),

/***/ "./node_modules/moment/locale/zh-tw.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-tw.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js locale configuration

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' && "function" === 'function' ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (moment) {
  'use strict';

  var zhTw = moment.defineLocale('zh-tw', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }
      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;
      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';
        case 'M':
          return number + '';
        case 'w':
        case 'W':
          return number + '';
        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhTw;
});

/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//! moment.js

;
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function () {
  'use strict';

  var hookCallback;
  function hooks() {
    return hookCallback.apply(null, arguments);
  }

  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback(callback) {
    hookCallback = callback;
  }
  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }
  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }
  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;
      for (k in obj) {
        if (obj.hasOwnProperty(k)) {
          return false;
        }
      }
      return true;
    }
  }
  function isUndefined(input) {
    return input === void 0;
  }
  function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }
  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }
  function map(arr, fn) {
    var res = [],
      i;
    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }
    return res;
  }
  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }
  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }
    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }
    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }
    return a;
  }
  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }
  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }
  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }
    return m._pf;
  }
  var some;
  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function some(fun) {
      var t = Object(this);
      var len = t.length >>> 0;
      for (var i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }
      return false;
    };
  }
  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m);
      var parsedParts = some.call(flags.parsedDateParts, function (i) {
        return i != null;
      });
      var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }
    return m._isValid;
  }
  function createInvalid(flags) {
    var m = createUTC(NaN);
    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }
    return m;
  }

  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var momentProperties = hooks.momentProperties = [];
  function copyConfig(to, from) {
    var i, prop, val;
    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
      to._i = from._i;
    }
    if (!isUndefined(from._f)) {
      to._f = from._f;
    }
    if (!isUndefined(from._l)) {
      to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }
    if (momentProperties.length > 0) {
      for (i = 0; i < momentProperties.length; i++) {
        prop = momentProperties[i];
        val = from[prop];
        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }
    return to;
  }
  var updateInProgress = false;

  // Moment prototype object
  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
      this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }
  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }
  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }
  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
      value = 0;
    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }
    return value;
  }

  // compare two arrays, return the number of differences
  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
      lengthDiff = Math.abs(array1.length - array2.length),
      diffs = 0,
      i;
    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }
    return diffs + lengthDiff;
  }
  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }
  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }
      if (firstTime) {
        var args = [];
        var arg;
        for (var i = 0; i < arguments.length; i++) {
          arg = '';
          if (_typeof(arguments[i]) === 'object') {
            arg += '\n[' + i + '] ';
            for (var key in arguments[0]) {
              arg += key + ': ' + arguments[0][key] + ', ';
            }
            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }
          args.push(arg);
        }
        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
        firstTime = false;
      }
      return fn.apply(this, arguments);
    }, fn);
  }
  var deprecations = {};
  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }
  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;
  function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }
  function set(config) {
    var prop, i;
    for (i in config) {
      prop = config[i];
      if (isFunction(prop)) {
        this[i] = prop;
      } else {
        this['_' + i] = prop;
      }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
  }
  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
      prop;
    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }
    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }
    return res;
  }
  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }
  var keys;
  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function keys(obj) {
      var i,
        res = [];
      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }
      return res;
    };
  }
  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };
  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }
  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };
  function longDateFormat(key) {
    var format = this._longDateFormat[key],
      formatUpper = this._longDateFormat[key.toUpperCase()];
    if (format || !formatUpper) {
      return format;
    }
    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
      return val.slice(1);
    });
    return this._longDateFormat[key];
  }
  var defaultInvalidDate = 'Invalid date';
  function invalidDate() {
    return this._invalidDate;
  }
  var defaultOrdinal = '%d';
  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }
  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };
  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }
  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }
  var aliases = {};
  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }
  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }
  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
      normalizedProp,
      prop;
    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);
        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }
    return normalizedInput;
  }
  var priorities = {};
  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }
  function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
      units.push({
        unit: u,
        priority: priorities[u]
      });
    }
    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }
  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
      zerosToFill = targetLength - absNumber.length,
      sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }
  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
  var formatFunctions = {};
  var formatTokenFunctions = {};

  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
      func = function func() {
        return this[callback]();
      };
    }
    if (token) {
      formatTokenFunctions[token] = func;
    }
    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }
    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }
  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
  }
  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
      i,
      length;
    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }
    return function (mom) {
      var output = '',
        i;
      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }
      return output;
    };
  }

  // format date using native date object
  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }
    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }
  function expandFormat(format, locale) {
    var i = 5;
    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }
    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }
    return format;
  }
  var match1 = /\d/; //       0 - 9
  var match2 = /\d\d/; //      00 - 99
  var match3 = /\d{3}/; //     000 - 999
  var match4 = /\d{4}/; //    0000 - 9999
  var match6 = /[+-]?\d{6}/; // -999999 - 999999
  var match1to2 = /\d\d?/; //       0 - 99
  var match3to4 = /\d\d\d\d?/; //     999 - 9999
  var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999
  var match1to3 = /\d{1,3}/; //       0 - 999
  var match1to4 = /\d{1,4}/; //       0 - 9999
  var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

  var matchUnsigned = /\d+/; //       0 - inf
  var matchSigned = /[+-]?\d+/; //    -inf - inf

  var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months
  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
  var regexes = {};
  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }
  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }
    return regexes[token](config._strict, config._locale);
  }

  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }
  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
  var tokens = {};
  function addParseToken(token, callback) {
    var i,
      func = callback;
    if (typeof token === 'string') {
      token = [token];
    }
    if (isNumber(callback)) {
      func = function func(input, array) {
        array[callback] = toInt(input);
      };
    }
    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }
  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }
  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }
  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;

  // FORMATTING

  addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

  // ALIASES

  addUnitAlias('year', 'y');

  // PRIORITIES

  addUnitPriority('year', 1);

  // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
  });

  // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }

  // HOOKS

  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };

  // MOMENTS

  var getSetYear = makeGetSet('FullYear', true);
  function getIsLeapYear() {
    return isLeapYear(this.year());
  }
  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }
  function get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }
  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
  }

  // MOMENTS

  function stringGet(units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units]();
    }
    return this;
  }
  function stringSet(units, value) {
    if (_typeof(units) === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units);
      for (var i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units](value);
      }
    }
    return this;
  }
  function mod(n, x) {
    return (n % x + x) % x;
  }
  var indexOf;
  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function indexOf(o) {
      // I know
      var i;
      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }
      return -1;
    };
  }
  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  }

  // FORMATTING

  addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  });

  // ALIASES

  addUnitAlias('month', 'M');

  // PRIORITY

  addUnitPriority('month', 8);

  // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  });

  // LOCALES

  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }
  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }
  function handleStrictParse(monthName, format, strict) {
    var i,
      ii,
      mom,
      llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }
      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
      // No op
      return mom;
    }
    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value);
        // TODO: Another silent failure?
        if (!isNumber(value)) {
          return mom;
        }
      }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
  }
  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, 'Month');
    }
  }
  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }
  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }
      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }
  var defaultMonthsRegex = matchWord;
  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }
      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }
      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }
  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom;
    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }
  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date;
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      date = new Date(y + 400, m, d, h, M, s, ms);
      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }
    return date;
  }
  function createUTCDate(y) {
    var date;
    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      var args = Array.prototype.slice.call(arguments);
      // preserve leap years using a full 400 year cycle, then reset
      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));
      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }
    return date;
  }

  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
    var
      // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
      // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  }

  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
      weekOffset = firstWeekOffset(year, dow, doy),
      dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
      resYear,
      resDayOfYear;
    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }
    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }
  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
      week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
      resWeek,
      resYear;
    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }
    return {
      week: resWeek,
      year: resYear
    };
  }
  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
      weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }

  // FORMATTING

  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

  // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');

  // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);

  // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  });

  // HELPERS

  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }
  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 6th is the first week of the year.
  };
  function localeFirstDayOfWeek() {
    return this._week.dow;
  }
  function localeFirstDayOfYear() {
    return this._week.doy;
  }

  // MOMENTS

  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }
  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  }

  // FORMATTING

  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');

  // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');

  // PRIORITY
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);

  // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
  });

  // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }
    if (!isNaN(input)) {
      return parseInt(input, 10);
    }
    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
      return input;
    }
    return null;
  }
  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
  }

  // LOCALES
  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }
  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays(m, format) {
    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }
  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }
  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }
  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
      ii,
      mom,
      llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];
      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }
    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._weekdaysParse, llc);
        if (ii !== -1) {
          return ii;
        }
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }
  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;
    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }
    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already

      mom = createUTC([2000, 1]).day(i);
      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
      }
      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      }
      // test the regex
      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  }

  // MOMENTS

  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }
  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }
  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }
  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }
      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }
  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }
      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }
  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }
      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }
      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }
  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }
    var minPieces = [],
      shortPieces = [],
      longPieces = [],
      mixedPieces = [],
      i,
      mom,
      minp,
      shortp,
      longp;
    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = this.weekdaysMin(mom, '');
      shortp = this.weekdaysShort(mom, '');
      longp = this.weekdays(mom, '');
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }

  // FORMATTING

  function hFormat() {
    return this.hours() % 12 || 12;
  }
  function kFormat() {
    return this.hours() || 24;
  }
  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }
  meridiem('a', true);
  meridiem('A', false);

  // ALIASES

  addUnitAlias('hour', 'h');

  // PRIORITY
  addUnitPriority('hour', 13);

  // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }
  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  });

  // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }
  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }

  // MOMENTS

  // Setting the hour should keep the time, because the user explicitly
  // specified which hour they want. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  var getSetHour = makeGetSet('Hours', true);
  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  };

  // internal storage for locale config files
  var locales = {};
  var localeFamilies = {};
  var globalLocale;
  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  }

  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
    var i = 0,
      j,
      next,
      locale,
      split;
    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;
      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));
        if (locale) {
          return locale;
        }
        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }
        j--;
      }
      i++;
    }
    return globalLocale;
  }
  function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && typeof module !== 'undefined' && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        var aliasedRequire = require;
        __webpack_require__("./node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {}
    }
    return locales[name];
  }

  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function getSetGlobalLocale(key, values) {
    var data;
    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }
      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== 'undefined' && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
        }
      }
    }
    return globalLocale._abbr;
  }
  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
        parentConfig = baseConfig;
      config.abbr = name;
      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);
          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }
            localeFamilies[config.parentLocale].push({
              name: name,
              config: config
            });
            return null;
          }
        }
      }
      locales[name] = new Locale(mergeConfigs(parentConfig, config));
      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      }

      // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.
      getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }
  function updateLocale(name, config) {
    if (config != null) {
      var locale,
        tmpLocale,
        parentConfig = baseConfig;
      // MERGE
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      locale = new Locale(config);
      locale.parentLocale = locales[name];
      locales[name] = locale;

      // backwards compat for now: also set the locale
      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }
    return locales[name];
  }

  // returns locale data
  function getLocale(key) {
    var locale;
    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }
    if (!key) {
      return globalLocale;
    }
    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);
      if (locale) {
        return locale;
      }
      key = [key];
    }
    return chooseLocale(key);
  }
  function listLocales() {
    return keys(locales);
  }
  function checkOverflow(m) {
    var overflow;
    var a = m._a;
    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }
      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }
      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }
      getParsingFlags(m).overflow = overflow;
    }
    return m;
  }

  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return c;
  }
  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }

  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray(config) {
    var i,
      date,
      input = [],
      currentDate,
      expectedWeekday,
      yearToUse;
    if (config._d) {
      return;
    }
    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }
      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }
    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
      config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }
  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4;

      // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).
      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);
      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      var curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

      // Default to current week.
      week = defaults(w.w, curWeek.week);
      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;
        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from beginning of week
        weekday = w.e + dow;
        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to beginning of week
        weekday = dow;
      }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }

  // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/],
  // YYYYMM is NOT allowed by the standard
  ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

  // iso time formats and regexes
  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

  // date from iso format
  function configFromISO(config) {
    var i,
      l,
      string = config._i,
      match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
      allowTime,
      dateFormat,
      timeFormat,
      tzFormat;
    if (match) {
      getParsingFlags(config).iso = true;
      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }
      if (dateFormat == null) {
        config._isValid = false;
        return;
      }
      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }
        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }
      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }
      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }
      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }

  // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }
    return result;
  }
  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }
    return year;
  }
  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }
  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
        weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }
    return true;
  }
  var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10);
      var m = hm % 100,
        h = (hm - m) / 100;
      return h * 60 + m;
    }
  }

  // date and time from ref 2822 format
  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
      var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }
      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  }

  // date from iso format or fallback
  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);
    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }
    configFromISO(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }
    configFromRFC2822(config);
    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
  }
  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  });

  // constant that refers to the ISO standard
  hooks.ISO_8601 = function () {};

  // constant that refers to the RFC 2822 form
  hooks.RFC_2822 = function () {};

  // date from string and format string
  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }
    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
      i,
      parsedInput,
      tokens,
      token,
      skipped,
      stringLength = string.length,
      totalParsedInputLength = 0;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
      // console.log('token', token, 'parsedInput', parsedInput,
      //         'regex', getParseRegexForToken(token, config));
      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));
        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      }
      // don't parse if it's not a known token
      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }
        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }
    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
    configFromArray(config);
    checkOverflow(config);
  }
  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
      // nothing to do
      return hour;
    }
    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);
      if (isPm && hour < 12) {
        hour += 12;
      }
      if (!isPm && hour === 12) {
        hour = 0;
      }
      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  }

  // date from string and array of format strings
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;
    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }
    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = copyConfig({}, config);
      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }
      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);
      if (!isValid(tempConfig)) {
        continue;
      }

      // if there is any input that was not parsed add a penalty for that format
      currentScore += getParsingFlags(tempConfig).charsLeftOver;

      //or tokens
      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;
      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
    extend(config, bestMoment || tempConfig);
  }
  function configFromObject(config) {
    if (config._d) {
      return;
    }
    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }
  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }
    return res;
  }
  function prepareConfig(config) {
    var input = config._i,
      format = config._f;
    config._locale = config._locale || getLocale(config._l);
    if (input === null || format === undefined && input === '') {
      return createInvalid({
        nullInput: true
      });
    }
    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }
    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }
    if (!isValid(config)) {
      config._d = null;
    }
    return config;
  }
  function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }
  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};
    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }
    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }
  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }
  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  });
  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  });

  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }
    if (!moments.length) {
      return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }
    return res;
  }

  // TODO: Use [].sort instead?
  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }
  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }
  var now = function now() {
    return Date.now ? Date.now() : +new Date();
  };
  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
  function isDurationValid(m) {
    for (var key in m) {
      if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }
    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }
        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }
    return true;
  }
  function isValid$1() {
    return this._isValid;
  }
  function createInvalid$1() {
    return createDuration(NaN);
  }
  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
      years = normalizedInput.year || 0,
      quarters = normalizedInput.quarter || 0,
      months = normalizedInput.month || 0,
      weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
      days = normalizedInput.day || 0,
      hours = normalizedInput.hour || 0,
      minutes = normalizedInput.minute || 0,
      seconds = normalizedInput.second || 0,
      milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds + seconds * 1e3 +
    // 1000
    minutes * 6e4 +
    // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();
    this._bubble();
  }
  function isDuration(obj) {
    return obj instanceof Duration;
  }
  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  }

  // FORMATTING

  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = '+';
      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }
      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }
  offset('Z', ':');
  offset('ZZ', '');

  // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  });

  // HELPERS

  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;
  function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);
    if (matches === null) {
      return null;
    }
    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  }

  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
      // Use low-level api, because this fn is low-level api.
      res._d.setTime(res._d.valueOf() + diff);
      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }
  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }

  // HOOKS

  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  hooks.updateOffset = function () {};

  // MOMENTS

  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
      localAdjust;
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }
    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);
        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }
      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }
      this._offset = input;
      this._isUTC = true;
      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }
      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }
      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }
  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }
      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }
  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }
  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;
      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }
    return this;
  }
  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
      var tZone = offsetFromString(matchOffset, this._i);
      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }
    return this;
  }
  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }
  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }
  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }
    var c = {};
    copyConfig(c, this);
    c = prepareConfig(c);
    if (c._a) {
      var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }
    return this._isDSTShifted;
  }
  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }
  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }
  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }

  // ASP.NET json date format regex
  var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

  // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day
  var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function createDuration(input, key) {
    var duration = input,
      // matching against regexp is expensive, do it on demand
      match = null,
      sign,
      ret,
      diffRes;
    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input)) {
      duration = {};
      if (key) {
        duration[key] = input;
      } else {
        duration.milliseconds = input;
      }
    } else if (!!(match = aspNetRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
      };
    } else if (!!(match = isoRegex.exec(input))) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (_typeof(duration) === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }
    ret = new Duration(duration);
    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }
    return ret;
  }
  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;
  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
  }
  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }
    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }
  function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }
    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }
    return res;
  }

  // TODO: remove 'name' arg after deprecation is removed
  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp;
      //invert the arguments, but complain about it
      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }
      val = typeof val === 'string' ? +val : val;
      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }
  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
      days = absRound(duration._days),
      months = absRound(duration._months);
    if (!mom.isValid()) {
      // No op
      return;
    }
    updateOffset = updateOffset == null ? true : updateOffset;
    if (months) {
      setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }
  var add = createAdder(1, 'add');
  var subtract = createAdder(-1, 'subtract');
  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }
  function calendar$1(time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
      sod = cloneWithOffset(now, this).startOf('day'),
      format = hooks.calendarFormat(this, sod) || 'sameElse';
    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }
  function clone() {
    return new Moment(this);
  }
  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }
  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }
  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
      localTo = isMoment(to) ? to : createLocal(to);
    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }
  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
      inputMs;
    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }
    units = normalizeUnits(units) || 'millisecond';
    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }
  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }
  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }
  function diff(input, units, asFloat) {
    var that, zoneDelta, output;
    if (!this.isValid()) {
      return NaN;
    }
    that = cloneWithOffset(input, this);
    if (!that.isValid()) {
      return NaN;
    }
    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);
    switch (units) {
      case 'year':
        output = monthDiff(this, that) / 12;
        break;
      case 'month':
        output = monthDiff(this, that);
        break;
      case 'quarter':
        output = monthDiff(this, that) / 3;
        break;
      case 'second':
        output = (this - that) / 1e3;
        break;
      // 1000
      case 'minute':
        output = (this - that) / 6e4;
        break;
      // 1000 * 60
      case 'hour':
        output = (this - that) / 36e5;
        break;
      // 1000 * 60 * 60
      case 'day':
        output = (this - that - zoneDelta) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst
      case 'week':
        output = (this - that - zoneDelta) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst
      default:
        output = this - that;
    }
    return asFloat ? output : absFloor(output);
  }
  function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
      // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
      anchor2,
      adjust;
    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
      // linear across the month
      adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
  }
  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }
  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
      }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }

  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */
  function inspect() {
    if (!this.isValid()) {
      return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
      zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }
  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }
  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }
  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }
  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  }

  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function locale(key) {
    var newLocaleData;
    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);
      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }
      return this;
    }
  }
  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });
  function localeData() {
    return this._locale;
  }
  var MS_PER_SECOND = 1000;
  var MS_PER_MINUTE = 60 * MS_PER_SECOND;
  var MS_PER_HOUR = 60 * MS_PER_MINUTE;
  var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

  // actual modulo - handles negative numbers (for dates before 1970):
  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }
  function localStartOfDate(y, m, d) {
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }
  function utcStartOfDate(y, m, d) {
    // Date.UTC remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }
  function startOf(units) {
    var time;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }
    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case 'year':
        time = startOfDate(this.year(), 0, 1);
        break;
      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;
      case 'month':
        time = startOfDate(this.year(), this.month(), 1);
        break;
      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;
      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;
      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date());
        break;
      case 'hour':
        time = this._d.valueOf();
        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;
      case 'minute':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;
      case 'second':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function endOf(units) {
    var time;
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }
    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
    switch (units) {
      case 'year':
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;
      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;
      case 'month':
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;
      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;
      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;
      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;
      case 'hour':
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;
      case 'minute':
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;
      case 'second':
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }
    this._d.setTime(time);
    hooks.updateOffset(this, true);
    return this;
  }
  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }
  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }
  function toDate() {
    return new Date(this.valueOf());
  }
  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }
  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }
  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }
  function isValid$2() {
    return isValid(this);
  }
  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }
  function invalidAt() {
    return getParsingFlags(this).overflow;
  }
  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }

  // FORMATTING

  addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
  });
  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }
  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');

  // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');

  // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);

  // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  });

  // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }
  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }
  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }
  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }
  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);
      if (week > weeksTarget) {
        week = weeksTarget;
      }
      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }
  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
      date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  }

  // FORMATTING

  addFormatToken('Q', 0, 'Qo', 'quarter');

  // ALIASES

  addUnitAlias('quarter', 'Q');

  // PRIORITY

  addUnitPriority('quarter', 7);

  // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  });

  // MOMENTS

  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }

  // FORMATTING

  addFormatToken('D', ['DD', 2], 'Do', 'date');

  // ALIASES

  addUnitAlias('date', 'D');

  // PRIORITY
  addUnitPriority('date', 9);

  // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  });

  // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true);

  // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

  // ALIASES

  addUnitAlias('dayOfYear', 'DDD');

  // PRIORITY
  addUnitPriority('dayOfYear', 4);

  // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
  });

  // HELPERS

  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  }

  // FORMATTING

  addFormatToken('m', ['mm', 2], 0, 'minute');

  // ALIASES

  addUnitAlias('minute', 'm');

  // PRIORITY

  addUnitPriority('minute', 14);

  // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);

  // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false);

  // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second');

  // ALIASES

  addUnitAlias('second', 's');

  // PRIORITY

  addUnitPriority('second', 15);

  // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);

  // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false);

  // FORMATTING

  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
  });

  // ALIASES

  addUnitAlias('millisecond', 'ms');

  // PRIORITY

  addUnitPriority('millisecond', 16);

  // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }
  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }
  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }
  // MOMENTS

  var getSetMillisecond = makeGetSet('Milliseconds', false);

  // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');

  // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }
  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }
  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;
  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
  function createUnix(input) {
    return createLocal(input * 1000);
  }
  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }
  function preParsePostFormat(string) {
    return string;
  }
  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;
  function get$1(format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }
  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }
    format = format || '';
    if (index != null) {
      return get$1(format, index, field, 'month');
    }
    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, 'month');
    }
    return out;
  }

  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }
      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }
      format = format || '';
    }
    var locale = getLocale(),
      shift = localeSorted ? locale._week.dow : 0;
    if (index != null) {
      return get$1(format, (index + shift) % 7, field, 'day');
    }
    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
  }
  function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }
  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }
  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }
  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }
  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }
  getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
        output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });

  // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
  var mathAbs = Math.abs;
  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }
  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  }

  // supports only 2.0-style add(1, 's') or add(duration)
  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  }

  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }
  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }
  function bubble() {
    var milliseconds = this._milliseconds;
    var days = this._days;
    var months = this._months;
    var data = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }
  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
  }
  function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
  }
  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;
    units = normalizeUnits(units);
    if (units === 'month' || units === 'quarter' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);
      switch (units) {
        case 'month':
          return months;
        case 'quarter':
          return months / 3;
        case 'year':
          return months / 12;
      }
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));
      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;
        case 'day':
          return days + milliseconds / 864e5;
        case 'hour':
          return days * 24 + milliseconds / 36e5;
        case 'minute':
          return days * 1440 + milliseconds / 6e4;
        case 'second':
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here
        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;
        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  }

  // TODO: Use this.as('ms')?
  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }
    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }
  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }
  var asMilliseconds = makeAs('ms');
  var asSeconds = makeAs('s');
  var asMinutes = makeAs('m');
  var asHours = makeAs('h');
  var asDays = makeAs('d');
  var asWeeks = makeAs('w');
  var asMonths = makeAs('M');
  var asQuarters = makeAs('Q');
  var asYears = makeAs('y');
  function clone$1() {
    return createDuration(this);
  }
  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
  }
  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }
  var milliseconds = makeGetter('milliseconds');
  var seconds = makeGetter('seconds');
  var minutes = makeGetter('minutes');
  var hours = makeGetter('hours');
  var days = makeGetter('days');
  var months = makeGetter('months');
  var years = makeGetter('years');
  function weeks() {
    return absFloor(this.days() / 7);
  }
  var round = Math.round;
  var thresholds = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month
    M: 11 // months to year
  };

  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }
  function relativeTime$1(posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds = round(duration.as('s'));
    var minutes = round(duration.as('m'));
    var hours = round(duration.as('h'));
    var days = round(duration.as('d'));
    var months = round(duration.as('M'));
    var years = round(duration.as('y'));
    var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  }

  // This function allows you to set the rounding function for relative time strings
  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }
    if (typeof roundingFunction === 'function') {
      round = roundingFunction;
      return true;
    }
    return false;
  }

  // This function allows you to set a threshold for relative time strings
  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }
    if (limit === undefined) {
      return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
      thresholds.ss = limit - 1;
    }
    return true;
  }
  function humanize(withSuffix) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);
    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }
    return locale.postformat(output);
  }
  var abs$1 = Math.abs;
  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }
  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }
    var seconds = abs$1(this._milliseconds) / 1000;
    var days = abs$1(this._days);
    var months = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();
    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    }
    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
  }
  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang;

  // Side effect imports

  // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');

  // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  });

  // Side effect imports

  hooks.version = '2.24.0';
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto;

  // currently HTML5 input type only supports 24-hour formats
  hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
    // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',
    // <input type="date" />
    TIME: 'HH:mm',
    // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',
    // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',
    // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',
    // <input type="week" />
    MONTH: 'YYYY-MM' // <input type="month" />
  };
  return hooks;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/mouse-pos/index.js":
/*!*****************************************!*\
  !*** ./node_modules/mouse-pos/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var Mouse;
module.exports = Mouse = {
  rel: function rel(e) {
    var mouseX, mouseY, rect, target;
    mouseX = e.offsetX;
    mouseY = e.offsetY;
    if (mouseX == undefined) {
      rect = target.getBoundingClientRect();
      target = e.target || e.srcElement;
      if (mouseX == undefined) {
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
      }
      if (mouseX == undefined) {
        mouseX = e.pageX - target.offsetLeft;
        mouseY = e.pageY - target.offsetTop;
      }
      if (mouseX == undefined) {
        console.log(e, "no mouse event defined. your browser sucks");
        return;
      }
    }
    return [mouseX, mouseY];
  },
  abs: function abs(e) {
    var mouseX, mouseY;
    mouseX = e.pageX;
    mouseY = e.pageY;
    if (mouseX == undefined) {
      mouseX = e.layerX;
      mouseY = e.layerY;
    }
    if (mouseX == undefined) {
      mouseX = e.clientX;
      mouseY = e.clientY;
    }
    if (mouseX == undefined) {
      mouseX = e.x;
      mouseY = e.y;
    }
    return [mouseX, mouseY];
  },
  wheelDelta: function wheelDelta(e) {
    var delta;
    delta = [e.deltaX, e.deltaY];
    if (delta[0] == undefined) {
      // in case there is a more detailed scroll sensor - use it
      if (e.mozMovementX) {
        delta = [0, e.mozMovementX];
      }
    }
    // safety first
    if (isNaN(delta[0])) {
      delta[0] = 0;
    }
    if (isNaN(delta[1])) {
      delta[1] = 0;
    }
    return delta;
  }
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/buried.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/buried.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#00a35c",
  R: "#00fc03",
  N: "#00eb14",
  D: "#00eb14",
  C: "#0000ff",
  Q: "#00f10e",
  E: "#00f10e",
  G: "#009d62",
  H: "#00d52a",
  I: "#0054ab",
  L: "#007b84",
  K: "#00ff00",
  M: "#009768",
  F: "#008778",
  P: "#00e01f",
  S: "#00d52a",
  T: "#00db24",
  W: "#00a857",
  Y: "#00e619",
  V: "#005fa0",
  B: "#00eb14",
  X: "#00b649",
  Z: "#00f10e"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/cinema.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/cinema.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#BBBBBB",
  B: "grey",
  C: "yellow",
  D: "red",
  E: "red",
  F: "magenta",
  G: "brown",
  H: "#00FFFF",
  I: "#BBBBBB",
  J: "#fff",
  K: "#00FFFF",
  L: "#BBBBBB",
  M: "#BBBBBB",
  N: "green",
  O: "#fff",
  P: "brown",
  Q: "green",
  R: "#00FFFF",
  S: "green",
  T: "green",
  U: "#fff",
  V: "#BBBBBB",
  W: "magenta",
  X: "grey",
  Y: "magenta",
  Z: "grey",
  Gap: "grey"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/clustal.js":
/*!******************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/clustal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "orange",
  B: "#fff",
  C: "green",
  D: "red",
  E: "red",
  F: "blue",
  G: "orange",
  H: "red",
  I: "green",
  J: "#fff",
  K: "red",
  L: "green",
  M: "green",
  N: "#fff",
  O: "#fff",
  P: "orange",
  Q: "#fff",
  R: "red",
  S: "orange",
  T: "orange",
  U: "#fff",
  V: "green",
  W: "blue",
  X: "#fff",
  Y: "blue",
  Z: "#fff",
  Gap: "#fff"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/clustal2.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/clustal2.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#80a0f0",
  R: "#f01505",
  N: "#00ff00",
  D: "#c048c0",
  C: "#f08080",
  Q: "#00ff00",
  E: "#c048c0",
  G: "#f09048",
  H: "#15a4a4",
  I: "#80a0f0",
  L: "#80a0f0",
  K: "#f01505",
  M: "#80a0f0",
  F: "#80a0f0",
  P: "#ffff00",
  S: "#00ff00",
  T: "#00ff00",
  W: "#80a0f0",
  Y: "#15a4a4",
  V: "#80a0f0",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/helix.js":
/*!****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/helix.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#e718e7",
  R: "#6f906f",
  N: "#1be41b",
  D: "#778877",
  C: "#23dc23",
  Q: "#926d92",
  E: "#ff00ff",
  G: "#00ff00",
  H: "#758a75",
  I: "#8a758a",
  L: "#ae51ae",
  K: "#a05fa0",
  M: "#ef10ef",
  F: "#986798",
  P: "#00ff00",
  S: "#36c936",
  T: "#47b847",
  W: "#8a758a",
  Y: "#21de21",
  V: "#857a85",
  B: "#49b649",
  X: "#758a75",
  Z: "#c936c9"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/hydrophobicity.js":
/*!*************************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/hydrophobicity.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#ad0052",
  B: "#0c00f3",
  C: "#c2003d",
  D: "#0c00f3",
  E: "#0c00f3",
  F: "#cb0034",
  G: "#6a0095",
  H: "#1500ea",
  I: "#ff0000",
  J: "#fff",
  K: "#0000ff",
  L: "#ea0015",
  M: "#b0004f",
  N: "#0c00f3",
  O: "#fff",
  P: "#4600b9",
  Q: "#0c00f3",
  R: "#0000ff",
  S: "#5e00a1",
  T: "#61009e",
  U: "#fff",
  V: "#f60009",
  W: "#5b00a4",
  X: "#680097",
  Y: "#4f00b0",
  Z: "#0c00f3"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var schemes = __webpack_require__(/*! ./schemeclass */ "./node_modules/msa-colorschemes/src/schemeclass.js");
var StaticSchemeClass = schemes.stat;
var DynSchemeClass = schemes.dyn;
var Buried = __webpack_require__(/*! ./buried */ "./node_modules/msa-colorschemes/src/buried.js");
var Cinema = __webpack_require__(/*! ./cinema */ "./node_modules/msa-colorschemes/src/cinema.js");
var Clustal = __webpack_require__(/*! ./clustal */ "./node_modules/msa-colorschemes/src/clustal.js");
var Clustal2 = __webpack_require__(/*! ./clustal2 */ "./node_modules/msa-colorschemes/src/clustal2.js");
var Helix = __webpack_require__(/*! ./helix */ "./node_modules/msa-colorschemes/src/helix.js");
var Hydro = __webpack_require__(/*! ./hydrophobicity */ "./node_modules/msa-colorschemes/src/hydrophobicity.js");
var Lesk = __webpack_require__(/*! ./lesk */ "./node_modules/msa-colorschemes/src/lesk.js");
var Mae = __webpack_require__(/*! ./mae */ "./node_modules/msa-colorschemes/src/mae.js");
var Nucleotide = __webpack_require__(/*! ./nucleotide */ "./node_modules/msa-colorschemes/src/nucleotide.js");
var Purine = __webpack_require__(/*! ./purine */ "./node_modules/msa-colorschemes/src/purine.js");
var Strand = __webpack_require__(/*! ./strand */ "./node_modules/msa-colorschemes/src/strand.js");
var Taylor = __webpack_require__(/*! ./taylor */ "./node_modules/msa-colorschemes/src/taylor.js");
var Turn = __webpack_require__(/*! ./turn */ "./node_modules/msa-colorschemes/src/turn.js");
var Zappo = __webpack_require__(/*! ./zappo */ "./node_modules/msa-colorschemes/src/zappo.js");
var staticSchemes = {
  buried: Buried,
  buried_index: Buried,
  cinema: Cinema,
  clustal2: Clustal2,
  clustal: Clustal,
  helix: Helix,
  helix_propensity: Helix,
  hydro: Hydro,
  lesk: Lesk,
  mae: Mae,
  nucleotide: Nucleotide,
  purine: Purine,
  purine_pyrimidine: Purine,
  strand: Strand,
  strand_propensity: Strand,
  taylor: Taylor,
  turn: Turn,
  turn_propensity: Turn,
  zappo: Zappo
};
var pid = __webpack_require__(/*! ./pid_colors.js */ "./node_modules/msa-colorschemes/src/pid_colors.js");
var dynSchemes = {
  pid: pid
};
var Colors = function Colors(opt) {
  this.maps = clone(staticSchemes);
  this.dyn = clone(dynSchemes);
  this.opt = opt;
};
module.exports = Colors;
Colors.getScheme = function (scheme) {
  return staticSchemes[scheme];
};
Colors.prototype.getScheme = function (scheme) {
  var color = this.maps[scheme];
  if (color === undefined) {
    color = {};
    if (this.dyn[scheme] != undefined) {
      return new DynSchemeClass(this.dyn[scheme], this.opt);
    }
  }
  return new StaticSchemeClass(color);
};
Colors.prototype.addStaticScheme = function (name, scheme) {
  this.maps[name] = scheme;
};
Colors.prototype.addDynScheme = function (name, scheme) {
  this.dyn[name] = scheme;
};

// small helper to clone an object
function clone(obj) {
  if (null == obj || "object" != _typeof(obj)) return obj;
  var copy = obj.constructor();
  for (var attr in obj) {
    if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
  }
  return copy;
}

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/lesk.js":
/*!***************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/lesk.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: " orange",
  B: " #fff",
  C: " green",
  D: " red",
  E: " red",
  F: " green",
  G: " orange",
  H: " magenta",
  I: " green",
  J: " #fff",
  K: " red",
  L: " green",
  M: " green",
  N: " magenta",
  O: " #fff",
  P: " green",
  Q: " magenta",
  R: " red",
  S: " orange",
  T: " orange",
  U: " #fff",
  V: " green",
  W: " green",
  X: " #fff",
  Y: " green",
  Z: " #fff",
  Gap: " #fff"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/mae.js":
/*!**************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/mae.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: " #77dd88",
  B: " #fff",
  C: " #99ee66",
  D: " #55bb33",
  E: " #55bb33",
  F: " #9999ff",
  G: " #77dd88",
  H: " #5555ff",
  I: " #66bbff",
  J: " #fff",
  K: " #ffcc77",
  L: " #66bbff",
  M: " #66bbff",
  N: " #55bb33",
  O: " #fff",
  P: " #eeaaaa",
  Q: " #55bb33",
  R: " #ffcc77",
  S: " #ff4455",
  T: " #ff4455",
  U: " #fff",
  V: " #66bbff",
  W: " #9999ff",
  X: " #fff",
  Y: " #9999ff",
  Z: " #fff",
  Gap: " #fff"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/nucleotide.js":
/*!*********************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/nucleotide.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: " #64F73F",
  C: " #FFB340",
  G: " #EB413C",
  T: " #3C88EE",
  U: " #3C88EE"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/pid_colors.js":
/*!*********************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/pid_colors.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var pid;
module.exports = pid = {};

// calculating the conservation is expensive 
// we only want to do it once
pid.init = function () {
  this.cons = this.opt.conservation();
};
pid.run = function (letter, opts) {
  var cons = this.cons[opts.pos];
  if (cons > 0.8) {
    return "#6464ff";
  } else if (cons > 0.6) {
    return "#9da5ff";
  } else if (cons > 0.4) {
    return "#cccccc";
  } else {
    return "#ffffff";
  }
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/purine.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/purine.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: " #FF83FA",
  C: " #40E0D0",
  G: " #FF83FA",
  R: " #FF83FA",
  T: " #40E0D0",
  U: " #40E0D0",
  Y: " #40E0D0"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/schemeclass.js":
/*!**********************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/schemeclass.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var StaticSchemeClass = function StaticSchemeClass(map) {
  this.defaultColor = "#ffffff";
  this.type = "static";
  this.map = map;
  this.getColor = function (letter) {
    if (this.map[letter] !== undefined) {
      return this.map[letter];
    } else {
      return this.defaultColor;
    }
  };
};
var DynSchemeClass = function DynSchemeClass(fun, opt) {
  this.type = "dyn";
  this.opt = opt;
  // init
  if (fun.init !== undefined) {
    fun.init.call(this);
    this.getColor = fun.run;
    this.reset = fun.init;
  } else {
    this.getColor = fun;
  }
};
module.exports.stat = StaticSchemeClass;
module.exports.dyn = DynSchemeClass;

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/strand.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/strand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#5858a7",
  R: "#6b6b94",
  N: "#64649b",
  D: "#2121de",
  C: "#9d9d62",
  Q: "#8c8c73",
  E: "#0000ff",
  G: "#4949b6",
  H: "#60609f",
  I: "#ecec13",
  L: "#b2b24d",
  K: "#4747b8",
  M: "#82827d",
  F: "#c2c23d",
  P: "#2323dc",
  S: "#4949b6",
  T: "#9d9d62",
  W: "#c0c03f",
  Y: "#d3d32c",
  V: "#ffff00",
  B: "#4343bc",
  X: "#797986",
  Z: "#4747b8"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/taylor.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/taylor.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#ccff00",
  R: "#0000ff",
  N: "#cc00ff",
  D: "#ff0000",
  C: "#ffff00",
  Q: "#ff00cc",
  E: "#ff0066",
  G: "#ff9900",
  H: "#0066ff",
  I: "#66ff00",
  L: "#33ff00",
  K: "#6600ff",
  M: "#00ff00",
  F: "#00ff66",
  P: "#ffcc00",
  S: "#ff3300",
  T: "#ff6600",
  W: "#00ccff",
  Y: "#00ffcc",
  V: "#99ff00",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/turn.js":
/*!***************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/turn.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#2cd3d3",
  R: "#708f8f",
  N: "#ff0000",
  D: "#e81717",
  C: "#a85757",
  Q: "#3fc0c0",
  E: "#778888",
  G: "#ff0000",
  H: "#708f8f",
  I: "#00ffff",
  L: "#1ce3e3",
  K: "#7e8181",
  M: "#1ee1e1",
  F: "#1ee1e1",
  P: "#f60909",
  S: "#e11e1e",
  T: "#738c8c",
  W: "#738c8c",
  Y: "#9d6262",
  V: "#07f8f8",
  B: "#f30c0c",
  X: "#7c8383",
  Z: "#5ba4a4"
};

/***/ }),

/***/ "./node_modules/msa-colorschemes/src/zappo.js":
/*!****************************************************!*\
  !*** ./node_modules/msa-colorschemes/src/zappo.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  A: "#ffafaf",
  R: "#6464ff",
  N: "#00ff00",
  D: "#ff0000",
  C: "#ffff00",
  Q: "#00ff00",
  E: "#ff0000",
  G: "#ff00ff",
  H: "#6464ff",
  I: "#ffafaf",
  L: "#ffafaf",
  K: "#6464ff",
  M: "#ffafaf",
  F: "#ffc800",
  P: "#ff00ff",
  S: "#00ff00",
  T: "#00ff00",
  W: "#ffc800",
  Y: "#ffc800",
  V: "#ffafaf",
  B: "#fff",
  X: "#fff",
  Z: "#fff"
};

/***/ }),

/***/ "./node_modules/msa-seqtools/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/msa-seqtools/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * msa-seqtools
 * https://github.com/greenify/msa-seqtools
 *
 * Copyright (c) 2014 greenify
 * Licensed under the MIT license.
 */

var st = {};
module.exports = st;

/****
 * Seems to be lots of different ways to format FASTA headers. 
 * 
 * Generally there's an ID and a DESCRIPTION
 *   >ID DESCRIPTION
 * 
 *   >(parts|of|ID) (DESCRIPTION with optional key=values)
 *   
 * This is complicated by the fact that the "values" in the description can have spaces
 * e.g. OS=Arabidopsis thaliana GN=CCD8
 * 
 ****
*/

// extract IDs and push them to the meta dict
st.getMeta = function (label) {
  var full_id = false,
    full_desc = false;
  var name,
    ids = {},
    details = {},
    description;

  // 	console.log( "getMeta.label: ", label );

  var label_parts = label.split(" ");
  if (label_parts.length >= 1) {
    full_id = label_parts.shift(); // everything up to the first white space
    full_desc = label_parts.join(" "); // everything else
  } else {
    full_id = label;
  }

  // 	console.log( "full_id", full_id );
  // 	console.log( "full_desc", full_desc );

  if (full_id) {
    var id_parts = full_id.split('|');

    // the last item is the accession
    name = id_parts.pop();
    details.en = name;

    // everything else should be pairs: db|id
    while (id_parts.length != 0) {
      var db = id_parts.shift();
      var id = id_parts.shift();
      ids[db] = id;
    }
  } else {
    name = full_id;
  }
  if (full_desc) {
    var kv_parts = full_desc.split('=');
    if (kv_parts.length > 1) {
      var current_key, next_key;
      var kv;
      var kv_idx_max = kv_parts.length - 1;
      var kv_idx = 0;
      kv_parts.forEach(function (value_and_maybe_next_key) {
        value_and_maybe_next_key = value_and_maybe_next_key.trim();
        var value_parts = value_and_maybe_next_key.split(" ");
        var value;
        if (value_parts.length > 1) {
          next_key = value_parts.pop();
          value = value_parts.join(' ');
        } else {
          value = value_and_maybe_next_key;
        }
        if (current_key) {
          var key = current_key.toLowerCase();
          details[key] = value;
          //console.log( "details[" + key + "] = " + value );
        } else {
          description = value;
          //console.log( "description=" + value );
        }
        current_key = next_key;
      });
    } else {
      description = kv_parts.shift();
    }
  }
  var meta = {
    name: name,
    ids: ids,
    details: details
  };
  if (description) {
    meta.desc = description;
  }

  // 	console.log( "meta", meta );

  return meta;
};
var findSepInArr = function findSepInArr(arr, sep) {
  for (var i = 0; i < arr.lenght; i++) {
    if (arr[i].indexOf(i)) {
      return i;
    }
  }
  return arr.length - 1;
};
var strToDict = function strToDict(str, sep, toJoin) {
  toJoin = toJoin || {};
  var entries = str.split(sep);
  toJoin[entries[0].toLowerCase()] = entries[1];
  return toJoin;
};
var identDB = {
  "sp": {
    link: "http://www.uniprot.org/%s",
    name: "Uniprot"
  },
  "tr": {
    link: "http://www.uniprot.org/%s",
    name: "Trembl"
  },
  "gb": {
    link: "http://www.ncbi.nlm.nih.gov/nuccore/%s",
    name: "Genbank"
  },
  "pdb": {
    link: "http://www.rcsb.org/pdb/explore/explore.do?structureId=%s",
    name: "PDB"
  }
};
st.buildLinks = function (meta) {
  var links = {};
  meta = meta || {};
  Object.keys(meta).forEach(function (id) {
    if (id in identDB) {
      var entry = identDB[id];
      var link = entry.link.replace("%s", meta[id]);
      links[entry.name] = link;
    }
  });
  return links;
};

// search for a text
st.contains = function (text, search) {
  return ''.indexOf.call(text, search, 0) !== -1;
};

// split after e.g. 80 chars
st.splitNChars = function (txt, num) {
  var i, _ref;
  num = num || 80;
  var result = [];
  for (i = 0, _ref = txt.length - 1; i <= _ref; i += num) {
    result.push(txt.substr(i, num));
  }
  return result;
};
st.reverse = function (seq) {
  return seq.split('').reverse().join('');
};
st.complement = function (seq) {
  var newSeq = seq + "";
  var replacements = [
  // cg
  [/g/g, "0"], [/c/g, "1"], [/0/g, "c"], [/1/g, "g"],
  // CG
  [/G/g, "0"], [/C/g, "1"], [/0/g, "C"], [/1/g, "G"],
  // at
  [/a/g, "0"], [/t/g, "1"], [/0/g, "t"], [/1/g, "a"],
  // AT
  [/A/g, "0"], [/T/g, "1"], [/0/g, "T"], [/1/g, "A"]];
  for (var rep in replacements) {
    newSeq = newSeq.replace(replacements[rep][0], replacements[rep][1]);
  }
  return newSeq;
};
st.reverseComplement = function (seq) {
  return st.reverse(st.complement(seq));
};
st.model = function Seq(seq, name, id) {
  this.seq = seq;
  this.name = name;
  this.id = id;
  this.ids = {};
};

/***/ }),

/***/ "./node_modules/msa/lib/g sync recursive":
/*!*************************************!*\
  !*** ./node_modules/msa/lib/g sync ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/msa/lib/g sync recursive";

/***/ }),

/***/ "./node_modules/msa/lib/g/colorscheme.js":
/*!***********************************************!*\
  !*** ./node_modules/msa/lib/g/colorscheme.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Colors,
  Colorscheme,
  Model,
  indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) return i;
    }
    return -1;
  };
Colors = __webpack_require__(/*! msa-colorschemes */ "./node_modules/msa-colorschemes/src/index.js");
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Colorscheme = Model.extend({
  defaults: {
    scheme: "taylor",
    colorBackground: true,
    showLowerCase: true,
    opacity: 0.6
  },
  initialize: function initialize(data, seqs, stat) {
    this.colors = new Colors({
      seqs: seqs,
      conservation: function conservation() {
        return stat.scale(stat.conservation());
      }
    });
    return stat.on("reset", function () {
      if (this.getSelectedScheme().type === "dyn") {
        if (indexOf.call(this.getSelectedScheme(), "reset") >= 0) {
          return this.getSelectedScheme().reset();
        }
      }
    }, this);
  },
  addStaticScheme: function addStaticScheme(name, dict) {
    return this.colors.addStaticScheme(name, dict);
  },
  addDynScheme: function addDynScheme(name, fun) {
    return this.colors.addDynScheme(name, fun);
  },
  getScheme: function getScheme(name) {
    return this.colors.getScheme(name);
  },
  getSelectedScheme: function getSelectedScheme() {
    return this.colors.getScheme(this.get("scheme"));
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/columns.js":
/*!*******************************************!*\
  !*** ./node_modules/msa/lib/g/columns.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Columns, Model, _;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = Columns = Model.extend({
  initialize: function initialize(o, stat) {
    if (this.get("hidden") == null) {
      this.set("hidden", []);
    }
    return this.stats = stat;
  },
  calcHiddenColumns: function calcHiddenColumns(n) {
    var hidden, i, j, len, newX;
    hidden = this.get("hidden");
    newX = n;
    for (j = 0, len = hidden.length; j < len; j++) {
      i = hidden[j];
      if (i <= newX) {
        newX++;
      }
    }
    return newX - n;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/config.js":
/*!******************************************!*\
  !*** ./node_modules/msa/lib/g/config.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Config, Model;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Config = Model.extend({
  defaults: {
    registerMouseHover: false,
    registerMouseClicks: true,
    importProxy: "https://cors-anywhere.herokuapp.com/",
    eventBus: true,
    alphabetSize: 20,
    dropImport: false,
    debug: false,
    hasRef: false,
    bootstrapMenu: false,
    manualRendering: false
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/package.js":
/*!*******************************************!*\
  !*** ./node_modules/msa/lib/g/package.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Loader, Model, Package;
Loader = __webpack_require__(/*! ../utils/loader */ "./node_modules/msa/lib/utils/loader.js");
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Package = Model.extend({
  initialize: function initialize(g) {
    return this.g = g;
  },
  development: {
    "msa-tnt": "/node_modules/msa-tnt/build/bundle.js",
    "biojs-io-newick": "/node_modules/biojs-io-newick/build/biojs-io-newick.min.js"
  },
  loadPackage: function loadPackage(pkg, cb) {
    var p;
    try {
      p = __webpack_require__("./node_modules/msa/lib/g sync recursive")(pkg);
      return cb(p);
    } catch (_error) {
      return Loader.loadScript(this._pkgURL(pkg), cb);
    }
  },
  loadPackages: function loadPackages(pkgs, cb) {
    var cbs;
    cbs = Loader.joinCb(function () {
      return cb();
    }, pkgs.length);
    return pkgs.forEach(function (_this) {
      return function (pkg) {
        return _this.loadPackage(pkg, cbs);
      };
    }(this));
  },
  _pkgURL: function _pkgURL(pkg) {
    var url;
    if (this.g.config.get("debug")) {
      url = this.development[pkg];
    } else {
      url = "http://wzrd.in/bundle/" + pkg + "@latest";
    }
    return url;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/selection/Selection.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa/lib/g/selection/Selection.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ColumnSelection, Model, PosSelection, RowSelection, Selection, _;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
Selection = Model.extend({
  defaults: {
    type: "super"
  }
});
RowSelection = Selection.extend({
  defaults: _.extend({}, Selection.prototype.defaults, {
    type: "row",
    seqId: ""
  }),
  inRow: function inRow(seqId) {
    return seqId === this.get("seqId");
  },
  inColumn: function inColumn(rowPos) {
    return true;
  },
  getLength: function getLength() {
    return 1;
  }
});
ColumnSelection = Selection.extend({
  defaults: _.extend({}, Selection.prototype.defaults, {
    type: "column",
    xStart: -1,
    xEnd: -1
  }),
  inRow: function inRow() {
    return true;
  },
  inColumn: function inColumn(rowPos) {
    return xStart <= rowPos && rowPos <= xEnd;
  },
  getLength: function getLength() {
    return xEnd - xStart;
  }
});
PosSelection = RowSelection.extend(_.extend({}, _.pick(ColumnSelection, "inColumn"), _.pick(ColumnSelection, "getLength"), {
  defaults: _.extend({}, ColumnSelection.prototype.defaults, RowSelection.prototype.defaults, {
    type: "pos"
  })
}));
module.exports.sel = Selection;
module.exports.possel = PosSelection;
module.exports.rowsel = RowSelection;
module.exports.columnsel = ColumnSelection;

/***/ }),

/***/ "./node_modules/msa/lib/g/selection/SelectionCol.js":
/*!**********************************************************!*\
  !*** ./node_modules/msa/lib/g/selection/SelectionCol.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Collection, SelectionManager, _, sel;
sel = __webpack_require__(/*! ./Selection */ "./node_modules/msa/lib/g/selection/Selection.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
Collection = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Collection;
module.exports = SelectionManager = Collection.extend({
  model: sel.sel,
  initialize: function initialize(data, opts) {
    if (opts != null) {
      this.g = opts.g;
      this.listenTo(this.g, "residue:click", function (e) {
        return this._handleE(e.evt, new sel.possel({
          xStart: e.rowPos,
          xEnd: e.rowPos,
          seqId: e.seqId
        }));
      });
      this.listenTo(this.g, "row:click", function (e) {
        return this._handleE(e.evt, new sel.rowsel({
          seqId: e.seqId
        }));
      });
      return this.listenTo(this.g, "column:click", function (e) {
        return this._handleE(e.evt, new sel.columnsel({
          xStart: e.rowPos,
          xEnd: e.rowPos + e.stepSize - 1
        }));
      });
    }
  },
  getSelForRow: function getSelForRow(seqId) {
    return this.filter(function (el) {
      return el.inRow(seqId);
    });
  },
  getSelForColumns: function getSelForColumns(rowPos) {
    return this.filter(function (el) {
      return el.inColumn(rowPos);
    });
  },
  addJSON: function addJSON(model) {
    return this.add(this._fromJSON(model));
  },
  _fromJSON: function _fromJSON(model) {
    switch (model.type) {
      case "column":
        return new sel.columnsel(model);
      case "row":
        return new sel.rowsel(model);
      case "pos":
        return new sel.possel(model);
    }
  },
  resetJSON: function resetJSON(arr) {
    arr = _.map(arr, this._fromJSON);
    return this.reset(arr);
  },
  getBlocksForRow: function getBlocksForRow(seqId, maxLen) {
    var blocks, i, j, k, len, ref, ref1, results, results1, seli, selis;
    selis = this.filter(function (el) {
      return el.inRow(seqId);
    });
    blocks = [];
    for (i = 0, len = selis.length; i < len; i++) {
      seli = selis[i];
      if (seli.attributes.type === "row") {
        blocks = function () {
          results = [];
          for (var j = 0; 0 <= maxLen ? j <= maxLen : j >= maxLen; 0 <= maxLen ? j++ : j--) {
            results.push(j);
          }
          return results;
        }.apply(this);
        break;
      } else {
        blocks = blocks.concat(function () {
          results1 = [];
          for (var k = ref = seli.attributes.xStart, ref1 = seli.attributes.xEnd; ref <= ref1 ? k <= ref1 : k >= ref1; ref <= ref1 ? k++ : k--) {
            results1.push(k);
          }
          return results1;
        }.apply(this));
      }
    }
    return blocks;
  },
  getAllColumnBlocks: function getAllColumnBlocks(conf) {
    var blocks, filtered, i, j, len, maxLen, ref, ref1, results, seli, withPos;
    maxLen = conf.maxLen;
    withPos = conf.withPos;
    blocks = [];
    if (conf.withPos) {
      filtered = this.filter(function (el) {
        return el.get('xStart') != null;
      });
    } else {
      filtered = this.filter(function (el) {
        return el.get('type') === "column";
      });
    }
    for (i = 0, len = filtered.length; i < len; i++) {
      seli = filtered[i];
      blocks = blocks.concat(function () {
        results = [];
        for (var j = ref = seli.attributes.xStart, ref1 = seli.attributes.xEnd; ref <= ref1 ? j <= ref1 : j >= ref1; ref <= ref1 ? j++ : j--) {
          results.push(j);
        }
        return results;
      }.apply(this));
    }
    blocks = _.uniq(blocks);
    return blocks;
  },
  invertRow: function invertRow(rows) {
    var el, i, inverted, len, s, selRows;
    selRows = this.where({
      type: "row"
    });
    selRows = _.map(selRows, function (el) {
      return el.attributes.seqId;
    });
    inverted = _.filter(rows, function (el) {
      if (selRows.indexOf(el) >= 0) {
        return false;
      }
      return true;
    });
    s = [];
    for (i = 0, len = inverted.length; i < len; i++) {
      el = inverted[i];
      s.push(new sel.rowsel({
        seqId: el
      }));
    }
    return this.reset(s);
  },
  invertCol: function invertCol(columns) {
    var el, i, inverted, len, s, selColumns, xEnd, xStart;
    selColumns = this.where({
      type: "column"
    });
    selColumns = _.reduce(selColumns, function (memo, el) {
      var i, ref, ref1, results;
      return memo.concat(function () {
        results = [];
        for (var i = ref = el.attributes.xStart, ref1 = el.attributes.xEnd; ref <= ref1 ? i <= ref1 : i >= ref1; ref <= ref1 ? i++ : i--) {
          results.push(i);
        }
        return results;
      }.apply(this));
    }, []);
    inverted = _.filter(columns, function (el) {
      if (selColumns.indexOf(el) >= 0) {
        return false;
      }
      return true;
    });
    if (inverted.length === 0) {
      return;
    }
    s = [];
    xStart = xEnd = inverted[0];
    for (i = 0, len = inverted.length; i < len; i++) {
      el = inverted[i];
      if (xEnd + 1 === el) {
        xEnd = el;
      } else {
        s.push(new sel.columnsel({
          xStart: xStart,
          xEnd: xEnd
        }));
        xStart = xEnd = el;
      }
    }
    if (xStart !== xEnd) {
      s.push(new sel.columnsel({
        xStart: xStart,
        xEnd: inverted[inverted.length - 1]
      }));
    }
    return this.reset(s);
  },
  _handleE: function _handleE(e, selection) {
    if (e.ctrlKey || e.metaKey) {
      return this.add(selection);
    } else {
      return this.reset([selection]);
    }
  },
  _reduceColumns: function _reduceColumns() {
    return this.each(function (el, index, arr) {
      var cols, i, j, left, lefts, len, len1, right, rights, xEnd, xStart;
      cols = _.filter(arr, function (el) {
        return el.get('type') === 'column';
      });
      xStart = el.get('xStart');
      xEnd = el.get('xEnd');
      lefts = _.filter(cols, function (el) {
        return el.get('xEnd') === xStart - 1;
      });
      for (i = 0, len = lefts.length; i < len; i++) {
        left = lefts[i];
        left.set('xEnd', xStart);
      }
      rights = _.filter(cols, function (el) {
        return el.get('xStart') === xEnd + 1;
      });
      for (j = 0, len1 = rights.length; j < len1; j++) {
        right = rights[j];
        right.set('xStart', xEnd);
      }
      if (lefts.length > 0 || rights.length > 0) {
        console.log("removed el");
        return el.collection.remove(el);
      }
    });
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/user.js":
/*!****************************************!*\
  !*** ./node_modules/msa/lib/g/user.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Config, Model;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Config = Model.extend({
  defaults: {
    searchText: ""
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/visOrdering.js":
/*!***********************************************!*\
  !*** ./node_modules/msa/lib/g/visOrdering.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Model, Visibility;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Visibility = Model.extend({
  defaults: {
    searchBox: -10,
    overviewBox: 30,
    headerBox: -1,
    alignmentBody: 0
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/visibility.js":
/*!**********************************************!*\
  !*** ./node_modules/msa/lib/g/visibility.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Model, Visibility;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Visibility = Model.extend({
  defaults: {
    sequences: true,
    markers: true,
    metacell: false,
    conserv: false,
    overviewbox: false,
    seqlogo: false,
    gapHeader: false,
    leftHeader: true,
    labels: true,
    labelName: true,
    labelId: true,
    labelPartition: false,
    labelCheckbox: false,
    metaGaps: true,
    metaIdentity: true,
    metaLinks: true
  },
  constructor: function constructor(attributes, options) {
    this.calcDefaults(options.model);
    return Model.apply(this, arguments);
  },
  initialize: function initialize() {
    this.listenTo(this, "change:metaLinks change:metaIdentity change:metaGaps", function () {
      return this.trigger("change:metacell");
    }, this);
    this.listenTo(this, "change:labelName change:labelId change:labelPartition change:labelCheckbox", function () {
      return this.trigger("change:labels");
    }, this);
    return this.listenTo(this, "change:markers change:conserv change:seqlogo change:gapHeader", function () {
      return this.trigger("change:header");
    }, this);
  },
  calcDefaults: function calcDefaults(seqs) {
    var ids, seq;
    if (seqs.length > 0) {
      seq = seqs.at(0);
      ids = seq.get("ids");
      if (ids !== void 0 && Object.keys(ids).length === 0) {
        return this.defaults.metaLinks = false;
      }
    }
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/g/zoomer.js":
/*!******************************************!*\
  !*** ./node_modules/msa/lib/g/zoomer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Model, Zoomer;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Zoomer = Model.extend({
  constructor: function constructor(attributes, options) {
    this.calcDefaults(options.model);
    Model.apply(this, arguments);
    this.g = options.g;
    this.listenTo(this, "change:labelIdLength change:labelNameLength change:labelPartLength change:labelCheckLength", function () {
      return this.trigger("change:labelWidth", this.getLabelWidth());
    }, this);
    this.listenTo(this, "change:metaLinksWidth change:metaIdentWidth change:metaGapWidth", function () {
      return this.trigger("change:metaWidth", this.getMetaWidth());
    }, this);
    return this;
  },
  defaults: {
    alignmentWidth: "auto",
    alignmentHeight: 225,
    columnWidth: 15,
    rowHeight: 15,
    autoResize: true,
    textVisible: true,
    labelIdLength: 50,
    labelNameLength: 100,
    labelPartLength: 15,
    labelCheckLength: 15,
    labelFontsize: 13,
    labelLineHeight: "13px",
    markerFontsize: "10px",
    stepSize: 1,
    markerStepSize: 2,
    markerHeight: 20,
    residueFont: "13",
    canvasEventScale: 1,
    boxRectHeight: 2,
    boxRectWidth: 2,
    overviewboxPaddingTop: 10,
    menuFontsize: "14px",
    menuItemFontsize: "14px",
    menuItemLineHeight: "14px",
    menuMarginLeft: "3px",
    menuPadding: "3px 4px 3px 4px",
    metaGapWidth: 35,
    metaIdentWidth: 40,
    metaLinksWidth: 25,
    _alignmentScrollLeft: 0,
    _alignmentScrollTop: 0
  },
  calcDefaults: function calcDefaults(model) {
    var maxLen;
    maxLen = model.getMaxLength();
    if (maxLen < 200 && model.length < 30) {
      return this.defaults.boxRectWidth = this.defaults.boxRectHeight = 5;
    }
  },
  getAlignmentWidth: function getAlignmentWidth(n) {
    if (this.get("autoResize") && n !== void 0) {
      return this.get("columnWidth") * n;
    }
    if (this.get("alignmentWidth") === void 0 || this.get("alignmentWidth") === "auto" || this.get("alignmentWidth") === 0) {
      return this._adjustWidth();
    } else {
      return this.get("alignmentWidth");
    }
  },
  setLeftOffset: function setLeftOffset(n) {
    var val;
    val = n;
    val = Math.max(0, val);
    val -= this.g.columns.calcHiddenColumns(val);
    return this.set("_alignmentScrollLeft", val * this.get('columnWidth'));
  },
  setTopOffset: function setTopOffset(n) {
    var height, i, j, ref, seq, val;
    val = Math.max(0, n - 1);
    height = 0;
    for (i = j = 0, ref = val; j <= ref; i = j += 1) {
      seq = this.model.at(i);
      height += seq.attributes.height || 1;
    }
    return this.set("_alignmentScrollTop", height * this.get("rowHeight"));
  },
  getLeftBlockWidth: function getLeftBlockWidth() {
    var paddingLeft;
    paddingLeft = 0;
    if (this.g.vis.get("labels")) {
      paddingLeft += this.getLabelWidth();
    }
    if (this.g.vis.get("metacell")) {
      paddingLeft += this.getMetaWidth();
    }
    return paddingLeft;
  },
  getMetaWidth: function getMetaWidth() {
    var val;
    val = 0;
    if (this.g.vis.get("metaGaps")) {
      val += this.get("metaGapWidth");
    }
    if (this.g.vis.get("metaIdentity")) {
      val += this.get("metaIdentWidth");
    }
    if (this.g.vis.get("metaLinks")) {
      val += this.get("metaLinksWidth");
    }
    return val;
  },
  getLabelWidth: function getLabelWidth() {
    var val;
    val = 0;
    if (this.g.vis.get("labelName")) {
      val += this.get("labelNameLength");
    }
    if (this.g.vis.get("labelId")) {
      val += this.get("labelIdLength");
    }
    if (this.g.vis.get("labelPartition")) {
      val += this.get("labelPartLength");
    }
    if (this.g.vis.get("labelCheckbox")) {
      val += this.get("labelCheckLength");
    }
    return val;
  },
  _adjustWidth: function _adjustWidth() {
    var calcWidth, maxWidth, parentWidth, val;
    if (!(this.el !== void 0 && this.model !== void 0)) {
      return;
    }
    if (this.el.parentNode != null && this.el.parentNode.offsetWidth !== 0) {
      parentWidth = this.el.parentNode.offsetWidth;
    } else {
      parentWidth = document.body.clientWidth - 35;
    }
    maxWidth = parentWidth - this.getLeftBlockWidth();
    calcWidth = this.getAlignmentWidth(this.model.getMaxLength() - this.g.columns.get('hidden').length);
    val = Math.min(maxWidth, calcWidth);
    val = Math.floor(val / this.get("columnWidth")) * this.get("columnWidth");
    return this.attributes.alignmentWidth = val;
  },
  autoResize: function autoResize() {
    if (this.get("autoResize")) {
      return this._adjustWidth(this.el, this.model);
    }
  },
  autoHeight: function autoHeight(max) {
    var val;
    val = this.getMaxAlignmentHeight();
    if (max !== void 0 && max > 0) {
      val = Math.min(val, max);
    }
    return this.set("alignmentHeight", val);
  },
  setEl: function setEl(el, model) {
    this.el = el;
    return this.model = model;
  },
  _checkScrolling: function _checkScrolling(scrollObj, opts) {
    var xScroll, yScroll;
    xScroll = scrollObj[0];
    yScroll = scrollObj[1];
    this.set("_alignmentScrollLeft", xScroll, opts);
    return this.set("_alignmentScrollTop", yScroll, opts);
  },
  getMaxAlignmentHeight: function getMaxAlignmentHeight() {
    var height;
    height = 0;
    this.model.each(function (seq) {
      return height += seq.attributes.height || 1;
    });
    return height * this.get("rowHeight");
  },
  getMaxAlignmentWidth: function getMaxAlignmentWidth() {
    return this.model.getMaxLength() * this.get("columnWidth");
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/index.js":
/*!***************************************!*\
  !*** ./node_modules/msa/lib/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MSA;
MSA = __webpack_require__(/*! ./msa */ "./node_modules/msa/lib/msa.js");
module.exports = function () {
  var msa;
  msa = function msa(args) {
    return MSA.apply(this, args);
  };
  msa.prototype = MSA.prototype;
  return new msa(arguments);
};
module.exports.msa = MSA;
module.exports.model = __webpack_require__(/*! ./model */ "./node_modules/msa/lib/model/index.js");
module.exports.menu = __webpack_require__(/*! ./menu */ "./node_modules/msa/lib/menu/index.js");
module.exports.utils = __webpack_require__(/*! ./utils */ "./node_modules/msa/lib/utils/index.js");
module.exports.selection = __webpack_require__(/*! ./g/selection/Selection */ "./node_modules/msa/lib/g/selection/Selection.js");
module.exports.selcol = __webpack_require__(/*! ./g/selection/SelectionCol */ "./node_modules/msa/lib/g/selection/SelectionCol.js");
module.exports.view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
module.exports.boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
module.exports._ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports.$ = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
module.exports.io = {};
module.exports.io.xhr = __webpack_require__(/*! xhr */ "./node_modules/xhr/index.js");
module.exports.io.fasta = __webpack_require__(/*! biojs-io-fasta */ "./node_modules/biojs-io-fasta/lib/index.js");
module.exports.io.clustal = __webpack_require__(/*! biojs-io-clustal */ "./node_modules/biojs-io-clustal/lib/index.js");
module.exports.io.gff = __webpack_require__(/*! biojs-io-gff */ "./node_modules/biojs-io-gff/lib/index.js");
module.exports.version = "0.2.0";

/***/ }),

/***/ "./node_modules/msa/lib/menu/defaultmenu.js":
/*!**************************************************!*\
  !*** ./node_modules/msa/lib/menu/defaultmenu.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ColorMenu, DebugMenu, ExportMenu, ExtraMenu, FilterMenu, HelpMenu, ImportMenu, MenuView, OrderingMenu, SelectionMenu, VisMenu, boneView;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
ImportMenu = __webpack_require__(/*! ./views/ImportMenu */ "./node_modules/msa/lib/menu/views/ImportMenu.js");
FilterMenu = __webpack_require__(/*! ./views/FilterMenu */ "./node_modules/msa/lib/menu/views/FilterMenu.js");
SelectionMenu = __webpack_require__(/*! ./views/SelectionMenu */ "./node_modules/msa/lib/menu/views/SelectionMenu.js");
VisMenu = __webpack_require__(/*! ./views/VisMenu */ "./node_modules/msa/lib/menu/views/VisMenu.js");
ColorMenu = __webpack_require__(/*! ./views/ColorMenu */ "./node_modules/msa/lib/menu/views/ColorMenu.js");
OrderingMenu = __webpack_require__(/*! ./views/OrderingMenu */ "./node_modules/msa/lib/menu/views/OrderingMenu.js");
ExtraMenu = __webpack_require__(/*! ./views/ExtraMenu */ "./node_modules/msa/lib/menu/views/ExtraMenu.js");
ExportMenu = __webpack_require__(/*! ./views/ExportMenu */ "./node_modules/msa/lib/menu/views/ExportMenu.js");
HelpMenu = __webpack_require__(/*! ./views/HelpMenu */ "./node_modules/msa/lib/menu/views/HelpMenu.js");
DebugMenu = __webpack_require__(/*! ./views/DebugMenu */ "./node_modules/msa/lib/menu/views/DebugMenu.js");
module.exports = MenuView = boneView.extend({
  initialize: function initialize(data) {
    this.msa = data.msa;
    this.addView("10_import", new ImportMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("20_filter", new FilterMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("30_selection", new SelectionMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("40_vis", new VisMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("50_color", new ColorMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("60_ordering", new OrderingMenu({
      model: this.msa.seqs,
      g: this.msa.g
    }));
    this.addView("70_extra", new ExtraMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("80_export", new ExportMenu({
      model: this.msa.seqs,
      g: this.msa.g,
      msa: this.msa
    }));
    this.addView("90_help", new HelpMenu({
      g: this.msa.g
    }));
    if (this.msa.g.config.get("debug")) {
      return this.addView("95_debug", new DebugMenu({
        g: this.msa.g
      }));
    }
  },
  render: function render() {
    this.renderSubviews();
    this.el.setAttribute("class", "smenubar");
    return this.el.appendChild(document.createElement("p"));
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/index.js":
/*!********************************************!*\
  !*** ./node_modules/msa/lib/menu/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
module.exports.defaultmenu = __webpack_require__(/*! ./defaultmenu */ "./node_modules/msa/lib/menu/defaultmenu.js");
module.exports.menubuilder = __webpack_require__(/*! ./menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");

/***/ }),

/***/ "./node_modules/msa/lib/menu/menubuilder.js":
/*!**************************************************!*\
  !*** ./node_modules/msa/lib/menu/menubuilder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MenuBuilder, builder;
builder = __webpack_require__(/*! menu-builder */ "./node_modules/menu-builder/index.js");
module.exports = MenuBuilder = builder.extend({
  buildDOM: function buildDOM() {
    this.on("new:node", this.buildNode);
    this.on("new:button", this.buildButton);
    this.on("new:menu", this.buildMenu);
    return builder.prototype.buildDOM.call(this);
  },
  buildNode: function buildNode(li) {
    if (this.g != null) {
      return li.style.lineHeight = this.g.zoomer.get("menuItemLineHeight");
    }
  },
  buildButton: function buildButton(btn) {
    if (this.g != null) {
      btn.style.fontSize = this.g.zoomer.get("menuFontsize");
      btn.style.marginLeft = this.g.zoomer.get("menuMarginLeft");
      return btn.style.padding = this.g.zoomer.get("menuPadding");
    }
  },
  buildMenu: function buildMenu(menu) {
    if (this.g != null) {
      return menu.style.fontSize = this.g.zoomer.get("menuItemFontsize");
    }
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/ColorMenu.js":
/*!******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/ColorMenu.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ColorMenu, MenuBuilder, _, dom;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
module.exports = ColorMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.listenTo(this.g.colorscheme, "change", function () {
      return this.render();
    });
  },
  render: function render() {
    var colorschemes, j, len, menuColor, scheme, text;
    menuColor = this.setName("Color scheme");
    this.removeAllNodes();
    colorschemes = this.getColorschemes();
    for (j = 0, len = colorschemes.length; j < len; j++) {
      scheme = colorschemes[j];
      this.addScheme(menuColor, scheme);
    }
    text = "Background";
    if (this.g.colorscheme.get("colorBackground")) {
      text = "Hide " + text;
    } else {
      text = "Show " + text;
    }
    this.addNode(text, function (_this) {
      return function () {
        return _this.g.colorscheme.set("colorBackground", !_this.g.colorscheme.get("colorBackground"));
      };
    }(this));
    this.grey(menuColor);
    dom.removeAllChilds(this.el);
    this.el.appendChild(this.buildDOM());
    return this;
  },
  addScheme: function addScheme(menuColor, scheme) {
    var current, style;
    style = {};
    current = this.g.colorscheme.get("scheme");
    if (current === scheme.id) {
      style.backgroundColor = "#77ED80";
    }
    return this.addNode(scheme.name, function (_this) {
      return function () {
        return _this.g.colorscheme.set("scheme", scheme.id);
      };
    }(this), {
      style: style
    });
  },
  getColorschemes: function getColorschemes() {
    var schemes;
    schemes = [];
    schemes.push({
      name: "Zappo",
      id: "zappo"
    });
    schemes.push({
      name: "Taylor",
      id: "taylor"
    });
    schemes.push({
      name: "Hydrophobicity",
      id: "hydro"
    });
    schemes.push({
      name: "Lesk",
      id: "lesk"
    });
    schemes.push({
      name: "Cinema",
      id: "cinema"
    });
    schemes.push({
      name: "MAE",
      id: "mae"
    });
    schemes.push({
      name: "Clustal",
      id: "clustal"
    });
    schemes.push({
      name: "Clustal2",
      id: "clustal2"
    });
    schemes.push({
      name: "Turn",
      id: "turn"
    });
    schemes.push({
      name: "Strand",
      id: "strand"
    });
    schemes.push({
      name: "Buried",
      id: "buried"
    });
    schemes.push({
      name: "Helix",
      id: "helix"
    });
    schemes.push({
      name: "Nucleotide",
      id: "nucleotide"
    });
    schemes.push({
      name: "Purine",
      id: "purine"
    });
    schemes.push({
      name: "PID",
      id: "pid"
    });
    schemes.push({
      name: "No color",
      id: "foo"
    });
    return schemes;
  },
  grey: function grey(menuColor) {
    this.addNode("Shade", function (_this) {
      return function () {
        _this.g.colorscheme.set("showLowerCase", false);
        return _this.model.each(function (seq) {
          var grey, residues;
          residues = seq.get("seq");
          grey = [];
          _.each(residues, function (el, index) {
            if (el === el.toLowerCase()) {
              return grey.push(index);
            }
          });
          return seq.set("grey", grey);
        });
      };
    }(this));
    this.addNode("Shade by threshold", function (_this) {
      return function () {
        var conserv, grey, i, j, maxLen, ref, threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        conserv = _this.g.stats.scale(_this.g.stats.conservation());
        grey = [];
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (conserv[i] < threshold) {
            grey.push(i);
          }
        }
        return _this.model.each(function (seq) {
          return seq.set("grey", grey);
        });
      };
    }(this));
    this.addNode("Shade selection", function (_this) {
      return function () {
        var maxLen;
        maxLen = _this.model.getMaxLength();
        return _this.model.each(function (seq) {
          var blocks;
          blocks = _this.g.selcol.getBlocksForRow(seq.get("id"), maxLen);
          return seq.set("grey", blocks);
        });
      };
    }(this));
    return this.addNode("Reset shade", function (_this) {
      return function () {
        _this.g.colorscheme.set("showLowerCase", true);
        return _this.model.each(function (seq) {
          return seq.set("grey", []);
        });
      };
    }(this));
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/DebugMenu.js":
/*!******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/DebugMenu.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var DebugMenu, MenuBuilder;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
module.exports = DebugMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function render() {
    this.setName("Debug");
    this.addNode("Get the code", function (_this) {
      return function () {
        return window.open("https://github.com/greenify/msa");
      };
    }(this));
    this.addNode("Toggle mouseover events", function (_this) {
      return function () {
        _this.g.config.set("registerMouseHover", !_this.g.config.get("registerMouseHover"));
        return _this.g.onAll(function () {
          return console.log(arguments);
        });
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/ExportMenu.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/ExportMenu.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ExportMenu, Exporter, FastaExporter, MenuBuilder, _;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
FastaExporter = __webpack_require__(/*! biojs-io-fasta */ "./node_modules/biojs-io-fasta/lib/index.js").writer;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
Exporter = __webpack_require__(/*! ../../utils/export */ "./node_modules/msa/lib/utils/export.js");
module.exports = ExportMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.msa = data.msa;
    return this.el.style.display = "inline-block";
  },
  render: function render() {
    this.setName("Export");
    this.addNode("View in Jalview", function (_this) {
      return function () {
        var url;
        url = _this.g.config.get('url');
        if (url == null) {
          return alert("Sequence weren't imported via an URL");
        } else {
          if (url.indexOf("localhost" || false)) {
            return Exporter.publishWeb(_this.msa, function (link) {
              return Exporter.openInJalview(link, _this.g.colorscheme.get("scheme"));
            });
          } else {
            return Exporter.openInJalview(url, _this.g.colorscheme.get("scheme"));
          }
        }
      };
    }(this));
    this.addNode("Publish to the web", function (_this) {
      return function () {
        return Exporter.publishWeb(_this.msa, function (link) {
          return window.open(link, '_blank');
        });
      };
    }(this));
    this.addNode("Share link", function (_this) {
      return function () {
        return Exporter.shareLink(_this.msa, function (link) {
          return window.open(link, '_blank');
        });
      };
    }(this));
    this.addNode("Export sequences", function (_this) {
      return function () {
        return Exporter.saveAsFile(_this.msa, "all.fasta");
      };
    }(this));
    this.addNode("Export selection", function (_this) {
      return function () {
        return Exporter.saveSelection(_this.msa, "selection.fasta");
      };
    }(this));
    this.addNode("Export features", function (_this) {
      return function () {
        return Exporter.saveAnnots(_this.msa, "features.gff3");
      };
    }(this));
    this.addNode("Export image", function (_this) {
      return function () {
        return Exporter.saveAsImg(_this.msa, "biojs-msa.png");
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/ExtraMenu.js":
/*!******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/ExtraMenu.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ExtraMenu, Loader, MenuBuilder, Seq, xhr;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
Seq = __webpack_require__(/*! ../../model/Sequence */ "./node_modules/msa/lib/model/Sequence.js");
Loader = __webpack_require__(/*! ../../utils/loader */ "./node_modules/msa/lib/utils/loader.js");
xhr = __webpack_require__(/*! xhr */ "./node_modules/xhr/index.js");
module.exports = ExtraMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.msa = data.msa;
  },
  render: function render() {
    var msa, stats;
    this.setName("Extras");
    stats = this.g.stats;
    msa = this.msa;
    this.addNode("Add consensus seq", function (_this) {
      return function () {
        var con, seq;
        con = stats.consensus();
        seq = new Seq({
          seq: con,
          id: "0c",
          name: "consenus"
        });
        _this.model.add(seq);
        _this.model.setRef(seq);
        _this.model.comparator = function (seq) {
          return !seq.get("ref");
        };
        return _this.model.sort();
      };
    }(this));
    this.addNode("Calc Tree", function () {
      var cbs, newickStr, nwkData;
      newickStr = "";
      cbs = Loader.joinCb(function () {
        return msa.u.tree.showTree(nwkData);
      }, 2, this);
      msa.u.tree.loadTree(cbs);
      nwkData = {
        name: "root",
        children: [{
          name: "c1",
          branch_length: 4,
          children: msa.seqs.filter(function (f, i) {
            return i % 2 === 0;
          })
        }, {
          name: "c2",
          children: msa.seqs.filter(function (f, i) {
            return i % 2 === 1;
          }),
          branch_length: 4
        }]
      };
      msa.seqs.each(function (s) {
        return s.set("branch_length", 2);
      });
      return cbs();
    });
    this.addNode("Increase font size", function (_this) {
      return function () {
        var columnWidth, nColumnWidth, nFontSize;
        columnWidth = _this.g.zoomer.get("columnWidth");
        nColumnWidth = columnWidth + 5;
        _this.g.zoomer.set("columnWidth", nColumnWidth);
        _this.g.zoomer.set("rowHeight", nColumnWidth);
        nFontSize = nColumnWidth * 0.7;
        _this.g.zoomer.set("residueFont", nFontSize);
        return _this.g.zoomer.set("labelFontSize", nFontSize);
      };
    }(this));
    this.addNode("Decrease font size", function (_this) {
      return function () {
        var columnWidth, nColumnWidth, nFontSize;
        columnWidth = _this.g.zoomer.get("columnWidth");
        nColumnWidth = columnWidth - 2;
        _this.g.zoomer.set("columnWidth", nColumnWidth);
        _this.g.zoomer.set("rowHeight", nColumnWidth);
        nFontSize = nColumnWidth * 0.6;
        _this.g.zoomer.set("residueFont", nFontSize);
        _this.g.zoomer.set("labelFontSize", nFontSize);
        if (_this.g.zoomer.get("columnWidth") < 8) {
          return _this.g.zoomer.set("textVisible", false);
        }
      };
    }(this));
    this.addNode("Minimized width", function (_this) {
      return function () {
        return _this.g.zoomer.set("alignmentWidth", 600);
      };
    }(this));
    this.addNode("Minimized height", function (_this) {
      return function () {
        return _this.g.zoomer.set("alignmentHeight", 120);
      };
    }(this));
    this.addNode("Jump to a column", function (_this) {
      return function () {
        var offset;
        offset = prompt("Column", "20");
        if (offset < 0 || offset > _this.model.getMaxLength() || isNaN(offset)) {
          alert("invalid column");
          return;
        }
        return _this.g.zoomer.setLeftOffset(offset);
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/FilterMenu.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/FilterMenu.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var FilterMenu, MenuBuilder, _;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = FilterMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function render() {
    this.setName("Filter");
    this.addNode("Hide columns by threshold", function (_this) {
      return function (e) {
        var conserv, hidden, i, j, maxLen, ref, threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        hidden = [];
        conserv = _this.g.stats.scale(_this.g.stats.conservation());
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          if (conserv[i] < threshold) {
            hidden.push(i);
          }
        }
        return _this.g.columns.set("hidden", hidden);
      };
    }(this));
    this.addNode("Hide columns by selection", function (_this) {
      return function () {
        var hidden, hiddenOld;
        hiddenOld = _this.g.columns.get("hidden");
        hidden = hiddenOld.concat(_this.g.selcol.getAllColumnBlocks({
          maxLen: _this.model.getMaxLength(),
          withPos: true
        }));
        _this.g.selcol.reset([]);
        return _this.g.columns.set("hidden", hidden);
      };
    }(this));
    this.addNode("Hide columns by gaps", function (_this) {
      return function () {
        var gapContent, gaps, hidden, i, j, maxLen, ref, threshold, total;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        maxLen = _this.model.getMaxLength();
        hidden = [];
        for (i = j = 0, ref = maxLen - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          gaps = 0;
          total = 0;
          _this.model.each(function (el) {
            if (el.get('seq')[i] === "-") {
              gaps++;
            }
            return total++;
          });
          gapContent = gaps / total;
          if (gapContent > threshold) {
            hidden.push(i);
          }
        }
        return _this.g.columns.set("hidden", hidden);
      };
    }(this));
    this.addNode("Hide seqs by identity", function (_this) {
      return function () {
        var threshold;
        threshold = prompt("Enter threshold (in percent)", 20);
        threshold = threshold / 100;
        return _this.model.each(function (el) {
          if (el.get('identity') < threshold) {
            return el.set('hidden', true);
          }
        });
      };
    }(this));
    this.addNode("Hide seqs by selection", function (_this) {
      return function () {
        var hidden, ids;
        hidden = _this.g.selcol.where({
          type: "row"
        });
        ids = _.map(hidden, function (el) {
          return el.get('seqId');
        });
        _this.g.selcol.reset([]);
        return _this.model.each(function (el) {
          if (ids.indexOf(el.get('id')) >= 0) {
            return el.set('hidden', true);
          }
        });
      };
    }(this));
    this.addNode("Hide seqs by gaps", function (_this) {
      return function () {
        var threshold;
        threshold = prompt("Enter threshold (in percent)", 40);
        return _this.model.each(function (el, i) {
          var gaps, seq;
          seq = el.get('seq');
          gaps = _.reduce(seq, function (memo, c) {
            if (c === '-') {
              memo++;
            }
            return memo;
          }, 0);
          if (gaps > threshold) {
            return el.set('hidden', true);
          }
        });
      };
    }(this));
    this.addNode("Reset", function (_this) {
      return function () {
        _this.g.columns.set("hidden", []);
        return _this.model.each(function (el) {
          if (el.get('hidden')) {
            return el.set('hidden', false);
          }
        });
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/HelpMenu.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/HelpMenu.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var HelpMenu, MenuBuilder;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
module.exports = HelpMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    return this.g = data.g;
  },
  render: function render() {
    this.setName("Help");
    this.addNode("About the project", function (_this) {
      return function () {
        return window.open("https://github.com/greenify/msa");
      };
    }(this));
    this.addNode("Report issues", function (_this) {
      return function () {
        return window.open("https://github.com/greenify/msa/issues");
      };
    }(this));
    this.addNode("User manual", function (_this) {
      return function () {
        return window.open("https://github.com/greenify/msa/wiki");
      };
    }(this));
    this.el.style.display = "inline-block";
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/ImportMenu.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/ImportMenu.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ImportMenu, MenuBuilder, k;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
k = __webpack_require__(/*! koala-js */ "./node_modules/koala-js/index.js");
module.exports = ImportMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.msa = data.msa;
  },
  render: function render() {
    var msa, uploader;
    msa = this.msa;
    uploader = k.mk("input");
    uploader.type = "file";
    uploader.style.display = "none";
    uploader.multiple = true;
    uploader.addEventListener("change", function () {
      var files;
      files = uploader.files || [];
      return msa.u.file.importFiles(files);
    });
    this.el.appendChild(uploader);
    this.setName("Import");
    this.addNode("URL", function (_this) {
      return function (e) {
        var url;
        url = prompt("URL", "http://rostlab.org/~goldberg/clustalw2-I20140818-215249-0556-53699878-pg.clustalw");
        return _this.msa.u.file.importURL(url, function () {});
      };
    }(this));
    this.addNode("From file", function (_this) {
      return function () {
        return uploader.click();
      };
    }(this));
    this.addNode("Drag & Drop", function (_this) {
      return function () {
        return alert("Yep. Just drag & drop your file");
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/OrderingMenu.js":
/*!*********************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/OrderingMenu.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MenuBuilder, OrderingMenu, _, dom;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = OrderingMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.order = "ID";
    return this.el.style.display = "inline-block";
  },
  setOrder: function setOrder(order) {
    this.order = order;
    return this.render();
  },
  render: function render() {
    var comps, el, i, len, m;
    this.setName("Ordering");
    this.removeAllNodes();
    comps = this.getComparators();
    for (i = 0, len = comps.length; i < len; i++) {
      m = comps[i];
      this._addNode(m);
    }
    el = this.buildDOM();
    dom.removeAllChilds(this.el);
    this.el.appendChild(el);
    return this;
  },
  _addNode: function _addNode(m) {
    var style, text;
    text = m.text;
    style = {};
    if (text === this.order) {
      style.backgroundColor = "#77ED80";
    }
    return this.addNode(text, function (_this) {
      return function () {
        if (m.precode != null) {
          m.precode();
        }
        _this.model.comparator = m.comparator;
        _this.model.sort();
        return _this.setOrder(m.text);
      };
    }(this), {
      style: style
    });
  },
  getComparators: function getComparators() {
    var models, setIdent;
    models = [];
    models.push({
      text: "ID",
      comparator: "id"
    });
    models.push({
      text: "ID Desc",
      comparator: function comparator(a, b) {
        return -("" + a.get("id")).localeCompare("" + b.get("id"), [], {
          numeric: true
        });
      }
    });
    models.push({
      text: "Label",
      comparator: "name"
    });
    models.push({
      text: "Label Desc",
      comparator: function comparator(a, b) {
        return -a.get("name").localeCompare(b.get("name"));
      }
    });
    models.push({
      text: "Seq",
      comparator: "seq"
    });
    models.push({
      text: "Seq Desc",
      comparator: function comparator(a, b) {
        return -a.get("seq").localeCompare(b.get("seq"));
      }
    });
    setIdent = function (_this) {
      return function () {
        return _this.ident = _this.g.stats.identity();
      };
    }(this);
    models.push({
      text: "Identity",
      comparator: function (_this) {
        return function (a, b) {
          var val;
          val = _this.ident[a.id] - _this.ident[b.id];
          if (val > 0) {
            return 1;
          }
          if (val < 0) {
            return -1;
          }
          return 0;
        };
      }(this),
      precode: setIdent
    });
    models.push({
      text: "Identity Desc",
      comparator: function (_this) {
        return function (a, b) {
          var val;
          val = _this.ident[a.id] - _this.ident[b.id];
          if (val > 0) {
            return -1;
          }
          if (val < 0) {
            return 1;
          }
          return 0;
        };
      }(this),
      precode: setIdent
    });
    models.push({
      text: "Reference",
      comparator: function comparator(seq) {
        return !seq.get("ref");
      }
    });
    models.push({
      text: "Partition codes",
      comparator: "partition",
      precode: function (_this) {
        return function () {
          _this.g.vis.set('labelPartition', true);
          return _this.model.each(function (el) {
            return el.set('partition', _.random(1, 3));
          });
        };
      }(this)
    });
    return models;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/SelectionMenu.js":
/*!**********************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/SelectionMenu.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MenuBuilder, SelectionMenu;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
module.exports = SelectionMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    return this.el.style.display = "inline-block";
  },
  render: function render() {
    this.setName("Selection");
    this.addNode("Find Motif (supports RegEx)", function (_this) {
      return function () {
        var search;
        search = prompt("your search", "D");
        return _this.g.user.set("searchText", search);
      };
    }(this));
    this.addNode("Invert columns", function (_this) {
      return function () {
        var i, ref, results;
        return _this.g.selcol.invertCol(function () {
          results = [];
          for (var i = 0, ref = _this.model.getMaxLength(); 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
            results.push(i);
          }
          return results;
        }.apply(this));
      };
    }(this));
    this.addNode("Invert rows", function (_this) {
      return function () {
        return _this.g.selcol.invertRow(_this.model.pluck("id"));
      };
    }(this));
    this.addNode("Reset", function (_this) {
      return function () {
        return _this.g.selcol.reset();
      };
    }(this));
    this.el.appendChild(this.buildDOM());
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/menu/views/VisMenu.js":
/*!****************************************************!*\
  !*** ./node_modules/msa/lib/menu/views/VisMenu.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MenuBuilder, VisMenu, dom;
MenuBuilder = __webpack_require__(/*! ../menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
module.exports = VisMenu = MenuBuilder.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.el.style.display = "inline-block";
    return this.listenTo(this.g.vis, "change", this.render);
  },
  render: function render() {
    var i, len, visEl, visElements;
    this.removeAllNodes();
    this.setName("Vis.elements");
    visElements = this.getVisElements();
    for (i = 0, len = visElements.length; i < len; i++) {
      visEl = visElements[i];
      this._addVisEl(visEl);
    }
    this.addNode("Reset", function (_this) {
      return function () {
        _this.g.vis.set("labels", true);
        _this.g.vis.set("sequences", true);
        _this.g.vis.set("metacell", true);
        _this.g.vis.set("conserv", true);
        _this.g.vis.set("labelId", true);
        _this.g.vis.set("labelName", true);
        _this.g.vis.set("labelCheckbox", false);
        _this.g.vis.set("seqlogo", false);
        _this.g.vis.set("gapHeader", false);
        _this.g.vis.set("leftHeader", true);
        _this.g.vis.set("metaGaps", true);
        _this.g.vis.set("metaIdentity", true);
        return _this.g.vis.set("metaLinks", true);
      };
    }(this));
    dom.removeAllChilds(this.el);
    this.el.appendChild(this.buildDOM());
    return this;
  },
  _addVisEl: function _addVisEl(visEl) {
    var pre, style;
    style = {};
    if (this.g.vis.get(visEl.id)) {
      pre = "Hide ";
      style.color = "red";
    } else {
      pre = "Show ";
      style.color = "green";
    }
    return this.addNode(pre + visEl.name, function (_this) {
      return function () {
        return _this.g.vis.set(visEl.id, !_this.g.vis.get(visEl.id));
      };
    }(this), {
      style: style
    });
  },
  getVisElements: function getVisElements() {
    var vis;
    vis = [];
    vis.push({
      name: "Markers",
      id: "markers"
    });
    vis.push({
      name: "Labels",
      id: "labels"
    });
    vis.push({
      name: "Meta info",
      id: "metacell"
    });
    vis.push({
      name: "Overviewbox",
      id: "overviewbox"
    });
    vis.push({
      name: "Conserv",
      id: "conserv"
    });
    vis.push({
      name: "Seq. logo",
      id: "seqlogo"
    });
    vis.push({
      name: "Gap Header",
      id: "gapHeader"
    });
    vis.push({
      name: "Left header",
      id: "leftHeader"
    });
    vis.push({
      name: "Label name",
      id: "labelName"
    });
    vis.push({
      name: "Label id",
      id: "labelId"
    });
    vis.push({
      name: "Label checkbox",
      id: "labelCheckbox"
    });
    vis.push({
      name: "Meta gaps",
      id: "metaGaps"
    });
    vis.push({
      name: "Meta identity",
      id: "metaIdentity"
    });
    vis.push({
      name: "Meta links",
      id: "metaLinks"
    });
    return vis;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/model/Feature.js":
/*!***********************************************!*\
  !*** ./node_modules/msa/lib/model/Feature.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Feature, Model;
Feature = __webpack_require__(/*! ./Feature */ "./node_modules/msa/lib/model/Feature.js");
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
module.exports = Feature = Model.extend({
  defaults: {
    xStart: -1,
    xEnd: -1,
    height: -1,
    text: "",
    fillColor: "red",
    fillOpacity: 0.5,
    type: "rectangle",
    borderSize: 1,
    borderColor: "black",
    borderOpacity: 0.5,
    validate: true,
    row: 0
  },
  initialize: function initialize(obj) {
    if (obj.start != null) {
      this.set("xStart", obj.start);
    }
    if (obj.end != null) {
      this.set("xEnd", obj.end);
    }
    if (obj.attributes != null) {
      if (obj.attributes.Name != null) {
        this.set("text", obj.attributes.Name);
      }
      if (obj.attributes.Color != null) {
        this.set("fillColor", obj.attributes.Color);
      }
    }
    if (this.attributes.xEnd < this.attributes.xStart) {
      console.warn("invalid feature range for", this.attributes);
    }
    if (!_.isNumber(this.attributes.xStart) || !_.isNumber(this.attributes.xEnd)) {
      console.warn("please provide numeric feature ranges", obj);
      this.set("xStart", parseInt(this.attributes.xStart));
      return this.set("xEnd", parseInt(this.attributes.xEnd));
    }
  },
  validate: function validate() {
    if (isNaN(this.attributes.xStart || isNaN(this.attributes.xEnd))) {
      return "features need integer start and end.";
    }
  },
  contains: function contains(index) {
    return this.attributes.xStart <= index && index <= this.attributes.xEnd;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/model/FeatureCol.js":
/*!**************************************************!*\
  !*** ./node_modules/msa/lib/model/FeatureCol.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Collection, Feature, FeatureCol, _;
Feature = __webpack_require__(/*! ./Feature */ "./node_modules/msa/lib/model/Feature.js");
Collection = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Collection;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = FeatureCol = Collection.extend({
  model: Feature,
  constructor: function constructor() {
    this.startOnCache = [];
    this.on("all", function () {
      return this.startOnCache = [];
    }, this);
    return Collection.apply(this, arguments);
  },
  startOn: function startOn(index) {
    if (this.startOnCache[index] == null) {
      this.startOnCache[index] = this.where({
        xStart: index
      });
    }
    return this.startOnCache[index];
  },
  contains: function contains(index) {
    return this.reduce(function (el, memo) {
      return memo || el.contains(index);
    }, false);
  },
  getFeatureOnRow: function getFeatureOnRow(row, x) {
    return this.filter(function (el) {
      return el.get("row") === row && el.get("xStart") <= x && x <= el.get("xEnd");
    });
  },
  assignRows: function assignRows() {
    var len, rows, x;
    len = this.max(function (el) {
      return el.get("xEnd");
    }).attributes.xEnd;
    rows = function () {
      var i, ref, results;
      results = [];
      for (x = i = 0, ref = len; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    }();
    this.each(function (el) {
      var i, max, ref, ref1;
      max = 0;
      for (x = i = ref = el.get("xStart"), ref1 = el.get("xEnd"); i <= ref1; x = i += 1) {
        if (rows[x] > max) {
          max = rows[x];
        }
        rows[x]++;
      }
      return el.set("row", max);
    });
    return _.max(rows);
  },
  getCurrentHeight: function getCurrentHeight() {
    return this.max(function (el) {
      return el.get("row");
    }).attributes.row + 1;
  },
  getMinRows: function getMinRows() {
    var len, rows, x;
    len = this.max(function (el) {
      return el.get("xEnd");
    }).attributes.xEnd;
    rows = function () {
      var i, ref, results;
      results = [];
      for (x = i = 0, ref = len; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    }();
    this.each(function (el) {
      var i, ref, ref1, results;
      results = [];
      for (x = i = ref = el.get("xStart"), ref1 = el.get("xEnd"); i <= ref1; x = i += 1) {
        results.push(rows[x]++);
      }
      return results;
    });
    return _.max(rows);
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/model/SeqCollection.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa/lib/model/SeqCollection.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Collection, FeatureCol, SeqManager, Sequence;
Sequence = __webpack_require__(/*! ./Sequence */ "./node_modules/msa/lib/model/Sequence.js");
FeatureCol = __webpack_require__(/*! ./FeatureCol */ "./node_modules/msa/lib/model/FeatureCol.js");
Collection = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Collection;
module.exports = SeqManager = Collection.extend({
  model: Sequence,
  constructor: function constructor(seqs, g) {
    Collection.apply(this, arguments);
    this.g = g;
    this.on("add reset remove", function (_this) {
      return function () {
        _this.lengthCache = null;
        return _this._bindSeqsWithFeatures();
      };
    }(this), this);
    this.on("reset", function (_this) {
      return function () {
        return _this._autoSetRefSeq();
      };
    }(this));
    this._autoSetRefSeq();
    this.lengthCache = null;
    this.features = {};
    return this;
  },
  getMaxLength: function getMaxLength() {
    if (this.models.length === 0) {
      return 0;
    }
    if (this.lengthCache === null) {
      this.lengthCache = this.max(function (seq) {
        return seq.get("seq").length;
      }).get("seq").length;
    }
    return this.lengthCache;
  },
  prev: function prev(model, endless) {
    var index;
    index = this.indexOf(model) - 1;
    if (index < 0 && endless) {
      index = this.length - 1;
    }
    return this.at(index);
  },
  next: function next(model, endless) {
    var index;
    index = this.indexOf(model) + 1;
    if (index === this.length && endless) {
      index = 0;
    }
    return this.at(index);
  },
  calcHiddenSeqs: function calcHiddenSeqs(n) {
    var i, j, nNew, ref;
    nNew = n;
    for (i = j = 0, ref = nNew; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this.at(i).get("hidden")) {
        nNew++;
      }
    }
    return nNew - n;
  },
  addFeatures: function addFeatures(features) {
    var colors, obj;
    if (features.config != null) {
      obj = features;
      features = features.seqs;
      if (obj.config.colors != null) {
        colors = obj.config.colors;
        _.each(features, function (seq) {
          return _.each(seq, function (val) {
            if (colors[val.feature] != null) {
              return val.fillColor = colors[val.feature];
            }
          });
        });
      }
    }
    if (_.isEmpty(this.features)) {
      this.features = features;
    } else {
      _.each(features, function (_this) {
        return function (val, key) {
          if (!_this.features.hasOwnProperty(key)) {
            return _this.features[key] = val;
          } else {
            return _this.features[key] = _.union(_this.features[key], val);
          }
        };
      }(this));
    }
    return this._bindSeqsWithFeatures();
  },
  _bindSeqWithFeatures: function _bindSeqWithFeatures(seq) {
    var features;
    features = this.features[seq.attributes.name];
    if (features) {
      seq.set("features", new FeatureCol(features));
      seq.attributes.features.assignRows();
      return seq.set("height", seq.attributes.features.getCurrentHeight() + 1);
    }
  },
  _bindSeqsWithFeatures: function _bindSeqsWithFeatures() {
    return this.each(function (_this) {
      return function (seq) {
        return _this._bindSeqWithFeatures(seq);
      };
    }(this));
  },
  removeAllFeatures: function removeAllFeatures() {
    return delete this.features;
  },
  _autoSetRefSeq: function _autoSetRefSeq() {
    if (this.length > 0) {
      return this.at(0).set("ref", true);
    }
  },
  setRef: function setRef(seq) {
    var obj;
    obj = this.get(seq);
    this.each(function (s) {
      if (seq.cid) {
        if (obj.cid === s.cid) {
          return s.set("ref", true);
        } else {
          return s.set("ref", false);
        }
      }
    });
    this.g.config.set("hasRef", true);
    return this.trigger("change:reference", seq);
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/model/Sequence.js":
/*!************************************************!*\
  !*** ./node_modules/msa/lib/model/Sequence.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var FeatureCol, Model, Sequence;
Model = __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model;
FeatureCol = __webpack_require__(/*! ./FeatureCol */ "./node_modules/msa/lib/model/FeatureCol.js");
module.exports = Sequence = Model.extend({
  defaults: {
    name: "",
    id: "",
    seq: "",
    height: 1,
    ref: false
  },
  initialize: function initialize() {
    this.set("grey", []);
    if (this.get("features") == null) {
      return this.set("features", new FeatureCol());
    }
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/model/index.js":
/*!*********************************************!*\
  !*** ./node_modules/msa/lib/model/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
module.exports.seq = __webpack_require__(/*! ./Sequence */ "./node_modules/msa/lib/model/Sequence.js");
module.exports.seqcol = __webpack_require__(/*! ./SeqCollection */ "./node_modules/msa/lib/model/SeqCollection.js");
module.exports.feature = __webpack_require__(/*! ./Feature */ "./node_modules/msa/lib/model/Feature.js");
module.exports.featurecol = __webpack_require__(/*! ./FeatureCol */ "./node_modules/msa/lib/model/FeatureCol.js");

/***/ }),

/***/ "./node_modules/msa/lib/msa.js":
/*!*************************************!*\
  !*** ./node_modules/msa/lib/msa.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var $, Colorator, Columns, Config, Eventhandler, FileHelper, Package, ProxyHelper, SelCol, SeqCollection, Stage, Stats, TreeHelper, User, VisOrdering, Visibility, Zoomer, boneView;
SeqCollection = __webpack_require__(/*! ./model/SeqCollection */ "./node_modules/msa/lib/model/SeqCollection.js");
Colorator = __webpack_require__(/*! ./g/colorscheme */ "./node_modules/msa/lib/g/colorscheme.js");
Columns = __webpack_require__(/*! ./g/columns */ "./node_modules/msa/lib/g/columns.js");
Config = __webpack_require__(/*! ./g/config */ "./node_modules/msa/lib/g/config.js");
Package = __webpack_require__(/*! ./g/package */ "./node_modules/msa/lib/g/package.js");
SelCol = __webpack_require__(/*! ./g/selection/SelectionCol */ "./node_modules/msa/lib/g/selection/SelectionCol.js");
User = __webpack_require__(/*! ./g/user */ "./node_modules/msa/lib/g/user.js");
Visibility = __webpack_require__(/*! ./g/visibility */ "./node_modules/msa/lib/g/visibility.js");
VisOrdering = __webpack_require__(/*! ./g/visOrdering */ "./node_modules/msa/lib/g/visOrdering.js");
Zoomer = __webpack_require__(/*! ./g/zoomer */ "./node_modules/msa/lib/g/zoomer.js");
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
Eventhandler = __webpack_require__(/*! biojs-events */ "./node_modules/biojs-events/index.js");
Stage = __webpack_require__(/*! ./views/Stage */ "./node_modules/msa/lib/views/Stage.js");
Stats = __webpack_require__(/*! stat.seqs */ "./node_modules/stat.seqs/lib/index.js");
$ = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
FileHelper = __webpack_require__(/*! ./utils/file */ "./node_modules/msa/lib/utils/file.js");
TreeHelper = __webpack_require__(/*! ./utils/tree */ "./node_modules/msa/lib/utils/tree.js");
ProxyHelper = __webpack_require__(/*! ./utils/proxy */ "./node_modules/msa/lib/utils/proxy.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    var events, ref;
    if (data == null) {
      data = {};
    }
    if (data.colorscheme == null) {
      data.colorscheme = {};
    }
    if (data.columns == null) {
      data.columns = {};
    }
    if (data.conf == null) {
      data.conf = {};
    }
    if (data.vis == null) {
      data.vis = {};
    }
    if (data.zoomer == null) {
      if (!((ref = data.visorder) != null ? ref : data.zoomer = {})) {
        data.visorder = {};
      }
    }
    this.g = Eventhandler.mixin({});
    this.seqs = new SeqCollection(data.seqs, this.g);
    this.g.config = new Config(data.conf);
    this.g["package"] = new Package(this.g);
    this.g.selcol = new SelCol([], {
      g: this.g
    });
    this.g.user = new User();
    this.g.vis = new Visibility(data.vis, {
      model: this.seqs
    });
    this.g.visorder = new VisOrdering(data.visorder);
    this.g.zoomer = new Zoomer(data.zoomer, {
      g: this.g,
      model: this.seqs
    });
    if (window.location.hostname === "localhost") {
      this.g.config.set("debug", true);
    }
    this._loadSeqs(data);
    this.u = {};
    this.u.file = new FileHelper(this);
    this.u.proxy = new ProxyHelper({
      g: this.g
    });
    this.u.tree = new TreeHelper(this);
    if (this.g.config.get("eventBus") === true) {
      this.startEventBus();
    }
    if (this.g.config.get("dropImport")) {
      events = {
        "dragover": this.dragOver,
        "drop": this.dropFile
      };
      this.delegateEvents(events);
    }
    if (data.importURL) {
      this.u.file.importURL(data.importURL, function (_this) {
        return function () {
          return _this.render();
        };
      }(this));
    }
    if (data.bootstrapMenu) {
      this.g.config.set("bootstrapMenu", true);
    }
    this.draw();
    return this.m();
  },
  _loadSeqs: function _loadSeqs(data) {
    var pureSeq;
    pureSeq = this.seqs.pluck("seq");
    this.g.stats = new Stats(this.seqs);
    this.g.stats.alphabetSize = this.g.config.get("alphabetSize");
    this.g.columns = new Columns(data.columns, this.g.stats);
    this.g.colorscheme = new Colorator(data.colorscheme, pureSeq, this.g.stats);
    return this.g.zoomer.setEl(this.el, this.seqs);
  },
  importURL: function importURL() {
    return this.u.file.importURL.apply(this.u.file, arguments);
  },
  m: function m() {
    var m;
    m = {};
    m.model = __webpack_require__(/*! ./model */ "./node_modules/msa/lib/model/index.js");
    m.selection = __webpack_require__(/*! ./g/selection/Selection */ "./node_modules/msa/lib/g/selection/Selection.js");
    m.selcol = __webpack_require__(/*! ./g/selection/SelectionCol */ "./node_modules/msa/lib/g/selection/SelectionCol.js");
    m.view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
    m.boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
    return this.m = m;
  },
  draw: function draw() {
    var defMenu, menuDiv, wrapperDiv;
    this.removeViews();
    this.addView("stage", new Stage({
      model: this.seqs,
      g: this.g
    }));
    this.el.setAttribute("class", "biojs_msa_div");
    if (this.g.config.get("bootstrapMenu")) {
      menuDiv = document.createElement('div');
      wrapperDiv = document.createElement('div');
      if (!this.el.parentNode) {
        wrapperDiv.appendChild(menuDiv);
        wrapperDiv.appendChild(this.el);
      } else {
        this.el.parentNode.replaceChild(wrapperDiv, this.el);
        wrapperDiv.appendChild(menuDiv);
        wrapperDiv.appendChild(this.el);
      }
      defMenu = new msa.menu.defaultmenu({
        el: menuDiv,
        msa: this
      });
      defMenu.render();
    }
    return $(window).on("resize", function (_this) {
      return function (e) {
        var f;
        f = function f() {
          return this.g.zoomer.autoResize();
        };
        return setTimeout(f.bind(_this), 5);
      };
    }(this));
  },
  dragOver: function dragOver(e) {
    e.preventDefault();
    e.target.className = 'hover';
    return false;
  },
  dropFile: function dropFile(e) {
    var files;
    e.preventDefault();
    files = e.target.files || e.dataTransfer.files;
    this.u.file.importFiles(files);
    return false;
  },
  startEventBus: function startEventBus() {
    var busObjs, i, key, len, results;
    busObjs = ["config", "columns", "colorscheme", "selcol", "vis", "visorder", "zoomer"];
    results = [];
    for (i = 0, len = busObjs.length; i < len; i++) {
      key = busObjs[i];
      results.push(this._proxyToG(key));
    }
    return results;
  },
  _proxyToG: function _proxyToG(key) {
    return this.listenTo(this.g[key], "all", function (name, prev, now, opts) {
      if (name === "change") {
        return;
      }
      if (opts != null) {
        return this.g.trigger(key + ":" + name, now, prev, opts);
      } else {
        return this.g.trigger(key + ":" + name, now, prev);
      }
    });
  },
  render: function render() {
    if (this.seqs === void 0 || this.seqs.length === 0) {
      console.log("warning. empty seqs.");
    }
    this.renderSubviews();
    this.g.vis.set("loaded", true);
    return this;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/utils sync recursive":
/*!*****************************************!*\
  !*** ./node_modules/msa/lib/utils sync ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/msa/lib/utils sync recursive";

/***/ }),

/***/ "./node_modules/msa/lib/utils/bmath.js":
/*!*********************************************!*\
  !*** ./node_modules/msa/lib/utils/bmath.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.9.1
var BMath;
module.exports = BMath = function () {
  function BMath() {}
  BMath.randomInt = function (lower, upper) {
    var ref, ref1;
    if (upper == null) {
      ref = [0, lower], lower = ref[0], upper = ref[1];
    }
    if (lower > upper) {
      ref1 = [upper, lower], lower = ref1[0], upper = ref1[1];
    }
    return Math.floor(Math.random() * (upper - lower + 1) + lower);
  };
  BMath.uniqueId = function (length) {
    var id;
    if (length == null) {
      length = 8;
    }
    id = "";
    while (id.length < length) {
      id += Math.random().toString(36).substr(2);
    }
    return id.substr(0, length);
  };
  BMath.getRandomInt = function (min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
  return BMath;
}();

/***/ }),

/***/ "./node_modules/msa/lib/utils/export.js":
/*!**********************************************!*\
  !*** ./node_modules/msa/lib/utils/export.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Exporter, Fasta, GFF, _, blobURL, saveAs, xhr;
Fasta = __webpack_require__(/*! biojs-io-fasta */ "./node_modules/biojs-io-fasta/lib/index.js");
GFF = __webpack_require__(/*! biojs-io-gff */ "./node_modules/biojs-io-gff/lib/index.js");
xhr = __webpack_require__(/*! xhr */ "./node_modules/xhr/index.js");
blobURL = __webpack_require__(/*! blueimp_canvastoblob */ "./node_modules/blueimp_canvastoblob/index.js");
saveAs = __webpack_require__(/*! browser-saveas */ "./node_modules/browser-saveas/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = Exporter = {
  openInJalview: function openInJalview(url, colorscheme) {
    var host, jalviewUrl;
    if (url.charAt(0) === '.') {
      url = document.URL.substr(0, document.URL.lastIndexOf('/')) + "/" + url;
    }
    if (url.indexOf("http") < 0) {
      host = "http://" + window.location.hostname;
      url = host + url;
    }
    url = encodeURIComponent(url);
    jalviewUrl = "http://www.jalview.org/services/launchApp?open=" + url;
    jalviewUrl += "&colour=" + colorscheme;
    return window.open(jalviewUrl, '_blank');
  },
  publishWeb: function publishWeb(that, cb) {
    var text, url;
    text = Fasta.write(that.seqs.toJSON());
    text = encodeURIComponent(text);
    url = that.u.proxy.corsURL("http://sprunge.biojs.net");
    return xhr({
      method: "POST",
      body: "sprunge=" + text,
      uri: url,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      }
    }, function (err, rep, body) {
      var link;
      link = body.trim();
      return cb(link);
    });
  },
  shareLink: function shareLink(that, cb) {
    var fCB, msaURL, url;
    url = that.g.config.get("importURL");
    msaURL = "http://biojs-msa.org/app/?seq=";
    fCB = function fCB(link) {
      var fURL;
      fURL = msaURL + link;
      if (cb) {
        return cb(fURL);
      }
    };
    if (!url) {
      return Exporter.publishWeb(that, fCB);
    } else {
      return fCB(url);
    }
  },
  saveAsFile: function saveAsFile(that, name) {
    var blob, text;
    text = Fasta.write(that.seqs.toJSON());
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveSelection: function saveSelection(that, name) {
    var blob, i, j, ref, selection, text;
    selection = that.g.selcol.pluck("seqId");
    console.log(selection);
    if (selection.length > 0) {
      selection = that.seqs.filter(function (el) {
        return _.contains(selection, el.get("id"));
      });
      for (i = j = 0, ref = selection.length - 1; j <= ref; i = j += 1) {
        selection[i] = selection[i].toJSON();
      }
    } else {
      selection = that.seqs.toJSON();
      console.warn("no selection found");
    }
    text = Fasta.write(selection);
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveAnnots: function saveAnnots(that, name) {
    var blob, features, text;
    features = that.seqs.map(function (el) {
      var seqname;
      features = el.get("features");
      if (features.length === 0) {
        return;
      }
      seqname = el.get("name");
      features.each(function (s) {
        return s.set("seqname", seqname);
      });
      return features.toJSON();
    });
    features = _.flatten(_.compact(features));
    console.log(features);
    text = GFF.exportLines(features);
    blob = new Blob([text], {
      type: 'text/plain'
    });
    return saveAs(blob, name);
  },
  saveAsImg: function saveAsImg(that, name) {
    var canvas, url;
    canvas = that.getView('stage').getView('body').getView('seqblock').el;
    if (canvas != null) {
      url = canvas.toDataURL('image/png');
      return saveAs(blobURL(url), name, "image/png");
    }
  }
};

/***/ }),

/***/ "./node_modules/msa/lib/utils/file.js":
/*!********************************************!*\
  !*** ./node_modules/msa/lib/utils/file.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ClustalReader, FastaReader, FileHelper, GffReader, _, funs, xhr;
FastaReader = __webpack_require__(/*! biojs-io-fasta */ "./node_modules/biojs-io-fasta/lib/index.js");
ClustalReader = __webpack_require__(/*! biojs-io-clustal */ "./node_modules/biojs-io-clustal/lib/index.js");
GffReader = __webpack_require__(/*! biojs-io-gff */ "./node_modules/biojs-io-gff/lib/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
xhr = __webpack_require__(/*! xhr */ "./node_modules/xhr/index.js");
module.exports = FileHelper = function FileHelper(msa) {
  this.msa = msa;
  return this;
};
funs = {
  guessFileType: function guessFileType(name) {
    var fileName;
    name = name.split(".");
    fileName = name[name.length(-1)];
    switch (fileName) {
      case "aln":
      case "clustal":
        return ClustalReader;
      case "fasta":
        return FastaReader;
      default:
        return FastaReader;
    }
  },
  guessFileFromText: function guessFileFromText(text) {
    var reader, type;
    if (text == null) {
      console.warn("invalid file format");
      return ["", "error"];
    }
    if (text.substring(0, 7) === "CLUSTAL") {
      reader = ClustalReader;
      type = "seqs";
    } else if (text.substring(0, 1) === ">") {
      reader = FastaReader;
      type = "seqs";
    } else if (text.substring(0, 1) === "(") {
      type = "newick";
    } else {
      reader = GffReader;
      type = "features";
    }
    return [reader, type];
  },
  parseText: function parseText(text) {
    var features, reader, ref, seqs, type;
    ref = this.guessFileFromText(text), reader = ref[0], type = ref[1];
    if (type === "seqs") {
      seqs = reader.parse(text);
      return [seqs, type];
    } else if (type === "features") {
      features = reader.parseSeqs(text);
      return [features, type];
    } else {
      return [text, type];
    }
  },
  importFiles: function importFiles(files) {
    var file, i, j, reader, ref, results;
    results = [];
    for (i = j = 0, ref = files.length - 1; j <= ref; i = j += 1) {
      file = files[i];
      reader = new FileReader();
      reader.onload = function (_this) {
        return function (evt) {
          return _this.importFile(evt.target.result);
        };
      }(this);
      results.push(reader.readAsText(file));
    }
    return results;
  },
  importFile: function importFile(file) {
    var fileName, objs, ref, type;
    ref = this.parseText(file), objs = ref[0], type = ref[1];
    if (type === "error") {
      return "error";
    }
    if (type === "seqs") {
      this.msa.seqs.reset(objs);
      this.msa.g.config.set("url", "userimport");
      this.msa.g.trigger("url:userImport");
    } else if (type === "features") {
      this.msa.seqs.addFeatures(objs);
    } else if (type === "newick") {
      this.msa.u.tree.loadTree(function (_this) {
        return function () {
          return _this.msa.u.tree.showTree(file);
        };
      }(this));
    }
    return fileName = file.name;
  },
  importURL: function importURL(url, cb) {
    url = this.msa.u.proxy.corsURL(url);
    this.msa.g.config.set("url", url);
    return xhr(url, function (_this) {
      return function (err, status, body) {
        var res;
        if (!err) {
          res = _this.importFile(body);
          if (res === "error") {
            return;
          }
          _this.msa.g.trigger("import:url", url);
          if (cb) {
            return cb();
          }
        } else {
          return console.log(err);
        }
      };
    }(this));
  }
};
_.extend(FileHelper.prototype, funs);

/***/ }),

/***/ "./node_modules/msa/lib/utils/index.js":
/*!*********************************************!*\
  !*** ./node_modules/msa/lib/utils/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
module.exports.bmath = __webpack_require__(/*! ./bmath */ "./node_modules/msa/lib/utils/bmath.js");
module.exports.proxy = __webpack_require__(/*! ./proxy */ "./node_modules/msa/lib/utils/proxy.js");
module.exports.seqgen = __webpack_require__(/*! ./seqgen */ "./node_modules/msa/lib/utils/seqgen.js");
module.exports.file = __webpack_require__(/*! ./file */ "./node_modules/msa/lib/utils/file.js");
module.exports["export"] = __webpack_require__(/*! ./export */ "./node_modules/msa/lib/utils/export.js");

/***/ }),

/***/ "./node_modules/msa/lib/utils/loader.js":
/*!**********************************************!*\
  !*** ./node_modules/msa/lib/utils/loader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var k,
  loader,
  indexOf = [].indexOf || function (item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) return i;
    }
    return -1;
  };
k = __webpack_require__(/*! koala-js */ "./node_modules/koala-js/index.js");
module.exports = loader = {
  loadScript: function loadScript(url, cb) {
    var s, t;
    s = k.mk("script");
    s.type = "text/javascript";
    s.src = url;
    s.async = true;
    s.onload = s.onreadystatechange = function () {
      var r;
      if (!r && (!this.readyState || this.readyState === "complete")) {
        r = true;
        return cb();
      }
    };
    t = document.getElementsByTagName("script")[0];
    return t.parentNode.appendChild(s);
  },
  joinCb: function joinCb(retCb, finalLength, finalScope) {
    var callbackWrapper, cbsFinished, counter;
    finalLength = finalLength || 1;
    cbsFinished = 0;
    callbackWrapper = function callbackWrapper(cb, scope) {
      if (cb == null) {
        return counter();
      } else {
        return function () {
          if (indexOf.call(cb, "apply") >= 0) {
            cb.apply(scope, arguments);
          }
          return counter();
        };
      }
    };
    counter = function counter() {
      cbsFinished++;
      if (cbsFinished === finalLength) {
        return retCb.call(finalScope);
      }
    };
    return callbackWrapper;
  }
};

/***/ }),

/***/ "./node_modules/msa/lib/utils/proxy.js":
/*!*********************************************!*\
  !*** ./node_modules/msa/lib/utils/proxy.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ProxyHelper, _, proxyFun;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = ProxyHelper = function ProxyHelper(opts) {
  this.g = opts.g;
  return this;
};
proxyFun = {
  corsURL: function corsURL(url) {
    if (document.URL.indexOf('localhost') >= 0 && url[0] === "/") {
      return url;
    }
    if (url.charAt(0) === "." || url.charAt(0) === "/") {
      return url;
    }
    url = url.replace("www\.", "");
    url = url.replace("http://", "");
    url = this.g.config.get('importProxy') + url;
    return url;
  }
};
_.extend(ProxyHelper.prototype, proxyFun);

/***/ }),

/***/ "./node_modules/msa/lib/utils/seqgen.js":
/*!**********************************************!*\
  !*** ./node_modules/msa/lib/utils/seqgen.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var BMath, Sequence, Stat, seqgen;
Sequence = __webpack_require__(/*! biojs-model */ "./node_modules/biojs-model/src/index.js").seq;
BMath = __webpack_require__(/*! ./bmath */ "./node_modules/msa/lib/utils/bmath.js");
Stat = __webpack_require__(/*! stat.seqs */ "./node_modules/stat.seqs/lib/index.js");
seqgen = module.exports = {
  _generateSequence: function _generateSequence(len) {
    var i, k, ref, text;
    text = "";
    for (i = k = 0, ref = len - 1; k <= ref; i = k += 1) {
      text += seqgen.getRandomChar();
    }
    return text;
  },
  getDummySequences: function getDummySequences(len, seqLen) {
    var i, k, ref, seqs;
    seqs = [];
    if (len == null) {
      len = BMath.getRandomInt(3, 5);
    }
    if (seqLen == null) {
      seqLen = BMath.getRandomInt(50, 200);
    }
    for (i = k = 1, ref = len; k <= ref; i = k += 1) {
      seqs.push(new Sequence(seqgen._generateSequence(seqLen), "seq" + i, "r" + i));
    }
    return seqs;
  },
  getRandomChar: function getRandomChar(dict) {
    var possible;
    possible = dict || "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return possible.charAt(Math.floor(Math.random() * possible.length));
  },
  genConservedSequences: function genConservedSequences(len, seqLen, dict) {
    var c, cConserv, conservAim, counter, i, j, k, l, m, n, observed, pseqs, ref, ref1, ref2, ref3, seqs, tolerance;
    seqs = [];
    if (len == null) {
      len = BMath.getRandomInt(3, 5);
    }
    if (seqLen == null) {
      seqLen = BMath.getRandomInt(50, 200);
    }
    dict = dict || "ACDEFGHIKLMNPQRSTVWY---";
    for (i = k = 1, ref = len; k <= ref; i = k += 1) {
      seqs[i - 1] = "";
    }
    tolerance = 0.2;
    conservAim = 1;
    for (i = l = 0, ref1 = seqLen - 1; l <= ref1; i = l += 1) {
      if (i % 3 === 0) {
        conservAim = BMath.getRandomInt(50, 100) / 100;
      }
      observed = [];
      for (j = m = 0, ref2 = len - 1; m <= ref2; j = m += 1) {
        counter = 0;
        while (counter < 100) {
          c = seqgen.getRandomChar(dict);
          cConserv = Stat(observed);
          cConserv.addSeq(c);
          counter++;
          if (Math.abs(conservAim - cConserv.scale(cConserv.conservation())[0]) < tolerance) {
            break;
          }
        }
        seqs[j] += c;
        observed.push(c);
      }
    }
    pseqs = [];
    for (i = n = 1, ref3 = len; n <= ref3; i = n += 1) {
      pseqs.push(new Sequence(seqs[i - 1], "seq" + i, "r" + i));
    }
    return pseqs;
  }
};

/***/ }),

/***/ "./node_modules/msa/lib/utils/svg.js":
/*!*******************************************!*\
  !*** ./node_modules/msa/lib/utils/svg.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.9.1
var Base, Line, Polygon, Rect, setAttr, svgns;
svgns = "http://www.w3.org/2000/svg";
setAttr = function setAttr(obj, opts) {
  var name, value;
  for (name in opts) {
    value = opts[name];
    obj.setAttributeNS(null, name, value);
  }
  return obj;
};
Base = function Base(opts) {
  var svg;
  svg = document.createElementNS(svgns, 'svg');
  svg.setAttribute("width", opts.width);
  svg.setAttribute("height", opts.height);
  return svg;
};
Rect = function Rect(opts) {
  var rect;
  rect = document.createElementNS(svgns, 'rect');
  return setAttr(rect, opts);
};
Line = function Line(opts) {
  var line;
  line = document.createElementNS(svgns, 'line');
  return setAttr(line, opts);
};
Polygon = function Polygon(opts) {
  var line;
  line = document.createElementNS(svgns, 'polygon');
  return setAttr(line, opts);
};
module.exports.rect = Rect;
module.exports.line = Line;
module.exports.polygon = Polygon;
module.exports.base = Base;

/***/ }),

/***/ "./node_modules/msa/lib/utils/tree.js":
/*!********************************************!*\
  !*** ./node_modules/msa/lib/utils/tree.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var SeqCollection, _, tf, treeHelper;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
SeqCollection = __webpack_require__(/*! ../model/SeqCollection */ "./node_modules/msa/lib/model/SeqCollection.js");
module.exports = treeHelper = function treeHelper(msa) {
  this.msa = msa;
  return this;
};
tf = {
  loadTree: function loadTree(cb) {
    return this.msa.g["package"].loadPackages(["msa-tnt", "biojs-io-newick"], cb);
  },
  showTree: function showTree(newickStr) {
    var m, mt, newick, newickObj, nodes, sel, t, treeDiv;
    newick = this.require("biojs-io-newick");
    if (typeof newickStr === "string") {
      newickObj = newick.parse_newick(newickStr);
    } else {
      newickObj = newickStr;
    }
    mt = this.require("msa-tnt");
    sel = new mt.selections();
    treeDiv = document.createElement("div");
    this.msa.el.insertBefore(treeDiv, this.msa.el.childNodes[0]);
    console.log(this.msa.seqs.models);
    console.log(newickObj);
    nodes = mt.app({
      seqs: this.msa.seqs.toJSON(),
      tree: newickObj
    });
    console.log("nodes", nodes);
    t = new mt.adapters.tree({
      model: nodes,
      el: treeDiv,
      sel: sel
    });
    m = new mt.adapters.msa({
      model: nodes,
      sel: sel,
      msa: this.msa
    });
    _.each(nodes.models, function (e) {
      delete e.collection;
      return Object.setPrototypeOf(e, __webpack_require__(/*! backbone-thin */ "./node_modules/backbone-thin/index.js").Model.prototype);
    });
    this.msa.seqs.reset(nodes.models);
    return console.log(this.msa.seqs);
  },
  require: function (_require) {
    function require(_x) {
      return _require.apply(this, arguments);
    }
    require.toString = function () {
      return _require.toString();
    };
    return require;
  }(function (pkg) {
    return __webpack_require__("./node_modules/msa/lib/utils sync recursive")(pkg);
  })
};
_.extend(treeHelper.prototype, tf);

/***/ }),

/***/ "./node_modules/msa/lib/views/AlignmentBody.js":
/*!*****************************************************!*\
  !*** ./node_modules/msa/lib/views/AlignmentBody.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelBlock, SeqBlock, boneView;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
SeqBlock = __webpack_require__(/*! ./canvas/CanvasSeqBlock */ "./node_modules/msa/lib/views/canvas/CanvasSeqBlock.js");
LabelBlock = __webpack_require__(/*! ./labels/LabelBlock */ "./node_modules/msa/lib/views/labels/LabelBlock.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    var labelblock, seqblock;
    this.g = data.g;
    if (true) {
      labelblock = new LabelBlock({
        model: this.model,
        g: this.g
      });
      labelblock.ordering = -1;
      this.addView("labelblock", labelblock);
    }
    if (this.g.vis.get("sequences")) {
      seqblock = new SeqBlock({
        model: this.model,
        g: this.g
      });
      seqblock.ordering = 0;
      this.addView("seqblock", seqblock);
    }
    this.listenTo(this.g.zoomer, "change:alignmentHeight", this.adjustHeight);
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this.adjustWidth);
    return this.listenTo(this.g.columns, "change:hidden", this.adjustHeight);
  },
  render: function render() {
    this.renderSubviews();
    this.el.className = "biojs_msa_albody";
    this.el.style.whiteSpace = "nowrap";
    this.adjustHeight();
    this.adjustWidth();
    return this;
  },
  adjustHeight: function adjustHeight() {
    if (this.g.zoomer.get("alignmentHeight") === "auto") {
      return this.el.style.height = this.g.zoomer.get("rowHeight") * this.model.length + 5;
    } else {
      return this.el.style.height = this.g.zoomer.get("alignmentHeight");
    }
  },
  adjustWidth: function adjustWidth() {
    return this.el.style.width = this.getWidth();
  },
  getWidth: function getWidth() {
    var width;
    width = 0;
    width += this.g.zoomer.getLeftBlockWidth();
    if (this.g.vis.get("sequences")) {
      width += this.g.zoomer.get("alignmentWidth");
    }
    return width;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/OverviewBox.js":
/*!***************************************************!*\
  !*** ./node_modules/msa/lib/views/OverviewBox.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var OverviewBox, _, jbone, mouse, selection, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
mouse = __webpack_require__(/*! mouse-pos */ "./node_modules/mouse-pos/index.js");
selection = __webpack_require__(/*! ../g/selection/Selection */ "./node_modules/msa/lib/g/selection/Selection.js");
jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = OverviewBox = view.extend({
  className: "biojs_msa_overviewbox",
  tagName: "canvas",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:boxRectWidth change:boxRectHeight change:overviewboxPaddingTop", this.rerender);
    this.listenTo(this.g.selcol, "add reset change", this.rerender);
    this.listenTo(this.g.columns, "change:hidden", this.rerender);
    this.listenTo(this.g.colorscheme, "change:showLowerCase", this.rerender);
    this.listenTo(this.model, "change", _.debounce(this.rerender, 5));
    this.color = this.g.colorscheme.getSelectedScheme();
    this.listenTo(this.g.colorscheme, "change:scheme", function () {
      this.color = this.g.colorscheme.getSelectedScheme();
      return this.rerender();
    });
    return this.dragStart = [];
  },
  events: {
    click: "_onclick",
    mousedown: "_onmousedown"
  },
  rerender: function rerender() {
    if (!this.g.config.get("manualRendering")) {
      return this.render();
    }
  },
  render: function render() {
    var c, color, hidden, i, j, k, l, rectHeight, rectWidth, ref, ref1, seq, showLowerCase, x, y;
    this._createCanvas();
    this.el.textContent = "overview";
    this.el.style.marginTop = this.g.zoomer.get("overviewboxPaddingTop");
    this.ctx.fillStyle = "#999999";
    this.ctx.fillRect(0, 0, this.el.width, this.el.height);
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    hidden = this.g.columns.get("hidden");
    showLowerCase = this.g.colorscheme.get("showLowerCase");
    y = -rectHeight;
    for (i = k = 0, ref = this.model.length - 1; k <= ref; i = k += 1) {
      seq = this.model.at(i).get("seq");
      x = 0;
      y = y + rectHeight;
      if (this.model.at(i).get("hidden")) {
        console.log(this.model.at(i).get("hidden"));
        this.ctx.fillStyle = "grey";
        this.ctx.fillRect(0, y, seq.length * rectWidth, rectHeight);
        continue;
      }
      for (j = l = 0, ref1 = seq.length - 1; l <= ref1; j = l += 1) {
        c = seq[j];
        if (showLowerCase) {
          c = c.toUpperCase();
        }
        color = this.color.getColor(c, {
          pos: j
        });
        if (hidden.indexOf(j) >= 0) {
          color = "grey";
        }
        if (color != null) {
          this.ctx.fillStyle = color;
          this.ctx.fillRect(x, y, rectWidth, rectHeight);
        }
        x = x + rectWidth;
      }
    }
    return this._drawSelection();
  },
  _drawSelection: function _drawSelection() {
    var i, k, maxHeight, pos, rectHeight, rectWidth, ref, sel, seq;
    if (this.dragStart.length > 0 && !this.prolongSelection) {
      return;
    }
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    maxHeight = rectHeight * this.model.length;
    this.ctx.fillStyle = "#ffff00";
    this.ctx.globalAlpha = 0.9;
    for (i = k = 0, ref = this.g.selcol.length - 1; k <= ref; i = k += 1) {
      sel = this.g.selcol.at(i);
      if (sel.get('type') === 'column') {
        this.ctx.fillRect(rectWidth * sel.get('xStart'), 0, rectWidth * (sel.get('xEnd') - sel.get('xStart') + 1), maxHeight);
      } else if (sel.get('type') === 'row') {
        seq = this.model.filter(function (el) {
          return el.get('id') === sel.get('seqId');
        })[0];
        pos = this.model.indexOf(seq);
        this.ctx.fillRect(0, rectHeight * pos, rectWidth * seq.get('seq').length, rectHeight);
      } else if (sel.get('type') === 'pos') {
        seq = this.model.filter(function (el) {
          return el.get('id') === sel.get('seqId');
        })[0];
        pos = this.model.indexOf(seq);
        this.ctx.fillRect(rectWidth * sel.get('xStart'), rectHeight * pos, rectWidth * (sel.get('xEnd') - sel.get('xStart') + 1), rectHeight);
      }
    }
    return this.ctx.globalAlpha = 1;
  },
  _onclick: function _onclick(evt) {
    return this.g.trigger("meta:click", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmousemove: function _onmousemove(e) {
    var rect;
    if (this.dragStart.length === 0) {
      return;
    }
    this.render();
    this.ctx.fillStyle = "#ffff00";
    this.ctx.globalAlpha = 0.9;
    rect = this._calcSelection(mouse.abs(e));
    this.ctx.fillRect(rect[0][0], rect[1][0], rect[0][1] - rect[0][0], rect[1][1] - rect[1][0]);
    e.preventDefault();
    return e.stopPropagation();
  },
  _onmousedown: function _onmousedown(e) {
    this.dragStart = mouse.abs(e);
    this.dragStartRel = mouse.rel(e);
    if (e.ctrlKey || e.metaKey) {
      this.prolongSelection = true;
    } else {
      this.prolongSelection = false;
    }
    jbone(document.body).on('mousemove.overmove', function (_this) {
      return function (e) {
        return _this._onmousemove(e);
      };
    }(this));
    jbone(document.body).on('mouseup.overup', function (_this) {
      return function (e) {
        return _this._onmouseup(e);
      };
    }(this));
    return this.dragStart;
  },
  _calcSelection: function _calcSelection(dragMove) {
    var dragRel, i, k, l, rect;
    dragRel = [dragMove[0] - this.dragStart[0], dragMove[1] - this.dragStart[1]];
    for (i = k = 0; k <= 1; i = k += 1) {
      dragRel[i] = this.dragStartRel[i] + dragRel[i];
    }
    rect = [[this.dragStartRel[0], dragRel[0]], [this.dragStartRel[1], dragRel[1]]];
    for (i = l = 0; l <= 1; i = l += 1) {
      if (rect[i][1] < rect[i][0]) {
        rect[i] = [rect[i][1], rect[i][0]];
      }
      rect[i][0] = Math.max(rect[i][0], 0);
    }
    return rect;
  },
  _endSelection: function _endSelection(dragEnd) {
    var args, i, j, k, l, m, rect, ref, ref1, selis;
    jbone(document.body).off('.overmove');
    jbone(document.body).off('.overup');
    if (this.dragStart.length === 0) {
      return;
    }
    rect = this._calcSelection(dragEnd);
    for (i = k = 0; k <= 1; i = ++k) {
      rect[0][i] = Math.floor(rect[0][i] / this.g.zoomer.get("boxRectWidth"));
    }
    for (i = l = 0; l <= 1; i = ++l) {
      rect[1][i] = Math.floor(rect[1][i] / this.g.zoomer.get("boxRectHeight"));
    }
    rect[0][1] = Math.min(this.model.getMaxLength() - 1, rect[0][1]);
    rect[1][1] = Math.min(this.model.length - 1, rect[1][1]);
    selis = [];
    for (j = m = ref = rect[1][0], ref1 = rect[1][1]; m <= ref1; j = m += 1) {
      args = {
        seqId: this.model.at(j).get('id'),
        xStart: rect[0][0],
        xEnd: rect[0][1]
      };
      selis.push(new selection.possel(args));
    }
    this.dragStart = [];
    if (this.prolongSelection) {
      this.g.selcol.add(selis);
    } else {
      this.g.selcol.reset(selis);
    }
    this.g.zoomer.setLeftOffset(rect[0][0]);
    return this.g.zoomer.setTopOffset(rect[1][0]);
  },
  _onmouseup: function _onmouseup(e) {
    return this._endSelection(mouse.abs(e));
  },
  _onmouseout: function _onmouseout(e) {
    return this._endSelection(mouse.abs(e));
  },
  _createCanvas: function _createCanvas() {
    var rectHeight, rectWidth;
    rectWidth = this.g.zoomer.get("boxRectWidth");
    rectHeight = this.g.zoomer.get("boxRectHeight");
    this.el.height = this.model.length * rectHeight;
    this.el.width = this.model.getMaxLength() * rectWidth;
    this.ctx = this.el.getContext("2d");
    this.el.style.overflow = "scroll";
    return this.el.style.cursor = "crosshair";
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/Search.js":
/*!**********************************************!*\
  !*** ./node_modules/msa/lib/views/Search.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var _, boneView, dom, k, sel;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
k = __webpack_require__(/*! koala-js */ "./node_modules/koala-js/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
sel = __webpack_require__(/*! ../g/selection/Selection */ "./node_modules/msa/lib/g/selection/Selection.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.user, "change:searchText", function (model, prop) {
      this.search(prop);
      return this.render();
    });
    this.sel = [];
    return this.selPos = 0;
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  render: function render() {
    var searchText;
    this.renderSubviews();
    this.el.className = "biojs_msa_searchresult";
    searchText = this.g.user.get("searchText");
    if (searchText != null && searchText.length > 0) {
      if (this.sel.length === 0) {
        this.el.textContent = "no selection found";
      } else {
        this.resultBox = k.mk("div");
        this.resultBox.className = "biojs_msa_searchresult_ovbox";
        this.updateResult();
        this.el.appendChild(this.resultBox);
        this.el.appendChild(this.buildBtns());
      }
    }
    return this;
  },
  updateResult: function updateResult() {
    var seli, text;
    text = "search pattern: " + this.g.user.get("searchText");
    text += ", selection: " + (this.selPos + 1);
    seli = this.sel[this.selPos];
    text += " (";
    text += seli.get("xStart") + " - " + seli.get("xEnd");
    text += ", id: " + seli.get("seqId");
    text += ")";
    return this.resultBox.textContent = text;
  },
  buildBtns: function buildBtns() {
    var allBtn, nextBtn, prevBtn, searchrow;
    prevBtn = k.mk("button");
    prevBtn.textContent = "Prev";
    prevBtn.addEventListener("click", function (_this) {
      return function () {
        return _this.moveSel(-1);
      };
    }(this));
    nextBtn = k.mk("button");
    nextBtn.textContent = "Next";
    nextBtn.addEventListener("click", function (_this) {
      return function () {
        return _this.moveSel(1);
      };
    }(this));
    allBtn = k.mk("button");
    allBtn.textContent = "All";
    allBtn.addEventListener("click", function (_this) {
      return function () {
        return _this.g.selcol.reset(_this.sel);
      };
    }(this));
    searchrow = k.mk("div");
    searchrow.appendChild(prevBtn);
    searchrow.appendChild(nextBtn);
    searchrow.appendChild(allBtn);
    searchrow.className = "biojs_msa_searchresult_row";
    return searchrow;
  },
  moveSel: function moveSel(relDist) {
    var selNew;
    selNew = this.selPos + relDist;
    if (selNew < 0 || selNew >= this.sel.length) {
      return -1;
    } else {
      this.focus(selNew);
      this.selPos = selNew;
      return this.updateResult();
    }
  },
  focus: function focus(selPos) {
    var leftIndex, seli;
    seli = this.sel[selPos];
    leftIndex = seli.get("xStart");
    this.g.zoomer.setLeftOffset(leftIndex);
    return this.g.selcol.reset([seli]);
  },
  search: function search(searchText) {
    var leftestIndex, newSeli, origIndex, search;
    search = new RegExp(searchText, "gi");
    newSeli = [];
    leftestIndex = origIndex = 100042;
    this.model.each(function (seq) {
      var args, index, match, results, strSeq;
      strSeq = seq.get("seq");
      results = [];
      while (match = search.exec(strSeq)) {
        index = match.index;
        args = {
          xStart: index,
          xEnd: index + match[0].length - 1,
          seqId: seq.get("id")
        };
        newSeli.push(new sel.possel(args));
        results.push(leftestIndex = Math.min(index, leftestIndex));
      }
      return results;
    });
    this.g.selcol.reset(newSeli);
    if (leftestIndex === origIndex) {
      leftestIndex = 0;
    }
    this.g.zoomer.setLeftOffset(leftestIndex);
    return this.sel = newSeli;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/Stage.js":
/*!*********************************************!*\
  !*** ./node_modules/msa/lib/views/Stage.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var AlignmentBody, HeaderBlock, OverviewBox, Search, _, boneView;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
AlignmentBody = __webpack_require__(/*! ./AlignmentBody */ "./node_modules/msa/lib/views/AlignmentBody.js");
HeaderBlock = __webpack_require__(/*! ./header/HeaderBlock */ "./node_modules/msa/lib/views/header/HeaderBlock.js");
OverviewBox = __webpack_require__(/*! ./OverviewBox */ "./node_modules/msa/lib/views/OverviewBox.js");
Search = __webpack_require__(/*! ./Search */ "./node_modules/msa/lib/views/Search.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.stats, "reset", function () {
      return this.rerender();
    });
    this.listenTo(this.model, "change:hidden", _.debounce(this.rerender, 10));
    this.listenTo(this.model, "sort", this.rerender);
    this.listenTo(this.model, "add", function () {
      return console.log("seq add");
    });
    this.listenTo(this.g.vis, "change:sequences", this.rerender);
    this.listenTo(this.g.vis, "change:overviewbox", this.rerender);
    return this.listenTo(this.g.visorder, "change", this.rerender);
  },
  draw: function draw() {
    var body, headerblock, overviewbox, searchblock;
    this.removeViews();
    if (this.g.vis.get("overviewbox")) {
      overviewbox = new OverviewBox({
        model: this.model,
        g: this.g
      });
      overviewbox.ordering = this.g.visorder.get('overviewBox');
      this.addView("overviewBox", overviewbox);
    }
    if (true) {
      headerblock = new HeaderBlock({
        model: this.model,
        g: this.g
      });
      headerblock.ordering = this.g.visorder.get('headerBox');
      this.addView("headerBox", headerblock);
    }
    if (true) {
      searchblock = new Search({
        model: this.model,
        g: this.g
      });
      searchblock.ordering = this.g.visorder.get('searchBox');
      this.addView("searchbox", searchblock);
    }
    body = new AlignmentBody({
      model: this.model,
      g: this.g
    });
    body.ordering = this.g.visorder.get('alignmentBody');
    return this.addView("body", body);
  },
  render: function render() {
    this.renderSubviews();
    this.el.className = "biojs_msa_stage";
    return this;
  },
  rerender: function rerender() {
    if (!this.g.config.get("manualRendering")) {
      this.draw();
      return this.render();
    }
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/canvas/CanvasCharCache.js":
/*!**************************************************************!*\
  !*** ./node_modules/msa/lib/views/canvas/CanvasCharCache.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var CanvasCharCache, Events;
Events = __webpack_require__(/*! biojs-events */ "./node_modules/biojs-events/index.js");
module.exports = CanvasCharCache = function () {
  function CanvasCharCache(g) {
    this.g = g;
    this.cache = {};
    this.cacheHeight = 0;
    this.cacheWidth = 0;
  }
  CanvasCharCache.prototype.getFontTile = function (letter, width, height) {
    if (width !== this.cacheWidth || height !== this.cacheHeight) {
      this.cacheHeight = height;
      this.cacheWidth = width;
      this.cache = {};
    }
    if (this.cache[letter] === void 0) {
      this.createTile(letter, width, height);
    }
    return this.cache[letter];
  };
  CanvasCharCache.prototype.createTile = function (letter, width, height) {
    var canvas;
    canvas = this.cache[letter] = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    this.ctx = canvas.getContext('2d');
    this.ctx.font = this.g.zoomer.get("residueFont") + "px mono";
    this.ctx.textBaseline = 'middle';
    this.ctx.textAlign = "center";
    return this.ctx.fillText(letter, width / 2, height / 2, width);
  };
  return CanvasCharCache;
}();

/***/ }),

/***/ "./node_modules/msa/lib/views/canvas/CanvasCoordsCache.js":
/*!****************************************************************!*\
  !*** ./node_modules/msa/lib/views/canvas/CanvasCoordsCache.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var Events, _, cache, cacheConstructor;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
Events = __webpack_require__(/*! biojs-events */ "./node_modules/biojs-events/index.js");
cache = {
  setMaxScrollHeight: function setMaxScrollHeight() {
    return this.maxScrollHeight = this.g.zoomer.getMaxAlignmentHeight() - this.g.zoomer.get('alignmentHeight');
  },
  setMaxScrollWidth: function setMaxScrollWidth() {
    return this.maxScrollWidth = this.g.zoomer.getMaxAlignmentWidth() - this.g.zoomer.getAlignmentWidth();
  }
};
module.exports = cacheConstructor = function cacheConstructor(g, model) {
  this.g = g;
  this.model = model;
  this.maxScrollWidth = 0;
  this.maxScrollHeight = 0;
  this.setMaxScrollHeight();
  this.setMaxScrollWidth();
  this.listenTo(this.g.zoomer, "change:rowHeight", this.setMaxScrollHeight);
  this.listenTo(this.g.zoomer, "change:columnWidth", this.setMaxScrollWidth);
  this.listenTo(this.g.zoomer, "change:alignmentWidth", this.setMaxScrollWidth);
  this.listenTo(this.g.zoomer, "change:alignmentHeight", this.setMaxScrollHeight);
  this.listenTo(this.model, "add change reset", function () {
    this.setMaxScrollHeight();
    return this.setMaxScrollWidth();
  }, this);
  return this;
};
_.extend(cacheConstructor.prototype, cache);
Events.mixin(cacheConstructor.prototype);

/***/ }),

/***/ "./node_modules/msa/lib/views/canvas/CanvasSelection.js":
/*!**************************************************************!*\
  !*** ./node_modules/msa/lib/views/canvas/CanvasSelection.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var SelectionClass, _;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
module.exports = SelectionClass = function SelectionClass(g, ctx) {
  this.g = g;
  this.ctx = ctx;
  return this;
};
_.extend(SelectionClass.prototype, {
  _getSelection: function _getSelection(model) {
    var j, l, len, m, maxLen, n, ref, ref1, ref2, rows, sel, selection, sels;
    maxLen = model.get("seq").length;
    selection = [];
    sels = this.g.selcol.getSelForRow(model.get("id"));
    rows = _.find(sels, function (el) {
      return el.get("type") === "row";
    });
    if (rows != null) {
      for (n = j = 0, ref = maxLen - 1; j <= ref; n = j += 1) {
        selection.push(n);
      }
    } else if (sels.length > 0) {
      for (l = 0, len = sels.length; l < len; l++) {
        sel = sels[l];
        for (n = m = ref1 = sel.get("xStart"), ref2 = sel.get("xEnd"); m <= ref2; n = m += 1) {
          selection.push(n);
        }
      }
    }
    return selection;
  },
  _appendSelection: function _appendSelection(data) {
    var boxHeight, boxWidth, hiddenOffset, j, k, mNextSel, mPrevSel, n, ref, ref1, results, selection, seq;
    seq = data.model.get("seq");
    selection = this._getSelection(data.model);
    ref = this._getPrevNextSelection(data.model), mPrevSel = ref[0], mNextSel = ref[1];
    boxWidth = this.g.zoomer.get("columnWidth");
    boxHeight = this.g.zoomer.get("rowHeight");
    if (selection.length === 0) {
      return;
    }
    hiddenOffset = 0;
    results = [];
    for (n = j = 0, ref1 = seq.length - 1; j <= ref1; n = j += 1) {
      if (data.hidden.indexOf(n) >= 0) {
        results.push(hiddenOffset++);
      } else {
        k = n - hiddenOffset;
        if (selection.indexOf(n) >= 0 && (k === 0 || selection.indexOf(n - 1) < 0)) {
          results.push(this._renderSelection({
            n: n,
            k: k,
            selection: selection,
            mPrevSel: mPrevSel,
            mNextSel: mNextSel,
            xZero: data.xZero,
            yZero: data.yZero,
            model: data.model
          }));
        } else {
          results.push(void 0);
        }
      }
    }
    return results;
  },
  _renderSelection: function _renderSelection(data) {
    var beforeStyle, beforeWidth, boxHeight, boxWidth, hidden, i, j, k, l, mNextSel, mPrevSel, n, ref, ref1, ref2, selection, selectionLength, totalWidth, xPart, xPos, xZero, yZero;
    xZero = data.xZero;
    yZero = data.yZero;
    n = data.n;
    k = data.k;
    selection = data.selection;
    mPrevSel = data.mPrevSel;
    mNextSel = data.mNextSel;
    selectionLength = 0;
    for (i = j = ref = n, ref1 = data.model.get("seq").length - 1; j <= ref1; i = j += 1) {
      if (selection.indexOf(i) >= 0) {
        selectionLength++;
      } else {
        break;
      }
    }
    boxWidth = this.g.zoomer.get("columnWidth");
    boxHeight = this.g.zoomer.get("rowHeight");
    totalWidth = boxWidth * selectionLength + 1;
    hidden = this.g.columns.get('hidden');
    this.ctx.beginPath();
    beforeWidth = this.ctx.lineWidth;
    this.ctx.lineWidth = 3;
    beforeStyle = this.ctx.strokeStyle;
    this.ctx.strokeStyle = "#FF0000";
    xZero += k * boxWidth;
    xPart = 0;
    for (i = l = 0, ref2 = selectionLength - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; i = 0 <= ref2 ? ++l : --l) {
      xPos = n + i;
      if (hidden.indexOf(xPos) >= 0) {
        continue;
      }
      if (!(mPrevSel != null && mPrevSel.indexOf(xPos) >= 0)) {
        this.ctx.moveTo(xZero + xPart, yZero);
        this.ctx.lineTo(xPart + boxWidth + xZero, yZero);
      }
      if (!(mNextSel != null && mNextSel.indexOf(xPos) >= 0)) {
        this.ctx.moveTo(xPart + xZero, boxHeight + yZero);
        this.ctx.lineTo(xPart + boxWidth + xZero, boxHeight + yZero);
      }
      xPart += boxWidth;
    }
    this.ctx.moveTo(xZero, yZero);
    this.ctx.lineTo(xZero, boxHeight + yZero);
    this.ctx.moveTo(xZero + totalWidth, yZero);
    this.ctx.lineTo(xZero + totalWidth, boxHeight + yZero);
    this.ctx.stroke();
    this.ctx.strokeStyle = beforeStyle;
    return this.ctx.lineWidth = beforeWidth;
  },
  _getPrevNextSelection: function _getPrevNextSelection(model) {
    var mNextSel, mPrevSel, modelNext, modelPrev;
    modelPrev = model.collection.prev(model);
    modelNext = model.collection.next(model);
    if (modelPrev != null) {
      mPrevSel = this._getSelection(modelPrev);
    }
    if (modelNext != null) {
      mNextSel = this._getSelection(modelNext);
    }
    return [mPrevSel, mNextSel];
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/canvas/CanvasSeqBlock.js":
/*!*************************************************************!*\
  !*** ./node_modules/msa/lib/views/canvas/CanvasSeqBlock.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var CanvasCoordsCache, CanvasSeqDrawer, CharCache, SelectionClass, _, boneView, jbone, mouse;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
mouse = __webpack_require__(/*! mouse-pos */ "./node_modules/mouse-pos/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
CharCache = __webpack_require__(/*! ./CanvasCharCache */ "./node_modules/msa/lib/views/canvas/CanvasCharCache.js");
SelectionClass = __webpack_require__(/*! ./CanvasSelection */ "./node_modules/msa/lib/views/canvas/CanvasSelection.js");
CanvasSeqDrawer = __webpack_require__(/*! ./CanvasSeqDrawer */ "./node_modules/msa/lib/views/canvas/CanvasSeqDrawer.js");
CanvasCoordsCache = __webpack_require__(/*! ./CanvasCoordsCache */ "./node_modules/msa/lib/views/canvas/CanvasCoordsCache.js");
module.exports = boneView.extend({
  tagName: "canvas",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:_alignmentScrollLeft change:_alignmentScrollTop", function (model, value, options) {
      if ((options != null ? options.origin : void 0) == null || options.origin !== "canvasseq") {
        return this.render();
      }
    });
    this.listenTo(this.g.columns, "change:hidden", this.render);
    this.listenTo(this.g.zoomer, "change:alignmentWidth change:alignmentHeight", this.render);
    this.listenTo(this.g.colorscheme, "change", this.render);
    this.listenTo(this.g.selcol, "reset add", this.render);
    this.el.style.display = "inline-block";
    this.el.style.overflowX = "hidden";
    this.el.style.overflowY = "hidden";
    this.el.className = "biojs_msa_seqblock";
    this.ctx = this.el.getContext('2d');
    this.cache = new CharCache(this.g);
    this.coordsCache = new CanvasCoordsCache(this.g, this.model);
    this.listenTo(this.g.zoomer, "change:residueFont", function () {
      this.cache = new CharCache(this.g);
      return this.render();
    });
    this.sel = new SelectionClass(this.g, this.ctx);
    this._setColor();
    this.throttleTime = 0;
    this.throttleCounts = 0;
    if (document.documentElement.style.webkitAppearance != null) {
      this.throttledDraw = function () {
        var start, tTime;
        start = +new Date();
        this.draw();
        this.throttleTime += +new Date() - start;
        this.throttleCounts++;
        if (this.throttleCounts > 15) {
          tTime = Math.ceil(this.throttleTime / this.throttleCounts);
          console.log("avgDrawTime/WebKit", tTime);
          return this.throttledDraw = this.draw;
        }
      };
    } else {
      this.throttledDraw = _.throttle(this.throttledDraw, 30);
    }
    return this.manageEvents();
  },
  throttledDraw: function throttledDraw() {
    var start, tTime;
    start = +new Date();
    this.draw();
    this.throttleTime += +new Date() - start;
    this.throttleCounts++;
    if (this.throttleCounts > 15) {
      tTime = Math.ceil(this.throttleTime / this.throttleCounts);
      console.log("avgDrawTime", tTime);
      tTime *= 1.2;
      tTime = Math.max(20, tTime);
      return this.throttledDraw = _.throttle(this.draw, tTime);
    }
  },
  manageEvents: function manageEvents() {
    var events;
    events = {};
    events.mousedown = "_onmousedown";
    events.touchstart = "_ontouchstart";
    if (this.g.config.get("registerMouseClicks")) {
      events.dblclick = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    events.mousewheel = "_onmousewheel";
    events.DOMMouseScroll = "_onmousewheel";
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
    return this.dragStart = [];
  },
  _setColor: function _setColor() {
    return this.color = this.g.colorscheme.getSelectedScheme();
  },
  draw: function draw() {
    this.el.width = this.el.width;
    if (this.seqDrawer != null && this.model.length > 0) {
      this.seqDrawer.drawLetters();
      this.seqDrawer.drawRows(this.sel._appendSelection, this.sel);
      return this.seqDrawer.drawRows(this.drawFeatures, this);
    }
  },
  drawFeatures: function drawFeatures(data) {
    var ctx, rectHeight, rectWidth;
    rectWidth = this.g.zoomer.get("columnWidth");
    rectHeight = this.g.zoomer.get("rowHeight");
    if (data.model.attributes.height > 1) {
      ctx = this.ctx;
      data.model.attributes.features.each(function (feature) {
        var len, y;
        ctx.fillStyle = feature.attributes.fillColor || "red";
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillRect(feature.attributes.xStart * rectWidth + data.xZero, y + data.yZero, rectWidth * len, rectHeight);
      });
      ctx.fillStyle = "black";
      ctx.font = this.g.zoomer.get("residueFont") + "px mono";
      ctx.textBaseline = 'middle';
      ctx.textAlign = "center";
      return data.model.attributes.features.each(function (feature) {
        var len, y;
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillText(feature.attributes.text, data.xZero + feature.attributes.xStart * rectWidth + len / 2 * rectWidth, data.yZero + rectHeight * 0.5 + y);
      });
    }
  },
  render: function render() {
    this.el.setAttribute('height', this.g.zoomer.get("alignmentHeight") + "px");
    this.el.setAttribute('width', this.g.zoomer.getAlignmentWidth() + "px");
    this.g.zoomer._checkScrolling(this._checkScrolling([this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')]), {
      header: "canvasseq"
    });
    this._setColor();
    this.seqDrawer = new CanvasSeqDrawer(this.g, this.ctx, this.model, {
      width: this.el.width,
      height: this.el.height,
      color: this.color,
      cache: this.cache
    });
    this.throttledDraw();
    return this;
  },
  _onmousemove: function _onmousemove(e, reversed) {
    var dragEnd, i, j, k, l, relDist, relEnd, scaleFactor, scrollCorrected;
    if (this.dragStart.length === 0) {
      return;
    }
    dragEnd = mouse.abs(e);
    relEnd = [dragEnd[0] - this.dragStart[0], dragEnd[1] - this.dragStart[1]];
    scaleFactor = this.g.zoomer.get("canvasEventScale");
    if (reversed) {
      scaleFactor = 3;
    }
    for (i = j = 0; j <= 1; i = j += 1) {
      relEnd[i] = relEnd[i] * scaleFactor;
    }
    relDist = [this.dragStartScroll[0] - relEnd[0], this.dragStartScroll[1] - relEnd[1]];
    for (i = k = 0; k <= 1; i = k += 1) {
      relDist[i] = Math.round(relDist[i]);
    }
    scrollCorrected = this._checkScrolling(relDist);
    this.g.zoomer._checkScrolling(scrollCorrected, {
      origin: "canvasseq"
    });
    for (i = l = 0; l <= 1; i = l += 1) {
      if (scrollCorrected[i] !== relDist[i]) {
        if (scrollCorrected[i] === 0) {
          this.dragStart[i] = dragEnd[i];
          this.dragStartScroll[i] = 0;
        } else {
          this.dragStart[i] = dragEnd[i] - scrollCorrected[i];
        }
      }
    }
    this.throttledDraw();
    if (e.preventDefault != null) {
      e.preventDefault();
      return e.stopPropagation();
    }
  },
  _ontouchmove: function _ontouchmove(e) {
    this._onmousemove(e.changedTouches[0], true);
    e.preventDefault();
    return e.stopPropagation();
  },
  _onmousedown: function _onmousedown(e) {
    this.dragStart = mouse.abs(e);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('mousemove.overmove', function (_this) {
      return function (e) {
        return _this._onmousemove(e);
      };
    }(this));
    jbone(document.body).on('mouseup.overup', function (_this) {
      return function () {
        return _this._cleanup();
      };
    }(this));
    return e.preventDefault();
  },
  _ontouchstart: function _ontouchstart(e) {
    this.dragStart = mouse.abs(e.changedTouches[0]);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('touchmove.overtmove', function (_this) {
      return function (e) {
        return _this._ontouchmove(e);
      };
    }(this));
    return jbone(document.body).on('touchend.overtend touchleave.overtleave touchcancel.overtcanel', function (_this) {
      return function (e) {
        return _this._touchCleanup(e);
      };
    }(this));
  },
  _onmousewinout: function _onmousewinout(e) {
    if (e.toElement === document.body.parentNode) {
      return this._cleanup();
    }
  },
  _cleanup: function _cleanup() {
    this.dragStart = [];
    jbone(document.body).off('.overmove');
    jbone(document.body).off('.overup');
    return jbone(document.body).off('.overout');
  },
  _touchCleanup: function _touchCleanup(e) {
    if (e.changedTouches.length > 0) {
      this._onmousemove(e.changedTouches[0], true);
    }
    this.dragStart = [];
    jbone(document.body).off('.overtmove');
    jbone(document.body).off('.overtend');
    jbone(document.body).off('.overtleave');
    return jbone(document.body).off('.overtcancel');
  },
  _onmousewheel: function _onmousewheel(e) {
    var delta;
    delta = mouse.wheelDelta(e);
    this.g.zoomer.set('_alignmentScrollLeft', this.g.zoomer.get('_alignmentScrollLeft') + delta[0]);
    this.g.zoomer.set('_alignmentScrollTop', this.g.zoomer.get('_alignmentScrollTop') + delta[1]);
    return e.preventDefault();
  },
  _onclick: function _onclick(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:click", res);
      } else {
        this.g.trigger("residue:click", res);
      }
    }
    return this.throttledDraw();
  },
  _onmousein: function _onmousein(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mousein", res);
      } else {
        this.g.trigger("residue:mousein", res);
      }
    }
    return this.throttledDraw();
  },
  _onmouseout: function _onmouseout(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mouseout", res);
      } else {
        this.g.trigger("residue:mouseout", res);
      }
    }
    return this.throttledDraw();
  },
  _getClickPos: function _getClickPos(e) {
    var coords, feature, features, ref, rowNumber, seqId, x, y;
    coords = mouse.rel(e);
    coords[0] += this.g.zoomer.get("_alignmentScrollLeft");
    x = Math.floor(coords[0] / this.g.zoomer.get("columnWidth"));
    ref = this.seqDrawer._getSeqForYClick(coords[1]), y = ref[0], rowNumber = ref[1];
    x += this.g.columns.calcHiddenColumns(x);
    y += this.model.calcHiddenSeqs(y);
    x = Math.max(0, x);
    y = Math.max(0, y);
    seqId = this.model.at(y).get("id");
    if (rowNumber > 0) {
      features = this.model.at(y).get("features").getFeatureOnRow(rowNumber - 1, x);
      if (features.length !== 0) {
        feature = features[0];
        console.log(features[0].attributes);
        return {
          seqId: seqId,
          feature: feature,
          rowPos: x,
          evt: e
        };
      }
    } else {
      return {
        seqId: seqId,
        rowPos: x,
        evt: e
      };
    }
  },
  _checkScrolling: function _checkScrolling(scrollObj) {
    var i, j, max;
    max = [this.coordsCache.maxScrollWidth, this.coordsCache.maxScrollHeight];
    for (i = j = 0; j <= 1; i = j += 1) {
      if (scrollObj[i] > max[i]) {
        scrollObj[i] = max[i];
      }
      if (scrollObj[i] < 0) {
        scrollObj[i] = 0;
      }
    }
    return scrollObj;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/canvas/CanvasSeqDrawer.js":
/*!**************************************************************!*\
  !*** ./node_modules/msa/lib/views/canvas/CanvasSeqDrawer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var _, construc, drawer;
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
drawer = {
  drawLetters: function drawLetters() {
    var rectHeight;
    rectHeight = this.rectHeight;
    this.ctx.globalAlpha = this.g.colorscheme.get("opacity");
    this.drawSeqs(function (data) {
      return this.drawSeq(data, this._drawRect);
    });
    this.ctx.globalAlpha = 1;
    return this.drawSeqs(function (data) {
      return this.drawSeq(data, this._drawLetter);
    });
  },
  drawSeqs: function drawSeqs(callback, target) {
    var hidden, i, k, ref, ref1, ref2, results, seq, seqHeight, start, y;
    hidden = this.g.columns.get("hidden");
    target = target || this;
    ref = this.getStartSeq(), start = ref[0], y = ref[1];
    results = [];
    for (i = k = ref1 = start, ref2 = this.model.length - 1; k <= ref2; i = k += 1) {
      seq = this.model.at(i);
      if (seq.get('hidden')) {
        continue;
      }
      callback.call(target, {
        model: seq,
        yPos: y,
        y: i,
        hidden: hidden
      });
      seqHeight = (seq.attributes.height || 1) * this.rectHeight;
      y = y + seqHeight;
      if (y > this.height) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  drawRows: function drawRows(callback, target) {
    return this.drawSeqs(function (data) {
      return this.drawRow(data, callback, target);
    });
  },
  drawRow: function drawRow(data, callback, target) {
    var rectWidth, start, x, xZero, yZero;
    rectWidth = this.g.zoomer.get("columnWidth");
    start = Math.max(0, Math.abs(Math.ceil(-this.g.zoomer.get('_alignmentScrollLeft') / rectWidth)));
    x = -Math.abs(-this.g.zoomer.get('_alignmentScrollLeft') % rectWidth);
    xZero = x - start * rectWidth;
    yZero = data.yPos;
    return callback.call(target, {
      model: data.model,
      xZero: xZero,
      yZero: yZero,
      hidden: data.hidden
    });
  },
  getStartSeq: function getStartSeq() {
    var counter, i, start, y;
    start = Math.max(0, Math.floor(this.g.zoomer.get('_alignmentScrollTop') / this.rectHeight)) + 1;
    counter = 0;
    i = 0;
    while (counter < start && i < this.model.length) {
      counter += this.model.at(i).attributes.height || 1;
      i++;
    }
    y = Math.max(0, this.g.zoomer.get('_alignmentScrollTop') - counter * this.rectHeight + (this.model.at(i - 1).attributes.height || 1) * this.rectHeight);
    return [i - 1, -y];
  },
  _getSeqForYClick: function _getSeqForYClick(click) {
    var clickedRows, counter, i, ref, rowNumber, start, yDiff, yRel;
    ref = this.getStartSeq(), start = ref[0], yDiff = ref[1];
    yRel = yDiff % this.rectHeight;
    clickedRows = Math.max(0, Math.floor((click - yRel) / this.rectHeight)) + 1;
    counter = 0;
    i = start;
    while (counter < clickedRows && i < this.model.length) {
      counter += this.model.at(i).attributes.height || 1;
      i++;
    }
    rowNumber = Math.max(0, Math.floor(click / this.rectHeight) - counter + (this.model.at(i - 1).get("height") || 1));
    return [i - 1, rowNumber];
  },
  drawSeq: function drawSeq(data, callback) {
    var c, elWidth, j, k, rectHeight, rectWidth, ref, ref1, res, results, seq, start, x, y;
    seq = data.model.get("seq");
    y = data.yPos;
    rectWidth = this.rectWidth;
    rectHeight = this.rectHeight;
    start = Math.max(0, Math.abs(Math.ceil(-this.g.zoomer.get('_alignmentScrollLeft') / rectWidth)));
    x = -Math.abs(-this.g.zoomer.get('_alignmentScrollLeft') % rectWidth);
    res = {
      rectWidth: rectWidth,
      rectHeight: rectHeight,
      yPos: y,
      y: data.y
    };
    elWidth = this.width;
    results = [];
    for (j = k = ref = start, ref1 = seq.length - 1; k <= ref1; j = k += 1) {
      c = seq[j];
      c = c.toUpperCase();
      res.x = j;
      res.c = c;
      res.xPos = x;
      if (data.hidden.indexOf(j) < 0) {
        callback(this, res);
      } else {
        continue;
      }
      x = x + rectWidth;
      if (x > elWidth) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  },
  _drawRect: function _drawRect(that, data) {
    var color;
    color = that.color.getColor(data.c, {
      pos: data.x,
      y: data.y
    });
    if (color != null) {
      that.ctx.fillStyle = color;
      return that.ctx.fillRect(data.xPos, data.yPos, data.rectWidth, data.rectHeight);
    }
  },
  _drawLetter: function _drawLetter(that, data) {
    return that.ctx.drawImage(that.cache.getFontTile(data.c, data.rectWidth, data.rectHeight), data.xPos, data.yPos, data.rectWidth, data.rectHeight);
  }
};
module.exports = construc = function construc(g, ctx, model, opts) {
  this.g = g;
  this.ctx = ctx;
  this.model = model;
  this.width = opts.width;
  this.height = opts.height;
  this.color = opts.color;
  this.cache = opts.cache;
  this.rectHeight = this.g.zoomer.get("rowHeight");
  this.rectWidth = this.g.zoomer.get("columnWidth");
  return this;
};
_.extend(construc.prototype, drawer);

/***/ }),

/***/ "./node_modules/msa/lib/views/header/ConservationView.js":
/*!***************************************************************!*\
  !*** ./node_modules/msa/lib/views/header/ConservationView.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ConservationView, dom, svg, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
svg = __webpack_require__(/*! ../../utils/svg */ "./node_modules/msa/lib/utils/svg.js");
ConservationView = view.extend({
  className: "biojs_msa_conserv",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    this.listenTo(this.g.columns, "change:scaling", this.render);
    this.listenTo(this.g.stats, "reset", this.render);
    return this.manageEvents();
  },
  render: function render() {
    var avgHeight, cellWidth, conserv, height, hidden, i, j, maxHeight, n, nMax, rect, ref, s, stepSize, width, x;
    conserv = this.g.stats.scale(this.g.stats.conservation());
    dom.removeAllChilds(this.el);
    nMax = this.model.getMaxLength();
    cellWidth = this.g.zoomer.get("columnWidth");
    maxHeight = 20;
    width = cellWidth * (nMax - this.g.columns.get('hidden').length);
    s = svg.base({
      height: maxHeight,
      width: width
    });
    s.style.display = "inline-block";
    s.style.cursor = "pointer";
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    x = 0;
    n = 0;
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        n += stepSize;
        continue;
      }
      width = cellWidth * stepSize;
      avgHeight = 0;
      for (i = j = 0, ref = stepSize - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        avgHeight += conserv[n];
      }
      height = maxHeight * (avgHeight / stepSize);
      rect = svg.rect({
        x: x,
        y: maxHeight - height,
        width: width - cellWidth / 4,
        height: height,
        style: "stroke:red;stroke-width:1;"
      });
      rect.rowPos = n;
      s.appendChild(rect);
      x += width;
      n += stepSize;
    }
    this.el.appendChild(s);
    return this;
  },
  _onclick: function _onclick(evt) {
    var i, j, ref, results, rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    results = [];
    for (i = j = 0, ref = stepSize - 1; j <= ref; i = j += 1) {
      results.push(this.g.trigger("bar:click", {
        rowPos: rowPos + i,
        evt: evt
      }));
    }
    return results;
  },
  manageEvents: function manageEvents() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onmousein: function _onmousein(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("bar:mousein", {
      rowPos: rowPos,
      evt: evt
    });
  },
  _onmouseout: function _onmouseout(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("bar:mouseout", {
      rowPos: rowPos,
      evt: evt
    });
  }
});
module.exports = ConservationView;

/***/ }),

/***/ "./node_modules/msa/lib/views/header/GapView.js":
/*!******************************************************!*\
  !*** ./node_modules/msa/lib/views/header/GapView.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ConservationView, dom, svg, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
svg = __webpack_require__(/*! ../../utils/svg */ "./node_modules/msa/lib/utils/svg.js");
ConservationView = view.extend({
  className: "biojs_msa_gapview",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    this.listenTo(this.g.columns, "change:scaling", this.render);
    this.listenTo(this.model, "reset", this.render);
    return this.manageEvents();
  },
  render: function render() {
    var avgHeight, cellWidth, gaps, height, hidden, i, j, maxHeight, n, nMax, rect, ref, s, stepSize, width, x;
    gaps = this.g.stats.gaps();
    dom.removeAllChilds(this.el);
    nMax = this.model.getMaxLength();
    cellWidth = this.g.zoomer.get("columnWidth");
    maxHeight = 20;
    width = cellWidth * (nMax - this.g.columns.get('hidden').length);
    s = svg.base({
      height: maxHeight,
      width: width
    });
    s.style.display = "inline-block";
    s.style.cursor = "pointer";
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    x = 0;
    n = 0;
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        n += stepSize;
        continue;
      }
      width = cellWidth * stepSize;
      avgHeight = 0;
      for (i = j = 0, ref = stepSize - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        avgHeight += gaps[n];
      }
      height = maxHeight * (avgHeight / stepSize);
      rect = svg.rect({
        x: x,
        y: maxHeight - height,
        width: width - cellWidth / 4,
        height: height,
        style: "stroke:red;stroke-width:1;"
      });
      rect.rowPos = n;
      s.appendChild(rect);
      x += width;
      n += stepSize;
    }
    this.el.appendChild(s);
    return this;
  },
  _onclick: function _onclick(evt) {
    var i, j, ref, results, rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    results = [];
    for (i = j = 0, ref = stepSize - 1; j <= ref; i = j += 1) {
      results.push(this.g.trigger("gap:click", {
        rowPos: rowPos + i,
        evt: evt
      }));
    }
    return results;
  },
  manageEvents: function manageEvents() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onmousein: function _onmousein(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("gap:mousein", {
      rowPos: rowPos,
      evt: evt
    });
  },
  _onmouseout: function _onmouseout(evt) {
    var rowPos;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    return this.g.trigger("gap:mouseout", {
      rowPos: rowPos,
      evt: evt
    });
  }
});
module.exports = ConservationView;

/***/ }),

/***/ "./node_modules/msa/lib/views/header/HeaderBlock.js":
/*!**********************************************************!*\
  !*** ./node_modules/msa/lib/views/header/HeaderBlock.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelHeader, RightLabelHeader, boneView;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
LabelHeader = __webpack_require__(/*! ./LabelHeader */ "./node_modules/msa/lib/views/header/LabelHeader.js");
RightLabelHeader = __webpack_require__(/*! ./RightHeaderBlock */ "./node_modules/msa/lib/views/header/RightHeaderBlock.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.draw();
    return this.listenTo(this.g.vis, "change:labels change:metacell change:leftHeader", function (_this) {
      return function () {
        _this.draw();
        return _this.render();
      };
    }(this));
  },
  draw: function draw() {
    var lHeader, rHeader;
    this.removeViews();
    if (this.g.vis.get("leftHeader") && (this.g.vis.get("labels") || this.g.vis.get("metacell"))) {
      lHeader = new LabelHeader({
        model: this.model,
        g: this.g
      });
      lHeader.ordering = -50;
      this.addView("lHeader", lHeader);
    }
    rHeader = new RightLabelHeader({
      model: this.model,
      g: this.g
    });
    rHeader.ordering = 0;
    return this.addView("rHeader", rHeader);
  },
  render: function render() {
    this.renderSubviews();
    return this.el.className = "biojs_msa_header";
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/header/LabelHeader.js":
/*!**********************************************************!*\
  !*** ./node_modules/msa/lib/views/header/LabelHeader.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelHeader, dom, k, view;
k = __webpack_require__(/*! koala-js */ "./node_modules/koala-js/index.js");
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
module.exports = LabelHeader = view.extend({
  className: "biojs_msa_headers",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.vis, "change:metacell change:labels", this.render);
    return this.listenTo(this.g.zoomer, "change:labelWidth change:metaWidth", this.render);
  },
  render: function render() {
    var width;
    dom.removeAllChilds(this.el);
    width = 0;
    width += this.g.zoomer.getLeftBlockWidth();
    this.el.style.width = width + "px";
    if (this.g.vis.get("labels")) {
      this.el.appendChild(this.labelDOM());
    }
    if (this.g.vis.get("metacell")) {
      this.el.appendChild(this.metaDOM());
    }
    this.el.style.display = "inline-block";
    this.el.style.fontSize = this.g.zoomer.get("markerFontsize");
    return this;
  },
  labelDOM: function labelDOM() {
    var labelHeader, name;
    labelHeader = k.mk("div");
    labelHeader.style.width = this.g.zoomer.getLabelWidth();
    labelHeader.style.display = "inline-block";
    if (this.g.vis.get("labelCheckbox")) {
      labelHeader.appendChild(this.addEl(".", 10));
    }
    if (this.g.vis.get("labelId")) {
      labelHeader.appendChild(this.addEl("id", this.g.zoomer.get("labelIdLength")));
    }
    if (this.g.vis.get("labelPartition")) {
      labelHeader.appendChild(this.addEl("part", 15));
    }
    if (this.g.vis.get("labelName")) {
      name = this.addEl("name");
      labelHeader.appendChild(name);
    }
    return labelHeader;
  },
  addEl: function addEl(content, width) {
    var id;
    id = document.createElement("span");
    id.textContent = content;
    if (width != null) {
      id.style.width = width + "px";
    }
    id.style.display = "inline-block";
    return id;
  },
  metaDOM: function metaDOM() {
    var metaHeader;
    metaHeader = k.mk("div");
    metaHeader.style.width = this.g.zoomer.getMetaWidth();
    metaHeader.style.display = "inline-block";
    if (this.g.vis.get("metaGaps")) {
      metaHeader.appendChild(this.addEl("gaps", this.g.zoomer.get('metaGapWidth')));
    }
    if (this.g.vis.get("metaIdentity")) {
      metaHeader.appendChild(this.addEl("ident", this.g.zoomer.get('metaIdentWidth')));
    }
    if (this.g.vis.get("metaLinks")) {
      metaHeader.appendChild(this.addEl("links"));
    }
    return metaHeader;
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/header/MarkerView.js":
/*!*********************************************************!*\
  !*** ./node_modules/msa/lib/views/header/MarkerView.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var HeaderView, dom, jbone, svg, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
svg = __webpack_require__(/*! ../../utils/svg */ "./node_modules/msa/lib/utils/svg.js");
jbone = __webpack_require__(/*! jbone */ "./node_modules/jbone/dist/jbone.js");
HeaderView = view.extend({
  className: "biojs_msa_marker",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:stepSize change:labelWidth change:columnWidth change:markerStepSize change:markerFontsize", this.render);
    this.listenTo(this.g.vis, "change:labels change:metacell", this.render);
    return this.manageEvents();
  },
  render: function render() {
    var cellWidth, container, hidden, n, nMax, span, stepSize;
    dom.removeAllChilds(this.el);
    this.el.style.fontSize = this.g.zoomer.get("markerFontsize");
    container = document.createElement("span");
    n = 0;
    cellWidth = this.g.zoomer.get("columnWidth");
    nMax = this.model.getMaxLength();
    stepSize = this.g.zoomer.get("stepSize");
    hidden = this.g.columns.get("hidden");
    while (n < nMax) {
      if (hidden.indexOf(n) >= 0) {
        this.markerHidden(span, n, stepSize);
        n += stepSize;
        continue;
      }
      span = document.createElement("span");
      span.style.width = cellWidth * stepSize + "px";
      span.style.display = "inline-block";
      if ((n + 1) % this.g.zoomer.get('markerStepSize') === 0) {
        span.textContent = n + 1;
      } else {
        span.textContent = ".";
      }
      span.rowPos = n;
      n += stepSize;
      container.appendChild(span);
    }
    this.el.appendChild(container);
    return this;
  },
  markerHidden: function markerHidden(span, n, stepSize) {
    var hidden, i, index, j, k, length, min, nMax, prevHidden, ref, ref1, ref2, ref3, s, triangle;
    hidden = this.g.columns.get("hidden").slice(0);
    min = Math.max(0, n - stepSize);
    prevHidden = true;
    for (j = i = ref = min, ref1 = n; i <= ref1; j = i += 1) {
      prevHidden &= hidden.indexOf(j) >= 0;
    }
    if (prevHidden) {
      return;
    }
    nMax = this.model.getMaxLength();
    length = 0;
    index = -1;
    for (n = k = ref2 = n, ref3 = nMax; k <= ref3; n = k += 1) {
      if (!(index >= 0)) {
        index = hidden.indexOf(n);
      }
      if (hidden.indexOf(n) >= 0) {
        length++;
      } else {
        break;
      }
    }
    s = svg.base({
      height: 10,
      width: 10
    });
    s.style.position = "relative";
    triangle = svg.polygon({
      points: "0,0 5,5 10,0",
      style: "fill:lime;stroke:purple;stroke-width:1"
    });
    jbone(triangle).on("click", function (_this) {
      return function (evt) {
        hidden.splice(index, length);
        return _this.g.columns.set("hidden", hidden);
      };
    }(this));
    s.appendChild(triangle);
    span.appendChild(s);
    return s;
  },
  manageEvents: function manageEvents() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    return this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
  },
  _onclick: function _onclick(evt) {
    var rowPos, stepSize;
    rowPos = evt.target.rowPos;
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:click", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  },
  _onmousein: function _onmousein(evt) {
    var rowPos, stepSize;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:mousein", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  },
  _onmouseout: function _onmouseout(evt) {
    var rowPos, stepSize;
    rowPos = this.g.zoomer.get("stepSize" * evt.rowPos);
    stepSize = this.g.zoomer.get("stepSize");
    return this.g.trigger("column:mouseout", {
      rowPos: rowPos,
      stepSize: stepSize,
      evt: evt
    });
  }
});
module.exports = HeaderView;

/***/ }),

/***/ "./node_modules/msa/lib/views/header/RightHeaderBlock.js":
/*!***************************************************************!*\
  !*** ./node_modules/msa/lib/views/header/RightHeaderBlock.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var ConservationView, GapView, MarkerView, SeqLogoWrapper, _, boneView;
MarkerView = __webpack_require__(/*! ./MarkerView */ "./node_modules/msa/lib/views/header/MarkerView.js");
ConservationView = __webpack_require__(/*! ./ConservationView */ "./node_modules/msa/lib/views/header/ConservationView.js");
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
SeqLogoWrapper = __webpack_require__(/*! ./SeqLogoWrapper */ "./node_modules/msa/lib/views/header/SeqLogoWrapper.js");
GapView = __webpack_require__(/*! ./GapView */ "./node_modules/msa/lib/views/header/GapView.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.blockEvents = false;
    this.listenTo(this.g.vis, "change:header", function () {
      this.draw();
      return this.render();
    });
    this.listenTo(this.g.vis, "change", this._setSpacer);
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this._setWidth);
    this.listenTo(this.g.zoomer, "change:_alignmentScrollLeft", this._adjustScrollingLeft);
    this.listenTo(this.g.columns, "change:hidden", function () {
      this.draw();
      return this.render();
    });
    this.draw();
    return this.g.vis.once('change:loaded', this._adjustScrollingLeft, this);
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  draw: function draw() {
    var conserv, gapview, marker, seqlogo;
    this.removeViews();
    if (this.g.vis.get("conserv")) {
      conserv = new ConservationView({
        model: this.model,
        g: this.g
      });
      conserv.ordering = -20;
      this.addView("conserv", conserv);
    }
    if (this.g.vis.get("markers")) {
      marker = new MarkerView({
        model: this.model,
        g: this.g
      });
      marker.ordering = -10;
      this.addView("marker", marker);
    }
    if (this.g.vis.get("seqlogo")) {
      seqlogo = new SeqLogoWrapper({
        model: this.model,
        g: this.g
      });
      seqlogo.ordering = -30;
      this.addView("seqlogo", seqlogo);
    }
    if (this.g.vis.get("gapHeader")) {
      gapview = new GapView({
        model: this.model,
        g: this.g
      });
      gapview.ordering = -25;
      return this.addView("gapview", gapview);
    }
  },
  render: function render() {
    this.renderSubviews();
    this._setSpacer();
    this.el.className = "biojs_msa_rheader";
    this.el.style.overflowX = "auto";
    this.el.style.display = "inline-block";
    this._setWidth();
    this._adjustScrollingLeft();
    return this;
  },
  _sendScrollEvent: function _sendScrollEvent() {
    if (!this.blockEvents) {
      this.g.zoomer.set("_alignmentScrollLeft", this.el.scrollLeft, {
        origin: "header"
      });
    }
    return this.blockEvents = false;
  },
  _adjustScrollingLeft: function _adjustScrollingLeft(model, value, options) {
    var scrollLeft;
    if ((options != null ? options.origin : void 0) == null || options.origin !== "header") {
      scrollLeft = this.g.zoomer.get("_alignmentScrollLeft");
      this.blockEvents = true;
      return this.el.scrollLeft = scrollLeft;
    }
  },
  _setSpacer: function _setSpacer() {
    return this.el.style.marginLeft = this._getLabelWidth() + "px";
  },
  _getLabelWidth: function _getLabelWidth() {
    var paddingLeft;
    paddingLeft = 0;
    if (!this.g.vis.get("leftHeader")) {
      paddingLeft += this.g.zoomer.getLeftBlockWidth();
    }
    return paddingLeft;
  },
  _setWidth: function _setWidth() {
    return this.el.style.width = this.g.zoomer.getAlignmentWidth() + "px";
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/header/SeqLogoWrapper.js":
/*!*************************************************************!*\
  !*** ./node_modules/msa/lib/views/header/SeqLogoWrapper.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var SeqLogoView, view;
SeqLogoView = __webpack_require__(/*! biojs-vis-seqlogo/light */ "./node_modules/biojs-vis-seqlogo/light.js");
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
module.exports = view.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:alignmentWidth", this.render);
    this.listenTo(this.g.colorscheme, "change", function () {
      var colors;
      colors = this.g.colorscheme.getSelectedScheme();
      this.seqlogo.changeColors(colors);
      return this.render();
    });
    this.listenTo(this.g.zoomer, "change:columnWidth", function () {
      return this.seqlogo.column_width = this.g.zoomer.get('columnWidth');
    });
    this.render;
    return this.draw();
  },
  draw: function draw() {
    var arr, colors, data;
    console.log("redraw");
    arr = this.g.stats.conservResidue({
      scaled: true
    });
    arr = _.map(arr, function (el) {
      return _.pick(el, function (e, k) {
        return k !== "-";
      });
    });
    data = {
      alphabet: "aa",
      heightArr: arr
    };
    colors = this.g.colorscheme.getSelectedScheme();
    return this.seqlogo = new SeqLogoView({
      model: this.model,
      g: this.g,
      data: data,
      yaxis: false,
      scroller: false,
      xaxis: false,
      height: 100,
      column_width: this.g.zoomer.get('columnWidth'),
      positionMarker: false,
      zoom: 1,
      el: this.el,
      colors: colors
    });
  },
  render: function render() {
    return this.seqlogo.render();
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/labels/LabelBlock.js":
/*!*********************************************************!*\
  !*** ./node_modules/msa/lib/views/labels/LabelBlock.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelRowView, boneView;
LabelRowView = __webpack_require__(/*! ./LabelRowView */ "./node_modules/msa/lib/views/labels/LabelRowView.js");
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.zoomer, "change:_alignmentScrollTop", this._adjustScrollingTop);
    this.g.vis.once('change:loaded', this._adjustScrollingTop, this);
    this.listenTo(this.g.zoomer, "change:alignmentHeight", this._setHeight);
    return this.listenTo(this.model, "change:reference", this.draw);
  },
  draw: function draw() {
    var i, j, ref, results, view;
    this.removeViews();
    results = [];
    for (i = j = 0, ref = this.model.length - 1; j <= ref; i = j += 1) {
      if (this.model.at(i).get('hidden')) {
        continue;
      }
      view = new LabelRowView({
        model: this.model.at(i),
        g: this.g
      });
      view.ordering = i;
      results.push(this.addView("row_" + i, view));
    }
    return results;
  },
  events: {
    "scroll": "_sendScrollEvent"
  },
  _sendScrollEvent: function _sendScrollEvent() {
    return this.g.zoomer.set("_alignmentScrollTop", this.el.scrollTop, {
      origin: "label"
    });
  },
  _adjustScrollingTop: function _adjustScrollingTop() {
    return this.el.scrollTop = this.g.zoomer.get("_alignmentScrollTop");
  },
  render: function render() {
    this.renderSubviews();
    this.el.className = "biojs_msa_labelblock";
    this.el.style.display = "inline-block";
    this.el.style.verticalAlign = "top";
    this.el.style.overflowY = "auto";
    this.el.style.overflowX = "hidden";
    this.el.style.fontSize = this.g.zoomer.get('labelFontsize') + "px";
    this.el.style.lineHeight = "" + this.g.zoomer.get("labelLineHeight");
    this._setHeight();
    return this;
  },
  _setHeight: function _setHeight() {
    return this.el.style.height = this.g.zoomer.get("alignmentHeight") + "px";
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/labels/LabelRowView.js":
/*!***********************************************************!*\
  !*** ./node_modules/msa/lib/views/labels/LabelRowView.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelView, MetaView, boneView;
boneView = __webpack_require__(/*! backbone-childs */ "./node_modules/backbone-childs/index.js");
LabelView = __webpack_require__(/*! ./LabelView */ "./node_modules/msa/lib/views/labels/LabelView.js");
MetaView = __webpack_require__(/*! ./MetaView */ "./node_modules/msa/lib/views/labels/MetaView.js");
module.exports = boneView.extend({
  initialize: function initialize(data) {
    this.g = data.g;
    this.draw();
    this.listenTo(this.g.vis, "change:labels", this.drawR);
    this.listenTo(this.g.vis, "change:metacell", this.drawR);
    this.listenTo(this.g.zoomer, "change:rowHeight", function () {
      return this.el.style.height = this.g.zoomer.get("rowHeight") + "px";
    });
    return this.listenTo(this.g.selcol, "change reset add", this.setSelection);
  },
  draw: function draw() {
    var meta;
    this.removeViews();
    if (this.g.vis.get("labels")) {
      this.addView("labels", new LabelView({
        model: this.model,
        g: this.g
      }));
    }
    if (this.g.vis.get("metacell")) {
      meta = new MetaView({
        model: this.model,
        g: this.g
      });
      return this.addView("metacell", meta);
    }
  },
  drawR: function drawR() {
    this.draw();
    return this.render();
  },
  render: function render() {
    this.renderSubviews();
    this.el.setAttribute("class", "biojs_msa_labelrow");
    this.el.style.height = this.g.zoomer.get("rowHeight") * (this.model.attributes.height || 1) + "px";
    this.setSelection();
    return this;
  },
  setSelection: function setSelection() {
    var sel;
    sel = this.g.selcol.getSelForRow(this.model.id);
    if (sel.length > 0) {
      return this.el.style.fontWeight = "bold";
    } else {
      return this.el.style.fontWeight = "normal";
    }
  }
});

/***/ }),

/***/ "./node_modules/msa/lib/views/labels/LabelView.js":
/*!********************************************************!*\
  !*** ./node_modules/msa/lib/views/labels/LabelView.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var LabelView, dom, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
LabelView = view.extend({
  initialize: function initialize(data) {
    this.seq = data.seq;
    this.g = data.g;
    return this.manageEvents();
  },
  manageEvents: function manageEvents() {
    var events;
    events = {};
    if (this.g.config.get("registerMouseClicks")) {
      events.click = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
    this.listenTo(this.g.vis, "change:labelName change:labelId change:labelPartition change:labelCheckbox", this.render);
    this.listenTo(this.g.zoomer, "change:labelIdLength change:labelNameLength change:labelPartLength change:labelCheckLength", this.render);
    return this.listenTo(this.g.zoomer, "change:labelFontSize change:labelLineHeight change:labelWidth change:rowHeight", this.render);
  },
  render: function render() {
    var checkBox, id, name, part, val;
    dom.removeAllChilds(this.el);
    this.el.style.width = this.g.zoomer.getLabelWidth() + "px";
    this.el.setAttribute("class", "biojs_msa_labels");
    if (this.g.vis.get("labelCheckbox")) {
      checkBox = document.createElement("input");
      checkBox.setAttribute("type", "checkbox");
      checkBox.value = this.model.get('id');
      checkBox.name = "seq";
      checkBox.style.width = this.g.zoomer.get("labelCheckLength") + "px";
      this.el.appendChild(checkBox);
    }
    if (this.g.vis.get("labelId")) {
      id = document.createElement("span");
      val = this.model.get("id");
      if (!isNaN(val)) {
        val++;
      }
      id.textContent = val;
      id.style.width = this.g.zoomer.get("labelIdLength") + "px";
      id.style.display = "inline-block";
      this.el.appendChild(id);
    }
    if (this.g.vis.get("labelPartition")) {
      part = document.createElement("span");
      part.style.width = this.g.zoomer.get("labelPartLength") + "px";
      part.textContent = this.model.get("partition");
      part.style.display = "inline-block";
      this.el.appendChild(id);
      this.el.appendChild(part);
    }
    if (this.g.vis.get("labelName")) {
      name = document.createElement("span");
      name.textContent = this.model.get("name");
      if (this.model.get("ref") && this.g.config.get("hasRef")) {
        name.style.fontWeight = "bold";
      }
      name.style.width = this.g.zoomer.get("labelNameLength") + "px";
      this.el.appendChild(name);
    }
    this.el.style.overflow = scroll;
    this.el.style.fontSize = this.g.zoomer.get('labelFontsize') + "px";
    return this;
  },
  _onclick: function _onclick(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:click", {
      seqId: seqId,
      evt: evt
    });
  },
  _onmousein: function _onmousein(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:mouseout", {
      seqId: seqId,
      evt: evt
    });
  },
  _onmouseout: function _onmouseout(evt) {
    var seqId;
    seqId = this.model.get("id");
    return this.g.trigger("row:mouseout", {
      seqId: seqId,
      evt: evt
    });
  }
});
module.exports = LabelView;

/***/ }),

/***/ "./node_modules/msa/lib/views/labels/MetaView.js":
/*!*******************************************************!*\
  !*** ./node_modules/msa/lib/views/labels/MetaView.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.9.1
var MenuBuilder, MetaView, _, dom, st, view;
view = __webpack_require__(/*! backbone-viewj */ "./node_modules/backbone-viewj/index.js");
MenuBuilder = __webpack_require__(/*! ../../menu/menubuilder */ "./node_modules/msa/lib/menu/menubuilder.js");
_ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
dom = __webpack_require__(/*! dom-helper */ "./node_modules/dom-helper/index.js");
st = __webpack_require__(/*! msa-seqtools */ "./node_modules/msa-seqtools/lib/index.js");
module.exports = MetaView = view.extend({
  className: "biojs_msa_metaview",
  initialize: function initialize(data) {
    this.g = data.g;
    this.listenTo(this.g.vis, "change:metacell", this.render);
    return this.listenTo(this.g.zoomer, "change:metaWidth", this.render);
  },
  events: {
    click: "_onclick",
    mousein: "_onmousein",
    mouseout: "_onmouseout"
  },
  render: function render() {
    var gapSpan, gaps, ident, identSpan, linkEl, links, menu, seq, width;
    dom.removeAllChilds(this.el);
    this.el.style.display = "inline-block";
    width = this.g.zoomer.getMetaWidth();
    this.el.style.width = width - 10;
    this.el.style.paddingRight = 5;
    this.el.style.paddingLeft = 5;
    this.el.style.fontSize = this.g.zoomer.get('labelFontsize') - 2 + "px";
    if (this.g.vis.get("metaGaps")) {
      seq = this.model.get('seq');
      gaps = _.reduce(seq, function (memo, c) {
        if (c === '-') {
          memo++;
        }
        return memo;
      }, 0);
      gaps = (gaps / seq.length).toFixed(1);
      gapSpan = document.createElement('span');
      gapSpan.textContent = gaps;
      gapSpan.style.display = "inline-block";
      gapSpan.style.width = 35;
      this.el.appendChild(gapSpan);
    }
    if (this.g.vis.get("metaIdentity")) {
      ident = this.g.stats.identity()[this.model.id];
      identSpan = document.createElement('span');
      if (this.model.get("ref") && this.g.config.get("hasRef")) {
        identSpan.textContent = "ref.";
      } else if (ident != null) {
        identSpan.textContent = ident.toFixed(2);
      }
      identSpan.style.display = "inline-block";
      identSpan.style.width = 40;
      this.el.appendChild(identSpan);
    }
    if (this.g.vis.get("metaLinks")) {
      if (this.model.attributes.ids) {
        links = st.buildLinks(this.model.attributes.ids);
        if (_.keys(links).length > 0) {
          menu = new MenuBuilder({
            name: ""
          });
          console.log(_.keys(links));
          _.each(links, function (val, key) {
            return menu.addNode(key, function (e) {
              return window.open(val);
            });
          });
          linkEl = menu.buildDOM();
          linkEl.style.cursor = "pointer";
          return this.el.appendChild(linkEl);
        }
      }
    }
  },
  _onclick: function _onclick(evt) {
    return this.g.trigger("meta:click", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmousein: function _onmousein(evt) {
    return this.g.trigger("meta:mousein", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  },
  _onmouseout: function _onmouseout(evt) {
    return this.g.trigger("meta:mouseout", {
      seqId: this.model.get("id", {
        evt: evt
      })
    });
  }
});

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var trim = __webpack_require__(/*! trim */ "./node_modules/trim/index.js"),
  forEach = __webpack_require__(/*! for-each */ "./node_modules/for-each/index.js"),
  isArray = function isArray(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
module.exports = function (headers) {
  if (!headers) return {};
  var result = {};
  forEach(trim(headers).split('\n'), function (row) {
    var index = row.indexOf(':'),
      key = trim(row.slice(0, index)).toLowerCase(),
      value = trim(row.slice(index + 1));
    if (typeof result[key] === 'undefined') {
      result[key] = value;
    } else if (isArray(result[key])) {
      result[key].push(value);
    } else {
      result[key] = [result[key], value];
    }
  });
  return result;
};

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }
  var nextHandle = 1; // Spec says greater than zero
  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;
  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    }
    // Copy function arguments
    var args = new Array(arguments.length - 1);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    }
    // Store and register the task
    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }
  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }
  function run(task) {
    var callback = task.callback;
    var args = task.args;
    switch (args.length) {
      case 0:
        callback();
        break;
      case 1:
        callback(args[0]);
        break;
      case 2:
        callback(args[0], args[1]);
        break;
      case 3:
        callback(args[0], args[1], args[2]);
        break;
      default:
        callback.apply(undefined, args);
        break;
    }
  }
  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];
      if (task) {
        currentlyRunningATask = true;
        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }
  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }
  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;
      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };
      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }
  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

    var messagePrefix = "setImmediate$" + Math.random() + "$";
    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };
    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }
    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }
  function installMessageChannelImplementation() {
    var channel = new MessageChannel();
    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };
    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }
  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;
    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");
      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };
      html.appendChild(script);
    };
  }
  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  }

  // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

  // Don't get fooled by e.g. browserify environments.
  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }
  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/stat.seqs/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/stat.seqs/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
var stat = function stat(seqs, opts) {
  // if someone forgets new
  if (!this || this.constructor !== stat) {
    return new stat(seqs);
  }
  if (seqs === undefined || typeof seqs === "string") {
    throw new TypeError("you need to give the seq stat an array");
  }
  //if(seqs.length == 0){
  //throw new TypeError("you need to give the seq stat a real array");
  //}
  this.resetSeqs(seqs);
  this.alphabetSize = 4;
  this._useBackground = false;
  this.useGaps = false;
  this.ignoredChars = ["-", "*"];
  _.extend(this, opts);
};
stat.prototype.addSeq = function addSeq(seq) {
  this.seqs.push(seq);
  this._reset();
};
stat.prototype.removeSeq = function addSeq(seq) {
  // check for int or string
  if (typeof seq === 'number') {
    this.seqs.splice(seq, 1);
  } else {
    // identify matches (we could have multiple)
    _.each(this.seqs, function (s, i) {
      if (seq === s) {
        this.seqs.splice(i, 1);
      }
    }.bind(this));
  }
  this._reset();
};
stat.prototype.addSeqs = function addSeqs(seqs) {
  seqs.forEach(function (seq) {
    this.addSeq(seq);
  }.bind(this));
};
stat.prototype.resetSeqs = function reset(seqs) {
  this.seqs = [];

  // support sequence models
  if (!seqs instanceof Array || "at" in seqs) {
    this.mseqs = seqs;
    var mSeqsPluck = function mSeqsPluck() {
      var seqArr = this.mseqs.pluck("seq");
      this.resetSeqs(seqArr);
    };
    seqs.on("add change reset ", mSeqsPluck, this);
    mSeqsPluck.call(this);
  } else {
    this.addSeqs(seqs);
    this._reset();
    this.trigger("reset");
  }
};
var calcValues = ["consensus", "frequency", "maxLength", "ic", "gaps"];
stat.prototype._reset = function _reset() {
  for (var i = 0; i < calcValues.length; i++) {
    this["_" + calcValues[i]] = undefined;
  }
  this._identity = undefined;
  this._background = undefined;
};

// -----------------------------------------------------------------------------
// BEGIN: setter/getter
// -----------------------------------------------------------------------------

stat.prototype.setBackground = function setBackground(b) {
  this._useBackground = b;
  this._reset();
};
stat.prototype.useBackground = function useBackground() {
  this.setBackground(true);
};
stat.prototype.setDNA = function setNucleotide() {
  this.alphabetSize = 4;
};
stat.prototype.setProtein = function setDNA() {
  this.alphabetSize = 20;
};

// -----------------------------------------------------------------------------
// BEGIN: auto wrappers
// -----------------------------------------------------------------------------

// neat auto-wrappers
calcValues.forEach(function (key) {
  stat.prototype[key] = function () {
    if (this["_" + key] === undefined) {
      this["_" + key] = this[key + "Calc"]();
    }
    return this["_" + key];
  };
});
stat.prototype.identity = function identitiy(seq) {
  // do not cache if its called with a special compare seq
  var ident;
  if (this._identity === undefined || seq) {
    ident = this.identityCalc(seq);
    this._identity = undefined;
  }
  return this._identity || ident;
};

// set your own background with obj.bg
stat.prototype.background = function background() {
  if (this.bg !== undefined) {
    return this.bg;
  }
  if (this._background === undefined) {
    this.backgroundCalc();
  }
  return this._background;
};

// -----------------------------------------------------------------------------
// BEGIN: calc tools
// -----------------------------------------------------------------------------

// calculates the relative frequency of a base at a given position
// this is needed e.g. for the entropy calculation
// seqs: array of sequences (strings)
// opts:
//    all: boolean (use to show the frequencies for all letters [including the ignored ones]
//    (default false)
// @returns array of all positions with a dictionary of all bases with their relative frequency
stat.prototype.frequencyCalc = function frequencyCalc(opts) {
  var occs, totalPerPos;
  occs = new Array(this.maxLength());
  totalPerPos = new Array(this.seqs.length);
  var ignoredChars = this.ignoredChars;
  if (opts !== undefined && opts.all) {
    ignoredChars = [];
  }

  // count the occurrences of the chars at a position
  _.each(this.seqs, function (el) {
    _.each(el, function (c, pos) {
      if (ignoredChars.indexOf(c) >= 0) return;
      if (occs[pos] === undefined) {
        occs[pos] = {};
      }
      if (occs[pos][c] === undefined) {
        occs[pos][c] = 0;
      }
      occs[pos][c]++;
      if (totalPerPos[pos] === undefined) {
        totalPerPos[pos] = 0;
      }
      totalPerPos[pos]++;
    });
  });

  // normalize to 1
  _.each(occs, function (el, pos) {
    return _.each(el, function (val, c) {
      return occs[pos][c] = val / totalPerPos[pos];
    });
  });
  this._frequency = occs;
  return occs;
};

// seqs: array of sequences (strings)
stat.prototype.backgroundCalc = function backgroundCalc() {
  var occ = {};
  var total = 0;

  // count the occurences of the chars of a position
  _.each(this.seqs, function (el) {
    _.each(el, function (c) {
      if (occ[c] === undefined) {
        occ[c] = 0;
      }
      occ[c]++;
      return total++;
    });
  });

  // normalize to 1
  occ = _.mapValues(occ, function (val) {
    return val / total;
  });
  this._background = occ;
  return occ;
};

// information content after Shannon
// * gaps are excluded
stat.prototype.icCalc = function icCalc() {
  var f = this.frequency();
  if (this._useBackground) {
    var b = this.background();
  }
  var ignoredChars = this.ignoredChars;
  var useBackground = this._useBackground;
  var ic = _.map(f, function (el) {
    return _.reduce(el, function (memo, val, c) {
      if (ignoredChars.indexOf(c) >= 0) return memo;
      if (useBackground) {
        val = val / b[c];
      }
      return memo - val * (Math.log(val) / Math.log(2));
    }, 0);
  });
  this._ic = ic;
  return ic;
};

// sequence conservation after Schneider and Stephens (1990)
// @cite Schneider, T.D. and Stephens, R.M. 1990. Sequence logos: A new way to
// display consensus sequences. Nucleic Acids Res. 18: 60976100.
stat.prototype.conservation = function conservation(alphabetSize) {
  var ic = this.ic();
  var gaps = this.gaps();
  var self = this;
  alphabetSize = alphabetSize || this.alphabetSize;
  var icMax = Math.log(alphabetSize) / Math.log(2);
  var i = 0;
  var conserv = _.map(ic, function (el) {
    var ret = icMax - el;
    if (self.useGaps) {
      ret = ret * (1 - gaps[i++]);
    }
    return ret;
  });
  return conserv;
};

// sequence conservation after Schneider and Stephens (1990)
// conservation for each amino acid
// * gaps are excluded
stat.prototype.conservResidue = function conservation(input) {
  var alphabetSize = input ? input.alphabetSize : undefined;
  var ic;
  var ignoredChars = this.ignoredChars;
  if (input !== undefined && input.scaled) {
    ic = this.scale(this.conservation(alphabetSize));
  } else {
    ic = this.conservation(alphabetSize);
  }
  var f = this.frequency();
  var keys;
  var conserv = _.map(f, function (el, i) {
    keys = _.reject(_.keys(el), function (c) {
      return ignoredChars.indexOf(c) >= 0;
    });
    var obj = {};
    _.each(keys, function (key) {
      obj[key] = el[key] * ic[i];
    });
    return obj;
  });
  return conserv;
};

// type 2 sequence logo method
// scales relative to background
stat.prototype.conservResidue2 = function conservation(alphabetSize) {
  var f = this.frequency();
  var ic = this.conservation(alphabetSize);
  var b = this.background();
  var conserv = _.map(f, function (el, i) {
    return _.map(el, function (val) {
      var sum = _.reduce(f[i], function (memo, e) {
        return memo + e / b[i];
      }, 0);
      return val / b[i] / sum * ic[i];
    }, 0);
  });
  return conserv;
};

// scale information content or conservation to 1
stat.prototype.scale = function conservation(ic, alphabetSize) {
  alphabetSize = alphabetSize || this.alphabetSize;
  var icMax = Math.log(alphabetSize) / Math.log(2);
  var conserv = _.map(ic, function (el) {
    return el / icMax;
  });
  return conserv;
};
stat.prototype.maxLengthCalc = function () {
  if (this.seqs.length === 0) {
    return 0;
  }
  return _.max(this.seqs, function (seq) {
    return seq.length;
  }).length;
};

// seqs: array of sequences (strings)
// @returns consenus sequence
stat.prototype.consensusCalc = function consensusCal() {
  var occs = new Array(this.maxLength());

  // count the occurrences of the chars of a position
  _.each(this.seqs, function (el) {
    _.each(el, function (c, pos) {
      if (occs[pos] === undefined) {
        occs[pos] = {};
      }
      if (occs[pos][c] === undefined) {
        occs[pos][c] = 0;
      }
      occs[pos][c]++;
    });
  });

  // now pick the char with most occurrences
  this._consensus = _.reduce(occs, function (memo, occ) {
    var keys;
    keys = _.keys(occ);
    return memo += _.max(keys, function (key) {
      return occ[key];
    });
  }, "");
  return this._consensus;
};

// seqs: array of sequences (strings)
// consensus: calculated consensus seq
// calculates for each sequence
// * matches with the consensus seq
// * identity = matchedChars / totalChars (excluding gaps)
// @returns: array of length of the seqs with the identity to the consensus (double)
stat.prototype.identityCalc = function identitiyCalc(compareSeq) {
  var consensus = compareSeq || this.consensus();
  this._identity = this.seqs.map(function (seq) {
    var matches = 0;
    var total = 0;
    for (var i = 0; i < seq.length; i++) {
      if (seq[i] !== "-" && consensus[i] !== "-") {
        total++;
        if (seq[i] === consensus[i]) {
          matches++;
        }
      }
    }
    return matches / total;
  });
  return this._identity;
};

// percentage of gaps per column
stat.prototype.gapsCalc = function gapsCount() {
  var mLength = this.maxLength();
  if (mLength <= 1 || typeof mLength === "undefined") {
    return [];
  }
  var occs = new Array(this.maxLength());
  // count the occurrences of the chars of a position
  _.each(this.seqs, function (el) {
    _.each(el, function (c, pos) {
      if (occs[pos] === undefined) {
        occs[pos] = {
          g: 0,
          t: 0
        };
      }
      c = c === "-" ? "g" : "t";
      occs[pos][c]++;
    });
  });

  // now pick the char with most occurrences
  this._gaps = _.map(occs, function (el) {
    return el.g / (el.g + el.t);
  });
  return this._gaps;
};
_.mixin({
  mapValues: function mapValues(obj, f_val) {
    return _.object(_.keys(obj), _.map(obj, f_val));
  }
});
__webpack_require__(/*! biojs-events */ "./node_modules/biojs-events/index.js").mixin(stat.prototype);
module.exports = stat;

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};
function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};
exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};
exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/trim/index.js":
/*!************************************!*\
  !*** ./node_modules/trim/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports = module.exports = trim;
function trim(str) {
  return str.replace(/^\s*|\s*$/g, '');
}
exports.left = function (str) {
  return str.replace(/^\s*/, '');
};
exports.right = function (str) {
  return str.replace(/\s*$/, '');
};

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function () {
  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global.global === global && global || this || {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype,
    ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
    slice = ArrayProto.slice,
    toString = ObjProto.toString,
    hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function Ctor() {};

  // Create a safe reference to the Underscore object for use below.
  var _ = function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if ( true && !exports.nodeType) {
    if ( true && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };
      // The 2-argument case is omitted because were not using it.
      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };
      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }
    return function () {
      return func.apply(context, arguments);
    };
  };
  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result  either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function cb(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function builtinIteratee(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the functions
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6s "rest parameter".
  var restArguments = function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function () {
      var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0:
          return func.call(this, rest);
        case 1:
          return func.call(this, arguments[0], rest);
        case 2:
          return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function baseCreate(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };
  var shallowProperty = function shallowProperty(key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  };
  var has = function has(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  };
  var deepGet = function deepGet(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function isArrayLike(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
      length = (keys || obj).length,
      results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function reducer(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };
    return function (obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function (obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
      length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
      length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function (obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function (context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function (obj, iteratee, context) {
    var result = -Infinity,
      lastComputed = -Infinity,
      value,
      computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function (obj, iteratee, context) {
    var result = Infinity,
      lastComputed = Infinity,
      value,
      computed;
    if (iteratee == null || typeof iteratee == 'number' && _typeof(obj[0]) != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function (v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function (obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function (obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function group(behavior, partition) {
    return function (obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function (result, value, key) {
    if (has(result, key)) result[key].push(value);else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function (result, value, key) {
    if (has(result, key)) result[key]++;else result[key] = 1;
  });
  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function (obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function (result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function (array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function (array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function flatten(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0,
            len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function (array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function (arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function (array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);
    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function (list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
      high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
        length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);
    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }
    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function (array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0,
      length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function (func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function (callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function (func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function bound() {
      var position = 0,
        length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });
  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function (obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function (func, hasher) {
    var memoize = function memoize(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function (func, wait, args) {
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function (func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};
    var later = function later() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    var throttled = function throttled() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };
    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function (func, wait, immediate) {
    var timeout, result;
    var later = function later(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };
    var debounced = restArguments(function (args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }
      return result;
    });
    debounced.cancel = function () {
      clearTimeout(timeout);
      timeout = null;
    };
    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);
  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);
    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function (obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
      length = keys.length,
      results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function createAssigner(keysFunc, defaults) {
    return function (obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj),
      key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function keyInObj(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function (obj, keys) {
    var result = {},
      iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function (obj, keys) {
    var iteratee = keys[0],
      context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function iteratee(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs),
      length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = _typeof(a);
    if (type !== 'function' && type !== 'object' && _typeof(b) != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }
    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (_typeof(a) != 'object' || _typeof(b) != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor,
        bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a),
        key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function (a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function (obj) {
    var type = _typeof(obj);
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if ( true && (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) != 'object' && typeof nodelist != 'function') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function (obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function (obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function (obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function (obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function (obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function (value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function (value) {
    return function () {
      return value;
    };
  };
  _.noop = function () {};

  // Creates a function that, when passed an object, will traverse that objects
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function (path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function (obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function (obj) {
    if (obj == null) {
      return function () {};
    }
    return function (path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function () {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function createEscaper(map) {
    var escaper = function escaper(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function (obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
  var escapeChar = function escapeChar(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;
      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    var template = function template(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function (obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function chainResult(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function () {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  _.prototype.toString = function () {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/vow/lib/vow.js":
/*!*************************************!*\
  !*** ./node_modules/vow/lib/vow.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate, process, module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * @module vow
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @version 0.4.17
 * @license
 * Dual licensed under the MIT and GPL licenses:
 *   * http://www.opensource.org/licenses/mit-license.php
 *   * http://www.gnu.org/licenses/gpl.html
 */

(function (global) {
  var undef,
    nextTick = function () {
      var fns = [],
        enqueueFn = function enqueueFn(fn) {
          fns.push(fn);
          return fns.length === 1;
        },
        callFns = function callFns() {
          var fnsToCall = fns,
            i = 0,
            len = fns.length;
          fns = [];
          while (i < len) {
            fnsToCall[i++]();
          }
        };
      if (typeof setImmediate === 'function') {
        // ie10, nodejs >= 0.10
        return function (fn) {
          enqueueFn(fn) && setImmediate(callFns);
        };
      }
      if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.nextTick) {
        // nodejs < 0.10
        return function (fn) {
          enqueueFn(fn) && process.nextTick(callFns);
        };
      }
      var MutationObserver = global.MutationObserver || global.WebKitMutationObserver; // modern browsers
      if (MutationObserver) {
        var num = 1,
          node = document.createTextNode('');
        new MutationObserver(callFns).observe(node, {
          characterData: true
        });
        return function (fn) {
          enqueueFn(fn) && (node.data = num *= -1);
        };
      }
      if (global.postMessage) {
        var isPostMessageAsync = true;
        if (global.attachEvent) {
          var checkAsync = function checkAsync() {
            isPostMessageAsync = false;
          };
          global.attachEvent('onmessage', checkAsync);
          global.postMessage('__checkAsync', '*');
          global.detachEvent('onmessage', checkAsync);
        }
        if (isPostMessageAsync) {
          var msg = '__promise' + Math.random() + '_' + new Date(),
            onMessage = function onMessage(e) {
              if (e.data === msg) {
                e.stopPropagation && e.stopPropagation();
                callFns();
              }
            };
          global.addEventListener ? global.addEventListener('message', onMessage, true) : global.attachEvent('onmessage', onMessage);
          return function (fn) {
            enqueueFn(fn) && global.postMessage(msg, '*');
          };
        }
      }
      var doc = global.document;
      if ('onreadystatechange' in doc.createElement('script')) {
        // ie6-ie8
        var createScript = function createScript() {
          var script = doc.createElement('script');
          script.onreadystatechange = function () {
            script.parentNode.removeChild(script);
            script = script.onreadystatechange = null;
            callFns();
          };
          (doc.documentElement || doc.body).appendChild(script);
        };
        return function (fn) {
          enqueueFn(fn) && createScript();
        };
      }
      return function (fn) {
        // old browsers
        enqueueFn(fn) && setTimeout(callFns, 0);
      };
    }(),
    throwException = function throwException(e) {
      nextTick(function () {
        throw e;
      });
    },
    isFunction = function isFunction(obj) {
      return typeof obj === 'function';
    },
    isObject = function isObject(obj) {
      return obj !== null && _typeof(obj) === 'object';
    },
    toStr = Object.prototype.toString,
    isArray = Array.isArray || function (obj) {
      return toStr.call(obj) === '[object Array]';
    },
    getArrayKeys = function getArrayKeys(arr) {
      var res = [],
        i = 0,
        len = arr.length;
      while (i < len) {
        res.push(i++);
      }
      return res;
    },
    getObjectKeys = Object.keys || function (obj) {
      var res = [];
      for (var i in obj) {
        obj.hasOwnProperty(i) && res.push(i);
      }
      return res;
    },
    defineCustomErrorType = function defineCustomErrorType(name) {
      var res = function res(message) {
        this.name = name;
        this.message = message;
      };
      res.prototype = new Error();
      return res;
    },
    wrapOnFulfilled = function wrapOnFulfilled(onFulfilled, idx) {
      return function (val) {
        onFulfilled.call(this, val, idx);
      };
    },
    emitUnhandledRejection = global.PromiseRejectionEvent ? function (reason, promise) {
      new global.PromiseRejectionEvent('unhandledrejection', {
        promise: promise,
        reason: reason
      });
    } : (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.emit ? function (reason, promise) {
      process.emit('unhandledRejection', reason, promise);
    } : function () {};

  /**
   * @class Deferred
   * @exports vow:Deferred
   * @description
   * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
   */

  /**
   * @constructor
   * @description
   * You can use `vow.defer()` instead of using this constructor.
   *
   * `new vow.Deferred()` gives the same result as `vow.defer()`.
   */
  var Deferred = function Deferred() {
    this._promise = new Promise();
  };
  Deferred.prototype = /** @lends Deferred.prototype */{
    /**
     * Returns the corresponding promise.
     *
     * @returns {vow:Promise}
     */
    promise: function promise() {
      return this._promise;
    },
    /**
     * Resolves the corresponding promise with the given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.then(function(value) {
     *     // value is "'success'" here
     * });
     *
     * defer.resolve('success');
     * ```
     */
    resolve: function resolve(value) {
      this._promise.isResolved() || this._promise._resolve(value);
    },
    /**
     * Rejects the corresponding promise with the given `reason`.
     *
     * @param {*} reason
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.fail(function(reason) {
     *     // reason is "'something is wrong'" here
     * });
     *
     * defer.reject('something is wrong');
     * ```
     */
    reject: function reject(reason) {
      if (this._promise.isResolved()) {
        return;
      }
      if (vow.isPromise(reason)) {
        reason = reason.then(function (val) {
          var defer = vow.defer();
          defer.reject(val);
          return defer.promise();
        });
        this._promise._resolve(reason);
      } else {
        this._promise._reject(reason);
      }
    },
    /**
     * Notifies the corresponding promise with the given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.progress(function(value) {
     *     // value is "'20%'", "'40%'" here
     * });
     *
     * defer.notify('20%');
     * defer.notify('40%');
     * ```
     */
    notify: function notify(value) {
      this._promise.isResolved() || this._promise._notify(value);
    }
  };
  var PROMISE_STATUS = {
    PENDING: 0,
    RESOLVED: 1,
    FULFILLED: 2,
    REJECTED: 3
  };

  /**
   * @class Promise
   * @exports vow:Promise
   * @description
   * The `Promise` class is used when you want to give to the caller something to subscribe to,
   * but not the ability to resolve or reject the deferred.
   */

  /**
   * @constructor
   * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
   * @description
   * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
   * In other case you should use `vow.defer()` and `defer.promise()` methods.
   * @example
   * ```js
   * function fetchJSON(url) {
   *     return new vow.Promise(function(resolve, reject, notify) {
   *         var xhr = new XMLHttpRequest();
   *         xhr.open('GET', url);
   *         xhr.responseType = 'json';
   *         xhr.send();
   *         xhr.onload = function() {
   *             if(xhr.response) {
   *                 resolve(xhr.response);
   *             }
   *             else {
   *                 reject(new TypeError());
   *             }
   *         };
   *     });
   * }
   * ```
   */
  var Promise = function Promise(resolver) {
    this._value = undef;
    this._status = PROMISE_STATUS.PENDING;
    this._shouldEmitUnhandledRejection = true;
    this._fulfilledCallbacks = [];
    this._rejectedCallbacks = [];
    this._progressCallbacks = [];
    if (resolver) {
      // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
      var _this = this,
        resolverFnLen = resolver.length;
      try {
        resolver(function (val) {
          _this.isResolved() || _this._resolve(val);
        }, resolverFnLen > 1 ? function (reason) {
          _this.isResolved() || _this._reject(reason);
        } : undef, resolverFnLen > 2 ? function (val) {
          _this.isResolved() || _this._notify(val);
        } : undef);
      } catch (e) {
        this._reject(e);
      }
    }
  };
  Promise.prototype = /** @lends Promise.prototype */{
    /**
     * Returns the value of the fulfilled promise or the reason in case of rejection.
     *
     * @returns {*}
     */
    valueOf: function valueOf() {
      return this._value;
    },
    /**
     * Returns `true` if the promise is resolved.
     *
     * @returns {Boolean}
     */
    isResolved: function isResolved() {
      return this._status !== PROMISE_STATUS.PENDING;
    },
    /**
     * Returns `true` if the promise is fulfilled.
     *
     * @returns {Boolean}
     */
    isFulfilled: function isFulfilled() {
      return this._status === PROMISE_STATUS.FULFILLED;
    },
    /**
     * Returns `true` if the promise is rejected.
     *
     * @returns {Boolean}
     */
    isRejected: function isRejected() {
      return this._status === PROMISE_STATUS.REJECTED;
    },
    /**
     * Adds reactions to the promise.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
     */
    then: function then(onFulfilled, onRejected, onProgress, ctx) {
      this._shouldEmitUnhandledRejection = false;
      var defer = new Deferred();
      this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
      return defer.promise();
    },
    /**
     * Adds only a rejection reaction. This method is a shorthand for `promise.then(undefined, onRejected)`.
     *
     * @param {Function} onRejected Callback that will be called with a provided 'reason' as argument after the promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    'catch': function _catch(onRejected, ctx) {
      return this.then(undef, onRejected, ctx);
    },
    /**
     * Adds only a rejection reaction. This method is a shorthand for `promise.then(null, onRejected)`. It's also an alias for `catch`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    fail: function fail(onRejected, ctx) {
      return this.then(undef, onRejected, ctx);
    },
    /**
     * Adds a resolving reaction (for both fulfillment and rejection).
     *
     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    always: function always(onResolved, ctx) {
      var _this = this,
        cb = function cb() {
          return onResolved.call(this, _this);
        };
      return this.then(cb, cb, ctx);
    },
    /**
     * Adds a progress reaction.
     *
     * @param {Function} onProgress Callback that will be called with a provided value when the promise has been notified
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    progress: function progress(onProgress, ctx) {
      return this.then(undef, undef, onProgress, ctx);
    },
    /**
     * Like `promise.then`, but "spreads" the array into a variadic value handler.
     * It is useful with the `vow.all` and the `vow.allResolved` methods.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
     *     // arg1 is "1", arg2 is "'two'" here
     * });
     *
     * defer1.resolve(1);
     * defer2.resolve('two');
     * ```
     */
    spread: function spread(onFulfilled, onRejected, ctx) {
      return this.then(function (val) {
        return onFulfilled.apply(this, val);
      }, onRejected, ctx);
    },
    /**
     * Like `then`, but terminates a chain of promises.
     * If the promise has been rejected, this method throws it's "reason" as an exception in a future turn of the event loop.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     *
     * @example
     * ```js
     * var defer = vow.defer();
     * defer.reject(Error('Internal error'));
     * defer.promise().done(); // exception to be thrown
     * ```
     */
    done: function done(onFulfilled, onRejected, onProgress, ctx) {
      this.then(onFulfilled, onRejected, onProgress, ctx).fail(throwException);
    },
    /**
     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
     * or immediately rejected if the promise is rejected.
     *
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay: function delay(_delay) {
      var timer,
        promise = this.then(function (val) {
          var defer = new Deferred();
          timer = setTimeout(function () {
            defer.resolve(val);
          }, _delay);
          return defer.promise();
        });
      promise.always(function () {
        clearTimeout(timer);
      });
      return promise;
    },
    /**
     * Returns a new promise that will be rejected in `timeout` milliseconds
     * if the promise is not resolved beforehand.
     *
     * @param {Number} timeout
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promiseWithTimeout1 = defer.promise().timeout(50),
     *     promiseWithTimeout2 = defer.promise().timeout(200);
     *
     * setTimeout(
     *     function() {
     *         defer.resolve('ok');
     *     },
     *     100);
     *
     * promiseWithTimeout1.fail(function(reason) {
     *     // promiseWithTimeout to be rejected in 50ms
     * });
     *
     * promiseWithTimeout2.then(function(value) {
     *     // promiseWithTimeout to be fulfilled with "'ok'" value
     * });
     * ```
     */
    timeout: function timeout(_timeout) {
      var defer = new Deferred(),
        timer = setTimeout(function () {
          defer.reject(new vow.TimedOutError('timed out'));
        }, _timeout);
      this.then(function (val) {
        defer.resolve(val);
      }, function (reason) {
        defer.reject(reason);
      });
      defer.promise().always(function () {
        clearTimeout(timer);
      });
      return defer.promise();
    },
    _vow: true,
    _resolve: function _resolve(val) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }
      if (val === this) {
        this._reject(TypeError('Can\'t resolve promise with itself'));
        return;
      }
      this._status = PROMISE_STATUS.RESOLVED;
      if (val && !!val._vow) {
        // shortpath for vow.Promise
        if (val.isFulfilled()) {
          this._fulfill(val.valueOf());
        } else if (val.isRejected()) {
          val._shouldEmitUnhandledRejection = false;
          this._reject(val.valueOf());
        } else {
          val.then(this._fulfill, this._reject, this._notify, this);
        }
        return;
      }
      if (isObject(val) || isFunction(val)) {
        var then;
        try {
          then = val.then;
        } catch (e) {
          this._reject(e);
          return;
        }
        if (isFunction(then)) {
          var _this = this,
            isResolved = false;
          try {
            then.call(val, function (val) {
              if (isResolved) {
                return;
              }
              isResolved = true;
              _this._resolve(val);
            }, function (err) {
              if (isResolved) {
                return;
              }
              isResolved = true;
              _this._reject(err);
            }, function (val) {
              _this._notify(val);
            });
          } catch (e) {
            isResolved || this._reject(e);
          }
          return;
        }
      }
      this._fulfill(val);
    },
    _fulfill: function _fulfill(val) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }
      this._status = PROMISE_STATUS.FULFILLED;
      this._value = val;
      this._callCallbacks(this._fulfilledCallbacks, val);
      this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },
    _reject: function _reject(reason) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }
      this._status = PROMISE_STATUS.REJECTED;
      this._value = reason;
      this._callCallbacks(this._rejectedCallbacks, reason);
      if (!this._rejectedCallbacks.length) {
        var _this = this;
        nextTick(function () {
          if (_this._shouldEmitUnhandledRejection) {
            emitUnhandledRejection(reason, _this);
          }
        });
      }
      this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },
    _notify: function _notify(val) {
      this._callCallbacks(this._progressCallbacks, val);
    },
    _addCallbacks: function _addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx) {
      if (onRejected && !isFunction(onRejected)) {
        ctx = onRejected;
        onRejected = undef;
      } else if (onProgress && !isFunction(onProgress)) {
        ctx = onProgress;
        onProgress = undef;
      }
      if (onRejected) {
        this._shouldEmitUnhandledRejection = false;
      }
      var cb;
      if (!this.isRejected()) {
        cb = {
          defer: defer,
          fn: isFunction(onFulfilled) ? onFulfilled : undef,
          ctx: ctx
        };
        this.isFulfilled() ? this._callCallbacks([cb], this._value) : this._fulfilledCallbacks.push(cb);
      }
      if (!this.isFulfilled()) {
        cb = {
          defer: defer,
          fn: onRejected,
          ctx: ctx
        };
        this.isRejected() ? this._callCallbacks([cb], this._value) : this._rejectedCallbacks.push(cb);
      }
      if (this._status <= PROMISE_STATUS.RESOLVED) {
        this._progressCallbacks.push({
          defer: defer,
          fn: onProgress,
          ctx: ctx
        });
      }
    },
    _callCallbacks: function _callCallbacks(callbacks, arg) {
      var len = callbacks.length;
      if (!len) {
        return;
      }
      var isResolved = this.isResolved(),
        isFulfilled = this.isFulfilled(),
        isRejected = this.isRejected();
      nextTick(function () {
        var i = 0,
          cb,
          defer,
          fn;
        while (i < len) {
          cb = callbacks[i++];
          defer = cb.defer;
          fn = cb.fn;
          if (fn) {
            var ctx = cb.ctx,
              res;
            try {
              res = ctx ? fn.call(ctx, arg) : fn(arg);
            } catch (e) {
              defer.reject(e);
              continue;
            }
            isFulfilled || isRejected ? defer.resolve(res) : defer.notify(res);
          } else if (isFulfilled) {
            defer.resolve(arg);
          } else if (isRejected) {
            defer.reject(arg);
          } else {
            defer.notify(arg);
          }
        }
      });
    }
  };

  /** @lends Promise */
  var staticMethods = {
    /**
     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast: function cast(value) {
      return vow.cast(value);
    },
    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     */
    all: function all(iterable) {
      return vow.all(iterable);
    },
    /**
     * Returns a promise, that will be fulfilled only when any of the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    race: function race(iterable) {
      return vow.anyResolved(iterable);
    },
    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, the returned promise will have `value`'s state.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve: function resolve(value) {
      return vow.resolve(value);
    },
    /**
     * Returns a promise that has already been rejected with the given `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject: function reject(reason) {
      return vow.reject(reason);
    }
  };
  for (var prop in staticMethods) {
    staticMethods.hasOwnProperty(prop) && (Promise[prop] = staticMethods[prop]);
  }
  var vow = /** @exports vow */{
    Deferred: Deferred,
    Promise: Promise,
    /**
     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
     * It's equivalent to `new vow.Deferred()`.
     *
     * @returns {vow:Deferred}
     */
    defer: function defer() {
      return new Deferred();
    },
    /**
     * Static equivalent to `promise.then`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     */
    when: function when(value, onFulfilled, onRejected, onProgress, ctx) {
      return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
    },
    /**
     * Static equivalent to `promise.fail`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onRejected Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    fail: function fail(value, onRejected, ctx) {
      return vow.when(value, undef, onRejected, ctx);
    },
    /**
     * Static equivalent to `promise.always`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    always: function always(value, onResolved, ctx) {
      return vow.when(value).always(onResolved, ctx);
    },
    /**
     * Static equivalent to `promise.progress`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onProgress Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    progress: function progress(value, onProgress, ctx) {
      return vow.when(value).progress(onProgress, ctx);
    },
    /**
     * Static equivalent to `promise.spread`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     */
    spread: function spread(value, onFulfilled, onRejected, ctx) {
      return vow.when(value).spread(onFulfilled, onRejected, ctx);
    },
    /**
     * Static equivalent to `promise.done`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     */
    done: function done(value, onFulfilled, onRejected, onProgress, ctx) {
      vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
    },
    /**
     * Checks whether the given `value` is a promise-like object
     *
     * @param {*} value
     * @returns {Boolean}
     *
     * @example
     * ```js
     * vow.isPromise('something'); // returns false
     * vow.isPromise(vow.defer().promise()); // returns true
     * vow.isPromise({ then : function() { }); // returns true
     * ```
     */
    isPromise: function isPromise(value) {
      return isObject(value) && isFunction(value.then);
    },
    /**
     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast: function cast(value) {
      return value && !!value._vow ? value : vow.resolve(value);
    },
    /**
     * Static equivalent to `promise.valueOf`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {*}
     */
    valueOf: function valueOf(value) {
      return value && isFunction(value.valueOf) ? value.valueOf() : value;
    },
    /**
     * Static equivalent to `promise.isFulfilled`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isFulfilled: function isFulfilled(value) {
      return value && isFunction(value.isFulfilled) ? value.isFulfilled() : true;
    },
    /**
     * Static equivalent to `promise.isRejected`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isRejected: function isRejected(value) {
      return value && isFunction(value.isRejected) ? value.isRejected() : false;
    },
    /**
     * Static equivalent to `promise.isResolved`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isResolved: function isResolved(value) {
      return value && isFunction(value.isResolved) ? value.isResolved() : true;
    },
    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, the returned promise will have `value`'s state.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve: function resolve(value) {
      var res = vow.defer();
      res.resolve(value);
      return res.promise();
    },
    /**
     * Returns a promise that has already been fulfilled with the given `value`.
     * If `value` is a promise, the returned promise will be fulfilled with the fulfill/rejection value of `value`.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    fulfill: function fulfill(value) {
      var defer = vow.defer(),
        promise = defer.promise();
      defer.resolve(value);
      return promise.isFulfilled() ? promise : promise.then(null, function (reason) {
        return reason;
      });
    },
    /**
     * Returns a promise that has already been rejected with the given `reason`.
     * If `reason` is a promise, the returned promise will be rejected with the fulfill/rejection value of `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject: function reject(reason) {
      var defer = vow.defer();
      defer.reject(reason);
      return defer.promise();
    },
    /**
     * Invokes the given function `fn` with arguments `args`
     *
     * @param {Function} fn
     * @param {...*} [args]
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var promise1 = vow.invoke(function(value) {
     *         return value;
     *     }, 'ok'),
     *     promise2 = vow.invoke(function() {
     *         throw Error();
     *     });
     *
     * promise1.isFulfilled(); // true
     * promise1.valueOf(); // 'ok'
     * promise2.isRejected(); // true
     * promise2.valueOf(); // instance of Error
     * ```
     */
    invoke: function invoke(fn, args) {
      var len = Math.max(arguments.length - 1, 0),
        callArgs;
      if (len) {
        // optimization for V8
        callArgs = Array(len);
        var i = 0;
        while (i < len) {
          callArgs[i++] = arguments[i];
        }
      }
      try {
        return vow.resolve(callArgs ? fn.apply(global, callArgs) : fn.call(global));
      } catch (e) {
        return vow.reject(e);
      }
    },
    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, the promise will be rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * with array:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise(), 3])
     *     .then(function(value) {
     *          // value is "[1, 2, 3]" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     *
     * @example
     * with object:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
     *     .then(function(value) {
     *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
     *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     */
    all: function all(iterable) {
      var defer = new Deferred(),
        isPromisesArray = isArray(iterable),
        keys = isPromisesArray ? getArrayKeys(iterable) : getObjectKeys(iterable),
        len = keys.length,
        res = isPromisesArray ? [] : {};
      if (!len) {
        defer.resolve(res);
        return defer.promise();
      }
      var i = len;
      vow._forEach(iterable, function (value, idx) {
        res[keys[idx]] = value;
        if (! --i) {
          defer.resolve(res);
        }
      }, defer.reject, defer.notify, defer, keys);
      return defer.promise();
    },
    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are resolved.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
     *     promise1.isRejected(); // returns true
     *     promise1.valueOf(); // returns "'error'"
     *     promise2.isFulfilled(); // returns true
     *     promise2.valueOf(); // returns "'ok'"
     * });
     *
     * defer1.reject('error');
     * defer2.resolve('ok');
     * ```
     */
    allResolved: function allResolved(iterable) {
      var defer = new Deferred(),
        isPromisesArray = isArray(iterable),
        keys = isPromisesArray ? getArrayKeys(iterable) : getObjectKeys(iterable),
        i = keys.length,
        res = isPromisesArray ? [] : {};
      if (!i) {
        defer.resolve(res);
        return defer.promise();
      }
      var onResolved = function onResolved() {
        --i || defer.resolve(iterable);
      };
      vow._forEach(iterable, onResolved, onResolved, defer.notify, defer, keys);
      return defer.promise();
    },
    allPatiently: function allPatiently(iterable) {
      return vow.allResolved(iterable).then(function () {
        var isPromisesArray = isArray(iterable),
          keys = isPromisesArray ? getArrayKeys(iterable) : getObjectKeys(iterable),
          rejectedPromises,
          fulfilledPromises,
          len = keys.length,
          i = 0,
          key,
          promise;
        if (!len) {
          return isPromisesArray ? [] : {};
        }
        while (i < len) {
          key = keys[i++];
          promise = iterable[key];
          if (vow.isRejected(promise)) {
            rejectedPromises || (rejectedPromises = isPromisesArray ? [] : {});
            isPromisesArray ? rejectedPromises.push(promise.valueOf()) : rejectedPromises[key] = promise.valueOf();
          } else if (!rejectedPromises) {
            (fulfilledPromises || (fulfilledPromises = isPromisesArray ? [] : {}))[key] = vow.valueOf(promise);
          }
        }
        if (rejectedPromises) {
          throw rejectedPromises;
        }
        return fulfilledPromises;
      });
    },
    /**
     * Returns a promise, that will be fulfilled if any of the items in `iterable` is fulfilled.
     * If all of the `iterable` items get rejected, the promise will be rejected (with the reason of the first rejected item).
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    any: function any(iterable) {
      var defer = new Deferred(),
        len = iterable.length;
      if (!len) {
        defer.reject(Error());
        return defer.promise();
      }
      var i = 0,
        reason;
      vow._forEach(iterable, defer.resolve, function (e) {
        i || (reason = e);
        ++i === len && defer.reject(reason);
      }, defer.notify, defer);
      return defer.promise();
    },
    /**
     * Returns a promise, that will be fulfilled only when any of the items in `iterable` is fulfilled.
     * If any of the `iterable` items gets rejected, the promise will be rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    anyResolved: function anyResolved(iterable) {
      var defer = new Deferred(),
        len = iterable.length;
      if (!len) {
        defer.reject(Error());
        return defer.promise();
      }
      vow._forEach(iterable, defer.resolve, defer.reject, defer.notify, defer);
      return defer.promise();
    },
    /**
     * Static equivalent to `promise.delay`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay: function delay(value, _delay2) {
      return vow.resolve(value).delay(_delay2);
    },
    /**
     * Static equivalent to `promise.timeout`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Number} timeout
     * @returns {vow:Promise}
     */
    timeout: function timeout(value, _timeout2) {
      return vow.resolve(value).timeout(_timeout2);
    },
    _forEach: function _forEach(promises, onFulfilled, onRejected, onProgress, ctx, keys) {
      var len = keys ? keys.length : promises.length,
        i = 0;
      while (i < len) {
        vow.when(promises[keys ? keys[i] : i], wrapOnFulfilled(onFulfilled, i), onRejected, onProgress, ctx);
        ++i;
      }
    },
    TimedOutError: defineCustomErrorType('TimedOut')
  };
  var defineAsGlobal = true;
  if (( false ? undefined : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {
    module.exports = vow;
    defineAsGlobal = false;
  }
  if ((typeof modules === "undefined" ? "undefined" : _typeof(modules)) === 'object' && isFunction(modules.define)) {
    modules.define('vow', function (provide) {
      provide(vow);
    });
    defineAsGlobal = false;
  }
  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, module) {
      module.exports = vow;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    defineAsGlobal = false;
  }
  defineAsGlobal && (global.vow = vow);
})(typeof window !== 'undefined' ? window : global);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ "./node_modules/node-libs-browser/node_modules/process/browser.js"), __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/w2ui/w2ui.js":
/*!***********************************!*\
  !*** ./node_modules/w2ui/w2ui.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($, jQuery) {function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/* w2ui 1.4.x (nightly) (c) http://w2ui.com, vitmalina@gmail.com */
var w2ui = w2ui || {};
var w2obj = w2obj || {}; // expose object to be able to overwrite default functions

/************************************************
*  Library: Web 2.0 UI for jQuery
*  - Following objects are defines
*        - w2ui             - object that will contain all widgets
*        - w2obj            - object with widget prototypes
*        - w2utils          - basic utilities
*        - $().w2render     - common render
*        - $().w2destroy    - common destroy
*        - $().w2marker     - marker plugin
*        - $().w2tag        - tag plugin
*        - $().w2overlay    - overlay plugin
*        - $().w2menu       - menu plugin
*        - w2utils.event    - generic event object
*        - w2utils.keyboard - object for keyboard navigation
*  - Dependencies: jQuery
*
* == NICE TO HAVE ==
*   - overlay should be displayed where more space (on top or on bottom)
*   - write and article how to replace certain framework functions
*   - onComplete should pass widget as context (this)
*   - add maxHeight for the w2menu
*   - user localization from another lib (make it generic), https://github.com/jquery/globalize#readme
*   - hidden and disabled in menus
*   - isTime should support seconds
*   - TEST On IOS
*
************************************************/

var w2utils = function () {
  var tmp = {}; // for some temp variables
  var obj = {
    version: '1.4.3',
    settings: {
      "locale": "en-us",
      "date_format": "m/d/yyyy",
      "date_display": "Mon d, yyyy",
      "time_format": "hh:mi pm",
      "currencyPrefix": "$",
      "currencySuffix": "",
      "currencyPrecision": 2,
      "groupSymbol": ",",
      "decimalSymbol": ".",
      "shortmonths": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      "fullmonths": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      "shortdays": ["M", "T", "W", "T", "F", "S", "S"],
      "fulldays": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
      "dataType": 'HTTP',
      // can be HTTP, RESTFULL, JSON (case sensative)
      "phrases": {} // empty object for english phrases
    },
    isInt: isInt,
    isFloat: isFloat,
    isMoney: isMoney,
    isHex: isHex,
    isAlphaNumeric: isAlphaNumeric,
    isEmail: isEmail,
    isDate: isDate,
    isTime: isTime,
    age: age,
    date: date,
    size: size,
    formatNumber: formatNumber,
    formatDate: formatDate,
    formatTime: formatTime,
    formatDateTime: formatDateTime,
    stripTags: stripTags,
    encodeTags: encodeTags,
    escapeId: escapeId,
    base64encode: base64encode,
    base64decode: base64decode,
    transition: transition,
    lock: lock,
    unlock: unlock,
    lang: lang,
    locale: locale,
    getSize: getSize,
    scrollBarSize: scrollBarSize,
    checkName: checkName,
    checkUniqueId: checkUniqueId,
    parseRoute: parseRoute,
    // some internal variables
    isIOS: navigator.userAgent.toLowerCase().indexOf('iphone') != -1 || navigator.userAgent.toLowerCase().indexOf('ipod') != -1 || navigator.userAgent.toLowerCase().indexOf('ipad') != -1 ? true : false,
    isIE: navigator.userAgent.toLowerCase().indexOf('msie') != -1 || navigator.userAgent.toLowerCase().indexOf('trident') != -1 ? true : false
  };
  return obj;
  function isInt(val) {
    var re = /^[-+]?[0-9]+$/;
    return re.test(val);
  }
  function isFloat(val) {
    if (typeof val == 'string') val = val.replace(w2utils.settings.decimalSymbol, '.');
    return (typeof val === 'number' || typeof val === 'string' && val !== '') && !isNaN(Number(val));
  }
  function isMoney(val) {
    var se = w2utils.settings;
    var re = new RegExp('^' + (se.currencyPrefix ? '\\' + se.currencyPrefix + '?' : '') + '[-+]?[0-9]*[\\' + w2utils.settings.decimalSymbol + ']?[0-9]+' + (se.currencySuffix ? '\\' + se.currencySuffix + '?' : '') + '$', 'i');
    if (typeof val === 'string') {
      val = val.replace(new RegExp(se.groupSymbol, 'g'), '');
    }
    if (_typeof(val) === 'object' || val === '') return false;
    return re.test(val);
  }
  function isHex(val) {
    var re = /^[a-fA-F0-9]+$/;
    return re.test(val);
  }
  function isAlphaNumeric(val) {
    var re = /^[a-zA-Z0-9_-]+$/;
    return re.test(val);
  }
  function isEmail(val) {
    var email = /^[a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
    return email.test(val);
  }
  function isDate(val, format, retDate) {
    if (!val) return false;
    var dt = 'Invalid Date';
    var month, day, year;
    if (format == null) format = w2utils.settings.date_format;
    if (typeof val.getUTCFullYear === 'function' && typeof val.getUTCMonth === 'function' && typeof val.getUTCDate === 'function') {
      year = val.getUTCFullYear();
      month = val.getUTCMonth();
      day = val.getUTCDate();
    } else if (typeof val.getFullYear === 'function' && typeof val.getMonth === 'function' && typeof val.getDate === 'function') {
      year = val.getFullYear();
      month = val.getMonth();
      day = val.getDate();
    } else {
      val = String(val);
      // convert month formats
      if (RegExp('mon', 'ig').test(format)) {
        format = format.replace(/month/ig, 'm').replace(/mon/ig, 'm').replace(/dd/ig, 'd').replace(/[, ]/ig, '/').replace(/\/\//g, '/').toLowerCase();
        val = val.replace(/[, ]/ig, '/').replace(/\/\//g, '/').toLowerCase();
        for (var m = 0, len = w2utils.settings.fullmonths.length; m < len; m++) {
          var t = w2utils.settings.fullmonths[m];
          val = val.replace(RegExp(t, 'ig'), parseInt(m) + 1).replace(RegExp(t.substr(0, 3), 'ig'), parseInt(m) + 1);
        }
      }
      // format date
      var tmp = val.replace(/-/g, '/').replace(/\./g, '/').toLowerCase().split('/');
      var tmp2 = format.replace(/-/g, '/').replace(/\./g, '/').toLowerCase();
      if (tmp2 === 'mm/dd/yyyy') {
        month = tmp[0];
        day = tmp[1];
        year = tmp[2];
      }
      if (tmp2 === 'm/d/yyyy') {
        month = tmp[0];
        day = tmp[1];
        year = tmp[2];
      }
      if (tmp2 === 'dd/mm/yyyy') {
        month = tmp[1];
        day = tmp[0];
        year = tmp[2];
      }
      if (tmp2 === 'd/m/yyyy') {
        month = tmp[1];
        day = tmp[0];
        year = tmp[2];
      }
      if (tmp2 === 'yyyy/dd/mm') {
        month = tmp[2];
        day = tmp[1];
        year = tmp[0];
      }
      if (tmp2 === 'yyyy/d/m') {
        month = tmp[2];
        day = tmp[1];
        year = tmp[0];
      }
      if (tmp2 === 'yyyy/mm/dd') {
        month = tmp[1];
        day = tmp[2];
        year = tmp[0];
      }
      if (tmp2 === 'yyyy/m/d') {
        month = tmp[1];
        day = tmp[2];
        year = tmp[0];
      }
      if (tmp2 === 'mm/dd/yy') {
        month = tmp[0];
        day = tmp[1];
        year = tmp[2];
      }
      if (tmp2 === 'm/d/yy') {
        month = tmp[0];
        day = tmp[1];
        year = parseInt(tmp[2]) + 1900;
      }
      if (tmp2 === 'dd/mm/yy') {
        month = tmp[1];
        day = tmp[0];
        year = parseInt(tmp[2]) + 1900;
      }
      if (tmp2 === 'd/m/yy') {
        month = tmp[1];
        day = tmp[0];
        year = parseInt(tmp[2]) + 1900;
      }
      if (tmp2 === 'yy/dd/mm') {
        month = tmp[2];
        day = tmp[1];
        year = parseInt(tmp[0]) + 1900;
      }
      if (tmp2 === 'yy/d/m') {
        month = tmp[2];
        day = tmp[1];
        year = parseInt(tmp[0]) + 1900;
      }
      if (tmp2 === 'yy/mm/dd') {
        month = tmp[1];
        day = tmp[2];
        year = parseInt(tmp[0]) + 1900;
      }
      if (tmp2 === 'yy/m/d') {
        month = tmp[1];
        day = tmp[2];
        year = parseInt(tmp[0]) + 1900;
      }
    }
    if (!isInt(year)) return false;
    if (!isInt(month)) return false;
    if (!isInt(day)) return false;
    year = +year;
    month = +month;
    day = +day;
    dt = new Date(year, month - 1, day);
    // do checks
    if (month == null) return false;
    if (String(dt) == 'Invalid Date') return false;
    if (dt.getMonth() + 1 !== month || dt.getDate() !== day || dt.getFullYear() !== year) return false;
    if (retDate === true) return dt;else return true;
  }
  function isTime(val, retTime) {
    // Both formats 10:20pm and 22:20
    if (val == null) return false;
    var max, pm;
    // -- process american format
    val = String(val);
    val = val.toUpperCase();
    pm = val.indexOf('PM') >= 0;
    var ampm = pm || val.indexOf('AM') >= 0;
    if (ampm) max = 12;else max = 24;
    val = val.replace('AM', '').replace('PM', '');
    val = $.trim(val);
    // ---
    var tmp = val.split(':');
    var h = parseInt(tmp[0] || 0),
      m = parseInt(tmp[1] || 0);
    // accept edge case: 3PM is a good timestamp, but 3 (without AM or PM) is NOT:
    if ((!ampm || tmp.length !== 1) && tmp.length !== 2) {
      return false;
    }
    if (tmp[0] === '' || h < 0 || h > max || !this.isInt(tmp[0]) || tmp[0].length > 2) {
      return false;
    }
    if (tmp.length === 2 && (tmp[1] === '' || m < 0 || m > 59 || !this.isInt(tmp[1]) || tmp[1].length !== 2)) {
      return false;
    }
    // check the edge cases: 12:01AM is ok, as is 12:01PM, but 24:01 is NOT ok while 24:00 is (midnight; equivalent to 00:00).
    // meanwhile, there is 00:00 which is ok, but 0AM nor 0PM are okay, while 0:01AM and 0:00AM are.
    if (!ampm && max === h && m !== 0) {
      return false;
    }
    if (ampm && tmp.length === 1 && h === 0) {
      return false;
    }
    if (retTime === true) {
      if (pm) h += 12;
      return {
        hours: h,
        minutes: m
      };
    }
    return true;
  }
  function age(dateStr) {
    if (dateStr === '' || dateStr == null) return '';
    var d1 = new Date(dateStr);
    if (w2utils.isInt(dateStr)) d1 = new Date(Number(dateStr)); // for unix timestamps
    if (String(d1) == 'Invalid Date') return '';
    var d2 = new Date();
    var sec = (d2.getTime() - d1.getTime()) / 1000;
    var amount = '';
    var type = '';
    if (sec < 0) {
      amount = '<span style="color: #aaa">future</span>';
      type = '';
    } else if (sec < 60) {
      amount = Math.floor(sec);
      type = 'sec';
      if (sec < 0) {
        amount = 0;
        type = 'sec';
      }
    } else if (sec < 60 * 60) {
      amount = Math.floor(sec / 60);
      type = 'min';
    } else if (sec < 24 * 60 * 60) {
      amount = Math.floor(sec / 60 / 60);
      type = 'hour';
    } else if (sec < 30 * 24 * 60 * 60) {
      amount = Math.floor(sec / 24 / 60 / 60);
      type = 'day';
    } else if (sec < 365.25 * 24 * 60 * 60) {
      amount = Math.floor(sec / 365.25 / 24 / 60 / 60 * 10) / 10;
      type = 'month';
    } else if (sec >= 365.25 * 24 * 60 * 60) {
      amount = Math.floor(sec / 365.25 / 24 / 60 / 60 * 10) / 10;
      type = 'year';
    }
    return amount + ' ' + type + (amount > 1 ? 's' : '');
  }
  function date(dateStr) {
    if (dateStr === '' || dateStr == null) return '';
    var d1 = new Date(dateStr);
    if (w2utils.isInt(dateStr)) d1 = new Date(Number(dateStr)); // for unix timestamps
    if (String(d1) == 'Invalid Date') return '';
    var months = w2utils.settings.shortmonths;
    var d2 = new Date(); // today
    var d3 = new Date();
    d3.setTime(d3.getTime() - 86400000); // yesterday

    var dd1 = months[d1.getMonth()] + ' ' + d1.getDate() + ', ' + d1.getFullYear();
    var dd2 = months[d2.getMonth()] + ' ' + d2.getDate() + ', ' + d2.getFullYear();
    var dd3 = months[d3.getMonth()] + ' ' + d3.getDate() + ', ' + d3.getFullYear();
    var time = d1.getHours() - (d1.getHours() > 12 ? 12 : 0) + ':' + (d1.getMinutes() < 10 ? '0' : '') + d1.getMinutes() + ' ' + (d1.getHours() >= 12 ? 'pm' : 'am');
    var time2 = d1.getHours() - (d1.getHours() > 12 ? 12 : 0) + ':' + (d1.getMinutes() < 10 ? '0' : '') + d1.getMinutes() + ':' + (d1.getSeconds() < 10 ? '0' : '') + d1.getSeconds() + ' ' + (d1.getHours() >= 12 ? 'pm' : 'am');
    var dsp = dd1;
    if (dd1 === dd2) dsp = time;
    if (dd1 === dd3) dsp = w2utils.lang('Yesterday');
    return '<span title="' + dd1 + ' ' + time2 + '">' + dsp + '</span>';
  }
  function size(sizeStr) {
    if (!w2utils.isFloat(sizeStr) || sizeStr === '') return '';
    sizeStr = parseFloat(sizeStr);
    if (sizeStr === 0) return 0;
    var sizes = ['Bt', 'KB', 'MB', 'GB', 'TB'];
    var i = parseInt(Math.floor(Math.log(sizeStr) / Math.log(1024)));
    return (Math.floor(sizeStr / Math.pow(1024, i) * 10) / 10).toFixed(i === 0 ? 0 : 1) + ' ' + sizes[i];
  }
  function formatNumber(val, groupSymbol, decimalSymbol) {
    var ret = '';
    if (groupSymbol == null) groupSymbol = w2utils.settings.groupSymbol || ',';
    if (decimalSymbol == null) decimalSymbol = w2utils.settings.decimalSymbol || '.';
    // check if this is a number
    if (w2utils.isFloat(val) || w2utils.isInt(val) || w2utils.isMoney(val)) {
      tmp = String(val).split('.');
      ret = String(tmp[0]).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + groupSymbol);
      if (tmp[1] != null) ret += w2utils.settings.decimalSymbol + tmp[1];
    }
    return ret;
  }
  function formatDate(dateStr, format) {
    // IMPORTANT dateStr HAS TO BE valid JavaScript Date String
    var months = w2utils.settings.shortmonths;
    var fullMonths = w2utils.settings.fullmonths;
    if (!format) format = this.settings.date_format;
    if (dateStr === '' || dateStr == null || _typeof(dateStr) == 'object' && !dateStr.getMonth) return '';
    var dt = new Date(dateStr);
    if (w2utils.isInt(dateStr)) dt = new Date(Number(dateStr)); // for unix timestamps
    if (String(dt) == 'Invalid Date') return '';
    var year = dt.getFullYear();
    var month = dt.getMonth();
    var date = dt.getDate();
    return format.toLowerCase().replace('month', w2utils.settings.fullmonths[month]).replace('mon', w2utils.settings.shortmonths[month]).replace(/yyyy/g, year).replace(/yyy/g, year).replace(/yy/g, year > 2000 ? 100 + parseInt(String(year).substr(2)) : String(year).substr(2)).replace(/(^|[^a-z$])y/g, '$1' + year) // only y's that are not preceeded by a letter
    .replace(/mm/g, (month + 1 < 10 ? '0' : '') + (month + 1)).replace(/dd/g, (date < 10 ? '0' : '') + date).replace(/th/g, date == 1 ? 'st' : 'th').replace(/th/g, date == 2 ? 'nd' : 'th').replace(/th/g, date == 3 ? 'rd' : 'th').replace(/(^|[^a-z$])m/g, '$1' + (month + 1)) // only y's that are not preceeded by a letter
    .replace(/(^|[^a-z$])d/g, '$1' + date); // only y's that are not preceeded by a letter
  }
  function formatTime(dateStr, format) {
    // IMPORTANT dateStr HAS TO BE valid JavaScript Date String
    var months = w2utils.settings.shortmonths;
    var fullMonths = w2utils.settings.fullmonths;
    if (!format) format = this.settings.time_format;
    if (dateStr === '' || dateStr == null || _typeof(dateStr) == 'object' && !dateStr.getMonth) return '';
    var dt = new Date(dateStr);
    if (w2utils.isInt(dateStr)) dt = new Date(Number(dateStr)); // for unix timestamps
    if (w2utils.isTime(dateStr)) {
      var tmp = w2utils.isTime(dateStr, true);
      dt = new Date();
      dt.setHours(tmp.hours);
      dt.setMinutes(tmp.minutes);
    }
    if (String(dt) == 'Invalid Date') return '';
    var type = 'am';
    var hour = dt.getHours();
    var h24 = dt.getHours();
    var min = dt.getMinutes();
    var sec = dt.getSeconds();
    if (min < 10) min = '0' + min;
    if (sec < 10) sec = '0' + sec;
    if (format.indexOf('am') !== -1 || format.indexOf('pm') !== -1) {
      if (hour >= 12) type = 'pm';
      if (hour > 12) hour = hour - 12;
    }
    return format.toLowerCase().replace('am', type).replace('pm', type).replace('hhh', hour < 10 ? '0' + hour : hour).replace('hh24', h24 < 10 ? '0' + h24 : h24).replace('h24', h24).replace('hh', hour).replace('mm', min).replace('mi', min).replace('ss', sec).replace(/(^|[^a-z$])h/g, '$1' + hour) // only y's that are not preceeded by a letter
    .replace(/(^|[^a-z$])m/g, '$1' + min) // only y's that are not preceeded by a letter
    .replace(/(^|[^a-z$])s/g, '$1' + sec); // only y's that are not preceeded by a letter
  }
  function formatDateTime(dateStr, format) {
    var fmt;
    if (dateStr === '' || dateStr == null || _typeof(dateStr) == 'object' && !dateStr.getMonth) return '';
    if (typeof format !== 'string') {
      fmt = [this.settings.date_format, this.settings.time_format];
    } else {
      fmt = format.split('|');
    }
    return this.formatDate(dateStr, fmt[0]) + ' ' + this.formatTime(dateStr, fmt[1]);
  }
  function stripTags(html) {
    if (html === null) return html;
    switch (_typeof(html)) {
      case 'number':
        break;
      case 'string':
        html = $.trim(String(html).replace(/(<([^>]+)>)/ig, ""));
        break;
      case 'object':
        for (var a in html) html[a] = this.stripTags(html[a]);
        break;
    }
    return html;
  }
  function encodeTags(html) {
    if (html === null) return html;
    switch (_typeof(html)) {
      case 'number':
        break;
      case 'string':
        html = String(html).replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
        break;
      case 'object':
        for (var a in html) html[a] = this.encodeTags(html[a]);
        break;
    }
    return html;
  }
  function escapeId(id) {
    if (id === '' || id == null) return '';
    return String(id).replace(/([;&,\.\+\*\~'`:"\!\^#$%@\[\]\(\)=<>\|\/? {}\\])/g, '\\$1');
  }
  function base64encode(input) {
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    input = utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
    }
    function utf8_encode(string) {
      var string = String(string).replace(/\r\n/g, "\n");
      var utftext = "";
      for (var n = 0; n < string.length; n++) {
        var c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if (c > 127 && c < 2048) {
          utftext += String.fromCharCode(c >> 6 | 192);
          utftext += String.fromCharCode(c & 63 | 128);
        } else {
          utftext += String.fromCharCode(c >> 12 | 224);
          utftext += String.fromCharCode(c >> 6 & 63 | 128);
          utftext += String.fromCharCode(c & 63 | 128);
        }
      }
      return utftext;
    }
    return output;
  }
  function base64decode(input) {
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    }
    output = utf8_decode(output);
    function utf8_decode(utftext) {
      var string = "";
      var i = 0;
      var c = 0,
        c2,
        c3;
      while (i < utftext.length) {
        c = utftext.charCodeAt(i);
        if (c < 128) {
          string += String.fromCharCode(c);
          i++;
        } else if (c > 191 && c < 224) {
          c2 = utftext.charCodeAt(i + 1);
          string += String.fromCharCode((c & 31) << 6 | c2 & 63);
          i += 2;
        } else {
          c2 = utftext.charCodeAt(i + 1);
          c3 = utftext.charCodeAt(i + 2);
          string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
          i += 3;
        }
      }
      return string;
    }
    return output;
  }
  function transition(div_old, div_new, type, callBack) {
    var width = $(div_old).width();
    var height = $(div_old).height();
    var time = 0.5;
    if (!div_old || !div_new) {
      console.log('ERROR: Cannot do transition when one of the divs is null');
      return;
    }
    div_old.parentNode.style.cssText += cross('perspective', '700px') + '; overflow: hidden;';
    div_old.style.cssText += '; position: absolute; z-index: 1019; ' + cross('backface-visibility', 'hidden');
    div_new.style.cssText += '; position: absolute; z-index: 1020; ' + cross('backface-visibility', 'hidden');
    switch (type) {
      case 'slide-left':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(' + width + 'px, 0, 0)', 'translate(' + width + 'px, 0)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + ';' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
          div_old.style.cssText += cross('transition', time + 's') + ';' + cross('transform', 'translate3d(-' + width + 'px, 0, 0)', 'translate(-' + width + 'px, 0)');
        }, 1);
        break;
      case 'slide-right':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(-' + width + 'px, 0, 0)', 'translate(-' + width + 'px, 0)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(0px, 0, 0)', 'translate(0px, 0)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(' + width + 'px, 0, 0)', 'translate(' + width + 'px, 0)');
        }, 1);
        break;
      case 'slide-down':
        // init divs
        div_old.style.cssText += 'overflow: hidden; z-index: 1; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; z-index: 0; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(0, ' + height + 'px, 0)', 'translate(0, ' + height + 'px)');
        }, 1);
        break;
      case 'slide-up':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, ' + height + 'px, 0)', 'translate(0, ' + height + 'px)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        }, 1);
        break;
      case 'flip-left':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateY(0deg)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateY(-180deg)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateY(0deg)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateY(180deg)');
        }, 1);
        break;
      case 'flip-right':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateY(0deg)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateY(180deg)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateY(0deg)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateY(-180deg)');
        }, 1);
        break;
      case 'flip-down':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateX(0deg)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateX(180deg)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateX(0deg)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateX(-180deg)');
        }, 1);
        break;
      case 'flip-up':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateX(0deg)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'rotateX(-180deg)');
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateX(0deg)');
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'rotateX(180deg)');
        }, 1);
        break;
      case 'pop-in':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)') + '; ' + cross('transform', 'scale(.8)') + '; opacity: 0;';
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'scale(1)') + '; opacity: 1;';
          div_old.style.cssText += cross('transition', time + 's') + ';';
        }, 1);
        break;
      case 'pop-out':
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)') + '; ' + cross('transform', 'scale(1)') + '; opacity: 1;';
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)') + '; opacity: 0;';
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; opacity: 1;';
          div_old.style.cssText += cross('transition', time + 's') + '; ' + cross('transform', 'scale(1.7)') + '; opacity: 0;';
        }, 1);
        break;
      default:
        // init divs
        div_old.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)');
        div_new.style.cssText += 'overflow: hidden; ' + cross('transform', 'translate3d(0, 0, 0)', 'translate(0, 0)') + '; opacity: 0;';
        $(div_new).show();
        // -- need a timing function because otherwise not working
        window.setTimeout(function () {
          div_new.style.cssText += cross('transition', time + 's') + '; opacity: 1;';
          div_old.style.cssText += cross('transition', time + 's');
        }, 1);
        break;
    }
    setTimeout(function () {
      if (type === 'slide-down') {
        $(div_old).css('z-index', '1019');
        $(div_new).css('z-index', '1020');
      }
      if (div_new) {
        $(div_new).css({
          'opacity': '1',
          '-webkit-transition': '',
          '-moz-transition': '',
          '-ms-transition': '',
          '-o-transition': '',
          '-webkit-transform': '',
          '-moz-transform': '',
          '-ms-transform': '',
          '-o-transform': '',
          '-webkit-backface-visibility': '',
          '-moz-backface-visibility': '',
          '-ms-backface-visibility': '',
          '-o-backface-visibility': ''
        });
      }
      if (div_old) {
        $(div_old).css({
          'opacity': '1',
          '-webkit-transition': '',
          '-moz-transition': '',
          '-ms-transition': '',
          '-o-transition': '',
          '-webkit-transform': '',
          '-moz-transform': '',
          '-ms-transform': '',
          '-o-transform': '',
          '-webkit-backface-visibility': '',
          '-moz-backface-visibility': '',
          '-ms-backface-visibility': '',
          '-o-backface-visibility': ''
        });
        if (div_old.parentNode) $(div_old.parentNode).css({
          '-webkit-perspective': '',
          '-moz-perspective': '',
          '-ms-perspective': '',
          '-o-perspective': ''
        });
      }
      if (typeof callBack === 'function') callBack();
    }, time * 1000);
    function cross(property, value, none_webkit_value) {
      var isWebkit = !!window.webkitURL; // jQuery no longer supports $.browser - RR
      if (!isWebkit && typeof none_webkit_value !== 'undefined') value = none_webkit_value;
      return ';' + property + ': ' + value + '; -webkit-' + property + ': ' + value + '; -moz-' + property + ': ' + value + '; ' + '-ms-' + property + ': ' + value + '; -o-' + property + ': ' + value + ';';
    }
  }
  function lock(box, msg, spinner) {
    var options = {};
    if (_typeof(msg) === 'object') {
      options = msg;
    } else {
      options.msg = msg;
      options.spinner = spinner;
    }
    if (!options.msg && options.msg !== 0) options.msg = '';
    w2utils.unlock(box);
    $(box).prepend('<div class="w2ui-lock"></div>' + '<div class="w2ui-lock-msg"></div>');
    var $lock = $(box).find('.w2ui-lock');
    var mess = $(box).find('.w2ui-lock-msg');
    if (!options.msg) mess.css({
      'background-color': 'transparent',
      'border': '0px'
    });
    if (options.spinner === true) options.msg = '<div class="w2ui-spinner" ' + (!options.msg ? 'style="width: 35px; height: 35px"' : '') + '></div>' + options.msg;
    if (options.opacity != null) $lock.css('opacity', options.opacity);
    if (typeof $lock.fadeIn == 'function') {
      $lock.fadeIn(200);
      mess.html(options.msg).fadeIn(200);
    } else {
      $lock.show();
      mess.html(options.msg).show(0);
    }
    // hide all tags (do not hide overlays as the form can be in overlay)
    $().w2tag();
  }
  function unlock(box) {
    $(box).find('.w2ui-lock').remove();
    $(box).find('.w2ui-lock-msg').remove();
  }
  function getSize(el, type) {
    var $el = $(el);
    var bwidth = {
      left: parseInt($el.css('border-left-width')) || 0,
      right: parseInt($el.css('border-right-width')) || 0,
      top: parseInt($el.css('border-top-width')) || 0,
      bottom: parseInt($el.css('border-bottom-width')) || 0
    };
    var mwidth = {
      left: parseInt($el.css('margin-left')) || 0,
      right: parseInt($el.css('margin-right')) || 0,
      top: parseInt($el.css('margin-top')) || 0,
      bottom: parseInt($el.css('margin-bottom')) || 0
    };
    var pwidth = {
      left: parseInt($el.css('padding-left')) || 0,
      right: parseInt($el.css('padding-right')) || 0,
      top: parseInt($el.css('padding-top')) || 0,
      bottom: parseInt($el.css('padding-bottom')) || 0
    };
    switch (type) {
      case 'top':
        return bwidth.top + mwidth.top + pwidth.top;
      case 'bottom':
        return bwidth.bottom + mwidth.bottom + pwidth.bottom;
      case 'left':
        return bwidth.left + mwidth.left + pwidth.left;
      case 'right':
        return bwidth.right + mwidth.right + pwidth.right;
      case 'width':
        return bwidth.left + bwidth.right + mwidth.left + mwidth.right + pwidth.left + pwidth.right + parseInt($el.width());
      case 'height':
        return bwidth.top + bwidth.bottom + mwidth.top + mwidth.bottom + pwidth.top + pwidth.bottom + parseInt($el.height());
      case '+width':
        return bwidth.left + bwidth.right + mwidth.left + mwidth.right + pwidth.left + pwidth.right;
      case '+height':
        return bwidth.top + bwidth.bottom + mwidth.top + mwidth.bottom + pwidth.top + pwidth.bottom;
    }
    return 0;
  }
  function lang(phrase) {
    var translation = this.settings.phrases[phrase];
    if (translation == null) return phrase;else return translation;
  }
  function locale(locale) {
    if (!locale) locale = 'en-us';
    if (locale.length === 5) locale = 'locale/' + locale + '.json';
    // load from the file
    $.ajax({
      url: locale,
      type: "GET",
      dataType: "JSON",
      async: false,
      cache: false,
      success: function success(data, status, xhr) {
        w2utils.settings = $.extend(true, w2utils.settings, data);
        // apply translation to some prototype functions
        var p = w2obj.grid.prototype;
        for (var b in p.buttons) {
          p.buttons[b].caption = w2utils.lang(p.buttons[b].caption);
          p.buttons[b].hint = w2utils.lang(p.buttons[b].hint);
        }
        p.msgDelete = w2utils.lang(p.msgDelete);
        p.msgNotJSON = w2utils.lang(p.msgNotJSON);
        p.msgRefresh = w2utils.lang(p.msgRefresh);
      },
      error: function error(xhr, status, msg) {
        console.log('ERROR: Cannot load locale ' + locale);
      }
    });
  }
  function scrollBarSize() {
    if (tmp.scrollBarSize) return tmp.scrollBarSize;
    var html = '<div id="_scrollbar_width" style="position: absolute; top: -300px; width: 100px; height: 100px; overflow-y: scroll;">' + '    <div style="height: 120px">1</div>' + '</div>';
    $('body').append(html);
    tmp.scrollBarSize = 100 - $('#_scrollbar_width > div').width();
    $('#_scrollbar_width').remove();
    if (String(navigator.userAgent).indexOf('MSIE') >= 0) tmp.scrollBarSize = tmp.scrollBarSize / 2; // need this for IE9+
    return tmp.scrollBarSize;
  }
  function checkName(params, component) {
    // was w2checkNameParam
    if (!params || typeof params.name === 'undefined') {
      console.log('ERROR: The parameter "name" is required but not supplied in $().' + component + '().');
      return false;
    }
    if (typeof w2ui[params.name] !== 'undefined') {
      console.log('ERROR: The parameter "name" is not unique. There are other objects already created with the same name (obj: ' + params.name + ').');
      return false;
    }
    if (!w2utils.isAlphaNumeric(params.name)) {
      console.log('ERROR: The parameter "name" has to be alpha-numeric (a-z, 0-9, dash and underscore). ');
      return false;
    }
    return true;
  }
  function checkUniqueId(id, items, itemsDecription, objName) {
    // was w2checkUniqueId
    if (!$.isArray(items)) items = [items];
    for (var i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        console.log('ERROR: The parameter "id=' + id + '" is not unique within the current ' + itemsDecription + '. (obj: ' + objName + ')');
        return false;
      }
    }
    return true;
  }
  function parseRoute(route) {
    var keys = [];
    var path = route.replace(/\/\(/g, '(?:/').replace(/\+/g, '__plus__').replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?/g, function (_, slash, format, key, capture, optional) {
      keys.push({
        name: key,
        optional: !!optional
      });
      slash = slash || '';
      return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || format && '([^/.]+?)' || '([^/]+?)') + ')' + (optional || '');
    }).replace(/([\/.])/g, '\\$1').replace(/__plus__/g, '(.+)').replace(/\*/g, '(.*)');
    return {
      path: new RegExp('^' + path + '$', 'i'),
      keys: keys
    };
  }
}();

/***********************************************************
*  Generic Event Object
*  --- This object is reused across all other
*  --- widgets in w2ui.
*
*********************************************************/

w2utils.event = {
  on: function on(eventData, handler) {
    if (!$.isPlainObject(eventData)) eventData = {
      type: eventData
    };
    eventData = $.extend({
      type: null,
      execute: 'before',
      target: null,
      onComplete: null
    }, eventData);
    if (!eventData.type) {
      console.log('ERROR: You must specify event type when calling .on() method of ' + this.name);
      return;
    }
    if (!handler) {
      console.log('ERROR: You must specify event handler function when calling .on() method of ' + this.name);
      return;
    }
    if (!$.isArray(this.handlers)) this.handlers = [];
    this.handlers.push({
      event: eventData,
      handler: handler
    });
  },
  off: function off(eventData, handler) {
    if (!$.isPlainObject(eventData)) eventData = {
      type: eventData
    };
    eventData = $.extend({}, {
      type: null,
      execute: 'before',
      target: null,
      onComplete: null
    }, eventData);
    if (!eventData.type) {
      console.log('ERROR: You must specify event type when calling .off() method of ' + this.name);
      return;
    }
    if (!handler) {
      handler = null;
    }
    // remove handlers
    var newHandlers = [];
    for (var h = 0, len = this.handlers.length; h < len; h++) {
      var t = this.handlers[h];
      if ((t.event.type === eventData.type || eventData.type === '*') && (t.event.target === eventData.target || eventData.target === null) && (t.handler === handler || handler === null)) {
        // match
      } else {
        newHandlers.push(t);
      }
    }
    this.handlers = newHandlers;
  },
  trigger: function trigger(eventData) {
    var eventData = $.extend({
      type: null,
      phase: 'before',
      target: null
    }, eventData, {
      isStopped: false,
      isCancelled: false,
      preventDefault: function preventDefault() {
        this.isCancelled = true;
      },
      stopPropagation: function stopPropagation() {
        this.isStopped = true;
      }
    });
    if (eventData.phase === 'before') eventData.onComplete = null;
    var args, fun, tmp;
    if (eventData.target == null) eventData.target = null;
    if (!$.isArray(this.handlers)) this.handlers = [];
    // process events in REVERSE order
    for (var h = this.handlers.length - 1; h >= 0; h--) {
      var item = this.handlers[h];
      if ((item.event.type === eventData.type || item.event.type === '*') && (item.event.target === eventData.target || item.event.target === null) && (item.event.execute === eventData.phase || item.event.execute === '*' || item.event.phase === '*')) {
        eventData = $.extend({}, item.event, eventData);
        // check handler arguments
        args = [];
        tmp = RegExp(/\((.*?)\)/).exec(item.handler);
        if (tmp) args = tmp[1].split(/\s*,\s*/);
        if (args.length === 2) {
          item.handler.call(this, eventData.target, eventData); // old way for back compatibility
        } else {
          item.handler.call(this, eventData); // new way
        }
        if (eventData.isStopped === true || eventData.stop === true) return eventData; // back compatibility eventData.stop === true
      }
    }
    // main object events
    var funName = 'on' + eventData.type.substr(0, 1).toUpperCase() + eventData.type.substr(1);
    if (eventData.phase === 'before' && typeof this[funName] === 'function') {
      fun = this[funName];
      // check handler arguments
      args = [];
      tmp = RegExp(/\((.*?)\)/).exec(fun);
      if (tmp) args = tmp[1].split(/\s*,\s*/);
      if (args.length === 2) {
        fun.call(this, eventData.target, eventData); // old way for back compatibility
      } else {
        fun.call(this, eventData); // new way
      }
      if (eventData.isStopped === true || eventData.stop === true) return eventData; // back compatibility eventData.stop === true
    }
    // item object events
    if (eventData.object != null && eventData.phase === 'before' && typeof eventData.object[funName] === 'function') {
      fun = eventData.object[funName];
      // check handler arguments
      args = [];
      tmp = RegExp(/\((.*?)\)/).exec(fun);
      if (tmp) args = tmp[1].split(/\s*,\s*/);
      if (args.length === 2) {
        fun.call(this, eventData.target, eventData); // old way for back compatibility
      } else {
        fun.call(this, eventData); // new way
      }
      if (eventData.isStopped === true || eventData.stop === true) return eventData;
    }
    // execute onComplete
    if (eventData.phase === 'after' && typeof eventData.onComplete === 'function') eventData.onComplete.call(this, eventData);
    return eventData;
  }
};

/***********************************************************
*  Common Keyboard Handler. Supported in
*  - grid
*  - sidebar
*  - popup
*
*********************************************************/

w2utils.keyboard = function (obj) {
  // private scope
  var w2ui_name = null;
  obj.active = active;
  obj.clear = clear;
  init();
  return obj;
  function init() {
    $(document).on('keydown', keydown);
    $(document).on('mousedown', mousedown);
  }
  function keydown(event) {
    var tag = event.target.tagName;
    if ($.inArray(tag, ['INPUT', 'SELECT', 'TEXTAREA']) !== -1) return;
    if ($(event.target).prop('contenteditable') === 'true') return;
    if (!w2ui_name) return;
    // pass to appropriate widget
    if (w2ui[w2ui_name] && typeof w2ui[w2ui_name].keydown === 'function') {
      w2ui[w2ui_name].keydown.call(w2ui[w2ui_name], event);
    }
  }
  function mousedown(event) {
    var tag = event.target.tagName;
    var obj = $(event.target).parents('.w2ui-reset');
    if (obj.length > 0) {
      var name = obj.attr('name');
      if (w2ui[name] && w2ui[name].keyboard) w2ui_name = name;
    }
  }
  function active(new_w2ui_name) {
    if (typeof new_w2ui_name !== 'undefined') w2ui_name = new_w2ui_name;
    return w2ui_name;
  }
  function clear() {
    w2ui_name = null;
  }
}({});

/***********************************************************
*  Commonly used plugins
*  --- used primarily in grid and form
*
*********************************************************/

(function () {
  $.fn.w2render = function (name) {
    if ($(this).length > 0) {
      if (typeof name === 'string' && w2ui[name]) w2ui[name].render($(this)[0]);
      if (_typeof(name) === 'object') name.render($(this)[0]);
    }
  };
  $.fn.w2destroy = function (name) {
    if (!name && this.length > 0) name = this.attr('name');
    if (typeof name === 'string' && w2ui[name]) w2ui[name].destroy();
    if (_typeof(name) === 'object') name.destroy();
  };
  $.fn.w2marker = function (str) {
    if (str === '' || str == null) {
      // remove marker
      return $(this).each(function (index, el) {
        el.innerHTML = el.innerHTML.replace(/\<span class=\"w2ui\-marker\"\>(.*)\<\/span\>/ig, '$1'); // unmark
      });
    } else {
      // add marker
      return $(this).each(function (index, el) {
        if (typeof str === 'string') str = [str];
        el.innerHTML = el.innerHTML.replace(/\<span class=\"w2ui\-marker\"\>(.*)\<\/span\>/ig, '$1'); // unmark
        for (var s in str) {
          var tmp = str[s];
          if (typeof tmp !== 'string') tmp = String(tmp);
          // escape regex special chars
          tmp = tmp.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&").replace(/&/g, '&amp;').replace(/</g, '&gt;').replace(/>/g, '&lt;');
          var regex = new RegExp(tmp + '(?!([^<]+)?>)', "gi"); // only outside tags
          el.innerHTML = el.innerHTML.replace(regex, replaceValue);
        }
        function replaceValue(matched) {
          // mark new
          return '<span class="w2ui-marker">' + matched + '</span>';
        }
      });
    }
  };

  // -- w2tag - appears on the right side from element, there can be multiple on screen at a time

  $.fn.w2tag = function (text, options) {
    if (!$.isPlainObject(options)) options = {};
    if (!$.isPlainObject(options.css)) options.css = {};
    if (typeof options['class'] === 'undefined') options['class'] = '';
    // remove all tags
    if ($(this).length === 0) {
      $('.w2ui-tag').each(function (index, elem) {
        var opt = $(elem).data('options');
        if (opt == null) opt = {};
        $($(elem).data('taged-el')).removeClass(opt['class']);
        clearInterval($(elem).data('timer'));
        $(elem).remove();
      });
      return;
    }
    return $(this).each(function (index, el) {
      // show or hide tag
      var tagOrigID = el.id;
      var tagID = w2utils.escapeId(el.id);
      if (text === '' || text == null) {
        $('#w2ui-tag-' + tagID).css('opacity', 0);
        setTimeout(function () {
          // remmove element
          clearInterval($('#w2ui-tag-' + tagID).data('timer'));
          $('#w2ui-tag-' + tagID).remove();
        }, 300);
      } else {
        // bind event to hide it
        var tmp_hide = function tmp_hide() {
          $tag = $('#w2ui-tag-' + tagID);
          if ($tag.length <= 0) return;
          clearInterval($tag.data('timer'));
          $tag.remove();
          $(el).off('keypress', tmp_hide).removeClass(options['class']);
          if ($(el).length > 0) $(el)[0].style.cssText = originalCSS;
          if (typeof options.onHide === 'function') options.onHide();
        };
        // remove elements
        clearInterval($('#w2ui-tag-' + tagID).data('timer'));
        $('#w2ui-tag-' + tagID).remove();
        // insert
        $('body').append('<div id="w2ui-tag-' + tagOrigID + '" class="w2ui-tag ' + ($(el).parents('.w2ui-popup').length > 0 ? 'w2ui-tag-popup' : '') + '" style=""></div>');
        var timer = setInterval(function () {
          // monitor if destroyed
          if ($(el).length === 0 || $(el).offset().left === 0 && $(el).offset().top === 0) {
            clearInterval($('#w2ui-tag-' + tagID).data('timer'));
            tmp_hide();
            return;
          }
          // monitor if moved
          if ($('#w2ui-tag-' + tagID).data('position') !== $(el).offset().left + el.offsetWidth + 'x' + $(el).offset().top) {
            $('#w2ui-tag-' + tagID).css({
              '-webkit-transition': '.2s',
              '-moz-transition': '.2s',
              '-ms-transition': '.2s',
              '-o-transition': '.2s',
              left: $(el).offset().left + el.offsetWidth + 'px',
              top: $(el).offset().top + 'px'
            }).data('position', $(el).offset().left + el.offsetWidth + 'x' + $(el).offset().top);
          }
        }, 100);
        setTimeout(function () {
          if (!$(el).offset()) return;
          $('#w2ui-tag-' + tagID).css({
            opacity: '1',
            left: $(el).offset().left + el.offsetWidth + 'px',
            top: $(el).offset().top + 'px'
          }).html('<div style="margin-top: -2px 0px 0px -2px; white-space: nowrap;"> <div class="w2ui-tag-body">' + text + '</div> </div>').data('text', text).data('taged-el', el).data('options', options).data('position', $(el).offset().left + el.offsetWidth + 'x' + $(el).offset().top).data('timer', timer);
          $(el).off('keypress', tmp_hide).on('keypress', tmp_hide).off('change', tmp_hide).on('change', tmp_hide).css(options.css).addClass(options['class']);
          if (typeof options.onShow === 'function') options.onShow();
        }, 1);
        var originalCSS = '';
        if ($(el).length > 0) originalCSS = $(el)[0].style.cssText;
      }
    });
  };

  // w2overlay - appears under the element, there can be only one at a time

  $.fn.w2overlay = function (html, options) {
    var obj = this;
    var name = '';
    var defaults = {
      name: null,
      // it not null, then allows multiple concurent overlays
      html: '',
      // html text to display
      align: 'none',
      // can be none, left, right, both
      left: 0,
      // offset left
      top: 0,
      // offset top
      tipLeft: 30,
      // tip offset left
      width: 0,
      // fixed width
      height: 0,
      // fixed height
      maxWidth: null,
      // max width if any
      maxHeight: null,
      // max height if any
      style: '',
      // additional style for main div
      'class': '',
      // additional class name for main div
      onShow: null,
      // event on show
      onHide: null,
      // event on hide
      openAbove: false,
      // show abover control
      tmp: {}
    };
    if (arguments.length == 1) {
      if (_typeof(html) == 'object') {
        options = html;
      } else {
        options = {
          html: html
        };
      }
    }
    if (arguments.length == 2) options.html = html;
    if (!$.isPlainObject(options)) options = {};
    options = $.extend({}, defaults, options);
    if (options.name) name = '-' + options.name;
    // if empty then hide
    var tmp_hide;
    if (this.length === 0 || options.html === '' || options.html == null) {
      if ($('#w2ui-overlay' + name).length > 0) {
        tmp_hide = $('#w2ui-overlay' + name)[0].hide;
        if (typeof tmp_hide === 'function') tmp_hide();
      } else {
        $('#w2ui-overlay' + name).remove();
      }
      return $(this);
    }
    if ($('#w2ui-overlay' + name).length > 0) {
      tmp_hide = $('#w2ui-overlay' + name)[0].hide;
      $(document).off('click', tmp_hide);
      if (typeof tmp_hide === 'function') tmp_hide();
    }
    $('body').append('<div id="w2ui-overlay' + name + '" style="display: none"' + '        class="w2ui-reset w2ui-overlay ' + ($(this).parents('.w2ui-popup, .w2ui-overlay-popup').length > 0 ? 'w2ui-overlay-popup' : '') + '">' + '    <style></style>' + '    <div style="' + options.style + '" class="' + options['class'] + '"></div>' + '</div>');
    // init
    var div1 = $('#w2ui-overlay' + name);
    var div2 = div1.find(' > div');
    div2.html(options.html);
    // pick bg color of first div
    var bc = div2.css('background-color');
    if (bc != null && bc !== 'rgba(0, 0, 0, 0)' && bc !== 'transparent') div1.css('background-color', bc);
    div1.data('element', obj.length > 0 ? obj[0] : null).data('options', options).data('position', $(obj).offset().left + 'x' + $(obj).offset().top).fadeIn('fast').on('mousedown', function (event) {
      $('#w2ui-overlay' + name).data('keepOpen', true);
      if (['INPUT', 'TEXTAREA', 'SELECT'].indexOf(event.target.tagName) === -1) event.preventDefault();
    });
    div1[0].hide = hide;
    div1[0].resize = resize;

    // need time to display
    resize();
    setTimeout(function () {
      resize();
      $(document).off('click', hide).on('click', hide);
      if (typeof options.onShow === 'function') options.onShow();
    }, 10);
    monitor();
    return $(this);

    // monitor position
    function monitor() {
      var tmp = $('#w2ui-overlay' + name);
      if (tmp.data('element') !== obj[0]) return; // it if it different overlay
      if (tmp.length === 0) return;
      var pos = $(obj).offset().left + 'x' + $(obj).offset().top;
      if (tmp.data('position') !== pos) {
        hide();
      } else {
        setTimeout(monitor, 250);
      }
    }

    // click anywhere else hides the drop down
    function hide() {
      var div1 = $('#w2ui-overlay' + name);
      if (div1.data('keepOpen') === true) {
        div1.removeData('keepOpen');
        return;
      }
      var result;
      if (typeof options.onHide === 'function') result = options.onHide();
      if (result === false) return;
      div1.remove();
      $(document).off('click', hide);
      clearInterval(div1.data('timer'));
    }
    function resize() {
      var div1 = $('#w2ui-overlay' + name);
      var div2 = div1.find(' > div');
      // if goes over the screen, limit height and width
      if (div1.length > 0) {
        div2.height('auto').width('auto');
        // width/height
        var overflowX = false;
        var overflowY = false;
        var h = div2.height();
        var w = div2.width();
        if (options.width && options.width < w) w = options.width;
        if (w < 30) w = 30;
        // if content of specific height
        if (options.tmp.contentHeight) {
          h = options.tmp.contentHeight;
          div2.height(h);
          setTimeout(function () {
            if (div2.height() > div2.find('div.menu > table').height()) {
              div2.find('div.menu').css('overflow-y', 'hidden');
            }
          }, 1);
          setTimeout(function () {
            div2.find('div.menu').css('overflow-y', 'auto');
          }, 10);
        }
        if (options.tmp.contentWidth) {
          w = options.tmp.contentWidth;
          div2.width(w);
          setTimeout(function () {
            if (div2.width() > div2.find('div.menu > table').width()) {
              div2.find('div.menu').css('overflow-x', 'hidden');
            }
          }, 1);
          setTimeout(function () {
            div2.find('div.menu').css('overflow-y', 'auto');
          }, 10);
        }
        // alignment
        switch (options.align) {
          case 'both':
            options.left = 17;
            if (options.width === 0) options.width = w2utils.getSize($(obj), 'width');
            break;
          case 'left':
            options.left = 17;
            break;
          case 'right':
            options.tipLeft = w - 45;
            options.left = w2utils.getSize($(obj), 'width') - w + 10;
            break;
        }
        // adjust position
        var tmp = (w - 17) / 2;
        var boxLeft = options.left;
        var boxWidth = options.width;
        var tipLeft = options.tipLeft;
        if (w === 30 && !boxWidth) boxWidth = 30;else boxWidth = options.width ? options.width : 'auto';
        if (tmp < 25) {
          boxLeft = 25 - tmp;
          tipLeft = Math.floor(tmp);
        }
        // Y coord
        div1.css({
          top: obj.offset().top + w2utils.getSize(obj, 'height') + options.top + 7 + 'px',
          left: (obj.offset().left > 25 ? obj.offset().left : 25) + boxLeft + 'px',
          'min-width': boxWidth,
          'min-height': options.height ? options.height : 'auto'
        });
        // $(window).height() - has a problem in FF20
        var maxHeight = window.innerHeight + $(document).scrollTop() - div2.offset().top - 7;
        var maxWidth = window.innerWidth + $(document).scrollLeft() - div2.offset().left - 7;
        if (maxHeight > -50 && maxHeight < 210 || options.openAbove === true) {
          // show on top
          maxHeight = div2.offset().top - $(document).scrollTop() - 7;
          if (options.maxHeight && maxHeight > options.maxHeight) maxHeight = options.maxHeight;
          if (h > maxHeight) {
            overflowY = true;
            div2.height(maxHeight).width(w).css({
              'overflow-y': 'auto'
            });
            h = maxHeight;
          }
          div1.css('top', $(obj).offset().top - h - 24 + options.top + 'px');
          div1.find('>style').html('#w2ui-overlay' + name + ':before { display: none; margin-left: ' + parseInt(tipLeft) + 'px; }' + '#w2ui-overlay' + name + ':after { display: block; margin-left: ' + parseInt(tipLeft) + 'px; }');
        } else {
          // show under
          if (options.maxHeight && maxHeight > options.maxHeight) maxHeight = options.maxHeight;
          if (h > maxHeight) {
            overflowY = true;
            div2.height(maxHeight).width(w).css({
              'overflow-y': 'auto'
            });
          }
          div1.find('>style').html('#w2ui-overlay' + name + ':before { display: block; margin-left: ' + parseInt(tipLeft) + 'px; }' + '#w2ui-overlay' + name + ':after { display: none; margin-left: ' + parseInt(tipLeft) + 'px; }');
        }
        // check width
        w = div2.width();
        maxWidth = window.innerWidth + $(document).scrollLeft() - div2.offset().left - 7;
        if (options.maxWidth && maxWidth > options.maxWidth) maxWidth = options.maxWidth;
        if (w > maxWidth && options.align !== 'both') {
          options.align = 'right';
          setTimeout(function () {
            resize();
          }, 1);
        }
        // check scroll bar
        if (overflowY && overflowX) div2.width(w + w2utils.scrollBarSize() + 2);
      }
    }
  };
  $.fn.w2menu = function (menu, options) {
    /*
    ITEM STRUCTURE
        item : {
            id       : null,
            text     : '',
            style    : '',
            img      : '',
            icon     : '',
            count    : '',
            hidden   : false,
            disabled : false
            ...
        }
    */
    var defaults = {
      index: null,
      // current selected
      items: [],
      render: null,
      msgNoItems: 'No items',
      onSelect: null,
      tmp: {}
    };
    var obj = this;
    var name = '';
    if (menu === 'refresh') {
      // if not show - call blur
      if ($('#w2ui-overlay' + name).length > 0) {
        options = $.extend($.fn.w2menuOptions, options);
        var scrTop = $('#w2ui-overlay' + name + ' div.menu').scrollTop();
        $('#w2ui-overlay' + name + ' div.menu').html(getMenuHTML());
        $('#w2ui-overlay' + name + ' div.menu').scrollTop(scrTop);
        mresize();
      } else {
        $(this).w2menu(options);
      }
    } else {
      if (arguments.length === 1) options = menu;else options.items = menu;
      if (_typeof(options) !== 'object') options = {};
      options = $.extend({}, defaults, options);
      $.fn.w2menuOptions = options;
      if (options.name) name = '-' + options.name;
      if (typeof options.select === 'function' && typeof options.onSelect !== 'function') options.onSelect = options.select;
      if (typeof options.onRender === 'function' && typeof options.render !== 'function') options.render = options.onRender;
      // since only one overlay can exist at a time
      $.fn.w2menuHandler = function (event, index) {
        if (typeof options.onSelect === 'function') {
          // need time so that menu first hides
          setTimeout(function () {
            options.onSelect({
              index: index,
              item: options.items[index],
              originalEvent: event
            });
          }, 10);
        }
        // do not uncomment (enum in grid search will not work)
        // setTimeout(function () { $(document).click(); }, 50);
      };
      var html = '';
      if (options.search) {
        html += '<div style="position: absolute; top: 0px; height: 40px; left: 0px; right: 0px; border-bottom: 1px solid silver; background-color: #ECECEC; padding: 8px 5px;">' + '    <div class="w2ui-icon icon-search" style="position: absolute; margin-top: 4px; margin-left: 6px; width: 11px; background-position: left !important;"></div>' + '    <input id="menu-search" type="text" style="width: 100%; outline: none; padding-left: 20px;" onclick="event.stopPropagation();">' + '</div>';
        options.style += ';background-color: #ECECEC';
        options.index = 0;
        for (var i in options.items) options.items[i].hidden = false;
      }
      html += '<div class="menu" style="position: absolute; top: ' + (options.search ? 40 : 0) + 'px; bottom: 0px; width: 100%; overflow: auto;">' + getMenuHTML() + '</div>';
      var ret = $(this).w2overlay(html, options);
      setTimeout(function () {
        $('#w2ui-overlay' + name + ' #menu-search').on('keyup', change).on('keydown', function (event) {
          // cancel tab key
          if (event.keyCode === 9) {
            event.stopPropagation();
            event.preventDefault();
          }
        });
        if (options.search) {
          if (['text', 'password'].indexOf($(obj)[0].type) != -1 || $(obj)[0].tagName == 'texarea') return;
          $('#w2ui-overlay' + name + ' #menu-search').focus();
        }
      }, 200);
      mresize();
      return ret;
    }
    function mresize() {
      setTimeout(function () {
        // show selected
        $('#w2ui-overlay' + name + ' tr.w2ui-selected').removeClass('w2ui-selected');
        var cur = $('#w2ui-overlay' + name + ' tr[index=' + options.index + ']');
        var scrTop = $('#w2ui-overlay' + name + ' div.menu').scrollTop();
        cur.addClass('w2ui-selected');
        if (options.tmp) options.tmp.contentHeight = $('#w2ui-overlay' + name + ' table').height() + (options.search ? 50 : 10);
        if (options.tmp) options.tmp.contentWidth = $('#w2ui-overlay' + name + ' table').width();
        if ($('#w2ui-overlay' + name).length > 0) $('#w2ui-overlay' + name)[0].resize();
        // scroll into view
        if (cur.length > 0) {
          var top = cur[0].offsetTop - 5; // 5 is margin top
          var el = $('#w2ui-overlay' + name + ' div.menu');
          var height = el.height();
          $('#w2ui-overlay' + name + ' div.menu').scrollTop(scrTop);
          if (top < scrTop || top + cur.height() > scrTop + height) {
            $('#w2ui-overlay' + name + ' div.menu').animate({
              'scrollTop': top - (height - cur.height() * 2) / 2
            }, 200, 'linear');
          }
        }
      }, 1);
    }
    function change(event) {
      var search = this.value;
      var key = event.keyCode;
      var cancel = false;
      switch (key) {
        case 13:
          // enter
          $('#w2ui-overlay' + name).remove();
          $.fn.w2menuHandler(event, options.index);
          break;
        case 9: // tab
        case 27:
          // escape
          $('#w2ui-overlay' + name).remove();
          $.fn.w2menuHandler(event, -1);
          break;
        case 38:
          // up
          options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
          options.index--;
          while (options.index > 0 && options.items[options.index].hidden) options.index--;
          if (options.index === 0 && options.items[options.index].hidden) {
            while (options.items[options.index] && options.items[options.index].hidden) options.index++;
          }
          if (options.index < 0) options.index = 0;
          cancel = true;
          break;
        case 40:
          // down
          options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
          options.index++;
          while (options.index < options.items.length - 1 && options.items[options.index].hidden) options.index++;
          if (options.index === options.items.length - 1 && options.items[options.index].hidden) {
            while (options.items[options.index] && options.items[options.index].hidden) options.index--;
          }
          if (options.index >= options.items.length) options.index = options.items.length - 1;
          cancel = true;
          break;
      }
      // filter
      if (!cancel) {
        var shown = 0;
        for (var i in options.items) {
          var item = options.items[i];
          var prefix = '';
          var suffix = '';
          if (['is', 'begins with'].indexOf(options.match) !== -1) prefix = '^';
          if (['is', 'ends with'].indexOf(options.match) !== -1) suffix = '$';
          try {
            var re = new RegExp(prefix + search + suffix, 'i');
            if (re.test(item.text) || item.text === '...') item.hidden = false;else item.hidden = true;
          } catch (e) {}
          // do not show selected items
          if (obj.type === 'enum' && $.inArray(item.id, ids) !== -1) item.hidden = true;
          if (item.hidden !== true) shown++;
        }
        options.index = 0;
        while (options.index < options.items.length - 1 && options.items[options.index].hidden) options.index++;
        if (shown <= 0) options.index = -1;
      }
      $(obj).w2menu('refresh', options);
      mresize();
    }
    function getMenuHTML() {
      if (options.spinner) {
        return '<table class="w2ui-drop-menu"><tr><td style="padding: 5px 10px 10px 10px; text-align: center">' + '    <div class="w2ui-spinner" style="width: 18px; height: 18px; position: relative; top: 5px;"></div> ' + '    <div style="display: inline-block; padding: 3px; color: #999;">' + w2utils.lang('Loading...') + '</div>' + '</td></tr></table>';
      }
      var count = 0;
      var menu_html = '<table cellspacing="0" cellpadding="0" class="w2ui-drop-menu">';
      var img = null,
        icon = null;
      for (var f = 0; f < options.items.length; f++) {
        var mitem = options.items[f];
        if (typeof mitem === 'string') {
          mitem = {
            id: mitem,
            text: mitem
          };
        } else {
          if (mitem.text != null && mitem.id == null) mitem.id = mitem.text;
          if (mitem.text == null && mitem.id != null) mitem.text = mitem.id;
          if (mitem.caption != null) mitem.text = mitem.caption;
          img = mitem.img;
          icon = mitem.icon;
          if (img == null) img = null;
          if (icon == null) icon = null;
        }
        if (mitem.hidden !== true) {
          var imgd = '';
          var txt = mitem.text;
          if (typeof options.render === 'function') txt = options.render(mitem, options);
          if (img) imgd = '<td class="menu-icon"><div class="w2ui-tb-image w2ui-icon ' + img + '"></div></td>';
          if (icon) imgd = '<td class="menu-icon" align="center"><span class="w2ui-icon ' + icon + '"></span></td>';
          // render only if non-empty
          if (typeof txt !== 'undefined' && txt !== '' && !/^-+$/.test(txt)) {
            var bg = count % 2 === 0 ? 'w2ui-item-even' : 'w2ui-item-odd';
            if (options.altRows !== true) bg = '';
            var colspan = 1;
            if (imgd == '') colspan++;
            if (mitem.count == null) colspan++;
            menu_html += '<tr index="' + f + '" style="' + (mitem.style ? mitem.style : '') + '" ' + '        class="' + bg + ' ' + (options.index === f ? 'w2ui-selected' : '') + ' ' + (mitem.disabled === true ? 'w2ui-disabled' : '') + '"' + '        onmousedown="$(this).parent().find(\'tr\').removeClass(\'w2ui-selected\'); $(this).addClass(\'w2ui-selected\');"' + '        onclick="event.stopPropagation(); ' + '               if (' + (mitem.disabled === true ? 'true' : 'false') + ') return;' + '               $(\'#w2ui-overlay' + name + '\').remove(); ' + '               $.fn.w2menuHandler(event, \'' + f + '\');">' + imgd + '   <td class="menu-text" colspan="' + colspan + '">' + txt + '</td>' + '   <td class="menu-count">' + (mitem.count != null ? '<span>' + mitem.count + '</span>' : '') + '</td>' + '</tr>';
            count++;
          } else {
            // horizontal line
            menu_html += '<tr><td colspan="2" style="padding: 6px; pointer-events: none"><div style="border-top: 1px solid silver;"></div></td></tr>';
          }
        }
        options.items[f] = mitem;
      }
      if (count === 0) {
        menu_html += '<tr><td style="padding: 13px; color: #999; text-align: center">' + options.msgNoItems + '</div></td></tr>';
      }
      menu_html += "</table>";
      return menu_html;
    }
  };
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2grid        - grid widget
*        - $().w2grid    - jQuery wrapper
*   - Dependencies: jQuery, w2utils, w2toolbar, w2fields, w2alert, w2confirm
*
* == NICE TO HAVE ==
*   - frozen columns
*   - add colspans
*   - allow this.total to be unknown (-1)
*   - column autosize based on largest content
*   - easy bubbles in the grid
*   - More than 2 layers of header groups
*   - reorder columns/records
*   - hidden searches could not be clearned by the user
*   - problem with .set() and arrays, array get extended too, but should be replaced
*   - move events into prototype
*   - add grid.focus()
*   - add showExtra, KickIn Infinite scroll when so many records
*   - after edit stay on the same record option
*   - allow render: function to be filters
*
************************************************************************/

(function () {
  var w2grid = function w2grid(options) {
    // public properties
    this.name = null;
    this.box = null; // HTML element that hold this element
    this.header = '';
    this.url = '';
    this.routeData = {}; // data for dynamic routes
    this.columns = []; // { field, caption, size, attr, render, hidden, gridMinWidth, editable }
    this.columnGroups = []; // { span: int, caption: 'string', master: true/false }
    this.records = []; // { recid: int(requied), field1: 'value1', ... fieldN: 'valueN', style: 'string', editable: true/false, summary: true/false, changes: object }
    this.summary = []; // arry of summary records, same structure as records array
    this.searches = []; // { type, caption, field, inTag, outTag, hidden }
    this.searchData = [];
    this.sortData = [];
    this.postData = {};
    this.toolbar = {}; // if not empty object; then it is toolbar object

    this.show = {
      header: false,
      toolbar: false,
      footer: false,
      columnHeaders: true,
      lineNumbers: false,
      expandColumn: false,
      selectColumn: false,
      emptyRecords: true,
      toolbarReload: true,
      toolbarColumns: true,
      toolbarSearch: true,
      toolbarAdd: false,
      toolbarEdit: false,
      toolbarDelete: false,
      toolbarSave: false,
      selectionBorder: true,
      recordTitles: true,
      skipRecords: true
    };
    this.autoLoad = true; // for infinite scroll
    this.fixedBody = true; // if false; then grid grows with data
    this.recordHeight = 24;
    this.keyboard = true;
    this.selectType = 'row'; // can be row|cell
    this.multiSearch = true;
    this.multiSelect = true;
    this.multiSort = true;
    this.reorderColumns = false;
    this.reorderRows = false;
    this.markSearch = true;
    this.total = 0; // server total
    this.limit = 100;
    this.offset = 0; // how many records to skip (for infinite scroll) when pulling from server
    this.style = '';
    this.ranges = [];
    this.menu = [];
    this.method = null; // if defined, then overwrited ajax method
    this.recid = null;
    this.parser = null;

    // events
    this.onAdd = null;
    this.onEdit = null;
    this.onRequest = null; // called on any server event
    this.onLoad = null;
    this.onDelete = null;
    this.onDeleted = null;
    this.onSubmit = null;
    this.onSave = null;
    this.onSelect = null;
    this.onUnselect = null;
    this.onClick = null;
    this.onDblClick = null;
    this.onContextMenu = null;
    this.onMenuClick = null; // when context menu item selected
    this.onColumnClick = null;
    this.onColumnResize = null;
    this.onSort = null;
    this.onSearch = null;
    this.onChange = null; // called when editable record is changed
    this.onRestore = null; // called when editable record is restored
    this.onExpand = null;
    this.onCollapse = null;
    this.onError = null;
    this.onKeydown = null;
    this.onToolbar = null; // all events from toolbar
    this.onColumnOnOff = null;
    this.onCopy = null;
    this.onPaste = null;
    this.onSelectionExtend = null;
    this.onEditField = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onReload = null;
    this.onResize = null;
    this.onDestroy = null;
    this.onStateSave = null;
    this.onStateRestore = null;

    // internal
    this.last = {
      field: 'all',
      caption: w2utils.lang('All Fields'),
      logic: 'OR',
      search: '',
      searchIds: [],
      selection: {
        indexes: [],
        columns: {}
      },
      multi: false,
      scrollTop: 0,
      scrollLeft: 0,
      sortData: null,
      sortCount: 0,
      xhr: null,
      range_start: null,
      range_end: null,
      sel_ind: null,
      sel_col: null,
      sel_type: null,
      edit_col: null
    };
    $.extend(true, this, w2obj.grid, options);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2grid = function (method) {
    if (_typeof(method) === 'object' || !method) {
      // check name parameter
      if (!w2utils.checkName(method, 'w2grid')) return;
      // remember items
      var columns = method.columns;
      var columnGroups = method.columnGroups;
      var records = method.records;
      var searches = method.searches;
      var searchData = method.searchData;
      var sortData = method.sortData;
      var postData = method.postData;
      var toolbar = method.toolbar;
      // extend items
      var object = new w2grid(method);
      $.extend(object, {
        postData: {},
        records: [],
        columns: [],
        searches: [],
        toolbar: {},
        sortData: [],
        searchData: [],
        handlers: []
      });
      if (object.onExpand != null) object.show.expandColumn = true;
      $.extend(true, object.toolbar, toolbar);
      // reassign variables
      for (var p in columns) object.columns[p] = $.extend(true, {}, columns[p]);
      for (var p in columnGroups) object.columnGroups[p] = $.extend(true, {}, columnGroups[p]);
      for (var p in searches) object.searches[p] = $.extend(true, {}, searches[p]);
      for (var p in searchData) object.searchData[p] = $.extend(true, {}, searchData[p]);
      for (var p in sortData) object.sortData[p] = $.extend(true, {}, sortData[p]);
      object.postData = $.extend(true, {}, postData);

      // check if there are records without recid
      for (var r in records) {
        if (records[r].recid == null || typeof records[r].recid == 'undefined') {
          console.log('ERROR: Cannot add records without recid. (obj: ' + object.name + ')');
          return;
        }
        object.records[r] = $.extend(true, {}, records[r]);
      }
      // add searches
      for (var c in object.columns) {
        var col = object.columns[c];
        if (typeof col.searchable == 'undefined' || object.getSearch(col.field) != null) continue;
        var stype = col.searchable;
        var attr = '';
        if (col.searchable === true) {
          stype = 'text';
          attr = 'size="20"';
        }
        object.addSearch({
          field: col.field,
          caption: col.caption,
          type: stype,
          attr: attr
        });
      }
      // init toolbar
      object.initToolbar();
      // render if necessary
      if ($(this).length !== 0) {
        object.render($(this)[0]);
      }
      // register new object
      w2ui[object.name] = object;
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2grid');
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2grid.prototype = {
    // ----
    // properties that need to be in prototype

    msgDelete: w2utils.lang('Are you sure you want to delete selected records?'),
    msgNotJSON: w2utils.lang('Returned data is not in valid JSON format.'),
    msgAJAXerror: w2utils.lang('AJAX error. See console for more details.'),
    msgRefresh: w2utils.lang('Refreshing...'),
    // for easy button overwrite
    buttons: {
      'reload': {
        type: 'button',
        id: 'w2ui-reload',
        icon: 'w2ui-icon-reload',
        hint: w2utils.lang('Reload data in the list')
      },
      'columns': {
        type: 'drop',
        id: 'w2ui-column-on-off',
        icon: 'w2ui-icon-columns',
        hint: w2utils.lang('Show/hide columns'),
        arrow: false,
        html: ''
      },
      'search': {
        type: 'html',
        id: 'w2ui-search',
        html: '<div class="w2ui-icon icon-search-down w2ui-search-down" title="' + 'Select Search Field' + '" ' + 'onclick="var obj = w2ui[$(this).parents(\'div.w2ui-grid\').attr(\'name\')]; obj.searchShowFields();"></div>'
      },
      'search-go': {
        type: 'check',
        id: 'w2ui-search-advanced',
        caption: w2utils.lang('Search...'),
        hint: w2utils.lang('Open Search Fields')
      },
      'add': {
        type: 'button',
        id: 'w2ui-add',
        caption: w2utils.lang('Add New'),
        hint: w2utils.lang('Add new record'),
        icon: 'w2ui-icon-plus'
      },
      'edit': {
        type: 'button',
        id: 'w2ui-edit',
        caption: w2utils.lang('Edit'),
        hint: w2utils.lang('Edit selected record'),
        icon: 'w2ui-icon-pencil',
        disabled: true
      },
      'delete': {
        type: 'button',
        id: 'w2ui-delete',
        caption: w2utils.lang('Delete'),
        hint: w2utils.lang('Delete selected records'),
        icon: 'w2ui-icon-cross',
        disabled: true
      },
      'save': {
        type: 'button',
        id: 'w2ui-save',
        caption: w2utils.lang('Save'),
        hint: w2utils.lang('Save changed records'),
        icon: 'w2ui-icon-check'
      }
    },
    add: function add(record) {
      if (!$.isArray(record)) record = [record];
      var added = 0;
      for (var o in record) {
        if (this.recid && typeof record[o].recid == 'undefined') record[o].recid = record[o][this.recid];
        if (record[o].recid == null || typeof record[o].recid == 'undefined') {
          console.log('ERROR: Cannot add record without recid. (obj: ' + this.name + ')');
          continue;
        }
        this.records.push(record[o]);
        added++;
      }
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (!url) {
        this.total = this.records.length;
        this.localSort();
        this.localSearch();
      }
      this.refresh(); // ??  should it be reload?
      return added;
    },
    find: function find(obj, returnIndex) {
      if (typeof obj == 'undefined' || obj == null) obj = {};
      var recs = [];
      var hasDots = false;
      // check if property is nested - needed for speed
      for (var o in obj) if (String(o).indexOf('.') != -1) hasDots = true;
      // look for an item
      for (var i = 0; i < this.records.length; i++) {
        var match = true;
        for (var o in obj) {
          var val = this.records[i][o];
          if (hasDots && String(o).indexOf('.') != -1) val = this.parseField(this.records[i], o);
          if (obj[o] !== val) match = false;
        }
        if (match && returnIndex !== true) recs.push(this.records[i].recid);
        if (match && returnIndex === true) recs.push(i);
      }
      return recs;
    },
    set: function set(recid, record, noRefresh) {
      // does not delete existing, but overrides on top of it
      if (_typeof(recid) == 'object') {
        noRefresh = record;
        record = recid;
        recid = null;
      }
      // update all records
      if (recid == null) {
        for (var r in this.records) {
          $.extend(true, this.records[r], record); // recid is the whole record
        }
        if (noRefresh !== true) this.refresh();
      } else {
        // find record to update
        var ind = this.get(recid, true);
        if (ind == null) return false;
        var isSummary = this.records[ind] && this.records[ind].recid == recid ? false : true;
        if (isSummary) {
          $.extend(true, this.summary[ind], record);
        } else {
          $.extend(true, this.records[ind], record);
        }
        if (noRefresh !== true) this.refreshRow(recid); // refresh only that record
      }
      return true;
    },
    get: function get(recid, returnIndex) {
      // search records
      for (var i = 0; i < this.records.length; i++) {
        if (this.records[i].recid == recid) {
          if (returnIndex === true) return i;else return this.records[i];
        }
      }
      // search summary
      for (var i = 0; i < this.summary.length; i++) {
        if (this.summary[i].recid == recid) {
          if (returnIndex === true) return i;else return this.summary[i];
        }
      }
      return null;
    },
    remove: function remove() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.records.length - 1; r >= 0; r--) {
          if (this.records[r].recid == arguments[a]) {
            this.records.splice(r, 1);
            removed++;
          }
        }
      }
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (!url) {
        this.localSort();
        this.localSearch();
      }
      this.refresh();
      return removed;
    },
    addColumn: function addColumn(before, columns) {
      var added = 0;
      if (arguments.length == 1) {
        columns = before;
        before = this.columns.length;
      } else {
        if (typeof before == 'string') before = this.getColumn(before, true);
        if (before === null) before = this.columns.length;
      }
      if (!$.isArray(columns)) columns = [columns];
      for (var o in columns) {
        this.columns.splice(before, 0, columns[o]);
        before++;
        added++;
      }
      this.refresh();
      return added;
    },
    removeColumn: function removeColumn() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.columns.length - 1; r >= 0; r--) {
          if (this.columns[r].field == arguments[a]) {
            this.columns.splice(r, 1);
            removed++;
          }
        }
      }
      this.refresh();
      return removed;
    },
    getColumn: function getColumn(field, returnIndex) {
      for (var i = 0; i < this.columns.length; i++) {
        if (this.columns[i].field == field) {
          if (returnIndex === true) return i;else return this.columns[i];
        }
      }
      return null;
    },
    toggleColumn: function toggleColumn() {
      var effected = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.columns.length - 1; r >= 0; r--) {
          var col = this.columns[r];
          if (col.field == arguments[a]) {
            col.hidden = !col.hidden;
            effected++;
          }
        }
      }
      this.refresh();
      return effected;
    },
    showColumn: function showColumn() {
      var shown = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.columns.length - 1; r >= 0; r--) {
          var col = this.columns[r];
          if (col.gridMinWidth) delete col.gridMinWidth;
          if (col.field == arguments[a] && col.hidden !== false) {
            col.hidden = false;
            shown++;
          }
        }
      }
      this.refresh();
      return shown;
    },
    hideColumn: function hideColumn() {
      var hidden = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.columns.length - 1; r >= 0; r--) {
          var col = this.columns[r];
          if (col.field == arguments[a] && col.hidden !== true) {
            col.hidden = true;
            hidden++;
          }
        }
      }
      this.refresh();
      return hidden;
    },
    addSearch: function addSearch(before, search) {
      var added = 0;
      if (arguments.length == 1) {
        search = before;
        before = this.searches.length;
      } else {
        if (typeof before == 'string') before = this.getSearch(before, true);
        if (before === null) before = this.searches.length;
      }
      if (!$.isArray(search)) search = [search];
      for (var o in search) {
        this.searches.splice(before, 0, search[o]);
        before++;
        added++;
      }
      this.searchClose();
      return added;
    },
    removeSearch: function removeSearch() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.searches.length - 1; r >= 0; r--) {
          if (this.searches[r].field == arguments[a]) {
            this.searches.splice(r, 1);
            removed++;
          }
        }
      }
      this.searchClose();
      return removed;
    },
    getSearch: function getSearch(field, returnIndex) {
      for (var i = 0; i < this.searches.length; i++) {
        if (this.searches[i].field == field) {
          if (returnIndex === true) return i;else return this.searches[i];
        }
      }
      return null;
    },
    toggleSearch: function toggleSearch() {
      var effected = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.searches.length - 1; r >= 0; r--) {
          if (this.searches[r].field == arguments[a]) {
            this.searches[r].hidden = !this.searches[r].hidden;
            effected++;
          }
        }
      }
      this.searchClose();
      return effected;
    },
    showSearch: function showSearch() {
      var shown = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.searches.length - 1; r >= 0; r--) {
          if (this.searches[r].field == arguments[a] && this.searches[r].hidden !== false) {
            this.searches[r].hidden = false;
            shown++;
          }
        }
      }
      this.searchClose();
      return shown;
    },
    hideSearch: function hideSearch() {
      var hidden = 0;
      for (var a = 0; a < arguments.length; a++) {
        for (var r = this.searches.length - 1; r >= 0; r--) {
          if (this.searches[r].field == arguments[a] && this.searches[r].hidden !== true) {
            this.searches[r].hidden = true;
            hidden++;
          }
        }
      }
      this.searchClose();
      return hidden;
    },
    getSearchData: function getSearchData(field) {
      for (var s in this.searchData) {
        if (this.searchData[s].field == field) return this.searchData[s];
      }
      return null;
    },
    localSort: function localSort(silent) {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url) {
        console.log('ERROR: grid.localSort can only be used on local data source, grid.url should be empty.');
        return;
      }
      if ($.isEmptyObject(this.sortData)) return;
      var time = new Date().getTime();
      var obj = this;
      // process date fields
      obj.prepareData();
      // process sortData
      for (var s in this.sortData) {
        var column = this.getColumn(this.sortData[s].field);
        if (!column) return;
        if (typeof column.render == 'string') {
          if (['date', 'age'].indexOf(column.render.split(':')[0]) != -1) {
            this.sortData[s]['field_'] = column.field + '_';
          }
          if (['time'].indexOf(column.render.split(':')[0]) != -1) {
            this.sortData[s]['field_'] = column.field + '_';
          }
        }
      }
      // process sort
      this.records.sort(function (a, b) {
        var ret = 0;
        for (var s in obj.sortData) {
          var fld = obj.sortData[s].field;
          if (obj.sortData[s].field_) fld = obj.sortData[s].field_;
          var aa = a[fld];
          var bb = b[fld];
          if (String(fld).indexOf('.') != -1) {
            aa = obj.parseField(a, fld);
            bb = obj.parseField(b, fld);
          }
          if (typeof aa == 'string') aa = $.trim(aa.toLowerCase());
          if (typeof bb == 'string') bb = $.trim(bb.toLowerCase());
          if (aa > bb) ret = obj.sortData[s].direction == 'asc' ? 1 : -1;
          if (aa < bb) ret = obj.sortData[s].direction == 'asc' ? -1 : 1;
          if (_typeof(aa) != 'object' && _typeof(bb) == 'object') ret = -1;
          if (_typeof(bb) != 'object' && _typeof(aa) == 'object') ret = 1;
          if (aa == null && bb != null) ret = 1; // all nuls and undefined on bottom
          if (aa != null && bb == null) ret = -1;
          if (ret != 0) break;
        }
        return ret;
      });
      time = new Date().getTime() - time;
      if (silent !== true) setTimeout(function () {
        obj.status(w2utils.lang('Sorting took') + ' ' + time / 1000 + ' ' + w2utils.lang('sec'));
      }, 10);
      return time;
    },
    localSearch: function localSearch(silent) {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url) {
        console.log('ERROR: grid.localSearch can only be used on local data source, grid.url should be empty.');
        return;
      }
      var time = new Date().getTime();
      var obj = this;
      this.total = this.records.length;
      // mark all records as shown
      this.last.searchIds = [];
      // prepare date/time fields
      this.prepareData();
      // hide records that did not match
      if (this.searchData.length > 0 && !url) {
        this.total = 0;
        for (var r in this.records) {
          var rec = this.records[r];
          var fl = 0;
          for (var s in this.searchData) {
            var sdata = this.searchData[s];
            var search = this.getSearch(sdata.field);
            if (sdata == null) continue;
            if (search == null) search = {
              field: sdata.field,
              type: sdata.type
            };
            var val1 = String(obj.parseField(rec, search.field)).toLowerCase();
            if (typeof sdata.value != 'undefined') {
              if (!$.isArray(sdata.value)) {
                var val2 = String(sdata.value).toLowerCase();
              } else {
                var val2 = sdata.value[0];
                var val3 = sdata.value[1];
              }
            }
            switch (sdata.operator) {
              case 'is':
                if (rec[search.field] == sdata.value) fl++; // do not hide record
                if (search.type == 'date') {
                  var val1 = w2utils.formatDate(rec[search.field + '_'], 'yyyy-mm-dd');
                  var val2 = w2utils.formatDate(val2, 'yyyy-mm-dd');
                  if (val1 == val2) fl++;
                }
                if (search.type == 'time') {
                  var val1 = w2utils.formatTime(rec[search.field + '_'], 'h24:mi');
                  var val2 = w2utils.formatTime(val2, 'h24:mi');
                  if (val1 == val2) fl++;
                }
                break;
              case 'between':
                if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
                  if (parseFloat(rec[search.field]) >= parseFloat(val2) && parseFloat(rec[search.field]) <= parseFloat(val3)) fl++;
                }
                if (search.type == 'date') {
                  var val1 = rec[search.field + '_'];
                  var val2 = w2utils.isDate(val2, w2utils.settings.date_format, true);
                  var val3 = w2utils.isDate(val3, w2utils.settings.date_format, true);
                  if (val3 != null) val3 = new Date(val3.getTime() + 86400000); // 1 day
                  if (val1 >= val2 && val1 < val3) fl++;
                }
                if (search.type == 'time') {
                  var val1 = rec[search.field + '_'];
                  var val2 = w2utils.isTime(val2, true);
                  var val3 = w2utils.isTime(val3, true);
                  val2 = new Date().setHours(val2.hours, val2.minutes, val2.seconds ? val2.seconds : 0, 0);
                  val3 = new Date().setHours(val3.hours, val3.minutes, val3.seconds ? val3.seconds : 0, 0);
                  if (val1 >= val2 && val1 < val3) fl++;
                }
                break;
              case 'in':
                var tmp = sdata.value;
                if (sdata.svalue) tmp = sdata.svalue;
                if (tmp.indexOf(val1) !== -1) fl++;
                break;
              case 'not in':
                var tmp = sdata.value;
                if (sdata.svalue) tmp = sdata.svalue;
                if (tmp.indexOf(val1) == -1) fl++;
                break;
              case 'begins':
              case 'begins with':
                // need for back compatib.
                if (val1.indexOf(val2) == 0) fl++; // do not hide record
                break;
              case 'contains':
                if (val1.indexOf(val2) >= 0) fl++; // do not hide record
                break;
              case 'ends':
              case 'ends with':
                // need for back compatib.
                if (val1.indexOf(val2) >= 0 && val1.indexOf(val2) == val1.length - val2.length) fl++; // do not hide record
                break;
            }
          }
          if (this.last.logic == 'OR' && fl != 0 || this.last.logic == 'AND' && fl == this.searchData.length) this.last.searchIds.push(parseInt(r));
        }
        this.total = this.last.searchIds.length;
      }
      time = new Date().getTime() - time;
      if (silent !== true) setTimeout(function () {
        obj.status(w2utils.lang('Search took') + ' ' + time / 1000 + ' ' + w2utils.lang('sec'));
      }, 10);
      return time;
    },
    getRangeData: function getRangeData(range, extra) {
      var rec1 = this.get(range[0].recid, true);
      var rec2 = this.get(range[1].recid, true);
      var col1 = range[0].column;
      var col2 = range[1].column;
      var res = [];
      if (col1 == col2) {
        // one row
        for (var r = rec1; r <= rec2; r++) {
          var record = this.records[r];
          var dt = record[this.columns[col1].field] || null;
          if (extra !== true) {
            res.push(dt);
          } else {
            res.push({
              data: dt,
              column: col1,
              index: r,
              record: record
            });
          }
        }
      } else if (rec1 == rec2) {
        // one line
        var record = this.records[rec1];
        for (var i = col1; i <= col2; i++) {
          var dt = record[this.columns[i].field] || null;
          if (extra !== true) {
            res.push(dt);
          } else {
            res.push({
              data: dt,
              column: i,
              index: rec1,
              record: record
            });
          }
        }
      } else {
        for (var r = rec1; r <= rec2; r++) {
          var record = this.records[r];
          res.push([]);
          for (var i = col1; i <= col2; i++) {
            var dt = record[this.columns[i].field];
            if (extra !== true) {
              res[res.length - 1].push(dt);
            } else {
              res[res.length - 1].push({
                data: dt,
                column: i,
                index: r,
                record: record
              });
            }
          }
        }
      }
      return res;
    },
    addRange: function addRange(ranges) {
      var added = 0;
      if (this.selectType == 'row') return added;
      if (!$.isArray(ranges)) ranges = [ranges];
      // if it is selection
      for (var r in ranges) {
        if (_typeof(ranges[r]) != 'object') ranges[r] = {
          name: 'selection'
        };
        if (ranges[r].name == 'selection') {
          if (this.show.selectionBorder === false) continue;
          var sel = this.getSelection();
          if (sel.length == 0) {
            this.removeRange(ranges[r].name);
            continue;
          } else {
            var first = sel[0];
            var last = sel[sel.length - 1];
            var td1 = $('#grid_' + this.name + '_rec_' + first.recid + ' td[col=' + first.column + ']');
            var td2 = $('#grid_' + this.name + '_rec_' + last.recid + ' td[col=' + last.column + ']');
          }
        } else {
          // other range
          var first = ranges[r].range[0];
          var last = ranges[r].range[1];
          var td1 = $('#grid_' + this.name + '_rec_' + first.recid + ' td[col=' + first.column + ']');
          var td2 = $('#grid_' + this.name + '_rec_' + last.recid + ' td[col=' + last.column + ']');
        }
        if (first) {
          var rg = {
            name: ranges[r].name,
            range: [{
              recid: first.recid,
              column: first.column
            }, {
              recid: last.recid,
              column: last.column
            }],
            style: ranges[r].style || ''
          };
          // add range
          var ind = false;
          for (var t in this.ranges) if (this.ranges[t].name == ranges[r].name) {
            ind = r;
            break;
          }
          if (ind !== false) {
            this.ranges[ind] = rg;
          } else {
            this.ranges.push(rg);
          }
          added++;
        }
      }
      this.refreshRanges();
      return added;
    },
    removeRange: function removeRange() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        var name = arguments[a];
        $('#grid_' + this.name + '_' + name).remove();
        for (var r = this.ranges.length - 1; r >= 0; r--) {
          if (this.ranges[r].name == name) {
            this.ranges.splice(r, 1);
            removed++;
          }
        }
      }
      return removed;
    },
    refreshRanges: function refreshRanges() {
      var obj = this;
      var time = new Date().getTime();
      var rec = $('#grid_' + this.name + '_records');
      for (var r in this.ranges) {
        var rg = this.ranges[r];
        var first = rg.range[0];
        var last = rg.range[1];
        var td1 = $('#grid_' + this.name + '_rec_' + first.recid + ' td[col=' + first.column + ']');
        var td2 = $('#grid_' + this.name + '_rec_' + last.recid + ' td[col=' + last.column + ']');
        if ($('#grid_' + this.name + '_' + rg.name).length == 0) {
          rec.append('<div id="grid_' + this.name + '_' + rg.name + '" class="w2ui-selection" style="' + rg.style + '">' + (rg.name == 'selection' ? '<div id="grid_' + this.name + '_resizer" class="w2ui-selection-resizer"></div>' : '') + '</div>');
        } else {
          $('#grid_' + this.name + '_' + rg.name).attr('style', rg.style);
        }
        if (td1.length > 0 && td2.length > 0) {
          $('#grid_' + this.name + '_' + rg.name).css({
            left: td1.position().left - 1 + rec.scrollLeft() + 'px',
            top: td1.position().top - 1 + rec.scrollTop() + 'px',
            width: td2.position().left - td1.position().left + td2.width() + 3 + 'px',
            height: td2.position().top - td1.position().top + td2.height() + 3 + 'px'
          });
        }
      }

      // add resizer events
      $(this.box).find('#grid_' + this.name + '_resizer').off('mousedown').on('mousedown', mouseStart);
      //$(this.box).find('#grid_'+ this.name +'_resizer').off('selectstart').on('selectstart', function () { return false; }); // fixes chrome cursror bug

      var eventData = {
        phase: 'before',
        type: 'selectionExtend',
        target: obj.name,
        originalRange: null,
        newRange: null
      };
      function mouseStart(event) {
        var sel = obj.getSelection();
        obj.last.move = {
          type: 'expand',
          x: event.screenX,
          y: event.screenY,
          divX: 0,
          divY: 0,
          recid: sel[0].recid,
          column: sel[0].column,
          originalRange: [{
            recid: sel[0].recid,
            column: sel[0].column
          }, {
            recid: sel[sel.length - 1].recid,
            column: sel[sel.length - 1].column
          }],
          newRange: [{
            recid: sel[0].recid,
            column: sel[0].column
          }, {
            recid: sel[sel.length - 1].recid,
            column: sel[sel.length - 1].column
          }]
        };
        $(document).off('mousemove', mouseMove).on('mousemove', mouseMove);
        $(document).off('mouseup', mouseStop).on('mouseup', mouseStop);
      }
      function mouseMove(event) {
        var mv = obj.last.move;
        if (!mv || mv.type != 'expand') return;
        mv.divX = event.screenX - mv.x;
        mv.divY = event.screenY - mv.y;
        // find new cell
        var recid, column;
        var tmp = event.originalEvent.target;
        if (tmp.tagName != 'TD') tmp = $(tmp).parents('td')[0];
        if (typeof $(tmp).attr('col') != 'undefined') column = parseInt($(tmp).attr('col'));
        tmp = $(tmp).parents('tr')[0];
        recid = $(tmp).attr('recid');
        // new range
        if (mv.newRange[1].recid == recid && mv.newRange[1].column == column) return;
        var prevNewRange = $.extend({}, mv.newRange);
        mv.newRange = [{
          recid: mv.recid,
          column: mv.column
        }, {
          recid: recid,
          column: column
        }];
        // event before
        eventData = obj.trigger($.extend(eventData, {
          originalRange: mv.originalRange,
          newRange: mv.newRange
        }));
        if (eventData.isCancelled === true) {
          mv.newRange = prevNewRange;
          eventData.newRange = prevNewRange;
          return;
        } else {
          // default behavior
          obj.removeRange('grid-selection-expand');
          obj.addRange({
            name: 'grid-selection-expand',
            range: eventData.newRange,
            style: 'background-color: rgba(100,100,100,0.1); border: 2px dotted rgba(100,100,100,0.5);'
          });
        }
      }
      function mouseStop(event) {
        // default behavior
        obj.removeRange('grid-selection-expand');
        delete obj.last.move;
        $(document).off('mousemove', mouseMove);
        $(document).off('mouseup', mouseStop);
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
      return new Date().getTime() - time;
    },
    select: function select() {
      var selected = 0;
      var sel = this.last.selection;
      if (!this.multiSelect) this.selectNone();
      for (var a = 0; a < arguments.length; a++) {
        var recid = _typeof(arguments[a]) == 'object' ? arguments[a].recid : arguments[a];
        var record = this.get(recid);
        if (record == null) continue;
        var index = this.get(recid, true);
        var recEl = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
        if (this.selectType == 'row') {
          if (sel.indexes.indexOf(index) >= 0) continue;
          // event before
          var eventData = this.trigger({
            phase: 'before',
            type: 'select',
            target: this.name,
            recid: recid,
            index: index
          });
          if (eventData.isCancelled === true) continue;
          // default action
          sel.indexes.push(index);
          sel.indexes.sort(function (a, b) {
            return a - b;
          });
          recEl.addClass('w2ui-selected').data('selected', 'yes');
          recEl.find('.w2ui-grid-select-check').prop("checked", true);
          selected++;
        } else {
          var col = arguments[a].column;
          if (!w2utils.isInt(col)) {
            // select all columns
            var cols = [];
            for (var c in this.columns) {
              if (this.columns[c].hidden) continue;
              cols.push({
                recid: recid,
                column: parseInt(c)
              });
            }
            if (!this.multiSelect) cols = cols.splice(0, 1);
            return this.select.apply(this, cols);
          }
          var s = sel.columns[index] || [];
          if ($.isArray(s) && s.indexOf(col) != -1) continue;
          // event before
          var eventData = this.trigger({
            phase: 'before',
            type: 'select',
            target: this.name,
            recid: recid,
            index: index,
            column: col
          });
          if (eventData.isCancelled === true) continue;
          // default action
          if (sel.indexes.indexOf(index) == -1) {
            sel.indexes.push(index);
            sel.indexes.sort(function (a, b) {
              return a - b;
            });
          }
          s.push(col);
          s.sort(function (a, b) {
            return a - b;
          }); // sort function must be for numerical sort
          recEl.find(' > td[col=' + col + ']').addClass('w2ui-selected');
          selected++;
          recEl.data('selected', 'yes');
          recEl.find('.w2ui-grid-select-check').prop("checked", true);
          // save back to selection object
          sel.columns[index] = s;
        }
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
      // all selected?
      if (sel.indexes.length == this.records.length || this.searchData.length !== 0 && sel.indexes.length == this.last.searchIds.length) {
        $('#grid_' + this.name + '_check_all').prop('checked', true);
      } else {
        $('#grid_' + this.name + '_check_all').prop('checked', false);
      }
      this.status();
      this.addRange('selection');
      return selected;
    },
    unselect: function unselect() {
      var unselected = 0;
      var sel = this.last.selection;
      for (var a = 0; a < arguments.length; a++) {
        var recid = _typeof(arguments[a]) == 'object' ? arguments[a].recid : arguments[a];
        var record = this.get(recid);
        if (record == null) continue;
        var index = this.get(record.recid, true);
        var recEl = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
        if (this.selectType == 'row') {
          if (sel.indexes.indexOf(index) == -1) continue;
          // event before
          var eventData = this.trigger({
            phase: 'before',
            type: 'unselect',
            target: this.name,
            recid: recid,
            index: index
          });
          if (eventData.isCancelled === true) continue;
          // default action
          sel.indexes.splice(sel.indexes.indexOf(index), 1);
          recEl.removeClass('w2ui-selected').removeData('selected');
          if (recEl.length != 0) recEl[0].style.cssText = 'height: ' + this.recordHeight + 'px; ' + recEl.attr('custom_style');
          recEl.find('.w2ui-grid-select-check').prop("checked", false);
          unselected++;
        } else {
          var col = arguments[a].column;
          if (!w2utils.isInt(col)) {
            // unselect all columns
            var cols = [];
            for (var c in this.columns) {
              if (this.columns[c].hidden) continue;
              cols.push({
                recid: recid,
                column: parseInt(c)
              });
            }
            return this.unselect.apply(this, cols);
          }
          var s = sel.columns[index];
          if (!$.isArray(s) || s.indexOf(col) == -1) continue;
          // event before
          var eventData = this.trigger({
            phase: 'before',
            type: 'unselect',
            target: this.name,
            recid: recid,
            column: col
          });
          if (eventData.isCancelled === true) continue;
          // default action
          s.splice(s.indexOf(col), 1);
          $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid) + ' > td[col=' + col + ']').removeClass('w2ui-selected');
          unselected++;
          if (s.length == 0) {
            delete sel.columns[index];
            sel.indexes.splice(sel.indexes.indexOf(index), 1);
            recEl.removeData('selected');
            recEl.find('.w2ui-grid-select-check').prop("checked", false);
          }
        }
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
      // all selected?
      if (sel.indexes.length == this.records.length || this.searchData.length !== 0 && sel.indexes.length == this.last.searchIds.length) {
        $('#grid_' + this.name + '_check_all').prop('checked', true);
      } else {
        $('#grid_' + this.name + '_check_all').prop('checked', false);
      }
      // show number of selected
      this.status();
      this.addRange('selection');
      return unselected;
    },
    selectAll: function selectAll() {
      if (this.multiSelect === false) return;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'select',
        target: this.name,
        all: true
      });
      if (eventData.isCancelled === true) return;
      // default action
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      var sel = this.last.selection;
      var cols = [];
      for (var c in this.columns) cols.push(parseInt(c));
      // if local data source and searched
      sel.indexes = [];
      if (!url && this.searchData.length !== 0) {
        // local search applied
        for (var i = 0; i < this.last.searchIds.length; i++) {
          sel.indexes.push(this.last.searchIds[i]);
          if (this.selectType != 'row') sel.columns[this.last.searchIds[i]] = cols.slice(); // .slice makes copy of the array
        }
      } else {
        var buffered = this.records.length;
        if (this.searchData.length != 0 && url) buffered = this.last.searchIds.length;
        for (var i = 0; i < buffered; i++) {
          sel.indexes.push(i);
          if (this.selectType != 'row') sel.columns[i] = cols.slice(); // .slice makes copy of the array
        }
      }
      this.refresh();
      // enable/disable toolbar buttons
      var sel = this.getSelection();
      if (sel.length == 1) this.toolbar.enable('w2ui-edit');else this.toolbar.disable('w2ui-edit');
      if (sel.length >= 1) this.toolbar.enable('w2ui-delete');else this.toolbar.disable('w2ui-delete');
      this.addRange('selection');
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    selectNone: function selectNone() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'unselect',
        target: this.name,
        all: true
      });
      if (eventData.isCancelled === true) return;
      // default action
      var sel = this.last.selection;
      for (var s in sel.indexes) {
        var index = sel.indexes[s];
        var rec = this.records[index];
        var recid = rec ? rec.recid : null;
        var recEl = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
        recEl.removeClass('w2ui-selected').removeData('selected');
        recEl.find('.w2ui-grid-select-check').prop("checked", false);
        // for not rows
        if (this.selectType != 'row') {
          var cols = sel.columns[index];
          for (var c in cols) recEl.find(' > td[col=' + cols[c] + ']').removeClass('w2ui-selected');
        }
      }
      sel.indexes = [];
      sel.columns = {};
      this.toolbar.disable('w2ui-edit', 'w2ui-delete');
      this.removeRange('selection');
      $('#grid_' + this.name + '_check_all').prop('checked', false);
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    getSelection: function getSelection(returnIndex) {
      var ret = [];
      var sel = this.last.selection;
      if (this.selectType == 'row') {
        for (var s in sel.indexes) {
          if (!this.records[sel.indexes[s]]) continue;
          if (returnIndex === true) ret.push(sel.indexes[s]);else ret.push(this.records[sel.indexes[s]].recid);
        }
        return ret;
      } else {
        for (var s in sel.indexes) {
          var cols = sel.columns[sel.indexes[s]];
          if (!this.records[sel.indexes[s]]) continue;
          for (var c in cols) {
            ret.push({
              recid: this.records[sel.indexes[s]].recid,
              index: parseInt(sel.indexes[s]),
              column: cols[c]
            });
          }
        }
        return ret;
      }
    },
    search: function search(field, value) {
      var obj = this;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      var searchData = [];
      var last_multi = this.last.multi;
      var last_logic = this.last.logic;
      var last_field = this.last.field;
      var last_search = this.last.search;
      // 1: search() - advanced search (reads from popup)
      if (arguments.length == 0) {
        last_search = '';
        // advanced search
        for (var s in this.searches) {
          var search = this.searches[s];
          var operator = $('#grid_' + this.name + '_operator_' + s).val();
          var field1 = $('#grid_' + this.name + '_field_' + s);
          var field2 = $('#grid_' + this.name + '_field2_' + s);
          var value1 = field1.val();
          var value2 = field2.val();
          var svalue = null;
          if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1) {
            var fld1 = field1.data('w2field');
            var fld2 = field2.data('w2field');
            if (fld1) value1 = fld1.clean(value1);
            if (fld2) value2 = fld2.clean(value2);
          }
          if (['list', 'enum'].indexOf(search.type) != -1) {
            value1 = field1.data('selected') || {};
            if ($.isArray(value1)) {
              svalue = [];
              for (var v in value1) {
                svalue.push(w2utils.isFloat(value1[v].id) ? parseFloat(value1[v].id) : String(value1[v].id).toLowerCase());
                delete value1[v].hidden;
              }
            } else {
              value1 = value1.id || '';
            }
          }
          if (value1 != '' && value1 != null || typeof value2 != 'undefined' && value2 != '') {
            var tmp = {
              field: search.field,
              type: search.type,
              operator: operator
            };
            if (operator == 'between') {
              $.extend(tmp, {
                value: [value1, value2]
              });
            } else if (operator == 'in' && typeof value1 == 'string') {
              $.extend(tmp, {
                value: value1.split(',')
              });
            } else if (operator == 'not in' && typeof value1 == 'string') {
              $.extend(tmp, {
                value: value1.split(',')
              });
            } else {
              $.extend(tmp, {
                value: value1
              });
            }
            if (svalue) $.extend(tmp, {
              svalue: svalue
            });
            // conver date to unix time
            try {
              if (search.type == 'date' && operator == 'between') {
                tmp.value[0] = value1; // w2utils.isDate(value1, w2utils.settings.date_format, true).getTime();
                tmp.value[1] = value2; // w2utils.isDate(value2, w2utils.settings.date_format, true).getTime();
              }
              if (search.type == 'date' && operator == 'is') {
                tmp.value = value1; // w2utils.isDate(value1, w2utils.settings.date_format, true).getTime();
              }
            } catch (e) {}
            searchData.push(tmp);
          }
        }
        if (searchData.length > 0 && !url) {
          last_multi = true;
          last_logic = 'AND';
        } else {
          last_multi = true;
          last_logic = 'AND';
        }
      }
      // 2: search(field, value) - regular search
      if (typeof field == 'string') {
        last_field = field;
        last_search = value;
        last_multi = false;
        last_logic = 'OR';
        // loop through all searches and see if it applies
        if (typeof value != 'undefined') {
          if (field.toLowerCase() == 'all') {
            // if there are search fields loop thru them
            if (this.searches.length > 0) {
              for (var s in this.searches) {
                var search = this.searches[s];
                if (search.type == 'text' || search.type == 'alphanumeric' && w2utils.isAlphaNumeric(value) || search.type == 'int' && w2utils.isInt(value) || search.type == 'float' && w2utils.isFloat(value) || search.type == 'percent' && w2utils.isFloat(value) || search.type == 'hex' && w2utils.isHex(value) || search.type == 'currency' && w2utils.isMoney(value) || search.type == 'money' && w2utils.isMoney(value) || search.type == 'date' && w2utils.isDate(value)) {
                  var tmp = {
                    field: search.field,
                    type: search.type,
                    operator: search.type == 'text' ? 'contains' : 'is',
                    value: value
                  };
                  searchData.push(tmp);
                }
                // range in global search box
                if (['int', 'float', 'money', 'currency', 'percent'].indexOf(search.type) != -1 && String(value).indexOf('-') != -1) {
                  var t = String(value).split('-');
                  var tmp = {
                    field: search.field,
                    type: search.type,
                    operator: 'between',
                    value: [t[0], t[1]]
                  };
                  searchData.push(tmp);
                }
              }
            } else {
              // no search fields, loop thru columns
              for (var c in this.columns) {
                var tmp = {
                  field: this.columns[c].field,
                  type: 'text',
                  operator: 'contains',
                  value: value
                };
                searchData.push(tmp);
              }
            }
          } else {
            var el = $('#grid_' + this.name + '_search_all');
            var search = this.getSearch(field);
            if (search == null) search = {
              field: field,
              type: 'text'
            };
            if (search.field == field) this.last.caption = search.caption;
            if (search.type == 'list') {
              var tmp = el.data('selected');
              if (tmp && !$.isEmptyObject(tmp)) value = tmp.id;
            }
            if (value != '') {
              var op = 'contains';
              var val = value;
              if (['date', 'time', 'list'].indexOf(search.type) != -1) op = 'is';
              if (search.type == 'int' && value != '') {
                op = 'is';
                if (String(value).indexOf('-') != -1) {
                  var tmp = value.split('-');
                  if (tmp.length == 2) {
                    op = 'between';
                    val = [parseInt(tmp[0]), parseInt(tmp[1])];
                  }
                }
                if (String(value).indexOf(',') != -1) {
                  var tmp = value.split(',');
                  op = 'in';
                  val = [];
                  for (var t in tmp) val.push(tmp[t]);
                }
              }
              var tmp = {
                field: search.field,
                type: search.type,
                operator: op,
                value: val
              };
              searchData.push(tmp);
            }
          }
        }
      }
      // 3: search([ { field, value, [operator,] [type] }, { field, value, [operator,] [type] } ], logic) - submit whole structure
      if ($.isArray(field)) {
        var logic = 'AND';
        if (typeof value == 'string') {
          logic = value.toUpperCase();
          if (logic != 'OR' && logic != 'AND') logic = 'AND';
        }
        last_search = '';
        last_multi = true;
        last_logic = logic;
        for (var f in field) {
          var data = field[f];
          var search = this.getSearch(data.field);
          if (search == null) search = {
            type: 'text',
            operator: 'contains'
          };
          // merge current field and search if any
          searchData.push($.extend(true, {}, search, data));
        }
      }
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'search',
        target: this.name,
        searchData: searchData,
        searchField: field ? field : 'multi',
        searchValue: value ? value : 'multi'
      });
      if (eventData.isCancelled === true) return;
      // default action
      this.searchData = eventData.searchData;
      this.last.field = last_field;
      this.last.search = last_search;
      this.last.multi = last_multi;
      this.last.logic = last_logic;
      this.last.scrollTop = 0;
      this.last.scrollLeft = 0;
      this.last.selection.indexes = [];
      this.last.selection.columns = {};
      // -- clear all search field
      this.searchClose();
      this.set({
        expanded: false
      }, true);
      // apply search
      if (url) {
        this.last.xhr_offset = 0;
        this.reload();
      } else {
        // local search
        this.localSearch();
        this.refresh();
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    searchOpen: function searchOpen() {
      if (!this.box) return;
      if (this.searches.length == 0) return;
      var obj = this;
      // show search
      $('#tb_' + this.name + '_toolbar_item_w2ui-search-advanced').w2overlay(this.getSearchesHTML(), {
        name: 'searches-' + this.name,
        left: -10,
        'class': 'w2ui-grid-searches',
        onShow: function onShow() {
          if (obj.last.logic == 'OR') obj.searchData = [];
          obj.initSearches();
          $('#w2ui-overlay-searches-' + this.name + ' .w2ui-grid-searches').data('grid-name', obj.name);
          var sfields = $('#w2ui-overlay-searches-' + this.name + ' .w2ui-grid-searches *[rel=search]');
          if (sfields.length > 0) sfields[0].focus();
        }
      });
    },
    searchClose: function searchClose() {
      if (!this.box) return;
      if (this.searches.length == 0) return;
      if (this.toolbar) this.toolbar.uncheck('w2ui-search-advanced');
      // hide search
      if ($('#w2ui-overlay-searches-' + this.name + ' .w2ui-grid-searches').length > 0) {
        $().w2overlay('', {
          name: 'searches-' + this.name
        });
      }
    },
    searchShowFields: function searchShowFields() {
      var el = $('#grid_' + this.name + '_search_all');
      var html = '<div class="w2ui-select-field"><table>';
      for (var s = -1; s < this.searches.length; s++) {
        var search = this.searches[s];
        if (s == -1) {
          if (!this.multiSearch) continue;
          search = {
            field: 'all',
            caption: w2utils.lang('All Fields')
          };
        } else {
          if (this.searches[s].hidden === true) continue;
        }
        html += '<tr ' + (w2utils.isIOS ? 'onTouchStart' : 'onClick') + '="w2ui[\'' + this.name + '\'].initAllField(\'' + search.field + '\')">' + '    <td><input type="radio" tabIndex="-1" ' + (search.field == this.last.field ? 'checked' : '') + '></td>' + '    <td>' + search.caption + '</td>' + '</tr>';
      }
      html += "</table></div>";
      // need timer otherwise does nto show with list type
      setTimeout(function () {
        $(el).w2overlay(html, {
          left: -10
        });
      }, 1);
    },
    initAllField: function initAllField(field, value) {
      var el = $('#grid_' + this.name + '_search_all');
      var search = this.getSearch(field);
      if (field == 'all') {
        search = {
          field: 'all',
          caption: w2utils.lang('All Fields')
        };
        el.w2field('clear');
        el.change().focus();
      } else {
        var st = search.type;
        if (['enum', 'select'].indexOf(st) != -1) st = 'list';
        el.w2field(st, $.extend({}, search.options, {
          suffix: '',
          autoFormat: false,
          selected: value
        }));
        if (['list', 'enum'].indexOf(search.type) != -1) {
          this.last.search = '';
          this.last.item = '';
          el.val('');
        }
        // set focus
        setTimeout(function () {
          el.focus(); /* do not do el.change() as it will refresh grid and pull from server */
        }, 1);
      }
      // update field
      if (this.last.search != '') {
        this.search(search.field, this.last.search);
      } else {
        this.last.field = search.field;
        this.last.caption = search.caption;
      }
      el.attr('placeholder', search.caption);
      $().w2overlay();
    },
    searchReset: function searchReset(noRefresh) {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'search',
        target: this.name,
        searchData: []
      });
      if (eventData.isCancelled === true) return;
      // default action
      this.searchData = [];
      this.last.search = '';
      this.last.logic = 'OR';
      // --- do not reset to All Fields (I think)
      // if (this.last.multi) {
      //     if (!this.multiSearch) {
      //         this.last.field     = this.searches[0].field;
      //         this.last.caption     = this.searches[0].caption;
      //     } else {
      //         this.last.field      = 'all';
      //         this.last.caption     = w2utils.lang('All Fields');
      //     }
      // }
      this.last.multi = false;
      this.last.xhr_offset = 0;
      // reset scrolling position
      this.last.scrollTop = 0;
      this.last.scrollLeft = 0;
      this.last.selection.indexes = [];
      this.last.selection.columns = {};
      // -- clear all search field
      this.searchClose();
      $('#grid_' + this.name + '_search_all').val('');
      // apply search
      if (!noRefresh) this.reload();
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    clear: function clear(noRefresh) {
      // this.offset              = 0;   // clear should not reset offset
      // this.total               = 0;   // clear should not reset total
      this.records = [];
      this.summary = [];
      this.last.scrollTop = 0;
      this.last.scrollLeft = 0;
      this.last.selection.indexes = [];
      this.last.selection.columns = {};
      this.last.range_start = null;
      this.last.range_end = null;
      this.last.xhr_offset = 0;
      if (!noRefresh) this.refresh();
    },
    reset: function reset(noRefresh) {
      // reset last remembered state
      this.offset = 0;
      this.total = 0;
      this.last.scrollTop = 0;
      this.last.scrollLeft = 0;
      this.last.selection.indexes = [];
      this.last.selection.columns = {};
      this.last.range_start = null;
      this.last.range_end = null;
      this.last.xhr_offset = 0;
      this.searchReset(noRefresh);
      // initial sort
      if (this.last.sortData != null) this.sortData = this.last.sortData;
      // select none without refresh
      this.set({
        expanded: false
      }, true);
      // refresh
      if (!noRefresh) this.refresh();
    },
    skip: function skip(offset) {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url) {
        this.offset = parseInt(offset);
        if (this.offset > this.total) this.offset = this.total - this.limit;
        if (this.offset < 0 || !w2utils.isInt(this.offset)) this.offset = 0;
        this.records = [];
        this.last.xhr_offset = 0;
        this.last.pull_more = true;
        this.last.scrollTop = 0;
        this.last.scrollLeft = 0;
        $('#grid_' + this.name + '_records').prop('scrollTop', 0);
        this.reload();
      } else {
        console.log('ERROR: grid.skip() can only be called when you have remote data source.');
      }
    },
    load: function load(url, callBack) {
      if (typeof url == 'undefined') {
        console.log('ERROR: You need to provide url argument when calling .load() method of "' + this.name + '" object.');
        return;
      }
      // default action
      this.request('get-records', {}, url, callBack);
    },
    reload: function reload(callBack) {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url) {
        this.clear(true);
        this.request('get-records', {}, null, callBack);
      } else {
        this.last.scrollTop = 0;
        this.last.scrollLeft = 0;
        this.last.range_start = null;
        this.last.range_end = null;
        this.localSearch();
        this.refresh();
        if (typeof callBack == 'function') callBack({
          status: 'success'
        });
      }
    },
    request: function request(cmd, add_params, url, callBack) {
      if (typeof add_params == 'undefined') add_params = {};
      if (url == '' || url == null) url = this.url;
      if (url == '' || url == null) return;
      // build parameters list
      var params = {};
      if (!w2utils.isInt(this.offset)) this.offset = 0;
      if (!w2utils.isInt(this.last.xhr_offset)) this.last.xhr_offset = 0;
      // add list params
      params['cmd'] = cmd;
      params['selected'] = this.getSelection();
      params['limit'] = this.limit;
      params['offset'] = parseInt(this.offset) + this.last.xhr_offset;
      params['search'] = this.searchData;
      params['searchLogic'] = this.last.logic;
      params['sort'] = this.sortData;
      if (this.searchData.length == 0) {
        delete params['search'];
        delete params['searchLogic'];
      }
      if (this.sortData.length == 0) {
        delete params['sort'];
      }
      // append other params
      $.extend(params, this.postData);
      $.extend(params, add_params);
      // event before
      if (cmd == 'get-records') {
        var eventData = this.trigger({
          phase: 'before',
          type: 'request',
          target: this.name,
          url: url,
          postData: params
        });
        if (eventData.isCancelled === true) {
          if (typeof callBack == 'function') callBack({
            status: 'error',
            message: 'Request aborted.'
          });
          return;
        }
      } else {
        var eventData = {
          url: url,
          postData: params
        };
      }
      // call server to get data
      var obj = this;
      if (this.last.xhr_offset == 0) {
        this.lock(this.msgRefresh, true);
      } else {
        var more = $('#grid_' + this.name + '_rec_more');
        if (this.autoLoad === true) {
          more.show().find('td').html('<div><div style="width: 20px; height: 20px;" class="w2ui-spinner"></div></div>');
        } else {
          more.find('td').html('<div>' + w2utils.lang('Load') + ' ' + obj.limit + ' ' + w2utils.lang('More') + '...</div>');
        }
      }
      if (this.last.xhr) try {
        this.last.xhr.abort();
      } catch (e) {}
      ;
      // URL
      url = _typeof(eventData.url) != 'object' ? eventData.url : eventData.url.get;
      if (params.cmd == 'save-records' && _typeof(eventData.url) == 'object') url = eventData.url.save;
      if (params.cmd == 'delete-records' && _typeof(eventData.url) == 'object') url = eventData.url.remove;
      // process url with routeData
      if (!$.isEmptyObject(obj.routeData)) {
        var info = w2utils.parseRoute(url);
        if (info.keys.length > 0) {
          for (var k = 0; k < info.keys.length; k++) {
            if (obj.routeData[info.keys[k].name] == null) continue;
            url = url.replace(new RegExp(':' + info.keys[k].name, 'g'), obj.routeData[info.keys[k].name]);
          }
        }
      }
      // ajax ptions
      var ajaxOptions = {
        type: 'POST',
        url: url,
        data: eventData.postData,
        dataType: 'text' // expected data type from server
      };
      if (w2utils.settings.dataType == 'HTTP') {
        ajaxOptions.data = _typeof(ajaxOptions.data) == 'object' ? String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']') : ajaxOptions.data;
      }
      if (w2utils.settings.dataType == 'RESTFULL') {
        ajaxOptions.type = 'GET';
        if (params.cmd == 'save-records') ajaxOptions.type = 'PUT'; // so far it is always update
        if (params.cmd == 'delete-records') ajaxOptions.type = 'DELETE';
        ajaxOptions.data = _typeof(ajaxOptions.data) == 'object' ? String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']') : ajaxOptions.data;
      }
      if (w2utils.settings.dataType == 'JSON') {
        ajaxOptions.type = 'POST';
        ajaxOptions.data = JSON.stringify(ajaxOptions.data);
        ajaxOptions.contentType = 'application/json';
      }
      if (this.method) ajaxOptions.type = this.method;
      this.last.xhr_cmd = params.cmd;
      this.last.xhr_start = new Date().getTime();
      this.last.xhr = $.ajax(ajaxOptions).done(function (data, status, xhr) {
        obj.requestComplete(status, cmd, callBack);
      }).fail(function (xhr, status, error) {
        // trigger event
        var errorObj = {
          status: status,
          error: error,
          rawResponseText: xhr.responseText
        };
        var eventData2 = obj.trigger({
          phase: 'before',
          type: 'error',
          error: errorObj,
          xhr: xhr
        });
        if (eventData2.isCancelled === true) return;
        // default behavior
        if (status != 'abort') {
          var data;
          try {
            data = $.parseJSON(xhr.responseText);
          } catch (e) {}
          console.log('ERROR: Server communication failed.', '\n   EXPECTED:', {
            status: 'success',
            total: 5,
            records: [{
              recid: 1,
              field: 'value'
            }]
          }, '\n         OR:', {
            status: 'error',
            message: 'error message'
          }, '\n   RECEIVED:', _typeof(data) == 'object' ? data : xhr.responseText);
          obj.requestComplete('error', cmd, callBack);
        }
        // event after
        obj.trigger($.extend(eventData2, {
          phase: 'after'
        }));
      });
      if (cmd == 'get-records') {
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
    },
    requestComplete: function requestComplete(status, cmd, callBack) {
      var obj = this;
      this.unlock();
      setTimeout(function () {
        obj.status(w2utils.lang('Server Response') + ' ' + (new Date().getTime() - obj.last.xhr_start) / 1000 + ' ' + w2utils.lang('sec'));
      }, 10);
      this.last.pull_more = false;
      this.last.pull_refresh = true;

      // event before
      var event_name = 'load';
      if (this.last.xhr_cmd == 'save-records') event_name = 'save';
      if (this.last.xhr_cmd == 'delete-records') event_name = 'deleted';
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: event_name,
        xhr: this.last.xhr,
        status: status
      });
      if (eventData.isCancelled === true) {
        if (typeof callBack == 'function') callBack({
          status: 'error',
          message: 'Request aborted.'
        });
        return;
      }
      // parse server response
      var data;
      var responseText = this.last.xhr.responseText;
      if (status != 'error') {
        // default action
        if (typeof responseText != 'undefined' && responseText != '') {
          // check if the onLoad handler has not already parsed the data
          if (_typeof(responseText) == "object") {
            data = responseText;
          } else {
            if (typeof obj.parser == 'function') {
              data = obj.parser(responseText);
              if (_typeof(data) != 'object') {
                console.log('ERROR: Your parser did not return proper object');
              }
            } else {
              // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
              //
              // TODO: avoid (potentially malicious) code injection from the response.
              try {
                eval('data = ' + responseText);
              } catch (e) {}
            }
          }
          // convert recids
          if (obj.recid) {
            for (var r in data.records) {
              data.records[r]['recid'] = data.records[r][obj.recid];
            }
          }
          if (typeof data == 'undefined') {
            data = {
              status: 'error',
              message: this.msgNotJSON,
              responseText: responseText
            };
          }
          if (data['status'] == 'error') {
            obj.error(data['message']);
          } else {
            if (cmd == 'get-records') {
              if (this.last.xhr_offset == 0) {
                this.records = [];
                this.summary = [];
                //data.xhr_status=data.status;
                delete data.status;
                $.extend(true, this, data);
              } else {
                var records = data.records;
                delete data.records;
                //data.xhr_status=data.status;
                delete data.status;
                $.extend(true, this, data);
                for (var r in records) {
                  this.records.push(records[r]);
                }
              }
            }
            if (cmd == 'delete-records') {
              // reset() also triggers reload
              this.reset(); // unselect old selections
              return;
            }
          }
        }
      } else {
        data = {
          status: 'error',
          message: this.msgAJAXerror,
          responseText: responseText
        };
        obj.error(this.msgAJAXerror);
      }
      // event after
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (!url) {
        this.localSort();
        this.localSearch();
      }
      this.total = parseInt(this.total);
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      // do not refresh if loading on infinite scroll
      if (this.last.xhr_offset == 0) this.refresh();else this.scroll();
      // call back
      if (typeof callBack == 'function') callBack(data);
    },
    error: function error(msg) {
      var obj = this;
      // let the management of the error outside of the grid
      var eventData = this.trigger({
        target: this.name,
        type: 'error',
        message: msg,
        xhr: this.last.xhr
      });
      if (eventData.isCancelled === true) {
        if (typeof callBack == 'function') callBack({
          status: 'error',
          message: 'Request aborted.'
        });
        return;
      }
      w2alert(msg, 'Error');
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    getChanges: function getChanges() {
      var changes = [];
      for (var r in this.records) {
        var rec = this.records[r];
        if (typeof rec['changes'] != 'undefined') {
          changes.push($.extend(true, {
            recid: rec.recid
          }, rec.changes));
        }
      }
      return changes;
    },
    mergeChanges: function mergeChanges() {
      var changes = this.getChanges();
      for (var c in changes) {
        var record = this.get(changes[c].recid);
        for (var s in changes[c]) {
          if (s == 'recid') continue; // do not allow to change recid
          try {
            eval('record.' + s + ' = changes[c][s]');
          } catch (e) {}
          delete record.changes;
        }
      }
      this.refresh();
    },
    // ===================================================
    // --  Action Handlers

    save: function save() {
      var obj = this;
      var changes = this.getChanges();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'submit',
        changes: changes
      });
      if (eventData.isCancelled === true) return;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.save;
      if (url) {
        this.request('save-records', {
          'changes': eventData.changes
        }, null, function (data) {
          if (data.status !== 'error') {
            // only merge changes, if save was successful
            obj.mergeChanges();
          }
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        });
      } else {
        this.mergeChanges();
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
    },
    editField: function editField(recid, column, value, event) {
      var obj = this;
      var index = obj.get(recid, true);
      var rec = obj.records[index];
      var col = obj.columns[column];
      var edit = col ? col.editable : null;
      if (!rec || !col || !edit || rec.editable === false) return;
      if (['enum', 'file'].indexOf(edit.type) != -1) {
        console.log('ERROR: input types "enum" and "file" are not supported in inline editing.');
        return;
      }
      // event before
      var eventData = obj.trigger({
        phase: 'before',
        type: 'editField',
        target: obj.name,
        recid: recid,
        column: column,
        value: value,
        index: index,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      value = eventData.value;
      // default behaviour
      this.selectNone();
      this.select({
        recid: recid,
        column: column
      });
      this.last.edit_col = column;
      if (['checkbox', 'check'].indexOf(edit.type) != -1) return;
      // create input element
      var tr = $('#grid_' + obj.name + '_rec_' + w2utils.escapeId(recid));
      var el = tr.find('[col=' + column + '] > div');
      if (typeof edit.inTag == 'undefined') edit.inTag = '';
      if (typeof edit.outTag == 'undefined') edit.outTag = '';
      if (typeof edit.style == 'undefined') edit.style = '';
      if (typeof edit.items == 'undefined') edit.items = [];
      var val = rec.changes && typeof rec.changes[col.field] != 'undefined' ? w2utils.stripTags(rec.changes[col.field]) : w2utils.stripTags(rec[col.field]);
      if (val == null || typeof val == 'undefined') val = '';
      if (typeof value != 'undefined' && value != null) val = value;
      var addStyle = typeof col.style != 'undefined' ? col.style + ';' : '';
      if (typeof col.render == 'string' && ['number', 'int', 'float', 'money', 'percent'].indexOf(col.render.split(':')[0]) != -1) {
        addStyle += 'text-align: right;';
      }
      // mormalize items
      if (edit.items.length > 0 && !$.isPlainObject(edit.items[0])) {
        edit.items = w2obj.field.prototype.normMenu(edit.items);
      }
      if (edit.type == 'select') {
        var html = '';
        for (var i in edit.items) {
          html += '<option value="' + edit.items[i].id + '" ' + (edit.items[i].id == val ? 'selected' : '') + '>' + edit.items[i].text + '</option>';
        }
        el.addClass('w2ui-editable').html('<select id="grid_' + obj.name + '_edit_' + recid + '_' + column + '" column="' + column + '" ' + '    style="width: 100%; ' + addStyle + edit.style + '" field="' + col.field + '" recid="' + recid + '" ' + '    ' + edit.inTag + '>' + html + '</select>' + edit.outTag);
        el.find('select').focus().on('change', function (event) {
          delete obj.last.move;
        }).on('blur', function (event) {
          obj.editChange.call(obj, this, index, column, event);
        });
      } else {
        el.addClass('w2ui-editable').html('<input id="grid_' + obj.name + '_edit_' + recid + '_' + column + '" ' + '    type="text" style="font-family: inherit; font-size: inherit; outline: none; ' + addStyle + edit.style + '" field="' + col.field + '" recid="' + recid + '" ' + '    column="' + column + '" ' + edit.inTag + '>' + edit.outTag);
        if (value == null) el.find('input').val(val != 'object' ? val : '');
        // init w2field
        var input = el.find('input').get(0);
        $(input).w2field(edit.type, $.extend(edit, {
          selected: val
        }));
        // add blur listener
        setTimeout(function () {
          var tmp = input;
          if (edit.type == 'list') {
            tmp = $($(input).data('w2field').helpers.focus).find('input');
            if (_typeof(val) != 'object' && val != '') tmp.val(val).css({
              opacity: 1
            }).prev().css({
              opacity: 1
            });
          }
          $(tmp).on('blur', function (event) {
            obj.editChange.call(obj, input, index, column, event);
          });
        }, 10);
        if (value != null) $(input).val(val != 'object' ? val : '');
      }
      setTimeout(function () {
        el.find('input, select').on('click', function (event) {
          event.stopPropagation();
        }).on('keydown', function (event) {
          var cancel = false;
          switch (event.keyCode) {
            case 9:
              // tab
              cancel = true;
              var next_rec = recid;
              var next_col = event.shiftKey ? obj.prevCell(column, true) : obj.nextCell(column, true);
              // next or prev row
              if (next_col == null) {
                var tmp = event.shiftKey ? obj.prevRow(index) : obj.nextRow(index);
                if (tmp != null && tmp != index) {
                  next_rec = obj.records[tmp].recid;
                  // find first editable row
                  for (var c in obj.columns) {
                    var tmp = obj.columns[c].editable;
                    if (typeof tmp != 'undefined' && ['checkbox', 'check'].indexOf(tmp.type) == -1) {
                      next_col = parseInt(c);
                      if (!event.shiftKey) break;
                    }
                  }
                }
              }
              if (next_rec === false) next_rec = recid;
              if (next_col == null) next_col = column;
              // init new or same record
              this.blur();
              setTimeout(function () {
                if (obj.selectType != 'row') {
                  obj.selectNone();
                  obj.select({
                    recid: next_rec,
                    column: next_col
                  });
                } else {
                  obj.editField(next_rec, next_col, null, event);
                }
              }, 1);
              break;
            case 13:
              // enter
              this.blur();
              var next = event.shiftKey ? obj.prevRow(index) : obj.nextRow(index);
              if (next != null && next != index) {
                setTimeout(function () {
                  if (obj.selectType != 'row') {
                    obj.selectNone();
                    obj.select({
                      recid: obj.records[next].recid,
                      column: column
                    });
                  } else {
                    obj.editField(obj.records[next].recid, column, null, event);
                  }
                }, 100);
              }
              break;
            case 38:
              // up arrow
              if (!event.shiftKey) break;
              cancel = true;
              var next = obj.prevRow(index);
              if (next != index) {
                this.blur();
                setTimeout(function () {
                  if (obj.selectType != 'row') {
                    obj.selectNone();
                    obj.select({
                      recid: obj.records[next].recid,
                      column: column
                    });
                  } else {
                    obj.editField(obj.records[next].recid, column, null, event);
                  }
                }, 1);
              }
              break;
            case 40:
              // down arrow
              if (!event.shiftKey) break;
              cancel = true;
              var next = obj.nextRow(index);
              if (next != null && next != index) {
                this.blur();
                setTimeout(function () {
                  if (obj.selectType != 'row') {
                    obj.selectNone();
                    obj.select({
                      recid: obj.records[next].recid,
                      column: column
                    });
                  } else {
                    obj.editField(obj.records[next].recid, column, null, event);
                  }
                }, 1);
              }
              break;
            case 27:
              // escape
              var old = obj.parseField(rec, col.field);
              if (rec.changes && typeof rec.changes[col.field] != 'undefined') old = rec.changes[col.field];
              this.value = typeof old != 'undefined' ? old : '';
              this.blur();
              setTimeout(function () {
                obj.select({
                  recid: recid,
                  column: column
                });
              }, 1);
              break;
          }
          if (cancel) if (event.preventDefault) event.preventDefault();
        });
        // focus and select
        var tmp = el.find('input').focus();
        if (value != null) {
          // set cursor to the end
          tmp[0].setSelectionRange(tmp.val().length, tmp.val().length);
        } else {
          tmp.select();
        }
      }, 1);
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    editChange: function editChange(el, index, column, event) {
      // all other fields
      var summary = index < 0;
      index = index < 0 ? -index - 1 : index;
      var records = summary ? this.summary : this.records;
      var rec = records[index];
      var tr = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(rec.recid));
      var col = this.columns[column];
      var new_val = el.value;
      var old_val = this.parseField(rec, col.field);
      var tmp = $(el).data('w2field');
      if (tmp) {
        new_val = tmp.clean(new_val);
        if (tmp.type == 'list' && new_val != '') new_val = $(el).data('selected');
      }
      if (el.type == 'checkbox') {
        if (rec.editable === false) el.checked = !el.checked;
        new_val = el.checked;
      }
      // change/restore event
      var eventData = {
        phase: 'before',
        type: 'change',
        target: this.name,
        input_id: el.id,
        recid: rec.recid,
        index: index,
        column: column,
        value_new: new_val,
        value_previous: rec.changes && rec.changes.hasOwnProperty(col.field) ? rec.changes[col.field] : old_val,
        value_original: old_val
      };
      while (true) {
        new_val = eventData.value_new;
        if (_typeof(new_val) != 'object' && String(old_val) != String(new_val) || _typeof(new_val) == 'object' && (_typeof(old_val) != 'object' || new_val.id != old_val.id)) {
          // change event
          eventData = this.trigger($.extend(eventData, {
            type: 'change',
            phase: 'before'
          }));
          if (eventData.isCancelled !== true) {
            if (new_val !== eventData.value_new) {
              // re-evaluate the type of change to be made
              continue;
            }
            // default action
            rec.changes = rec.changes || {};
            rec.changes[col.field] = eventData.value_new;
            // event after
            this.trigger($.extend(eventData, {
              phase: 'after'
            }));
          }
        } else {
          // restore event
          eventData = this.trigger($.extend(eventData, {
            type: 'restore',
            phase: 'before'
          }));
          if (eventData.isCancelled !== true) {
            if (new_val !== eventData.value_new) {
              // re-evaluate the type of change to be made
              continue;
            }
            // default action
            if (rec.changes) delete rec.changes[col.field];
            if ($.isEmptyObject(rec.changes)) delete rec.changes;
            // event after
            this.trigger($.extend(eventData, {
              phase: 'after'
            }));
          }
        }
        break;
      }
      // refresh cell
      var cell = this.getCellHTML(index, column, summary);
      if (!summary) {
        if (rec.changes && typeof rec.changes[col.field] != 'undefined') {
          $(tr).find('[col=' + column + ']').addClass('w2ui-changed').html(cell);
        } else {
          $(tr).find('[col=' + column + ']').removeClass('w2ui-changed').html(cell);
        }
      }
    },
    "delete": function _delete(force) {
      var obj = this;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'delete',
        force: force
      });
      if (eventData.isCancelled === true) return;
      force = eventData.force;
      // default action
      var recs = this.getSelection();
      if (recs.length == 0) return;
      if (this.msgDelete != '' && !force) {
        w2confirm({
          title: w2utils.lang('Delete Confirmation'),
          msg: obj.msgDelete,
          btn_yes: {
            "class": 'w2ui-btn-red'
          },
          callBack: function callBack(result) {
            if (result == 'Yes') w2ui[obj.name]['delete'](true);
          }
        });
        return;
      }
      // call delete script
      var url = _typeof(this.url) != 'object' ? this.url : this.url.remove;
      if (url) {
        this.request('delete-records');
      } else {
        this.selectNone();
        if (_typeof(recs[0]) != 'object') {
          this.remove.apply(this, recs);
        } else {
          // clear cells
          for (var r in recs) {
            var fld = this.columns[recs[r].column].field;
            var ind = this.get(recs[r].recid, true);
            if (ind != null && fld != 'recid') {
              this.records[ind][fld] = '';
              if (this.records[ind].changes) delete this.records[ind].changes[fld];
            }
          }
          this.refresh();
        }
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    click: function click(recid, event) {
      var time = new Date().getTime();
      var column = null;
      if (this.last.cancelClick == true || event && event.altKey) return;
      if (_typeof(recid) == 'object') {
        column = recid.column;
        recid = recid.recid;
      }
      if (typeof event == 'undefined') event = {};
      // check for double click
      if (time - parseInt(this.last.click_time) < 350 && this.last.click_recid == recid && event.type == 'click') {
        this.dblClick(recid, event);
        return;
      }
      this.last.click_time = time;
      this.last.click_recid = recid;
      // column user clicked on
      if (column == null && event.target) {
        var tmp = event.target;
        if (tmp.tagName != 'TD') tmp = $(tmp).parents('td')[0];
        if (typeof $(tmp).attr('col') != 'undefined') column = parseInt($(tmp).attr('col'));
      }
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'click',
        recid: recid,
        column: column,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // if it is subgrid unselect top grid
      var parent = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid)).parents('tr');
      if (parent.length > 0 && String(parent.attr('id')).indexOf('expanded_row') != -1) {
        var grid = parent.parents('.w2ui-grid').attr('name');
        w2ui[grid].selectNone();
        // all subgrids
        parent.parents('.w2ui-grid').find('.w2ui-expanded-row .w2ui-grid').each(function (index, el) {
          var grid = $(el).attr('name');
          if (w2ui[grid]) w2ui[grid].selectNone();
        });
      }
      // unselect all subgrids
      $(this.box).find('.w2ui-expanded-row .w2ui-grid').each(function (index, el) {
        var grid = $(el).attr('name');
        if (w2ui[grid]) w2ui[grid].selectNone();
      });
      // default action
      var obj = this;
      var sel = this.getSelection();
      $('#grid_' + this.name + '_check_all').prop("checked", false);
      var ind = this.get(recid, true);
      var record = this.records[ind];
      var selectColumns = [];
      obj.last.sel_ind = ind;
      obj.last.sel_col = column;
      obj.last.sel_recid = recid;
      obj.last.sel_type = 'click';
      // multi select with shif key
      if (event.shiftKey && sel.length > 0 && obj.multiSelect) {
        if (sel[0].recid) {
          var start = this.get(sel[0].recid, true);
          var end = this.get(recid, true);
          if (column > sel[0].column) {
            var t1 = sel[0].column;
            var t2 = column;
          } else {
            var t1 = column;
            var t2 = sel[0].column;
          }
          for (var c = t1; c <= t2; c++) selectColumns.push(c);
        } else {
          var start = this.get(sel[0], true);
          var end = this.get(recid, true);
        }
        var sel_add = [];
        if (start > end) {
          var tmp = start;
          start = end;
          end = tmp;
        }
        var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
        for (var i = start; i <= end; i++) {
          if (this.searchData.length > 0 && !url && $.inArray(i, this.last.searchIds) == -1) continue;
          if (this.selectType == 'row') {
            sel_add.push(this.records[i].recid);
          } else {
            for (var sc in selectColumns) sel_add.push({
              recid: this.records[i].recid,
              column: selectColumns[sc]
            });
          }
          //sel.push(this.records[i].recid);
        }
        this.select.apply(this, sel_add);
      } else {
        var last = this.last.selection;
        var flag = last.indexes.indexOf(ind) != -1 ? true : false;
        // clear other if necessary
        if ((!event.ctrlKey && !event.shiftKey && !event.metaKey || !this.multiSelect) && !this.showSelectColumn) {
          if (this.selectType != 'row' && $.inArray(column, last.columns[ind]) == -1) flag = false;
          if (sel.length > 300) this.selectNone();else this.unselect.apply(this, sel);
          if (flag === true) {
            this.unselect({
              recid: recid,
              column: column
            });
          } else {
            this.select({
              recid: recid,
              column: column
            });
          }
        } else {
          if (this.selectType != 'row' && $.inArray(column, last.columns[ind]) == -1) flag = false;
          if (flag === true) {
            this.unselect({
              recid: recid,
              column: column
            });
          } else {
            this.select({
              recid: recid,
              column: column
            });
          }
        }
      }
      this.status();
      obj.initResize();
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    columnClick: function columnClick(field, event) {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'columnClick',
        target: this.name,
        field: field,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default behaviour
      var column = this.getColumn(field);
      if (column && column.sortable) {
        this.sort(field, null, event && (event.ctrlKey || event.metaKey) ? true : false);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    keydown: function keydown(event) {
      // this method is called from w2utils
      var obj = this;
      if (obj.keyboard !== true) return;
      // trigger event
      var eventData = obj.trigger({
        phase: 'before',
        type: 'keydown',
        target: obj.name,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default behavior
      var empty = false;
      var records = $('#grid_' + obj.name + '_records');
      var sel = obj.getSelection();
      if (sel.length == 0) empty = true;
      var recid = sel[0] || null;
      var columns = [];
      var recid2 = sel[sel.length - 1];
      if (_typeof(recid) == 'object' && recid != null) {
        recid = sel[0].recid;
        columns = [];
        var ii = 0;
        while (true) {
          if (!sel[ii] || sel[ii].recid != recid) break;
          columns.push(sel[ii].column);
          ii++;
        }
        recid2 = sel[sel.length - 1].recid;
      }
      var ind = obj.get(recid, true);
      var ind2 = obj.get(recid2, true);
      var rec = obj.get(recid);
      var recEL = $('#grid_' + obj.name + '_rec_' + (ind !== null ? w2utils.escapeId(obj.records[ind].recid) : 'none'));
      var cancel = false;
      var key = event.keyCode;
      var shiftKey = event.shiftKey;
      if (key == 9) {
        // tab key
        if (event.shiftKey) key = 37;else key = 39; // replace with arrows
        shiftKey = false;
        cancel = true;
      }
      switch (key) {
        case 8: // backspace
        case 46:
          // delete
          if (this.show.toolbarDelete) obj["delete"]();
          cancel = true;
          event.stopPropagation();
          break;
        case 27:
          // escape
          obj.selectNone();
          if (sel.length > 0 && _typeof(sel[0]) == 'object') {
            obj.select({
              recid: sel[0].recid,
              column: sel[0].column
            });
          }
          cancel = true;
          break;
        case 65:
          // cmd + A
          if (!event.metaKey && !event.ctrlKey) break;
          obj.selectAll();
          cancel = true;
          break;
        case 70:
          // cmd + F
          if (!event.metaKey && !event.ctrlKey) break;
          $('#grid_' + obj.name + '_search_all').focus();
          cancel = true;
          break;
        case 13:
          // enter
          // if expandable columns - expand it
          if (this.selectType == 'row' && obj.show.expandColumn === true) {
            if (recEL.length <= 0) break;
            obj.toggle(recid, event);
            cancel = true;
          } else {
            // or enter edit
            for (var c in this.columns) {
              if (this.columns[c].editable) {
                columns.push(parseInt(c));
                break;
              }
            }
            // edit last column that was edited
            if (this.selectType == 'row' && this.last.edit_col) columns = [this.last.edit_col];
            if (columns.length > 0) {
              obj.editField(recid, columns[0], null, event);
              cancel = true;
            }
          }
          break;
        case 37:
          // left
          if (empty) break;
          // check if this is subgrid
          var parent = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(obj.records[ind].recid)).parents('tr');
          if (parent.length > 0 && String(parent.attr('id')).indexOf('expanded_row') != -1) {
            var recid = parent.prev().attr('recid');
            var grid = parent.parents('.w2ui-grid').attr('name');
            obj.selectNone();
            w2utils.keyboard.active(grid);
            w2ui[grid].set(recid, {
              expanded: false
            });
            w2ui[grid].collapse(recid);
            w2ui[grid].click(recid);
            cancel = true;
            break;
          }
          if (this.selectType == 'row') {
            if (recEL.length <= 0 || rec.expanded !== true) break;
            obj.set(recid, {
              expanded: false
            }, true);
            obj.collapse(recid, event);
          } else {
            var prev = obj.prevCell(columns[0]);
            if (prev != null) {
              if (shiftKey && obj.multiSelect) {
                if (tmpUnselect()) return;
                var tmp = [];
                var newSel = [];
                var unSel = [];
                if (columns.indexOf(this.last.sel_col) == 0 && columns.length > 1) {
                  for (var i in sel) {
                    if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                    unSel.push({
                      recid: sel[i].recid,
                      column: columns[columns.length - 1]
                    });
                  }
                } else {
                  for (var i in sel) {
                    if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                    newSel.push({
                      recid: sel[i].recid,
                      column: prev
                    });
                  }
                }
                obj.unselect.apply(obj, unSel);
                obj.select.apply(obj, newSel);
              } else {
                event.shiftKey = false;
                obj.click({
                  recid: recid,
                  column: prev
                }, event);
              }
            } else {
              // if selected more then one, then select first
              if (!shiftKey) {
                for (var s = 1; s < sel.length; s++) obj.unselect(sel[s]);
              }
            }
          }
          cancel = true;
          break;
        case 39:
          // right
          if (empty) break;
          if (this.selectType == 'row') {
            if (recEL.length <= 0 || rec.expanded === true || obj.show.expandColumn !== true) break;
            obj.expand(recid, event);
          } else {
            var next = obj.nextCell(columns[columns.length - 1]);
            if (next !== null) {
              if (shiftKey && key == 39 && obj.multiSelect) {
                if (tmpUnselect()) return;
                var tmp = [];
                var newSel = [];
                var unSel = [];
                if (columns.indexOf(this.last.sel_col) == columns.length - 1 && columns.length > 1) {
                  for (var i in sel) {
                    if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                    unSel.push({
                      recid: sel[i].recid,
                      column: columns[0]
                    });
                  }
                } else {
                  for (var i in sel) {
                    if (tmp.indexOf(sel[i].recid) == -1) tmp.push(sel[i].recid);
                    newSel.push({
                      recid: sel[i].recid,
                      column: next
                    });
                  }
                }
                obj.unselect.apply(obj, unSel);
                obj.select.apply(obj, newSel);
              } else {
                obj.click({
                  recid: recid,
                  column: next
                }, event);
              }
            } else {
              // if selected more then one, then select first
              if (!shiftKey) {
                for (var s = 0; s < sel.length - 1; s++) obj.unselect(sel[s]);
              }
            }
          }
          cancel = true;
          break;
        case 38:
          // up
          if (empty) selectTopRecord();
          if (recEL.length <= 0) break;
          // move to the previous record
          var prev = obj.prevRow(ind);
          if (prev != null) {
            // jump into subgrid
            if (obj.records[prev].expanded) {
              var subgrid = $('#grid_' + obj.name + '_rec_' + w2utils.escapeId(obj.records[prev].recid) + '_expanded_row').find('.w2ui-grid');
              if (subgrid.length > 0 && w2ui[subgrid.attr('name')]) {
                obj.selectNone();
                var grid = subgrid.attr('name');
                var recs = w2ui[grid].records;
                w2utils.keyboard.active(grid);
                w2ui[grid].click(recs[recs.length - 1].recid);
                cancel = true;
                break;
              }
            }
            if (shiftKey && obj.multiSelect) {
              // expand selection
              if (tmpUnselect()) return;
              if (obj.selectType == 'row') {
                if (obj.last.sel_ind > prev && obj.last.sel_ind != ind2) {
                  obj.unselect(obj.records[ind2].recid);
                } else {
                  obj.select(obj.records[prev].recid);
                }
              } else {
                if (obj.last.sel_ind > prev && obj.last.sel_ind != ind2) {
                  prev = ind2;
                  var tmp = [];
                  for (var c in columns) tmp.push({
                    recid: obj.records[prev].recid,
                    column: columns[c]
                  });
                  obj.unselect.apply(obj, tmp);
                } else {
                  var tmp = [];
                  for (var c in columns) tmp.push({
                    recid: obj.records[prev].recid,
                    column: columns[c]
                  });
                  obj.select.apply(obj, tmp);
                }
              }
            } else {
              // move selected record
              if (sel.length > 300) this.selectNone();else this.unselect.apply(this, sel);
              obj.click({
                recid: obj.records[prev].recid,
                column: columns[0]
              }, event);
            }
            obj.scrollIntoView(prev);
            if (event.preventDefault) event.preventDefault();
          } else {
            // if selected more then one, then select first
            if (!shiftKey) {
              for (var s = 1; s < sel.length; s++) obj.unselect(sel[s]);
            }
            // jump out of subgird (if first record)
            var parent = $('#grid_' + obj.name + '_rec_' + w2utils.escapeId(obj.records[ind].recid)).parents('tr');
            if (parent.length > 0 && String(parent.attr('id')).indexOf('expanded_row') != -1) {
              var recid = parent.prev().attr('recid');
              var grid = parent.parents('.w2ui-grid').attr('name');
              obj.selectNone();
              w2utils.keyboard.active(grid);
              w2ui[grid].click(recid);
              cancel = true;
              break;
            }
          }
          break;
        case 40:
          // down
          if (empty) selectTopRecord();
          if (recEL.length <= 0) break;
          // jump into subgrid
          if (obj.records[ind2].expanded) {
            var subgrid = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(obj.records[ind2].recid) + '_expanded_row').find('.w2ui-grid');
            if (subgrid.length > 0 && w2ui[subgrid.attr('name')]) {
              obj.selectNone();
              var grid = subgrid.attr('name');
              var recs = w2ui[grid].records;
              w2utils.keyboard.active(grid);
              w2ui[grid].click(recs[0].recid);
              cancel = true;
              break;
            }
          }
          // move to the next record
          var next = obj.nextRow(ind2);
          if (next != null) {
            if (shiftKey && obj.multiSelect) {
              // expand selection
              if (tmpUnselect()) return;
              if (obj.selectType == 'row') {
                if (this.last.sel_ind < next && this.last.sel_ind != ind) {
                  obj.unselect(obj.records[ind].recid);
                } else {
                  obj.select(obj.records[next].recid);
                }
              } else {
                if (this.last.sel_ind < next && this.last.sel_ind != ind) {
                  next = ind;
                  var tmp = [];
                  for (var c in columns) tmp.push({
                    recid: obj.records[next].recid,
                    column: columns[c]
                  });
                  obj.unselect.apply(obj, tmp);
                } else {
                  var tmp = [];
                  for (var c in columns) tmp.push({
                    recid: obj.records[next].recid,
                    column: columns[c]
                  });
                  obj.select.apply(obj, tmp);
                }
              }
            } else {
              // move selected record
              if (sel.length > 300) this.selectNone();else this.unselect.apply(this, sel);
              obj.click({
                recid: obj.records[next].recid,
                column: columns[0]
              }, event);
            }
            obj.scrollIntoView(next);
            cancel = true;
          } else {
            // if selected more then one, then select first
            if (!shiftKey) {
              for (var s = 0; s < sel.length - 1; s++) obj.unselect(sel[s]);
            }
            // jump out of subgrid (if last record in subgrid)
            var parent = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(obj.records[ind2].recid)).parents('tr');
            if (parent.length > 0 && String(parent.attr('id')).indexOf('expanded_row') != -1) {
              var recid = parent.next().attr('recid');
              var grid = parent.parents('.w2ui-grid').attr('name');
              obj.selectNone();
              w2utils.keyboard.active(grid);
              w2ui[grid].click(recid);
              cancel = true;
              break;
            }
          }
          break;

        // copy & paste

        case 17: // ctrl key
        case 91:
          var tmp_key_down = function tmp_key_down() {
            $('#_tmp_copy_data').remove();
            $(document).off('keyup', tmp_key_down);
          };
          // cmd key
          if (empty) break;
          var text = obj.copy();
          $('body').append('<textarea id="_tmp_copy_data" ' + '   onpaste="var obj = this; setTimeout(function () { w2ui[\'' + obj.name + '\'].paste(obj.value); }, 1);" ' + '   onkeydown="w2ui[\'' + obj.name + '\'].keydown(event)"' + '   style="position: absolute; top: -100px; height: 1px; width: 1px">' + text + '</textarea>');
          $('#_tmp_copy_data').focus().select();
          // remove _tmp_copy_data textarea
          $(document).on('keyup', tmp_key_down);
          break;
        case 88:
          // x - cut
          if (empty) break;
          if (event.ctrlKey || event.metaKey) {
            setTimeout(function () {
              obj["delete"](true);
            }, 100);
          }
          break;
      }
      var tmp = [187, 189, 32]; // =-spacebar
      for (var i = 48; i <= 90; i++) tmp.push(i); // 0-9,a-z,A-Z
      if (tmp.indexOf(key) != -1 && !event.ctrlKey && !event.metaKey && !cancel) {
        if (columns.length == 0) columns.push(0);
        var tmp = String.fromCharCode(key);
        if (key == 187) tmp = '=';
        if (key == 189) tmp = '-';
        if (!shiftKey) tmp = tmp.toLowerCase();
        obj.editField(recid, columns[0], tmp, event);
        cancel = true;
      }
      if (cancel) {
        // cancel default behaviour
        if (event.preventDefault) event.preventDefault();
      }
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
      function selectTopRecord() {
        var ind = Math.floor((records[0].scrollTop + records.height() / 2.1) / obj.recordHeight);
        if (!obj.records[ind]) ind = 0;
        obj.select({
          recid: obj.records[ind].recid,
          column: 0
        });
      }
      function tmpUnselect() {
        if (obj.last.sel_type != 'click') return false;
        if (obj.selectType != 'row') {
          obj.last.sel_type = 'key';
          if (sel.length > 1) {
            for (var s in sel) {
              if (sel[s].recid == obj.last.sel_recid && sel[s].column == obj.last.sel_col) {
                sel.splice(s, 1);
                break;
              }
            }
            obj.unselect.apply(obj, sel);
            return true;
          }
          return false;
        } else {
          obj.last.sel_type = 'key';
          if (sel.length > 1) {
            sel.splice(sel.indexOf(obj.records[obj.last.sel_ind].recid), 1);
            obj.unselect.apply(obj, sel);
            return true;
          }
          return false;
        }
      }
    },
    scrollIntoView: function scrollIntoView(ind) {
      var buffered = this.records.length;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (this.searchData.length != 0 && !url) buffered = this.last.searchIds.length;
      if (typeof ind == 'undefined') {
        var sel = this.getSelection();
        if (sel.length == 0) return;
        ind = this.get(sel[0], true);
      }
      var records = $('#grid_' + this.name + '_records');
      if (buffered == 0) return;
      // if all records in view
      var len = this.last.searchIds.length;
      if (records.height() > this.recordHeight * (len > 0 ? len : buffered)) return;
      if (len > 0) ind = this.last.searchIds.indexOf(ind); // if seach is applied
      // scroll to correct one
      var t1 = Math.floor(records[0].scrollTop / this.recordHeight);
      var t2 = t1 + Math.floor(records.height() / this.recordHeight);
      if (ind == t1) records.animate({
        'scrollTop': records.scrollTop() - records.height() / 1.3
      }, 250, 'linear');
      if (ind == t2) records.animate({
        'scrollTop': records.scrollTop() + records.height() / 1.3
      }, 250, 'linear');
      if (ind < t1 || ind > t2) records.animate({
        'scrollTop': (ind - 1) * this.recordHeight
      });
    },
    dblClick: function dblClick(recid, event) {
      //if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      // find columns
      var column = null;
      if (_typeof(recid) == 'object') {
        column = recid.column;
        recid = recid.recid;
      }
      if (typeof event == 'undefined') event = {};
      // column user clicked on
      if (column == null && event.target) {
        var tmp = event.target;
        if (tmp.tagName != 'TD') tmp = $(tmp).parents('td')[0];
        column = parseInt($(tmp).attr('col'));
      }
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'dblClick',
        recid: recid,
        column: column,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default action
      this.selectNone();
      var col = this.columns[column];
      if (col && $.isPlainObject(col.editable)) {
        this.editField(recid, column, null, event);
      } else {
        this.select({
          recid: recid,
          column: column
        });
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    contextMenu: function contextMenu(recid, event) {
      var obj = this;
      if (obj.last.userSelect == 'text') return;
      if (typeof event == 'undefined') event = {
        offsetX: 0,
        offsetY: 0,
        target: $('#grid_' + obj.name + '_rec_' + recid)[0]
      };
      if (typeof event.offsetX === 'undefined') {
        event.offsetX = event.layerX - event.target.offsetLeft;
        event.offsetY = event.layerY - event.target.offsetTop;
      }
      if (w2utils.isFloat(recid)) recid = parseFloat(recid);
      if (this.getSelection().indexOf(recid) == -1) obj.click(recid);
      // need timeout to allow click to finish first
      setTimeout(function () {
        // event before
        var eventData = obj.trigger({
          phase: 'before',
          type: 'contextMenu',
          target: obj.name,
          originalEvent: event,
          recid: recid
        });
        if (eventData.isCancelled === true) return;
        // default action
        if (obj.menu.length > 0) {
          $(obj.box).find(event.target).w2menu(obj.menu, {
            left: event.offsetX,
            onSelect: function onSelect(event) {
              obj.menuClick(recid, parseInt(event.index), event.originalEvent);
            }
          });
        }
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, 150); // need timer 150 for FF
      // cancel event
      if (event.preventDefault) event.preventDefault();
    },
    menuClick: function menuClick(recid, index, event) {
      var obj = this;
      // event before
      var eventData = obj.trigger({
        phase: 'before',
        type: 'menuClick',
        target: obj.name,
        originalEvent: event,
        recid: recid,
        menuIndex: index,
        menuItem: obj.menu[index]
      });
      if (eventData.isCancelled === true) return;
      // default action
      // -- empty
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    toggle: function toggle(recid) {
      var rec = this.get(recid);
      if (rec.expanded === true) return this.collapse(recid);else return this.expand(recid);
    },
    expand: function expand(recid) {
      var rec = this.get(recid);
      var obj = this;
      var id = w2utils.escapeId(recid);
      if ($('#grid_' + this.name + '_rec_' + id + '_expanded_row').length > 0) return false;
      if (rec.expanded == 'none') return false;
      // insert expand row
      var tmp = 1 + (this.show.selectColumn ? 1 : 0);
      var addClass = ''; // ($('#grid_'+this.name +'_rec_'+ w2utils.escapeId(recid)).hasClass('w2ui-odd') ? 'w2ui-odd' : 'w2ui-even');
      $('#grid_' + this.name + '_rec_' + id).after('<tr id="grid_' + this.name + '_rec_' + recid + '_expanded_row" class="w2ui-expanded-row ' + addClass + '">' + (this.show.lineNumbers ? '<td class="w2ui-col-number"></td>' : '') + '    <td class="w2ui-grid-data w2ui-expanded1" colspan="' + tmp + '"><div style="display: none"></div></td>' + '    <td colspan="100" class="w2ui-expanded2">' + '        <div id="grid_' + this.name + '_rec_' + recid + '_expanded" style="opacity: 0"></div>' + '    </td>' + '</tr>');
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'expand',
        target: this.name,
        recid: recid,
        box_id: 'grid_' + this.name + '_rec_' + recid + '_expanded',
        ready: ready
      });
      if (eventData.isCancelled === true) {
        $('#grid_' + this.name + '_rec_' + id + '_expanded_row').remove();
        return;
      }
      // default action
      $('#grid_' + this.name + '_rec_' + id).attr('expanded', 'yes').addClass('w2ui-expanded');
      $('#grid_' + this.name + '_rec_' + id + '_expanded_row').show();
      $('#grid_' + this.name + '_cell_' + this.get(recid, true) + '_expand div').html('<div class="w2ui-spinner" style="width: 16px; height: 16px; margin: -2px 2px;"></div>');
      rec.expanded = true;
      // check if height of expanded row > 5 then remove spinner
      setTimeout(ready, 300);
      function ready() {
        var div1 = $('#grid_' + obj.name + '_rec_' + id + '_expanded');
        var div2 = $('#grid_' + obj.name + '_rec_' + id + '_expanded_row .w2ui-expanded1 > div');
        if (div1.height() < 5) return;
        div1.css('opacity', 1);
        div2.show().css('opacity', 1);
        $('#grid_' + obj.name + '_cell_' + obj.get(recid, true) + '_expand div').html('-');
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      this.resizeRecords();
      return true;
    },
    collapse: function collapse(recid) {
      var rec = this.get(recid);
      var obj = this;
      var id = w2utils.escapeId(recid);
      if ($('#grid_' + this.name + '_rec_' + id + '_expanded_row').length == 0) return false;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'collapse',
        target: this.name,
        recid: recid,
        box_id: 'grid_' + this.name + '_rec_' + id + '_expanded'
      });
      if (eventData.isCancelled === true) return;
      // default action
      $('#grid_' + this.name + '_rec_' + id).removeAttr('expanded').removeClass('w2ui-expanded');
      $('#grid_' + this.name + '_rec_' + id + '_expanded').css('opacity', 0);
      $('#grid_' + this.name + '_cell_' + this.get(recid, true) + '_expand div').html('+');
      setTimeout(function () {
        $('#grid_' + obj.name + '_rec_' + id + '_expanded').height('0px');
        setTimeout(function () {
          $('#grid_' + obj.name + '_rec_' + id + '_expanded_row').remove();
          delete rec.expanded;
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
          obj.resizeRecords();
        }, 300);
      }, 200);
      return true;
    },
    sort: function sort(field, direction, multiField) {
      // if no params - clears sort
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'sort',
        target: this.name,
        field: field,
        direction: direction,
        multiField: multiField
      });
      if (eventData.isCancelled === true) return;
      // check if needed to quit
      if (typeof field != 'undefined') {
        // default action
        var sortIndex = this.sortData.length;
        for (var s in this.sortData) {
          if (this.sortData[s].field == field) {
            sortIndex = s;
            break;
          }
        }
        if (typeof direction == 'undefined' || direction == null) {
          if (typeof this.sortData[sortIndex] == 'undefined') {
            direction = 'asc';
          } else {
            switch (String(this.sortData[sortIndex].direction)) {
              case 'asc':
                direction = 'desc';
                break;
              case 'desc':
                direction = 'asc';
                break;
              default:
                direction = 'asc';
                break;
            }
          }
        }
        if (this.multiSort === false) {
          this.sortData = [];
          sortIndex = 0;
        }
        if (multiField != true) {
          this.sortData = [];
          sortIndex = 0;
        }
        // set new sort
        if (typeof this.sortData[sortIndex] == 'undefined') this.sortData[sortIndex] = {};
        this.sortData[sortIndex].field = field;
        this.sortData[sortIndex].direction = direction;
      } else {
        this.sortData = [];
      }
      this.selectNone();
      // if local
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (!url) {
        this.localSort();
        if (this.searchData.length > 0) this.localSearch(true);
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
        this.refresh();
      } else {
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
        this.last.xhr_offset = 0;
        this.reload();
      }
    },
    copy: function copy() {
      var sel = this.getSelection();
      if (sel.length == 0) return '';
      var text = '';
      if (_typeof(sel[0]) == 'object') {
        // cell copy
        // find min/max column
        var minCol = sel[0].column;
        var maxCol = sel[0].column;
        var recs = [];
        for (var s in sel) {
          if (sel[s].column < minCol) minCol = sel[s].column;
          if (sel[s].column > maxCol) maxCol = sel[s].column;
          if (recs.indexOf(sel[s].index) == -1) recs.push(sel[s].index);
        }
        for (var r in recs) {
          var ind = recs[r];
          for (var c = minCol; c <= maxCol; c++) {
            var col = this.columns[c];
            if (col.hidden === true) continue;
            text += w2utils.stripTags(this.getCellHTML(ind, c)) + '\t';
          }
          text = text.substr(0, text.length - 1); // remove last \t
          text += '\n';
        }
      } else {
        // row copy
        // copy headers
        for (var c in this.columns) {
          var col = this.columns[c];
          if (col.hidden === true) continue;
          text += '"' + w2utils.stripTags(col.caption ? col.caption : col.field) + '"\t';
        }
        text = text.substr(0, text.length - 1); // remove last \t
        text += '\n';
        // copy selected text
        for (var s in sel) {
          var ind = this.get(sel[s], true);
          for (var c in this.columns) {
            var col = this.columns[c];
            if (col.hidden === true) continue;
            text += '"' + w2utils.stripTags(this.getCellHTML(ind, c)) + '"\t';
          }
          text = text.substr(0, text.length - 1); // remove last \t
          text += '\n';
        }
      }
      text = text.substr(0, text.length - 1);
      // before event
      var eventData = this.trigger({
        phase: 'before',
        type: 'copy',
        target: this.name,
        text: text
      });
      if (eventData.isCancelled === true) return '';
      text = eventData.text;
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return text;
    },
    paste: function paste(text) {
      var sel = this.getSelection();
      var ind = this.get(sel[0].recid, true);
      var col = sel[0].column;
      // before event
      var eventData = this.trigger({
        phase: 'before',
        type: 'paste',
        target: this.name,
        text: text,
        index: ind,
        column: col
      });
      if (eventData.isCancelled === true) return;
      text = eventData.text;
      // default action
      if (this.selectType == 'row' || sel.length == 0) {
        console.log('ERROR: You can paste only if grid.selectType = \'cell\' and when at least one cell selected.');
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
        return;
      }
      var newSel = [];
      var text = text.split('\n');
      for (var t in text) {
        var tmp = text[t].split('\t');
        var cnt = 0;
        var rec = this.records[ind];
        var cols = [];
        for (var dt in tmp) {
          if (!this.columns[col + cnt]) continue;
          var field = this.columns[col + cnt].field;
          rec.changes = rec.changes || {};
          rec.changes[field] = tmp[dt];
          cols.push(col + cnt);
          cnt++;
        }
        for (var c in cols) newSel.push({
          recid: rec.recid,
          column: cols[c]
        });
        ind++;
      }
      this.selectNone();
      this.select.apply(this, newSel);
      this.refresh();
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    // ==================================================
    // --- Common functions

    resize: function resize() {
      var obj = this;
      var time = new Date().getTime();
      //if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      // make sure the box is right
      if (!this.box || $(this.box).attr('name') != this.name) return;
      // determine new width and height
      $(this.box).find('> div').css('width', $(this.box).width()).css('height', $(this.box).height());
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'resize',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      // resize
      obj.resizeBoxes();
      obj.resizeRecords();
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    refreshCell: function refreshCell(recid, field) {
      var index = this.get(recid, true);
      var isSummary = this.records[index] && this.records[index].recid == recid ? false : true;
      var col_ind = this.getColumn(field, true);
      var rec = isSummary ? this.summary[index] : this.records[index];
      var col = this.columns[col_ind];
      var cell = $('#grid_' + this.name + '_rec_' + recid + ' [col=' + col_ind + ']');
      // set cell html and changed flag
      cell.html(this.getCellHTML(index, col_ind, isSummary));
      if (rec.changes && typeof rec.changes[col.field] != 'undefined') {
        cell.addClass('w2ui-changed');
      } else {
        cell.removeClass('w2ui-changed');
      }
    },
    refreshRow: function refreshRow(recid) {
      var tr = $('#grid_' + this.name + '_rec_' + w2utils.escapeId(recid));
      if (tr.length != 0) {
        var ind = this.get(recid, true);
        var line = tr.attr('line');
        var isSummary = this.records[ind] && this.records[ind].recid == recid ? false : true;
        // if it is searched, find index in search array
        var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
        if (this.searchData.length > 0 && !url) for (var s in this.last.searchIds) if (this.last.searchIds[s] == ind) ind = s;
        $(tr).replaceWith(this.getRecordHTML(ind, line, isSummary));
        if (isSummary) this.resize();
      }
    },
    refresh: function refresh() {
      var obj = this;
      var time = new Date().getTime();
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (this.total <= 0 && !url && this.searchData.length == 0) {
        this.total = this.records.length;
      }
      //if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      this.toolbar.disable('w2ui-edit', 'w2ui-delete');
      if (!this.box) return;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'refresh'
      });
      if (eventData.isCancelled === true) return;
      // -- header
      if (this.show.header) {
        $('#grid_' + this.name + '_header').html(this.header + '&nbsp;').show();
      } else {
        $('#grid_' + this.name + '_header').hide();
      }
      // -- toolbar
      if (this.show.toolbar) {
        // if select-collumn is checked - no toolbar refresh
        if (this.toolbar && this.toolbar.get('w2ui-column-on-off') && this.toolbar.get('w2ui-column-on-off').checked) {
          // no action
        } else {
          $('#grid_' + this.name + '_toolbar').show();
          // refresh toolbar all but search field
          if (_typeof(this.toolbar) == 'object') {
            var tmp = this.toolbar.items;
            for (var t in tmp) {
              if (tmp[t].id == 'w2ui-search' || tmp[t].type == 'break') continue;
              this.toolbar.refresh(tmp[t].id);
            }
          }
        }
      } else {
        $('#grid_' + this.name + '_toolbar').hide();
      }
      // -- make sure search is closed
      this.searchClose();
      // search placeholder
      var el = $('#grid_' + obj.name + '_search_all');
      if (!this.multiSearch && this.last.field == 'all' && this.searches.length > 0) {
        this.last.field = this.searches[0].field;
        this.last.caption = this.searches[0].caption;
      }
      for (var s in this.searches) {
        if (this.searches[s].field == this.last.field) this.last.caption = this.searches[s].caption;
      }
      if (this.last.multi) {
        el.attr('placeholder', '[' + w2utils.lang('Multiple Fields') + ']');
      } else {
        el.attr('placeholder', this.last.caption);
      }
      if (el.val() != this.last.search) {
        var val = this.last.search;
        var tmp = el.data('w2field');
        if (tmp) val = tmp.format(val);
        el.val(val);
      }

      // -- separate summary
      var tmp = this.find({
        summary: true
      }, true);
      if (tmp.length > 0) {
        for (var t in tmp) this.summary.push(this.records[tmp[t]]);
        for (var t = tmp.length - 1; t >= 0; t--) this.records.splice(tmp[t], 1);
        this.total = this.total - tmp.length;
      }

      // collapse all records
      var rows = obj.find({
        expanded: true
      }, true);
      for (var r in rows) obj.records[rows[r]].expanded = false;

      // -- body
      var bodyHTML = '';
      bodyHTML += '<div id="grid_' + this.name + '_records" class="w2ui-grid-records"' + '    onscroll="var obj = w2ui[\'' + this.name + '\']; ' + '        obj.last.scrollTop = this.scrollTop; ' + '        obj.last.scrollLeft = this.scrollLeft; ' + '        $(\'#grid_' + this.name + '_columns\')[0].scrollLeft = this.scrollLeft;' + '        $(\'#grid_' + this.name + '_summary\')[0].scrollLeft = this.scrollLeft;' + '        obj.scroll(event);">' + this.getRecordsHTML() + '</div>' + '<div id="grid_' + this.name + '_columns" class="w2ui-grid-columns">' + '    <table>' + this.getColumnsHTML() + '</table>' + '</div>'; // Columns need to be after to be able to overlap
      $('#grid_' + this.name + '_body').html(bodyHTML);
      // show summary records
      if (this.summary.length > 0) {
        $('#grid_' + this.name + '_summary').html(this.getSummaryHTML()).show();
      } else {
        $('#grid_' + this.name + '_summary').hide();
      }
      // -- footer
      if (this.show.footer) {
        $('#grid_' + this.name + '_footer').html(this.getFooterHTML()).show();
      } else {
        $('#grid_' + this.name + '_footer').hide();
      }
      // show/hide clear search link
      if (this.searchData.length > 0) {
        $('#grid_' + this.name + '_searchClear').show();
      } else {
        $('#grid_' + this.name + '_searchClear').hide();
      }
      // all selected?
      var sel = this.last.selection;
      if (sel.indexes.length == this.records.length || this.searchData.length !== 0 && sel.indexes.length == this.last.searchIds.length) {
        $('#grid_' + this.name + '_check_all').prop('checked', true);
      } else {
        $('#grid_' + this.name + '_check_all').prop('checked', false);
      }
      // show number of selected
      this.status();
      // mark selection
      setTimeout(function () {
        var str = $.trim($('#grid_' + obj.name + '_search_all').val());
        if (str != '') $(obj.box).find('.w2ui-grid-data > div').w2marker(str);
      }, 50);
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      obj.resize();
      obj.addRange('selection');
      setTimeout(function () {
        obj.resize();
        obj.scroll();
      }, 1); // allow to render first

      if (obj.reorderColumns && !obj.last.columnDrag) {
        obj.last.columnDrag = obj.initColumnDrag();
      } else if (!obj.reorderColumns && obj.last.columnDrag) {
        obj.last.columnDrag.remove();
      }
      return new Date().getTime() - time;
    },
    render: function render(box) {
      var obj = this;
      var time = new Date().getTime();
      //if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      if (typeof box != 'undefined' && box != null) {
        if ($(this.box).find('#grid_' + this.name + '_body').length > 0) {
          $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-grid').html('');
        }
        this.box = box;
      }
      if (!this.box) return;
      if (this.last.sortData == null) this.last.sortData = this.sortData;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'render',
        box: box
      });
      if (eventData.isCancelled === true) return;
      // insert Elements
      $(this.box).attr('name', this.name).addClass('w2ui-reset w2ui-grid').html('<div>' + '    <div id="grid_' + this.name + '_header" class="w2ui-grid-header"></div>' + '    <div id="grid_' + this.name + '_toolbar" class="w2ui-grid-toolbar"></div>' + '    <div id="grid_' + this.name + '_body" class="w2ui-grid-body"></div>' + '    <div id="grid_' + this.name + '_summary" class="w2ui-grid-body w2ui-grid-summary"></div>' + '    <div id="grid_' + this.name + '_footer" class="w2ui-grid-footer"></div>' + '</div>');
      if (this.selectType != 'row') $(this.box).addClass('w2ui-ss');
      if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
      // init toolbar
      this.initToolbar();
      if (this.toolbar != null) this.toolbar.render($('#grid_' + this.name + '_toolbar')[0]);
      // reinit search_all
      if (this.last.field && this.last.field != 'all') {
        var sd = this.searchData;
        this.initAllField(this.last.field, sd.length == 1 ? sd[0].value : null);
      }
      // init footer
      $('#grid_' + this.name + '_footer').html(this.getFooterHTML());
      // refresh
      if (!this.last.state) this.last.state = this.stateSave(true); // initial default state
      this.stateRestore();
      if (url) this.refresh(); // show empty grid (need it) - should it be only for remote data source
      this.reload();

      // init mouse events for mouse selection
      $(this.box).on('mousedown', mouseStart);
      $(this.box).on('selectstart', function () {
        return false;
      }); // fixes chrome cursor bug

      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      // attach to resize event
      if ($('.w2ui-layout').length == 0) {
        // if there is layout, it will send a resize event
        this.tmp_resize = function (event) {
          w2ui[obj.name].resize();
        };
        $(window).off('resize', this.tmp_resize).on('resize', this.tmp_resize);
      }
      return new Date().getTime() - time;
      function mouseStart(event) {
        if (event.which != 1) return; // if not left mouse button
        // restore css user-select
        if (obj.last.userSelect == 'text') {
          delete obj.last.userSelect;
          $(obj.box).find('.w2ui-grid-body').css('user-select', 'none').css('-webkit-user-select', 'none').css('-moz-user-select', 'none').css('-ms-user-select', 'none');
          $(this.box).on('selectstart', function () {
            return false;
          });
        }
        // regular record select
        if ($(event.target).parents().hasClass('w2ui-head') || $(event.target).hasClass('w2ui-head')) return;
        if (obj.last.move && obj.last.move.type == 'expand') return;
        // if altKey - alow text selection
        if (event.altKey) {
          $(obj.box).off('selectstart');
          $(obj.box).find('.w2ui-grid-body').css('user-select', 'text').css('-webkit-user-select', 'text').css('-moz-user-select', 'text').css('-ms-user-select', 'text');
          obj.selectNone();
          obj.last.move = {
            type: 'text-select'
          };
          obj.last.userSelect = 'text';
        } else {
          if (!obj.multiSelect) return;
          obj.last.move = {
            x: event.screenX,
            y: event.screenY,
            divX: 0,
            divY: 0,
            recid: $(event.target).parents('tr').attr('recid'),
            column: event.target.tagName == 'TD' ? $(event.target).attr('col') : $(event.target).parents('td').attr('col'),
            type: 'select',
            ghost: false,
            start: true
          };
        }
        $(document).on('mousemove', mouseMove);
        $(document).on('mouseup', mouseStop);
      }
      function mouseMove(event) {
        var mv = obj.last.move;
        if (!mv || mv.type != 'select') return;
        mv.divX = event.screenX - mv.x;
        mv.divY = event.screenY - mv.y;
        if (Math.abs(mv.divX) <= 1 && Math.abs(mv.divY) <= 1) return; // only if moved more then 1px
        obj.last.cancelClick = true;
        if (obj.reorderRows == true) {
          if (!mv.ghost) {
            var row = $('#grid_' + obj.name + '_rec_' + mv.recid);
            var tmp = row.parents('table').find('tr:first-child').clone();
            mv.offsetY = event.offsetY;
            mv.from = mv.recid;
            mv.pos = row.position();
            mv.ghost = $(row).clone(true);
            mv.ghost.removeAttr('id');
            row.find('td:first-child').replaceWith('<td colspan="1000" style="height: ' + obj.recordHeight + 'px; background-color: #ddd"></td>');
            var recs = $(obj.box).find('.w2ui-grid-records');
            recs.append('<table id="grid_' + obj.name + '_ghost" style="position: absolute; z-index: 999999; opacity: 0.8; border-bottom: 2px dashed #aaa; border-top: 2px dashed #aaa; pointer-events: none;"></table>');
            $('#grid_' + obj.name + '_ghost').append(tmp).append(mv.ghost);
          }
          var recid = $(event.target).parents('tr').attr('recid');
          if (recid != mv.from) {
            var row1 = $('#grid_' + obj.name + '_rec_' + mv.recid);
            var row2 = $('#grid_' + obj.name + '_rec_' + recid);
            if (event.screenY - mv.lastY < 0) row1.after(row2);else row2.after(row1);
            mv.lastY = event.screenY;
            mv.to = recid;
          }
          var ghost = $('#grid_' + obj.name + '_ghost');
          var recs = $(obj.box).find('.w2ui-grid-records');
          ghost.css({
            top: mv.pos.top + mv.divY + recs.scrollTop(),
            // + mv.offsetY - obj.recordHeight / 2,
            left: mv.pos.left
          });
          return;
        }
        if (mv.start && mv.recid) {
          obj.selectNone();
          mv.start = false;
        }
        var newSel = [];
        var recid = event.target.tagName == 'TR' ? $(event.target).attr('recid') : $(event.target).parents('tr').attr('recid');
        if (typeof recid == 'undefined') return;
        var ind1 = obj.get(mv.recid, true);
        // |:wolfmanx:| this happens when selection is started on summary row
        if (ind1 === null) return;
        var ind2 = obj.get(recid, true);
        // this happens when selection is extended into summary row (a good place to implement scrolling)
        if (ind2 === null) return;
        var col1 = parseInt(mv.column);
        var col2 = parseInt(event.target.tagName == 'TD' ? $(event.target).attr('col') : $(event.target).parents('td').attr('col'));
        if (ind1 > ind2) {
          var tmp = ind1;
          ind1 = ind2;
          ind2 = tmp;
        }
        // check if need to refresh
        var tmp = 'ind1:' + ind1 + ',ind2;' + ind2 + ',col1:' + col1 + ',col2:' + col2;
        if (mv.range == tmp) return;
        mv.range = tmp;
        for (var i = ind1; i <= ind2; i++) {
          if (obj.last.searchIds.length > 0 && obj.last.searchIds.indexOf(i) == -1) continue;
          if (obj.selectType != 'row') {
            if (col1 > col2) {
              var tmp = col1;
              col1 = col2;
              col2 = tmp;
            }
            var tmp = [];
            for (var c = col1; c <= col2; c++) {
              if (obj.columns[c].hidden) continue;
              newSel.push({
                recid: obj.records[i].recid,
                column: parseInt(c)
              });
            }
          } else {
            newSel.push(obj.records[i].recid);
          }
        }
        if (obj.selectType != 'row') {
          var sel = obj.getSelection();
          // add more items
          var tmp = [];
          for (var ns in newSel) {
            var flag = false;
            for (var s in sel) if (newSel[ns].recid == sel[s].recid && newSel[ns].column == sel[s].column) flag = true;
            if (!flag) tmp.push({
              recid: newSel[ns].recid,
              column: newSel[ns].column
            });
          }
          obj.select.apply(obj, tmp);
          // remove items
          var tmp = [];
          for (var s in sel) {
            var flag = false;
            for (var ns in newSel) if (newSel[ns].recid == sel[s].recid && newSel[ns].column == sel[s].column) flag = true;
            if (!flag) tmp.push({
              recid: sel[s].recid,
              column: sel[s].column
            });
          }
          obj.unselect.apply(obj, tmp);
        } else {
          if (obj.multiSelect) {
            var sel = obj.getSelection();
            for (var ns in newSel) if (sel.indexOf(newSel[ns]) == -1) obj.select(newSel[ns]); // add more items
            for (var s in sel) if (newSel.indexOf(sel[s]) == -1) obj.unselect(sel[s]); // remove items
          }
        }
      }
      function mouseStop(event) {
        var mv = obj.last.move;
        setTimeout(function () {
          delete obj.last.cancelClick;
        }, 1);
        if ($(event.target).parents().hasClass('.w2ui-head') || $(event.target).hasClass('.w2ui-head')) return;
        if (mv && mv.type == 'select') {
          if (obj.reorderRows == true) {
            var ind1 = obj.get(mv.from, true);
            var tmp = obj.records[ind1];
            obj.records.splice(ind1, 1);
            var ind2 = obj.get(mv.to, true);
            if (ind1 > ind2) obj.records.splice(ind2, 0, tmp);else obj.records.splice(ind2 + 1, 0, tmp);
            $('#grid_' + obj.name + '_ghost').remove();
            obj.refresh();
          }
        }
        delete obj.last.move;
        $(document).off('mousemove', mouseMove);
        $(document).off('mouseup', mouseStop);
      }
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'destroy'
      });
      if (eventData.isCancelled === true) return;
      // remove events
      $(window).off('resize', this.tmp_resize);
      // clean up
      if (_typeof(this.toolbar) == 'object' && this.toolbar.destroy) this.toolbar.destroy();
      if ($(this.box).find('#grid_' + this.name + '_body').length > 0) {
        $(this.box).removeAttr('name').off('selectstart').removeClass('w2ui-reset w2ui-grid').html('');
      }
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    // ===========================================
    // --- Internal Functions

    initColumnOnOff: function initColumnOnOff() {
      if (!this.show.toolbarColumns) return;
      var obj = this;
      var col_html = '<div class="w2ui-col-on-off">' + '<table><tr>' + '<td style="width: 30px">' + '    <input id="grid_' + this.name + '_column_ln_check" type="checkbox" tabIndex="-1" ' + (obj.show.lineNumbers ? 'checked' : '') + '        onclick="w2ui[\'' + obj.name + '\'].columnOnOff(this, event, \'line-numbers\');">' + '</td>' + '<td onclick="w2ui[\'' + obj.name + '\'].columnOnOff(this, event, \'line-numbers\'); $(\'#w2ui-overlay\')[0].hide();">' + '    <label for="grid_' + this.name + '_column_ln_check">' + w2utils.lang('Line #') + '</label>' + '</td></tr>';
      for (var c in this.columns) {
        var col = this.columns[c];
        var tmp = this.columns[c].caption;
        if (col.hideable === false) continue;
        if (!tmp && this.columns[c].hint) tmp = this.columns[c].hint;
        if (!tmp) tmp = '- column ' + (parseInt(c) + 1) + ' -';
        col_html += '<tr>' + '<td style="width: 30px">' + '    <input id="grid_' + this.name + '_column_' + c + '_check" type="checkbox" tabIndex="-1" ' + (col.hidden ? '' : 'checked') + '        onclick="w2ui[\'' + obj.name + '\'].columnOnOff(this, event, \'' + col.field + '\');">' + '</td>' + '<td>' + '    <label for="grid_' + this.name + '_column_' + c + '_check">' + tmp + '</label>' + '</td>' + '</tr>';
      }
      col_html += '<tr><td colspan="2"><div style="border-top: 1px solid #ddd;"></div></td></tr>';
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url && obj.show.skipRecords) {
        col_html += '<tr><td colspan="2" style="padding: 0px">' + '    <div style="cursor: pointer; padding: 2px 8px; cursor: default">' + w2utils.lang('Skip') + '        <input type="text" style="width: 45px" value="' + this.offset + '" ' + '            onkeypress="if (event.keyCode == 13) { ' + '               w2ui[\'' + obj.name + '\'].skip(this.value); ' + '               $(\'#w2ui-overlay\')[0].hide(); ' + '            }"> ' + w2utils.lang('Records') + '    </div>' + '</td></tr>';
      }
      col_html += '<tr><td colspan="2" onclick="w2ui[\'' + obj.name + '\'].stateSave(); $(\'#w2ui-overlay\')[0].hide();">' + '    <div style="cursor: pointer; padding: 4px 8px; cursor: default">' + w2utils.lang('Save Grid State') + '</div>' + '</td></tr>' + '<tr><td colspan="2" onclick="w2ui[\'' + obj.name + '\'].stateReset(); $(\'#w2ui-overlay\')[0].hide();">' + '    <div style="cursor: pointer; padding: 4px 8px; cursor: default">' + w2utils.lang('Restore Default State') + '</div>' + '</td></tr>';
      col_html += "</table></div>";
      this.toolbar.get('w2ui-column-on-off').html = col_html;
    },
    /**
     *
     * @param box, grid object
     * @returns {{remove: Function}} contains a closure around all events to ensure they are removed from the dom
     */
    initColumnDrag: function initColumnDrag(box) {
      //throw error if using column groups
      if (this.columnGroups && this.columnGroups.length) throw 'Draggable columns are not currently supported with column groups.';
      var obj = this,
        _dragData = {};
      _dragData.lastInt = null;
      _dragData.pressed = false;
      _dragData.timeout = null;
      _dragData.columnHead = null;

      //attach orginal event listener
      $(obj.box).on('mousedown', dragColStart);
      $(obj.box).on('mouseup', catchMouseup);
      function catchMouseup() {
        _dragData.pressed = false;
        clearTimeout(_dragData.timeout);
      }
      /**
       *
       * @param event, mousedown
       * @returns {boolean} false, preventsDefault
       */
      function dragColStart(event) {
        if (_dragData.timeout) clearTimeout(_dragData.timeout);
        var self = this;
        _dragData.pressed = true;
        _dragData.timeout = setTimeout(function () {
          if (!_dragData.pressed) return;
          var eventData,
            columns,
            selectedCol,
            origColumn,
            origColumnNumber,
            invalidPreColumns = ['w2ui-col-number', 'w2ui-col-expand', 'w2ui-col-select'],
            invalidPostColumns = ['w2ui-head-last'],
            invalidColumns = invalidPreColumns.concat(invalidPostColumns),
            preColumnsSelector = '.w2ui-col-number, .w2ui-col-expand, .w2ui-col-select',
            preColHeadersSelector = '.w2ui-head.w2ui-col-number, .w2ui-head.w2ui-col-expand, .w2ui-head.w2ui-col-select';

          // do nothing if it is not a header
          if (!$(event.originalEvent.target).parents().hasClass('w2ui-head')) return;

          // do nothing if it is an invalid column
          for (var i = 0, l = invalidColumns.length; i < l; i++) {
            if ($(event.originalEvent.target).parents().hasClass(invalidColumns[i])) return;
          }
          _dragData.numberPreColumnsPresent = $(obj.box).find(preColHeadersSelector).length;

          //start event for drag start
          _dragData.columnHead = origColumn = $(event.originalEvent.target).parents('.w2ui-head');
          origColumnNumber = parseInt(origColumn.attr('col'), 10);
          eventData = obj.trigger({
            type: 'columnDragStart',
            phase: 'before',
            originalEvent: event,
            origColumnNumber: origColumnNumber,
            target: origColumn[0]
          });
          if (eventData.isCancelled === true) return false;
          columns = _dragData.columns = $(obj.box).find('.w2ui-head:not(.w2ui-head-last)');

          //add events
          $(document).on('mouseup', dragColEnd);
          $(document).on('mousemove', dragColOver);
          _dragData.originalPos = parseInt($(event.originalEvent.target).parent('.w2ui-head').attr('col'), 10);
          //_dragData.columns.css({ overflow: 'visible' }).children( 'div' ).css({ overflow: 'visible' });

          //configure and style ghost image
          _dragData.ghost = $(self).clone(true);

          //hide other elements on ghost except the grid body
          $(_dragData.ghost).find('[col]:not([col="' + _dragData.originalPos + '"]), .w2ui-toolbar, .w2ui-grid-header').remove();
          $(_dragData.ghost).find(preColumnsSelector).remove();
          $(_dragData.ghost).find('.w2ui-grid-body').css({
            top: 0
          });
          selectedCol = $(_dragData.ghost).find('[col="' + _dragData.originalPos + '"]');
          $(document.body).append(_dragData.ghost);
          $(_dragData.ghost).css({
            width: 0,
            height: 0,
            margin: 0,
            position: 'fixed',
            zIndex: 999999,
            opacity: 0
          }).addClass('.w2ui-grid-ghost').animate({
            width: selectedCol.width(),
            height: $(obj.box).find('.w2ui-grid-body:first').height(),
            left: event.pageX,
            top: event.pageY,
            opacity: .8
          }, 0);

          //establish current offsets
          _dragData.offsets = [];
          for (var i = 0, l = columns.length; i < l; i++) {
            _dragData.offsets.push($(columns[i]).offset().left);
          }

          //conclude event
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        }, 150); //end timeout wrapper
      }
      function dragColOver(event) {
        if (!_dragData.pressed) return;
        var cursorX = event.originalEvent.pageX,
          cursorY = event.originalEvent.pageY,
          offsets = _dragData.offsets,
          lastWidth = $('.w2ui-head:not(.w2ui-head-last)').width();
        _dragData.targetInt = Math.max(_dragData.numberPreColumnsPresent, targetIntersection(cursorX, offsets, lastWidth));
        markIntersection(_dragData.targetInt);
        trackGhost(cursorX, cursorY);
      }
      function dragColEnd(event) {
        _dragData.pressed = false;
        var eventData,
          target,
          selected,
          columnConfig,
          targetColumn,
          ghosts = $('.w2ui-grid-ghost');

        //start event for drag start
        eventData = obj.trigger({
          type: 'columnDragEnd',
          phase: 'before',
          originalEvent: event,
          target: _dragData.columnHead[0]
        });
        if (eventData.isCancelled === true) return false;
        selected = obj.columns[_dragData.originalPos];
        columnConfig = obj.columns;
        targetColumn = $(_dragData.columns[Math.min(_dragData.lastInt, _dragData.columns.length - 1)]);
        target = _dragData.lastInt < _dragData.columns.length ? parseInt(targetColumn.attr('col')) : columnConfig.length;
        if (target !== _dragData.originalPos + 1 && target !== _dragData.originalPos && targetColumn && targetColumn.length) {
          $(_dragData.ghost).animate({
            top: $(obj.box).offset().top,
            left: targetColumn.offset().left,
            width: 0,
            height: 0,
            opacity: .2
          }, 300, function () {
            $(this).remove();
            ghosts.remove();
          });
          columnConfig.splice(target, 0, $.extend({}, selected));
          columnConfig.splice(columnConfig.indexOf(selected), 1);
        } else {
          $(_dragData.ghost).remove();
          ghosts.remove();
        }

        //_dragData.columns.css({ overflow: '' }).children( 'div' ).css({ overflow: '' });

        $(document).off('mouseup', dragColEnd);
        $(document).off('mousemove', dragColOver);
        if (_dragData.marker) _dragData.marker.remove();
        _dragData = {};
        obj.refresh();

        //conclude event
        obj.trigger($.extend(eventData, {
          phase: 'after',
          targetColumnNumber: target - 1
        }));
      }
      function markIntersection(intersection) {
        if (!_dragData.marker && !_dragData.markerLeft) {
          _dragData.marker = $('<div class="col-intersection-marker">' + '<div class="top-marker"></div>' + '<div class="bottom-marker"></div>' + '</div>');
          _dragData.markerLeft = $('<div class="col-intersection-marker">' + '<div class="top-marker"></div>' + '<div class="bottom-marker"></div>' + '</div>');
        }
        if (!_dragData.lastInt || _dragData.lastInt !== intersection) {
          _dragData.lastInt = intersection;
          _dragData.marker.remove();
          _dragData.markerLeft.remove();
          $('.w2ui-head').removeClass('w2ui-col-intersection');

          //if the current intersection is greater than the number of columns add the marker to the end of the last column only
          if (intersection >= _dragData.columns.length) {
            $(_dragData.columns[_dragData.columns.length - 1]).children('div:last').append(_dragData.marker.addClass('right').removeClass('left'));
            $(_dragData.columns[_dragData.columns.length - 1]).addClass('w2ui-col-intersection');
          } else if (intersection <= _dragData.numberPreColumnsPresent) {
            //if the current intersection is on the column numbers place marker on first available column only
            $(_dragData.columns[_dragData.numberPreColumnsPresent]).prepend(_dragData.marker.addClass('left').removeClass('right')).css({
              position: 'relative'
            });
            $(_dragData.columns[_dragData.numberPreColumnsPresent]).prev().addClass('w2ui-col-intersection');
          } else {
            //otherwise prepend the marker to the targeted column and append it to the previous column
            $(_dragData.columns[intersection]).children('div:last').prepend(_dragData.marker.addClass('left').removeClass('right'));
            $(_dragData.columns[intersection]).prev().children('div:last').append(_dragData.markerLeft.addClass('right').removeClass('left')).css({
              position: 'relative'
            });
            $(_dragData.columns[intersection - 1]).addClass('w2ui-col-intersection');
          }
        }
      }
      function targetIntersection(cursorX, offsets, lastWidth) {
        if (cursorX <= offsets[0]) {
          return 0;
        } else if (cursorX >= offsets[offsets.length - 1] + lastWidth) {
          return offsets.length;
        } else {
          for (var i = 0, l = offsets.length; i < l; i++) {
            var thisOffset = offsets[i];
            var nextOffset = offsets[i + 1] || offsets[i] + lastWidth;
            var midpoint = (nextOffset - offsets[i]) / 2 + offsets[i];
            if (cursorX > thisOffset && cursorX <= midpoint) {
              return i;
            } else if (cursorX > midpoint && cursorX <= nextOffset) {
              return i + 1;
            }
          }
          return intersection;
        }
      }
      function trackGhost(cursorX, cursorY) {
        $(_dragData.ghost).css({
          left: cursorX - 10,
          top: cursorY - 10
        });
      }

      //return an object to remove drag if it has ever been enabled
      return {
        remove: function remove() {
          $(obj.box).off('mousedown', dragColStart);
          $(obj.box).off('mouseup', catchMouseup);
          $(obj.box).find('.w2ui-head').removeAttr('draggable');
          obj.last.columnDrag = false;
        }
      };
    },
    columnOnOff: function columnOnOff(el, event, field) {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'columnOnOff',
        checkbox: el,
        field: field,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // regular processing
      var obj = this;
      // collapse expanded rows
      for (var r in this.records) {
        if (this.records[r].expanded === true) this.records[r].expanded = false;
      }
      // show/hide
      var hide = true;
      if (field == 'line-numbers') {
        this.show.lineNumbers = !this.show.lineNumbers;
        this.refresh();
      } else {
        var col = this.getColumn(field);
        if (col.hidden) {
          $(el).prop('checked', true);
          this.showColumn(col.field);
        } else {
          $(el).prop('checked', false);
          this.hideColumn(col.field);
        }
        hide = false;
      }
      if (hide) {
        setTimeout(function () {
          $().w2overlay('', {
            name: 'searches-' + this.name
          });
          obj.toolbar.uncheck('column-on-off');
        }, 100);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    initToolbar: function initToolbar() {
      // -- if toolbar is true
      if (typeof this.toolbar['render'] == 'undefined') {
        var tmp_items = this.toolbar.items;
        this.toolbar.items = [];
        this.toolbar = $().w2toolbar($.extend(true, {}, this.toolbar, {
          name: this.name + '_toolbar',
          owner: this
        }));

        // =============================================
        // ------ Toolbar Generic buttons

        if (this.show.toolbarReload) {
          this.toolbar.items.push($.extend(true, {}, this.buttons['reload']));
        }
        if (this.show.toolbarColumns) {
          this.toolbar.items.push($.extend(true, {}, this.buttons['columns']));
        }
        if (this.show.toolbarReload || this.show.toolbarColumn) {
          this.toolbar.items.push({
            type: 'break',
            id: 'w2ui-break0'
          });
        }
        if (this.show.toolbarSearch) {
          var html = '<div class="w2ui-toolbar-search">' + '<table cellpadding="0" cellspacing="0"><tr>' + '    <td>' + this.buttons['search'].html + '</td>' + '    <td>' + '        <input id="grid_' + this.name + '_search_all" class="w2ui-search-all" ' + '            placeholder="' + this.last.caption + '" value="' + this.last.search + '"' + '            onkeydown="if (event.keyCode == 13 && w2utils.isIE) this.onchange();"' + '            onchange="' + '                var val = this.value; ' + '                var fld = $(this).data(\'w2field\'); ' + '                var dat = $(this).data(\'selected\'); ' + '                if (fld) val = fld.clean(val);' + '                if (dat != null && $.isPlainObject(dat)) val = dat.id;' + '                w2ui[\'' + this.name + '\'].search(w2ui[\'' + this.name + '\'].last.field, val); ' + '            ">' + '    </td>' + '    <td>' + '        <div title="' + w2utils.lang('Clear Search') + '" class="w2ui-search-clear" id="grid_' + this.name + '_searchClear"  ' + '             onclick="var obj = w2ui[\'' + this.name + '\']; obj.searchReset();" ' + '        >&nbsp;&nbsp;</div>' + '    </td>' + '</tr></table>' + '</div>';
          this.toolbar.items.push({
            type: 'html',
            id: 'w2ui-search',
            html: html
          });
          if (this.multiSearch && this.searches.length > 0) {
            this.toolbar.items.push($.extend(true, {}, this.buttons['search-go']));
          }
        }
        if (this.show.toolbarSearch && (this.show.toolbarAdd || this.show.toolbarEdit || this.show.toolbarDelete || this.show.toolbarSave)) {
          this.toolbar.items.push({
            type: 'break',
            id: 'w2ui-break1'
          });
        }
        if (this.show.toolbarAdd) {
          this.toolbar.items.push($.extend(true, {}, this.buttons['add']));
        }
        if (this.show.toolbarEdit) {
          this.toolbar.items.push($.extend(true, {}, this.buttons['edit']));
        }
        if (this.show.toolbarDelete) {
          this.toolbar.items.push($.extend(true, {}, this.buttons['delete']));
        }
        if (this.show.toolbarSave) {
          if (this.show.toolbarAdd || this.show.toolbarDelete || this.show.toolbarEdit) {
            this.toolbar.items.push({
              type: 'break',
              id: 'w2ui-break2'
            });
          }
          this.toolbar.items.push($.extend(true, {}, this.buttons['save']));
        }
        // add original buttons
        for (var i in tmp_items) this.toolbar.items.push(tmp_items[i]);

        // =============================================
        // ------ Toolbar onClick processing

        var obj = this;
        this.toolbar.on('click', function (event) {
          var eventData = obj.trigger({
            phase: 'before',
            type: 'toolbar',
            target: event.target,
            originalEvent: event
          });
          if (eventData.isCancelled === true) return;
          var id = event.target;
          switch (id) {
            case 'w2ui-reload':
              var eventData2 = obj.trigger({
                phase: 'before',
                type: 'reload',
                target: obj.name
              });
              if (eventData2.isCancelled === true) return false;
              obj.reload();
              obj.trigger($.extend(eventData2, {
                phase: 'after'
              }));
              break;
            case 'w2ui-column-on-off':
              obj.initColumnOnOff();
              obj.initResize();
              obj.resize();
              break;
            case 'w2ui-search-advanced':
              var tb = this;
              var it = this.get(id);
              if (it.checked) {
                obj.searchClose();
                setTimeout(function () {
                  tb.uncheck(id);
                }, 1);
              } else {
                var tmp_close = function tmp_close() {
                  if ($('#w2ui-overlay-searches-' + obj.name).data('keepOpen') === true) return;
                  tb.uncheck(id);
                  $(document).off('click', 'body', tmp_close);
                };
                obj.searchOpen();
                event.originalEvent.stopPropagation();
                $(document).on('click', 'body', tmp_close);
              }
              break;
            case 'w2ui-add':
              // events
              var eventData = obj.trigger({
                phase: 'before',
                target: obj.name,
                type: 'add',
                recid: null
              });
              obj.trigger($.extend(eventData, {
                phase: 'after'
              }));
              break;
            case 'w2ui-edit':
              var sel = obj.getSelection();
              var recid = null;
              if (sel.length == 1) recid = sel[0];
              // events
              var eventData = obj.trigger({
                phase: 'before',
                target: obj.name,
                type: 'edit',
                recid: recid
              });
              obj.trigger($.extend(eventData, {
                phase: 'after'
              }));
              break;
            case 'w2ui-delete':
              obj["delete"]();
              break;
            case 'w2ui-save':
              obj.save();
              break;
          }
          // no default action
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        });
      }
      return;
    },
    initResize: function initResize() {
      var obj = this;
      //if (obj.resizing === true) return;
      $(this.box).find('.w2ui-resizer').off('click').on('click', function (event) {
        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
        if (event.preventDefault) event.preventDefault();
      }).off('mousedown').on('mousedown', function (event) {
        if (!event) event = window.event;
        if (!window.addEventListener) {
          window.document.attachEvent('onselectstart', function () {
            return false;
          });
        }
        obj.resizing = true;
        obj.last.tmp = {
          x: event.screenX,
          y: event.screenY,
          gx: event.screenX,
          gy: event.screenY,
          col: parseInt($(this).attr('name'))
        };
        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
        if (event.preventDefault) event.preventDefault();
        // fix sizes
        for (var c in obj.columns) {
          if (obj.columns[c].hidden) continue;
          if (typeof obj.columns[c].sizeOriginal == 'undefined') obj.columns[c].sizeOriginal = obj.columns[c].size;
          obj.columns[c].size = obj.columns[c].sizeCalculated;
        }
        var eventData = {
          phase: 'before',
          type: 'columnResize',
          target: obj.name,
          column: obj.last.tmp.col,
          field: obj.columns[obj.last.tmp.col].field
        };
        eventData = obj.trigger($.extend(eventData, {
          resizeBy: 0,
          originalEvent: event
        }));
        // set move event
        var mouseMove = function mouseMove(event) {
          if (obj.resizing != true) return;
          if (!event) event = window.event;
          // event before
          eventData = obj.trigger($.extend(eventData, {
            resizeBy: event.screenX - obj.last.tmp.gx,
            originalEvent: event
          }));
          if (eventData.isCancelled === true) {
            eventData.isCancelled = false;
            return;
          }
          // default action
          obj.last.tmp.x = event.screenX - obj.last.tmp.x;
          obj.last.tmp.y = event.screenY - obj.last.tmp.y;
          obj.columns[obj.last.tmp.col].size = parseInt(obj.columns[obj.last.tmp.col].size) + obj.last.tmp.x + 'px';
          obj.resizeRecords();
          // reset
          obj.last.tmp.x = event.screenX;
          obj.last.tmp.y = event.screenY;
        };
        var mouseUp = function mouseUp(event) {
          delete obj.resizing;
          $(document).off('mousemove', 'body');
          $(document).off('mouseup', 'body');
          obj.resizeRecords();
          // event before
          obj.trigger($.extend(eventData, {
            phase: 'after',
            originalEvent: event
          }));
        };
        $(document).on('mousemove', 'body', mouseMove);
        $(document).on('mouseup', 'body', mouseUp);
      }).each(function (index, el) {
        var td = $(el).parent();
        $(el).css({
          "height": '25px',
          "margin-left": td.width() - 3 + 'px'
        });
      });
    },
    resizeBoxes: function resizeBoxes() {
      // elements
      var main = $(this.box).find('> div');
      var header = $('#grid_' + this.name + '_header');
      var toolbar = $('#grid_' + this.name + '_toolbar');
      var summary = $('#grid_' + this.name + '_summary');
      var footer = $('#grid_' + this.name + '_footer');
      var body = $('#grid_' + this.name + '_body');
      var columns = $('#grid_' + this.name + '_columns');
      var records = $('#grid_' + this.name + '_records');
      if (this.show.header) {
        header.css({
          top: '0px',
          left: '0px',
          right: '0px'
        });
      }
      if (this.show.toolbar) {
        toolbar.css({
          top: 0 + (this.show.header ? w2utils.getSize(header, 'height') : 0) + 'px',
          left: '0px',
          right: '0px'
        });
      }
      if (this.show.footer) {
        footer.css({
          bottom: '0px',
          left: '0px',
          right: '0px'
        });
      }
      if (this.summary.length > 0) {
        summary.css({
          bottom: 0 + (this.show.footer ? w2utils.getSize(footer, 'height') : 0) + 'px',
          left: '0px',
          right: '0px'
        });
      }
      body.css({
        top: 0 + (this.show.header ? w2utils.getSize(header, 'height') : 0) + (this.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0) + 'px',
        bottom: 0 + (this.show.footer ? w2utils.getSize(footer, 'height') : 0) + (this.summary.length > 0 ? w2utils.getSize(summary, 'height') : 0) + 'px',
        left: '0px',
        right: '0px'
      });
    },
    resizeRecords: function resizeRecords() {
      var obj = this;
      // remove empty records
      $(this.box).find('.w2ui-empty-record').remove();
      // -- Calculate Column size in PX
      var box = $(this.box);
      var grid = $(this.box).find('> div');
      var header = $('#grid_' + this.name + '_header');
      var toolbar = $('#grid_' + this.name + '_toolbar');
      var summary = $('#grid_' + this.name + '_summary');
      var footer = $('#grid_' + this.name + '_footer');
      var body = $('#grid_' + this.name + '_body');
      var columns = $('#grid_' + this.name + '_columns');
      var records = $('#grid_' + this.name + '_records');

      // body might be expanded by data
      if (!this.fixedBody) {
        // allow it to render records, then resize
        var calculatedHeight = w2utils.getSize(columns, 'height') + w2utils.getSize($('#grid_' + obj.name + '_records table'), 'height');
        obj.height = calculatedHeight + w2utils.getSize(grid, '+height') + (obj.show.header ? w2utils.getSize(header, 'height') : 0) + (obj.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0) + (summary.css('display') != 'none' ? w2utils.getSize(summary, 'height') : 0) + (obj.show.footer ? w2utils.getSize(footer, 'height') : 0);
        grid.css('height', obj.height);
        body.css('height', calculatedHeight);
        box.css('height', w2utils.getSize(grid, 'height') + w2utils.getSize(box, '+height'));
      } else {
        // fixed body height
        var calculatedHeight = grid.height() - (this.show.header ? w2utils.getSize(header, 'height') : 0) - (this.show.toolbar ? w2utils.getSize(toolbar, 'height') : 0) - (summary.css('display') != 'none' ? w2utils.getSize(summary, 'height') : 0) - (this.show.footer ? w2utils.getSize(footer, 'height') : 0);
        body.css('height', calculatedHeight);
      }
      var buffered = this.records.length;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (this.searchData.length != 0 && !url) buffered = this.last.searchIds.length;
      // check overflow
      var bodyOverflowX = false;
      var bodyOverflowY = false;
      if (body.width() < $(records).find('>table').width()) bodyOverflowX = true;
      if (body.height() - columns.height() < $(records).find('>table').height() + (bodyOverflowX ? w2utils.scrollBarSize() : 0)) bodyOverflowY = true;
      if (!this.fixedBody) {
        bodyOverflowY = false;
      }
      if (bodyOverflowX || bodyOverflowY) {
        columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').css('width', w2utils.scrollBarSize()).show();
        records.css({
          top: (this.columnGroups.length > 0 && this.show.columns ? 1 : 0) + w2utils.getSize(columns, 'height') + 'px',
          "-webkit-overflow-scrolling": "touch",
          "overflow-x": bodyOverflowX ? 'auto' : 'hidden',
          "overflow-y": bodyOverflowY ? 'auto' : 'hidden'
        });
      } else {
        columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').hide();
        records.css({
          top: (this.columnGroups.length > 0 && this.show.columns ? 1 : 0) + w2utils.getSize(columns, 'height') + 'px',
          overflow: 'hidden'
        });
        if (records.length > 0) {
          this.last.scrollTop = 0;
          this.last.scrollLeft = 0;
        } // if no scrollbars, always show top
      }
      if (this.show.emptyRecords && !bodyOverflowY) {
        var max = Math.floor(records.height() / this.recordHeight) + 1;
        if (this.fixedBody) {
          for (var di = buffered; di <= max; di++) {
            var html = '';
            html += '<tr class="' + (di % 2 ? 'w2ui-even' : 'w2ui-odd') + ' w2ui-empty-record" style="height: ' + this.recordHeight + 'px">';
            if (this.show.lineNumbers) html += '<td class="w2ui-col-number"></td>';
            if (this.show.selectColumn) html += '<td class="w2ui-grid-data w2ui-col-select"></td>';
            if (this.show.expandColumn) html += '<td class="w2ui-grid-data w2ui-col-expand"></td>';
            var j = 0;
            while ( true && this.columns.length > 0) {
              var col = this.columns[j];
              if (col.hidden) {
                j++;
                if (typeof this.columns[j] == 'undefined') break;else continue;
              }
              html += '<td class="w2ui-grid-data" ' + (typeof col.attr != 'undefined' ? col.attr : '') + ' col="' + j + '"></td>';
              j++;
              if (typeof this.columns[j] == 'undefined') break;
            }
            html += '<td class="w2ui-grid-data-last"></td>';
            html += '</tr>';
            $('#grid_' + this.name + '_records > table').append(html);
          }
        }
      }
      if (body.length > 0) {
        var width_max = parseInt(body.width()) - (bodyOverflowY ? w2utils.scrollBarSize() : 0) - (this.show.lineNumbers ? 34 : 0) - (this.show.selectColumn ? 26 : 0) - (this.show.expandColumn ? 26 : 0);
        var width_box = width_max;
        var percent = 0;
        // gridMinWidth processiong
        var restart = false;
        for (var i = 0; i < this.columns.length; i++) {
          var col = this.columns[i];
          if (col.gridMinWidth > 0) {
            if (col.gridMinWidth > width_box && col.hidden !== true) {
              col.hidden = true;
              restart = true;
            }
            if (col.gridMinWidth < width_box && col.hidden === true) {
              col.hidden = false;
              restart = true;
            }
          }
        }
        if (restart === true) {
          this.refresh();
          return;
        }
        // assign PX column s
        for (var i = 0; i < this.columns.length; i++) {
          var col = this.columns[i];
          if (col.hidden) continue;
          if (String(col.size).substr(String(col.size).length - 2).toLowerCase() == 'px') {
            width_max -= parseFloat(col.size);
            this.columns[i].sizeCalculated = col.size;
            this.columns[i].sizeType = 'px';
          } else {
            percent += parseFloat(col.size);
            this.columns[i].sizeType = '%';
            delete col.sizeCorrected;
          }
        }
        // if sum != 100% -- reassign proportionally
        if (percent != 100 && percent > 0) {
          for (var i = 0; i < this.columns.length; i++) {
            var col = this.columns[i];
            if (col.hidden) continue;
            if (col.sizeType == '%') {
              col.sizeCorrected = Math.round(parseFloat(col.size) * 100 * 100 / percent) / 100 + '%';
            }
          }
        }
        // calculate % columns
        for (var i = 0; i < this.columns.length; i++) {
          var col = this.columns[i];
          if (col.hidden) continue;
          if (col.sizeType == '%') {
            if (typeof this.columns[i].sizeCorrected != 'undefined') {
              // make it 1px smaller, so margin of error can be calculated correctly
              this.columns[i].sizeCalculated = Math.floor(width_max * parseFloat(col.sizeCorrected) / 100) - 1 + 'px';
            } else {
              // make it 1px smaller, so margin of error can be calculated correctly
              this.columns[i].sizeCalculated = Math.floor(width_max * parseFloat(col.size) / 100) - 1 + 'px';
            }
          }
        }
      }
      // fix margin of error that is due percentage calculations
      var width_cols = 0;
      for (var i = 0; i < this.columns.length; i++) {
        var col = this.columns[i];
        if (col.hidden) continue;
        if (typeof col.min == 'undefined') col.min = 20;
        if (parseInt(col.sizeCalculated) < parseInt(col.min)) col.sizeCalculated = col.min + 'px';
        if (parseInt(col.sizeCalculated) > parseInt(col.max)) col.sizeCalculated = col.max + 'px';
        width_cols += parseInt(col.sizeCalculated);
      }
      var width_diff = parseInt(width_box) - parseInt(width_cols);
      if (width_diff > 0 && percent > 0) {
        var i = 0;
        while (true) {
          var col = this.columns[i];
          if (typeof col == 'undefined') {
            i = 0;
            continue;
          }
          if (col.hidden || col.sizeType == 'px') {
            i++;
            continue;
          }
          col.sizeCalculated = parseInt(col.sizeCalculated) + 1 + 'px';
          width_diff--;
          if (width_diff == 0) break;
          i++;
        }
      } else if (width_diff > 0) {
        columns.find('> table > tbody > tr:nth-child(1) td.w2ui-head-last').css('width', w2utils.scrollBarSize()).show();
      }
      // resize columns
      columns.find('> table > tbody > tr:nth-child(1) td').each(function (index, el) {
        var ind = $(el).attr('col');
        if (typeof ind != 'undefined' && obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
        // last column
        if ($(el).hasClass('w2ui-head-last')) {
          $(el).css('width', w2utils.scrollBarSize() + (width_diff > 0 && percent == 0 ? width_diff : 0) + 'px');
        }
      });
      // if there are column groups - hide first row (needed for sizing)
      if (columns.find('> table > tbody > tr').length == 3) {
        columns.find('> table > tbody > tr:nth-child(1) td').html('').css({
          'height': '0px',
          'border': '0px',
          'padding': '0px',
          'margin': '0px'
        });
      }
      // resize records
      records.find('> table > tbody > tr:nth-child(1) td').each(function (index, el) {
        var ind = $(el).attr('col');
        if (typeof ind != 'undefined' && obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
        // last column
        if ($(el).hasClass('w2ui-grid-data-last')) {
          $(el).css('width', (width_diff > 0 && percent == 0 ? width_diff : 0) + 'px');
        }
      });
      // resize summary
      summary.find('> table > tbody > tr:nth-child(1) td').each(function (index, el) {
        var ind = $(el).attr('col');
        if (typeof ind != 'undefined' && obj.columns[ind]) $(el).css('width', obj.columns[ind].sizeCalculated);
        // last column
        if ($(el).hasClass('w2ui-grid-data-last')) {
          $(el).css('width', w2utils.scrollBarSize() + (width_diff > 0 && percent == 0 ? width_diff : 0) + 'px');
        }
      });
      this.initResize();
      this.refreshRanges();
      // apply last scroll if any
      if ((this.last.scrollTop || this.last.scrollLeft) && records.length > 0) {
        columns.prop('scrollLeft', this.last.scrollLeft);
        records.prop('scrollTop', this.last.scrollTop);
        records.prop('scrollLeft', this.last.scrollLeft);
      }
    },
    getSearchesHTML: function getSearchesHTML() {
      var html = '<table cellspacing="0">';
      var showBtn = false;
      for (var i = 0; i < this.searches.length; i++) {
        var s = this.searches[i];
        s.type = String(s.type).toLowerCase();
        if (s.hidden) continue;
        var btn = '';
        if (showBtn == false) {
          btn = '<button class="w2ui-btn close-btn" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) { obj.searchClose(); }">X</button';
          showBtn = true;
        }
        if (typeof s.inTag == 'undefined') s.inTag = '';
        if (typeof s.outTag == 'undefined') s.outTag = '';
        if (typeof s.type == 'undefined') s.type = 'text';
        if (['text', 'alphanumeric', 'combo'].indexOf(s.type) != -1) {
          var operator = '<select id="grid_' + this.name + '_operator_' + i + '" onclick="event.stopPropagation();">' + '    <option value="is">' + w2utils.lang('is') + '</option>' + '    <option value="begins">' + w2utils.lang('begins') + '</option>' + '    <option value="contains">' + w2utils.lang('contains') + '</option>' + '    <option value="ends">' + w2utils.lang('ends') + '</option>' + '</select>';
        }
        if (['int', 'float', 'money', 'currency', 'percent', 'date', 'time'].indexOf(s.type) != -1) {
          var operator = '<select id="grid_' + this.name + '_operator_' + i + '" ' + '        onchange="w2ui[\'' + this.name + '\'].initOperator(this, ' + i + ');" onclick="event.stopPropagation();">' + '    <option value="is">' + w2utils.lang('is') + '</option>' + (['int'].indexOf(s.type) != -1 ? '<option value="in">' + w2utils.lang('in') + '</option>' : '') + (['int'].indexOf(s.type) != -1 ? '<option value="not in">' + w2utils.lang('not in') + '</option>' : '') + '<option value="between">' + w2utils.lang('between') + '</option>' + '</select>';
        }
        if (['select', 'list', 'hex'].indexOf(s.type) != -1) {
          var operator = '<select id="grid_' + this.name + '_operator_' + i + '" onclick="event.stopPropagation();">' + '    <option value="is">' + w2utils.lang('is') + '</option>' + '</select>';
        }
        if (['enum'].indexOf(s.type) != -1) {
          var operator = '<select id="grid_' + this.name + '_operator_' + i + '" onclick="event.stopPropagation();">' + '    <option value="in">' + w2utils.lang('in') + '</option>' + '    <option value="not in">' + w2utils.lang('not in') + '</option>' + '</select>';
        }
        html += '<tr>' + '    <td class="close-btn">' + btn + '</td>' + '    <td class="caption">' + s.caption + '</td>' + '    <td class="operator">' + operator + '</td>' + '    <td class="value">';
        switch (s.type) {
          case 'text':
          case 'alphanumeric':
          case 'hex':
          case 'list':
          case 'combo':
          case 'enum':
            html += '<input rel="search" type="text" style="width: 300px;" id="grid_' + this.name + '_field_' + i + '" name="' + s.field + '" ' + s.inTag + '>';
            break;
          case 'int':
          case 'float':
          case 'money':
          case 'currency':
          case 'percent':
          case 'date':
          case 'time':
            html += '<input rel="search" type="text" size="12" id="grid_' + this.name + '_field_' + i + '" name="' + s.field + '" ' + s.inTag + '>' + '<span id="grid_' + this.name + '_range_' + i + '" style="display: none">' + '&nbsp;-&nbsp;&nbsp;<input rel="search" type="text" style="width: 90px" id="grid_' + this.name + '_field2_' + i + '" name="' + s.field + '" ' + s.inTag + '>' + '</span>';
            break;
          case 'select':
            html += '<select rel="search" id="grid_' + this.name + '_field_' + i + '" name="' + s.field + '" ' + s.inTag + '  onclick="event.stopPropagation();"></select>';
            break;
        }
        html += s.outTag + '    </td>' + '</tr>';
      }
      html += '<tr>' + '    <td colspan="4" class="actions">' + '        <div>' + '        <button class="w2ui-btn" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) { obj.searchReset(); }">' + w2utils.lang('Reset') + '</button>' + '        <button class="w2ui-btn w2ui-btn-blue" onclick="obj = w2ui[\'' + this.name + '\']; if (obj) { obj.search(); }">' + w2utils.lang('Search') + '</button>' + '        </div>' + '    </td>' + '</tr></table>';
      return html;
    },
    initOperator: function initOperator(el, search_ind) {
      var obj = this;
      var search = obj.searches[search_ind];
      var range = $('#grid_' + obj.name + '_range_' + search_ind);
      var fld1 = $('#grid_' + obj.name + '_field_' + search_ind);
      var fld2 = fld1.parent().find('span input');
      if ($(el).val() == 'in' || $(el).val() == 'not in') {
        fld1.w2field('clear');
      } else {
        fld1.w2field(search.type);
      }
      if ($(el).val() == 'between') {
        range.show();
        fld2.w2field(search.type);
      } else {
        range.hide();
      }
    },
    initSearches: function initSearches() {
      var obj = this;
      // init searches
      for (var s in this.searches) {
        var search = this.searches[s];
        var sdata = this.getSearchData(search.field);
        search.type = String(search.type).toLowerCase();
        if (_typeof(search.options) != 'object') search.options = {};
        // init types
        switch (search.type) {
          case 'text':
          case 'alphanumeric':
            $('#grid_' + this.name + '_operator_' + s).val('begins');
            if (['alphanumeric', 'hex'].indexOf(search.type) != -1) {
              $('#grid_' + this.name + '_field_' + s).w2field(search.type, search.options);
            }
            break;
          case 'int':
          case 'float':
          case 'money':
          case 'currency':
          case 'percent':
          case 'date':
          case 'time':
            if (sdata && sdata.type == 'int' && ['in', 'not in'].indexOf(sdata.operator) != -1) break;
            $('#grid_' + this.name + '_field_' + s).w2field(search.type, search.options);
            $('#grid_' + this.name + '_field2_' + s).w2field(search.type, search.options);
            setTimeout(function () {
              // convert to date if it is number
              $('#grid_' + obj.name + '_field_' + s).keydown();
              $('#grid_' + obj.name + '_field2_' + s).keydown();
            }, 1);
            break;
          case 'hex':
            break;
          case 'list':
          case 'combo':
          case 'enum':
            var options = search.options;
            if (search.type == 'list') options.selected = {};
            if (search.type == 'enum') options.selected = [];
            if (sdata) options.selected = sdata.value;
            $('#grid_' + this.name + '_field_' + s).w2field(search.type, options);
            if (search.type == 'combo') {
              $('#grid_' + this.name + '_operator_' + s).val('begins');
            }
            break;
          case 'select':
            // build options
            var options = '<option value="">--</option>';
            for (var i in search.options.items) {
              var si = search.options.items[i];
              if ($.isPlainObject(search.options.items[i])) {
                var val = si.id;
                var txt = si.text;
                if (typeof val == 'undefined' && typeof si.value != 'undefined') val = si.value;
                if (typeof txt == 'undefined' && typeof si.caption != 'undefined') txt = si.caption;
                if (val == null) val = '';
                options += '<option value="' + val + '">' + txt + '</option>';
              } else {
                options += '<option value="' + si + '">' + si + '</option>';
              }
            }
            $('#grid_' + this.name + '_field_' + s).html(options);
            break;
        }
        if (sdata != null) {
          if (sdata.type == 'int' && ['in', 'not in'].indexOf(sdata.operator) != -1) {
            $('#grid_' + this.name + '_field_' + s).w2field('clear').val(sdata.value);
          }
          $('#grid_' + this.name + '_operator_' + s).val(sdata.operator).trigger('change');
          if (!$.isArray(sdata.value)) {
            if (typeof sdata.value != 'udefined') $('#grid_' + this.name + '_field_' + s).val(sdata.value).trigger('change');
          } else {
            if (['in', 'not in'].indexOf(sdata.operator) != -1) {
              $('#grid_' + this.name + '_field_' + s).val(sdata.value).trigger('change');
            } else {
              $('#grid_' + this.name + '_field_' + s).val(sdata.value[0]).trigger('change');
              $('#grid_' + this.name + '_field2_' + s).val(sdata.value[1]).trigger('change');
            }
          }
        }
      }
      // add on change event
      $('#w2ui-overlay-searches-' + this.name + ' .w2ui-grid-searches *[rel=search]').on('keypress', function (evnt) {
        if (evnt.keyCode == 13) {
          obj.search();
          $().w2overlay();
        }
      });
    },
    getColumnsHTML: function getColumnsHTML() {
      var obj = this;
      var html = '';
      if (this.show.columnHeaders) {
        if (this.columnGroups.length > 0) {
          html = getColumns(true) + getGroups() + getColumns(false);
        } else {
          html = getColumns(true);
        }
      }
      return html;
      function getGroups() {
        var html = '<tr>';
        // add empty group at the end
        if (obj.columnGroups[obj.columnGroups.length - 1].caption != '') obj.columnGroups.push({
          caption: ''
        });
        if (obj.show.lineNumbers) {
          html += '<td class="w2ui-head w2ui-col-number">' + '    <div>&nbsp;</div>' + '</td>';
        }
        if (obj.show.selectColumn) {
          html += '<td class="w2ui-head w2ui-col-select">' + '    <div>&nbsp;</div>' + '</td>';
        }
        if (obj.show.expandColumn) {
          html += '<td class="w2ui-head w2ui-col-expand">' + '    <div>&nbsp;</div>' + '</td>';
        }
        var ii = 0;
        for (var i = 0; i < obj.columnGroups.length; i++) {
          var colg = obj.columnGroups[i];
          var col = obj.columns[ii];
          if (typeof colg.span == 'undefined' || colg.span != parseInt(colg.span)) colg.span = 1;
          if (typeof colg.colspan != 'undefined') colg.span = colg.colspan;
          if (colg.master === true) {
            var sortStyle = '';
            for (var si in obj.sortData) {
              if (obj.sortData[si].field == col.field) {
                if (RegExp('asc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-up';
                if (RegExp('desc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-down';
              }
            }
            var resizer = "";
            if (col.resizable !== false) {
              resizer = '<div class="w2ui-resizer" name="' + ii + '"></div>';
            }
            html += '<td class="w2ui-head ' + sortStyle + '" col="' + ii + '" rowspan="2" colspan="' + (colg.span + (i == obj.columnGroups.length - 1 ? 1 : 0)) + '" ' + '    onclick="w2ui[\'' + obj.name + '\'].columnClick(\'' + col.field + '\', event);">' + resizer + '    <div class="w2ui-col-group w2ui-col-header ' + (sortStyle ? 'w2ui-col-sorted' : '') + '">' + '        <div class="' + sortStyle + '"></div>' + (!col.caption ? '&nbsp;' : col.caption) + '    </div>' + '</td>';
          } else {
            html += '<td class="w2ui-head" col="' + ii + '" ' + '        colspan="' + (colg.span + (i == obj.columnGroups.length - 1 ? 1 : 0)) + '">' + '    <div class="w2ui-col-group">' + (!colg.caption ? '&nbsp;' : colg.caption) + '    </div>' + '</td>';
          }
          ii += colg.span;
        }
        html += '</tr>';
        return html;
      }
      function getColumns(master) {
        var html = '<tr>',
          reorderCols = obj.reorderColumns && (!obj.columnGroups || !obj.columnGroups.length) ? ' w2ui-reorder-cols-head ' : '';
        if (obj.show.lineNumbers) {
          html += '<td class="w2ui-head w2ui-col-number" onclick="w2ui[\'' + obj.name + '\'].columnClick(\'line-number\', event);">' + '    <div>#</div>' + '</td>';
        }
        if (obj.show.selectColumn) {
          html += '<td class="w2ui-head w2ui-col-select" ' + '        onclick="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' + '    <div>' + '        <input type="checkbox" id="grid_' + obj.name + '_check_all" tabIndex="-1"' + '            style="' + (obj.multiSelect == false ? 'display: none;' : '') + '"' + '            onclick="if (this.checked) w2ui[\'' + obj.name + '\'].selectAll(); ' + '                     else w2ui[\'' + obj.name + '\'].selectNone(); ' + '                     if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; ' + '                     this.blur();">' + '    </div>' + '</td>';
        }
        if (obj.show.expandColumn) {
          html += '<td class="w2ui-head w2ui-col-expand">' + '    <div>&nbsp;</div>' + '</td>';
        }
        var ii = 0;
        var id = 0;
        for (var i = 0; i < obj.columns.length; i++) {
          var col = obj.columns[i];
          var colg = {};
          if (i == id) {
            id = id + (typeof obj.columnGroups[ii] != 'undefined' ? parseInt(obj.columnGroups[ii].span) : 0);
            ii++;
          }
          if (typeof obj.columnGroups[ii - 1] != 'undefined') var colg = obj.columnGroups[ii - 1];
          if (col.hidden) continue;
          var sortStyle = '';
          for (var si in obj.sortData) {
            if (obj.sortData[si].field == col.field) {
              if (RegExp('asc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-up';
              if (RegExp('desc', 'i').test(obj.sortData[si].direction)) sortStyle = 'w2ui-sort-down';
            }
          }
          if (colg['master'] !== true || master) {
            // grouping of columns
            var resizer = "";
            if (col.resizable !== false) {
              resizer = '<div class="w2ui-resizer" name="' + i + '"></div>';
            }
            html += '<td col="' + i + '" class="w2ui-head ' + sortStyle + reorderCols + '" ' + '    onclick="w2ui[\'' + obj.name + '\'].columnClick(\'' + col.field + '\', event);">' + resizer + '    <div class="w2ui-col-header ' + (sortStyle ? 'w2ui-col-sorted' : '') + '">' + '        <div class="' + sortStyle + '"></div>' + (!col.caption ? '&nbsp;' : col.caption) + '    </div>' + '</td>';
          }
        }
        html += '<td class="w2ui-head w2ui-head-last"><div>&nbsp;</div></td>';
        html += '</tr>';
        return html;
      }
    },
    getRecordsHTML: function getRecordsHTML() {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      var buffered = this.records.length;
      if (this.searchData.length != 0 && !url) buffered = this.last.searchIds.length;
      // larget number works better with chrome, smaller with FF.
      if (buffered > 300) this.show_extra = 30;else this.show_extra = 300;
      var records = $('#grid_' + this.name + '_records');
      var limit = Math.floor(records.height() / this.recordHeight) + this.show_extra + 1;
      if (!this.fixedBody || limit > buffered) limit = buffered;
      // always need first record for resizing purposes
      var html = '<table>' + this.getRecordHTML(-1, 0);
      // first empty row with height
      html += '<tr id="grid_' + this.name + '_rec_top" line="top" style="height: ' + 0 + 'px">' + '    <td colspan="200"></td>' + '</tr>';
      for (var i = 0; i < limit; i++) {
        html += this.getRecordHTML(i, i + 1);
      }
      html += '<tr id="grid_' + this.name + '_rec_bottom" line="bottom" style="height: ' + (buffered - limit) * this.recordHeight + 'px">' + '    <td colspan="200"></td>' + '</tr>' + '<tr id="grid_' + this.name + '_rec_more" style="display: none">' + '    <td colspan="200" class="w2ui-load-more"></td>' + '</tr>' + '</table>';
      this.last.range_start = 0;
      this.last.range_end = limit;
      return html;
    },
    getSummaryHTML: function getSummaryHTML() {
      if (this.summary.length == 0) return;
      var html = '<table>';
      for (var i = 0; i < this.summary.length; i++) {
        html += this.getRecordHTML(i, i + 1, true);
      }
      html += '</table>';
      return html;
    },
    scroll: function scroll(event) {
      var time = new Date().getTime();
      var obj = this;
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      var records = $('#grid_' + this.name + '_records');
      var buffered = this.records.length;
      if (this.searchData.length != 0 && !url) buffered = this.last.searchIds.length;
      if (buffered == 0 || records.length == 0 || records.height() == 0) return;
      if (buffered > 300) this.show_extra = 30;else this.show_extra = 300;
      // need this to enable scrolling when this.limit < then a screen can fit
      if (records.height() < buffered * this.recordHeight && records.css('overflow-y') == 'hidden') {
        if (this.total > 0) this.refresh();
        return;
      }
      // update footer
      var t1 = Math.round(records[0].scrollTop / this.recordHeight + 1);
      var t2 = t1 + (Math.round(records.height() / this.recordHeight) - 1);
      if (t1 > buffered) t1 = buffered;
      if (t2 > buffered) t2 = buffered;
      $('#grid_' + this.name + '_footer .w2ui-footer-right').html(w2utils.formatNumber(this.offset + t1) + '-' + w2utils.formatNumber(this.offset + t2) + ' ' + w2utils.lang('of') + ' ' + w2utils.formatNumber(this.total) + (url ? ' (' + w2utils.lang('buffered') + ' ' + w2utils.formatNumber(buffered) + (this.offset > 0 ? ', skip ' + w2utils.formatNumber(this.offset) : '') + ')' : ''));
      // only for local data source, else no extra records loaded
      if (!url && (!this.fixedBody || this.total <= 300)) return;
      // regular processing
      var start = Math.floor(records[0].scrollTop / this.recordHeight) - this.show_extra;
      var end = start + Math.floor(records.height() / this.recordHeight) + this.show_extra * 2 + 1;
      // var div     = start - this.last.range_start;
      if (start < 1) start = 1;
      if (end > this.total) end = this.total;
      var tr1 = records.find('#grid_' + this.name + '_rec_top');
      var tr2 = records.find('#grid_' + this.name + '_rec_bottom');
      // if row is expanded
      if (String(tr1.next().prop('id')).indexOf('_expanded_row') != -1) tr1.next().remove();
      if (this.total > end && String(tr2.prev().prop('id')).indexOf('_expanded_row') != -1) tr2.prev().remove();
      var first = parseInt(tr1.next().attr('line'));
      var last = parseInt(tr2.prev().attr('line'));
      //$('#log').html('buffer: '+ this.buffered +' start-end: ' + start + '-'+ end + ' ===> first-last: ' + first + '-' + last);
      if (first < start || first == 1 || this.last.pull_refresh) {
        // scroll down
        // console.log('end', end, 'last', last, 'show_extre', this.show_extra, this.last.pull_refresh);
        if (end <= last + this.show_extra - 2 && end != this.total) return;
        this.last.pull_refresh = false;
        // remove from top
        while (true) {
          var tmp = records.find('#grid_' + this.name + '_rec_top').next();
          if (tmp.attr('line') == 'bottom') break;
          if (parseInt(tmp.attr('line')) < start) tmp.remove();else break;
        }
        // add at bottom
        var tmp = records.find('#grid_' + this.name + '_rec_bottom').prev();
        var rec_start = tmp.attr('line');
        if (rec_start == 'top') rec_start = start;
        for (var i = parseInt(rec_start) + 1; i <= end; i++) {
          if (!this.records[i - 1]) continue;
          if (this.records[i - 1].expanded === true) this.records[i - 1].expanded = false;
          tr2.before(this.getRecordHTML(i - 1, i));
        }
        markSearch();
        setTimeout(function () {
          obj.refreshRanges();
        }, 0);
      } else {
        // scroll up
        if (start >= first - this.show_extra + 2 && start > 1) return;
        // remove from bottom
        while (true) {
          var tmp = records.find('#grid_' + this.name + '_rec_bottom').prev();
          if (tmp.attr('line') == 'top') break;
          if (parseInt(tmp.attr('line')) > end) tmp.remove();else break;
        }
        // add at top
        var tmp = records.find('#grid_' + this.name + '_rec_top').next();
        var rec_start = tmp.attr('line');
        if (rec_start == 'bottom') rec_start = end;
        for (var i = parseInt(rec_start) - 1; i >= start; i--) {
          if (!this.records[i - 1]) continue;
          if (this.records[i - 1].expanded === true) this.records[i - 1].expanded = false;
          tr1.after(this.getRecordHTML(i - 1, i));
        }
        markSearch();
        setTimeout(function () {
          obj.refreshRanges();
        }, 0);
      }
      // first/last row size
      var h1 = (start - 1) * obj.recordHeight;
      var h2 = (buffered - end) * obj.recordHeight;
      if (h2 < 0) h2 = 0;
      tr1.css('height', h1 + 'px');
      tr2.css('height', h2 + 'px');
      obj.last.range_start = start;
      obj.last.range_end = end;
      // load more if needed
      var s = Math.floor(records[0].scrollTop / this.recordHeight);
      var e = s + Math.floor(records.height() / this.recordHeight);
      if (e + 10 > buffered && this.last.pull_more !== true && buffered < this.total - this.offset) {
        if (this.autoLoad === true) {
          this.last.pull_more = true;
          this.last.xhr_offset += this.limit;
          this.request('get-records');
        } else {
          var more = $('#grid_' + this.name + '_rec_more');
          if (more.css('display') == 'none') {
            more.show().on('click', function () {
              obj.last.pull_more = true;
              obj.last.xhr_offset += obj.limit;
              obj.request('get-records');
              // show spinner the last
              $(this).find('td').html('<div><div style="width: 20px; height: 20px;" class="w2ui-spinner"></div></div>');
            });
          }
          if (more.find('td').text().indexOf('Load') == -1) {
            more.find('td').html('<div>' + w2utils.lang('Load') + ' ' + obj.limit + ' ' + w2utils.lang('More') + '...</div>');
          }
        }
      }
      // check for grid end
      if (buffered >= this.total - this.offset) $('#grid_' + this.name + '_rec_more').hide();
      return;
      function markSearch() {
        // mark search
        if (obj.markSearch === false) return;
        clearTimeout(obj.last.marker_timer);
        obj.last.marker_timer = setTimeout(function () {
          // mark all search strings
          var str = [];
          for (var s in obj.searchData) {
            var tmp = obj.searchData[s];
            if ($.inArray(tmp.value, str) == -1) str.push(tmp.value);
          }
          if (str.length > 0) $(obj.box).find('.w2ui-grid-data > div').w2marker(str);
        }, 50);
      }
    },
    getRecordHTML: function getRecordHTML(ind, lineNum, summary) {
      var rec_html = '';
      var sel = this.last.selection;
      var record;
      // first record needs for resize purposes
      if (ind == -1) {
        rec_html += '<tr line="0">';
        if (this.show.lineNumbers) rec_html += '<td class="w2ui-col-number" style="height: 0px;"></td>';
        if (this.show.selectColumn) rec_html += '<td class="w2ui-col-select" style="height: 0px;"></td>';
        if (this.show.expandColumn) rec_html += '<td class="w2ui-col-expand" style="height: 0px;"></td>';
        for (var i in this.columns) {
          if (this.columns[i].hidden) continue;
          rec_html += '<td class="w2ui-grid-data" col="' + i + '" style="height: 0px;"></td>';
        }
        rec_html += '<td class="w2ui-grid-data-last" style="height: 0px;"></td>';
        rec_html += '</tr>';
        return rec_html;
      }
      // regular record
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (summary !== true) {
        if (this.searchData.length > 0 && !url) {
          if (ind >= this.last.searchIds.length) return '';
          ind = this.last.searchIds[ind];
          record = this.records[ind];
        } else {
          if (ind >= this.records.length) return '';
          record = this.records[ind];
        }
      } else {
        if (ind >= this.summary.length) return '';
        record = this.summary[ind];
      }
      if (!record) return '';
      var id = w2utils.escapeId(record.recid);
      var isRowSelected = false;
      if (sel.indexes.indexOf(ind) != -1) isRowSelected = true;
      // render TR
      rec_html += '<tr id="grid_' + this.name + '_rec_' + record.recid + '" recid="' + record.recid + '" line="' + lineNum + '" ' + ' class="' + (lineNum % 2 == 0 ? 'w2ui-even' : 'w2ui-odd') + (isRowSelected && this.selectType == 'row' ? ' w2ui-selected' : '') + (record.editable === false ? ' w2ui-no-edit' : '') + (record.expanded === true ? ' w2ui-expanded' : '') + '" ' + (summary !== true ? w2utils.isIOS ? '    onclick  = "w2ui[\'' + this.name + '\'].dblClick(\'' + record.recid + '\', event);"' : '    onclick  = "w2ui[\'' + this.name + '\'].click(\'' + record.recid + '\', event);"' + '    oncontextmenu = "w2ui[\'' + this.name + '\'].contextMenu(\'' + record.recid + '\', event);"' : '') + ' style="height: ' + this.recordHeight + 'px; ' + (!isRowSelected && typeof record['style'] == 'string' ? record['style'] : '') + '" ' + (typeof record['style'] == 'string' ? 'custom_style="' + record['style'] + '"' : '') + '>';
      if (this.show.lineNumbers) {
        rec_html += '<td id="grid_' + this.name + '_cell_' + ind + '_number' + (summary ? '_s' : '') + '" class="w2ui-col-number">' + (summary !== true ? '<div>' + lineNum + '</div>' : '') + '</td>';
      }
      if (this.show.selectColumn) {
        rec_html += '<td id="grid_' + this.name + '_cell_' + ind + '_select' + (summary ? '_s' : '') + '" class="w2ui-grid-data w2ui-col-select" ' + '        onclick="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' + (summary !== true ? '    <div>' + '        <input class="w2ui-grid-select-check" type="checkbox" tabIndex="-1"' + '            ' + (isRowSelected ? 'checked="checked"' : '') + '            onclick="var obj = w2ui[\'' + this.name + '\']; ' + '                if (!obj.multiSelect) { obj.selectNone(); }' + '                if (this.checked) obj.select(\'' + record.recid + '\'); else obj.unselect(\'' + record.recid + '\'); ' + '                if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;' + '                this. blur()">' + '    </div>' : '') + '</td>';
      }
      if (this.show.expandColumn) {
        var tmp_img = '';
        if (record.expanded === true) tmp_img = '-';else tmp_img = '+';
        if (record.expanded == 'none') tmp_img = '';
        if (record.expanded == 'spinner') tmp_img = '<div class="w2ui-spinner" style="width: 16px; margin: -2px 2px;"></div>';
        rec_html += '<td id="grid_' + this.name + '_cell_' + ind + '_expand' + (summary ? '_s' : '') + '" class="w2ui-grid-data w2ui-col-expand">' + (summary !== true ? '    <div ondblclick="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;" ' + '            onclick="w2ui[\'' + this.name + '\'].toggle(\'' + record.recid + '\', event); ' + '                if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' + '        ' + tmp_img + ' </div>' : '') + '</td>';
      }
      var col_ind = 0;
      while (true) {
        var col = this.columns[col_ind];
        if (col.hidden) {
          col_ind++;
          if (typeof this.columns[col_ind] == 'undefined') break;else continue;
        }
        var isChanged = !summary && record.changes && typeof record.changes[col.field] != 'undefined';
        var rec_cell = this.getCellHTML(ind, col_ind, summary);
        var addStyle = '';
        if (typeof col.render == 'string') {
          var tmp = col.render.toLowerCase().split(':');
          if (['number', 'int', 'float', 'money', 'currency', 'percent'].indexOf(tmp[0]) != -1) addStyle += 'text-align: right;';
        }
        if (_typeof(record.style) == 'object' && typeof record.style[col_ind] == 'string') {
          addStyle += record.style[col_ind] + ';';
        }
        var isCellSelected = false;
        if (isRowSelected && $.inArray(col_ind, sel.columns[ind]) != -1) isCellSelected = true;
        rec_html += '<td class="w2ui-grid-data' + (isCellSelected ? ' w2ui-selected' : '') + (isChanged ? ' w2ui-changed' : '') + '" col="' + col_ind + '" ' + '    style="' + addStyle + (typeof col.style != 'undefined' ? col.style : '') + '" ' + (typeof col.attr != 'undefined' ? col.attr : '') + '>' + rec_cell + '</td>';
        col_ind++;
        if (typeof this.columns[col_ind] == 'undefined') break;
      }
      rec_html += '<td class="w2ui-grid-data-last"></td>';
      rec_html += '</tr>';
      return rec_html;
    },
    getCellHTML: function getCellHTML(ind, col_ind, summary) {
      var col = this.columns[col_ind];
      var record = summary !== true ? this.records[ind] : this.summary[ind];
      var data = this.getCellValue(ind, col_ind, summary);
      var edit = col.editable;
      // various renderers
      if (col.render != null) {
        if (typeof col.render == 'function') {
          data = $.trim(col.render.call(this, record, ind, col_ind));
          if (data.length < 4 || data.substr(0, 4).toLowerCase() != '<div') data = '<div>' + data + '</div>';
        }
        if (_typeof(col.render) == 'object') data = '<div>' + (col.render[data] || '') + '</div>';
        if (typeof col.render == 'string') {
          var tmp = col.render.toLowerCase().split(':');
          var prefix = '';
          var suffix = '';
          if (['number', 'int', 'float', 'money', 'currency', 'percent'].indexOf(tmp[0]) != -1) {
            if (typeof tmp[1] == 'undefined' || !w2utils.isInt(tmp[1])) tmp[1] = 0;
            if (tmp[1] > 20) tmp[1] = 20;
            if (tmp[1] < 0) tmp[1] = 0;
            if (['money', 'currency'].indexOf(tmp[0]) != -1) {
              tmp[1] = w2utils.settings.currencyPrecision;
              prefix = w2utils.settings.currencyPrefix;
              suffix = w2utils.settings.currencySuffix;
            }
            if (tmp[0] == 'percent') {
              suffix = '%';
              if (tmp[1] !== '0') tmp[1] = 1;
            }
            if (tmp[0] == 'int') {
              tmp[1] = 0;
            }
            // format
            data = '<div>' + (data !== '' ? prefix + w2utils.formatNumber(Number(data).toFixed(tmp[1])) + suffix : '') + '</div>';
          }
          if (tmp[0] == 'time') {
            if (typeof tmp[1] == 'undefined' || tmp[1] == '') tmp[1] = w2utils.settings.time_format;
            data = '<div>' + prefix + w2utils.formatTime(data, tmp[1] == 'h12' ? 'hh:mi pm' : 'h24:mi') + suffix + '</div>';
          }
          if (tmp[0] == 'date') {
            if (typeof tmp[1] == 'undefined' || tmp[1] == '') tmp[1] = w2utils.settings.date_display;
            data = '<div>' + prefix + w2utils.formatDate(data, tmp[1]) + suffix + '</div>';
          }
          if (tmp[0] == 'age') {
            data = '<div>' + prefix + w2utils.age(data) + suffix + '</div>';
          }
          if (tmp[0] == 'toggle') {
            data = '<div>' + prefix + (data ? 'Yes' : '') + suffix + '</div>';
          }
        }
      } else {
        // if editable checkbox
        var addStyle = '';
        if (edit && ['checkbox', 'check'].indexOf(edit.type) != -1) {
          var changeInd = summary ? -(ind + 1) : ind;
          addStyle = 'text-align: center';
          data = '<input type="checkbox" ' + (data ? 'checked' : '') + ' onclick="' + '    var obj = w2ui[\'' + this.name + '\']; ' + '    obj.editChange.call(obj, this, ' + changeInd + ', ' + col_ind + ', event); ' + '">';
        }
        if (!this.show.recordTitles) {
          var data = '<div style="' + addStyle + '">' + data + '</div>';
        } else {
          // title overwrite
          var title = String(data).replace(/"/g, "''");
          if (typeof col.title != 'undefined') {
            if (typeof col.title == 'function') title = col.title.call(this, record, ind, col_ind);
            if (typeof col.title == 'string') title = col.title;
          }
          var data = '<div title="' + w2utils.stripTags(title) + '" style="' + addStyle + '">' + data + '</div>';
        }
      }
      if (data == null || typeof data == 'undefined') data = '';
      return data;
    },
    getCellValue: function getCellValue(ind, col_ind, summary) {
      var col = this.columns[col_ind];
      var record = summary !== true ? this.records[ind] : this.summary[ind];
      var data = this.parseField(record, col.field);
      if (record.changes && typeof record.changes[col.field] != 'undefined') data = record.changes[col.field];
      if (data == null || typeof data == 'undefined') data = '';
      return data;
    },
    getFooterHTML: function getFooterHTML() {
      return '<div>' + '    <div class="w2ui-footer-left"></div>' + '    <div class="w2ui-footer-right"></div>' + '    <div class="w2ui-footer-center"></div>' + '</div>';
    },
    status: function status(msg) {
      if (typeof msg != 'undefined') {
        $('#grid_' + this.name + '_footer').find('.w2ui-footer-left').html(msg);
      } else {
        // show number of selected
        var msgLeft = '';
        var sel = this.getSelection();
        if (sel.length > 0) {
          msgLeft = String(sel.length).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,") + ' ' + w2utils.lang('selected');
          var tmp = sel[0];
          if (_typeof(tmp) == 'object') tmp = tmp.recid + ', ' + w2utils.lang('Column') + ': ' + tmp.column;
          if (sel.length == 1) msgLeft = w2utils.lang('Record ID') + ': ' + tmp + ' ';
        }
        $('#grid_' + this.name + '_footer .w2ui-footer-left').html(msgLeft);
        // toolbar
        if (sel.length == 1) this.toolbar.enable('w2ui-edit');else this.toolbar.disable('w2ui-edit');
        if (sel.length >= 1) this.toolbar.enable('w2ui-delete');else this.toolbar.disable('w2ui-delete');
      }
    },
    lock: function lock(msg, showSpinner) {
      var box = $(this.box).find('> div:first-child');
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift(box);
      setTimeout(function () {
        w2utils.lock.apply(window, args);
      }, 10);
    },
    unlock: function unlock() {
      var box = this.box;
      setTimeout(function () {
        w2utils.unlock(box);
      }, 25); // needed timer so if server fast, it will not flash
    },
    stateSave: function stateSave(returnOnly) {
      if (!localStorage) return null;
      var state = {
        columns: [],
        show: $.extend({}, this.show),
        last: {
          search: this.last.search,
          multi: this.last.multi,
          logic: this.last.logic,
          caption: this.last.caption,
          field: this.last.field,
          scrollTop: this.last.scrollTop,
          scrollLeft: this.last.scrollLeft
        },
        sortData: [],
        searchData: []
      };
      for (var i in this.columns) {
        var col = this.columns[i];
        state.columns.push({
          field: col.field,
          hidden: col.hidden,
          size: col.size,
          sizeCalculated: col.sizeCalculated,
          sizeOriginal: col.sizeOriginal,
          sizeType: col.sizeType
        });
      }
      for (var i in this.sortData) state.sortData.push($.extend({}, this.sortData[i]));
      for (var i in this.searchData) state.searchData.push($.extend({}, this.searchData[i]));
      // save into local storage
      if (returnOnly !== true) {
        // event before
        var eventData = this.trigger({
          phase: 'before',
          type: 'stateSave',
          target: this.name,
          state: state
        });
        if (eventData.isCancelled === true) {
          if (typeof callBack == 'function') callBack({
            status: 'error',
            message: 'Request aborted.'
          });
          return;
        }
        try {
          var savedState = $.parseJSON(localStorage.w2ui || '{}');
          if (!savedState) savedState = {};
          if (!savedState.states) savedState.states = {};
          savedState.states[this.name] = state;
          localStorage.w2ui = JSON.stringify(savedState);
        } catch (e) {
          delete localStorage.w2ui;
          return null;
        }
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
      return state;
    },
    stateRestore: function stateRestore(newState) {
      var obj = this;
      if (!newState) {
        // read it from local storage
        try {
          if (!localStorage) return false;
          var tmp = $.parseJSON(localStorage.w2ui || '{}');
          if (!tmp) tmp = {};
          if (!tmp.states) tmp.states = {};
          newState = tmp.states[this.name];
        } catch (e) {
          delete localStorage.w2ui;
          return null;
        }
      }
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'stateRestore',
        target: this.name,
        state: newState
      });
      if (eventData.isCancelled === true) {
        if (typeof callBack == 'function') callBack({
          status: 'error',
          message: 'Request aborted.'
        });
        return;
      }
      // default behavior
      if ($.isPlainObject(newState)) {
        $.extend(this.show, newState.show);
        $.extend(this.last, newState.last);
        var sTop = this.last.scrollTop;
        var sLeft = this.last.scrollLeft;
        for (var c in newState.columns) {
          var tmp = newState.columns[c];
          var col = this.getColumn(tmp.field);
          if (col) $.extend(col, tmp);
        }
        this.sortData.splice(0, this.sortData.length);
        for (var c in newState.sortData) this.sortData.push(newState.sortData[c]);
        this.searchData.splice(0, this.searchData.length);
        for (var c in newState.searchData) this.searchData.push(newState.searchData[c]);
        // apply sort and search
        setTimeout(function () {
          // needs timeout as records need to be populated
          if (obj.sortData.length > 0) obj.localSort();
          if (obj.searchData.length > 0) obj.localSearch();
          obj.last.scrollTop = sTop;
          obj.last.scrollLeft = sLeft;
          obj.refresh();
        }, 1);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return true;
    },
    stateReset: function stateReset() {
      this.stateRestore(this.last.state);
      // remove from local storage
      if (localStorage) {
        try {
          var tmp = $.parseJSON(localStorage.w2ui || '{}');
          if (tmp.states && tmp.states[this.name]) {
            delete tmp.states[this.name];
          }
          localStorage.w2ui = JSON.stringify(tmp);
        } catch (e) {
          delete localStorage.w2ui;
          return null;
        }
      }
    },
    parseField: function parseField(obj, field) {
      var val = '';
      try {
        // need this to make sure no error in fields
        val = obj;
        var tmp = String(field).split('.');
        for (var i in tmp) {
          val = val[tmp[i]];
        }
      } catch (event) {
        val = '';
      }
      return val;
    },
    prepareData: function prepareData() {
      // loops thru records and prepares date and time objects
      for (var r in this.records) {
        var rec = this.records[r];
        for (var c in this.columns) {
          var column = this.columns[c];
          if (rec[column.field] == null || typeof column.render != 'string') continue;
          // number
          if (['number', 'int', 'float', 'money', 'currency', 'percent'].indexOf(column.render.split(':')[0]) != -1) {
            if (typeof rec[column.field] != 'number') rec[column.field] = parseFloat(rec[column.field]);
          }
          // date
          if (['date', 'age'].indexOf(column.render.split(':')[0]) != -1) {
            if (!rec[column.field + '_']) {
              var dt = rec[column.field];
              if (w2utils.isInt(dt)) dt = parseInt(dt);
              rec[column.field + '_'] = new Date(dt);
            }
          }
          // time
          if (['time'].indexOf(column.render) != -1) {
            if (w2utils.isTime(rec[column.field])) {
              // if string
              var tmp = w2utils.isTime(rec[column.field], true);
              var dt = new Date();
              dt.setHours(tmp.hours, tmp.minutes, tmp.seconds ? tmp.seconds : 0, 0); // sets hours, min, sec, mills
              if (!rec[column.field + '_']) rec[column.field + '_'] = dt;
            } else {
              // if date object
              var tmp = rec[column.field];
              if (w2utils.isInt(tmp)) tmp = parseInt(tmp);
              var tmp = tmp != null ? new Date(tmp) : new Date();
              var dt = new Date();
              dt.setHours(tmp.getHours(), tmp.getMinutes(), tmp.getSeconds(), 0); // sets hours, min, sec, mills
              if (!rec[column.field + '_']) rec[column.field + '_'] = dt;
            }
          }
        }
      }
    },
    nextCell: function nextCell(col_ind, editable) {
      var check = col_ind + 1;
      if (this.columns.length == check) return null;
      if (editable === true) {
        var edit = this.columns[check].editable;
        if (this.columns[check].hidden || typeof edit == 'undefined' || edit && ['checkbox', 'check'].indexOf(edit.type) != -1) return this.nextCell(check, editable);
      }
      return check;
    },
    prevCell: function prevCell(col_ind, editable) {
      var check = col_ind - 1;
      if (check < 0) return null;
      if (editable === true) {
        var edit = this.columns[check].editable;
        if (this.columns[check].hidden || typeof edit == 'undefined' || edit && ['checkbox', 'check'].indexOf(edit.type) != -1) return this.prevCell(check, editable);
      }
      return check;
    },
    nextRow: function nextRow(ind) {
      if (ind + 1 < this.records.length && this.last.searchIds.length == 0 // if there are more records
      || this.last.searchIds.length > 0 && ind < this.last.searchIds[this.last.searchIds.length - 1]) {
        ind++;
        if (this.last.searchIds.length > 0) {
          while (true) {
            if ($.inArray(ind, this.last.searchIds) != -1 || ind > this.records.length) break;
            ind++;
          }
        }
        return ind;
      } else {
        return null;
      }
    },
    prevRow: function prevRow(ind) {
      if (ind > 0 && this.last.searchIds.length == 0 // if there are more records
      || this.last.searchIds.length > 0 && ind > this.last.searchIds[0]) {
        ind--;
        if (this.last.searchIds.length > 0) {
          while (true) {
            if ($.inArray(ind, this.last.searchIds) != -1 || ind < 0) break;
            ind--;
          }
        }
        return ind;
      } else {
        return null;
      }
    }
  };
  $.extend(w2grid.prototype, w2utils.event);
  w2obj.grid = w2grid;
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2layout        - layout widget
*        - $().w2layout    - jQuery wrapper
*   - Dependencies: jQuery, w2utils, w2toolbar, w2tabs
*
* == NICE TO HAVE ==
*   - onResize for the panel
*   - add more panel title positions (left=rotated, right=rotated, bottom)
*   - bug: resizer is visible (and onHover) when panel is hidden.
*   - bug: when you assign content before previous transition completed.
*
************************************************************************/

(function () {
  var w2layout = function w2layout(options) {
    this.box = null; // DOM Element that holds the element
    this.name = null; // unique name for w2ui
    this.panels = [];
    this.tmp = {};
    this.padding = 1; // panel padding
    this.resizer = 4; // resizer width or height
    this.style = '';
    this.onShow = null;
    this.onHide = null;
    this.onResizing = null;
    this.onResizerClick = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onResize = null;
    this.onDestroy = null;
    $.extend(true, this, w2obj.layout, options);
  };

  /* @const */
  var w2layout_panels = ['top', 'left', 'main', 'preview', 'right', 'bottom'];

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2layout = function (method) {
    if (_typeof(method) === 'object' || !method) {
      // check name parameter
      if (!w2utils.checkName(method, 'w2layout')) return;
      var panels = method.panels || [];
      var object = new w2layout(method);
      $.extend(object, {
        handlers: [],
        panels: []
      });
      // add defined panels
      for (var p = 0, len = panels.length; p < len; p++) {
        object.panels[p] = $.extend(true, {}, w2layout.prototype.panel, panels[p]);
        if ($.isPlainObject(object.panels[p].tabs) || $.isArray(object.panels[p].tabs)) initTabs(object, panels[p].type);
        if ($.isPlainObject(object.panels[p].toolbar) || $.isArray(object.panels[p].toolbar)) initToolbar(object, panels[p].type);
      }
      // add all other panels
      for (var p1 in w2layout_panels) {
        p1 = w2layout_panels[p1];
        if (object.get(p1) !== null) continue;
        object.panels.push($.extend(true, {}, w2layout.prototype.panel, {
          type: p1,
          hidden: p1 !== 'main',
          size: 50
        }));
      }
      if ($(this).length > 0) {
        object.render($(this)[0]);
      }
      w2ui[object.name] = object;
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2layout');
    }
    function initTabs(object, panel, tabs) {
      var pan = object.get(panel);
      if (pan !== null && typeof tabs == 'undefined') tabs = pan.tabs;
      if (pan === null || tabs === null) return false;
      // instanciate tabs
      if ($.isArray(tabs)) tabs = {
        tabs: tabs
      };
      $().w2destroy(object.name + '_' + panel + '_tabs'); // destroy if existed
      pan.tabs = $().w2tabs($.extend({}, tabs, {
        owner: object,
        name: object.name + '_' + panel + '_tabs'
      }));
      pan.show.tabs = true;
      return true;
    }
    function initToolbar(object, panel, toolbar) {
      var pan = object.get(panel);
      if (pan !== null && typeof toolbar == 'undefined') toolbar = pan.toolbar;
      if (pan === null || toolbar === null) return false;
      // instanciate toolbar
      if ($.isArray(toolbar)) toolbar = {
        items: toolbar
      };
      $().w2destroy(object.name + '_' + panel + '_toolbar'); // destroy if existed
      pan.toolbar = $().w2toolbar($.extend({}, toolbar, {
        owner: object,
        name: object.name + '_' + panel + '_toolbar'
      }));
      pan.show.toolbar = true;
      return true;
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2layout.prototype = {
    // default setting for a panel
    panel: {
      type: null,
      // left, right, top, bottom
      title: '',
      size: 100,
      // width or height depending on panel name
      minSize: 20,
      maxSize: false,
      hidden: false,
      resizable: false,
      overflow: 'auto',
      style: '',
      content: '',
      // can be String or Object with .render(box) method
      tabs: null,
      toolbar: null,
      width: null,
      // read only
      height: null,
      // read only
      show: {
        toolbar: false,
        tabs: false
      },
      onRefresh: null,
      onShow: null,
      onHide: null
    },
    // alias for content
    html: function html(panel, data, transition) {
      return this.content(panel, data, transition);
    },
    content: function content(panel, data, transition) {
      var obj = this;
      var p = this.get(panel);
      // if it is CSS panel
      if (panel == 'css') {
        $('#layout_' + obj.name + '_panel_css').html('<style>' + data + '</style>');
        return true;
      }
      if (p === null) return false;
      if (typeof data == 'undefined' || data === null) {
        return p.content;
      } else {
        if (data instanceof jQuery) {
          console.log('ERROR: You can not pass jQuery object to w2layout.content() method');
          return false;
        }
        var pname = '#layout_' + this.name + '_panel_' + p.type;
        var current = $(pname + '> .w2ui-panel-content');
        var panelTop = 0;
        if (current.length > 0) {
          $(pname).scrollTop(0);
          panelTop = $(current).position().top;
        }
        if (p.content === '') {
          p.content = data;
          this.refresh(panel);
        } else {
          p.content = data;
          if (!p.hidden) {
            if (transition !== null && transition !== '' && typeof transition != 'undefined') {
              // apply transition
              var div1 = $(pname + '> .w2ui-panel-content');
              div1.after('<div class="w2ui-panel-content new-panel" style="' + div1[0].style.cssText + '"></div>');
              var div2 = $(pname + '> .w2ui-panel-content.new-panel');
              div1.css('top', panelTop);
              div2.css('top', panelTop);
              if (_typeof(data) == 'object') {
                data.box = div2[0]; // do not do .render(box);
                data.render();
              } else {
                div2.html(data);
              }
              w2utils.transition(div1[0], div2[0], transition, function () {
                div1.remove();
                div2.removeClass('new-panel');
                div2.css('overflow', p.overflow);
                // IE Hack
                obj.resize();
                if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
                  obj.resize();
                }, 100);
              });
            }
          }
          this.refresh(panel);
        }
      }
      // IE Hack
      obj.resize();
      if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
        obj.resize();
      }, 100);
      return true;
    },
    load: function load(panel, url, transition, onLoad) {
      var obj = this;
      if (panel == 'css') {
        $.get(url, function (data, status, xhr) {
          // should always be $.get as it is template
          obj.content(panel, xhr.responseText);
          if (onLoad) onLoad();
        });
        return true;
      }
      if (this.get(panel) !== null) {
        $.get(url, function (data, status, xhr) {
          // should always be $.get as it is template
          obj.content(panel, xhr.responseText, transition);
          if (onLoad) onLoad();
          // IE Hack
          obj.resize();
          if (window.navigator.userAgent.indexOf('MSIE') != -1) setTimeout(function () {
            obj.resize();
          }, 100);
        });
        return true;
      }
      return false;
    },
    sizeTo: function sizeTo(panel, size) {
      var obj = this;
      var pan = obj.get(panel);
      if (pan === null) return false;
      // resize
      $(obj.box).find(' > div > .w2ui-panel').css({
        '-webkit-transition': '.2s',
        '-moz-transition': '.2s',
        '-ms-transition': '.2s',
        '-o-transition': '.2s'
      });
      setTimeout(function () {
        obj.set(panel, {
          size: size
        });
      }, 1);
      // clean
      setTimeout(function () {
        $(obj.box).find(' > div > .w2ui-panel').css({
          '-webkit-transition': '0s',
          '-moz-transition': '0s',
          '-ms-transition': '0s',
          '-o-transition': '0s'
        });
        obj.resize();
      }, 500);
      return true;
    },
    show: function show(panel, immediate) {
      var obj = this;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'show',
        target: panel,
        object: this.get(panel),
        immediate: immediate
      });
      if (eventData.isCancelled === true) return;
      var p = obj.get(panel);
      if (p === null) return false;
      p.hidden = false;
      if (immediate === true) {
        $('#layout_' + obj.name + '_panel_' + panel).css({
          'opacity': '1'
        });
        if (p.resizable) $('#layout_' + obj.name + '_resizer_' + panel).show();
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
        obj.resize();
      } else {
        if (p.resizable) $('#layout_' + obj.name + '_resizer_' + panel).show();
        // resize
        $('#layout_' + obj.name + '_panel_' + panel).css({
          'opacity': '0'
        });
        $(obj.box).find(' > div > .w2ui-panel').css({
          '-webkit-transition': '.2s',
          '-moz-transition': '.2s',
          '-ms-transition': '.2s',
          '-o-transition': '.2s'
        });
        setTimeout(function () {
          obj.resize();
        }, 1);
        // show
        setTimeout(function () {
          $('#layout_' + obj.name + '_panel_' + panel).css({
            'opacity': '1'
          });
        }, 250);
        // clean
        setTimeout(function () {
          $(obj.box).find(' > div > .w2ui-panel').css({
            '-webkit-transition': '0s',
            '-moz-transition': '0s',
            '-ms-transition': '0s',
            '-o-transition': '0s'
          });
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
          obj.resize();
        }, 500);
      }
      return true;
    },
    hide: function hide(panel, immediate) {
      var obj = this;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'hide',
        target: panel,
        object: this.get(panel),
        immediate: immediate
      });
      if (eventData.isCancelled === true) return;
      var p = obj.get(panel);
      if (p === null) return false;
      p.hidden = true;
      if (immediate === true) {
        $('#layout_' + obj.name + '_panel_' + panel).css({
          'opacity': '0'
        });
        $('#layout_' + obj.name + '_resizer_' + panel).hide();
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
        obj.resize();
      } else {
        $('#layout_' + obj.name + '_resizer_' + panel).hide();
        // hide
        $(obj.box).find(' > div > .w2ui-panel').css({
          '-webkit-transition': '.2s',
          '-moz-transition': '.2s',
          '-ms-transition': '.2s',
          '-o-transition': '.2s'
        });
        $('#layout_' + obj.name + '_panel_' + panel).css({
          'opacity': '0'
        });
        setTimeout(function () {
          obj.resize();
        }, 1);
        // clean
        setTimeout(function () {
          $(obj.box).find(' > div > .w2ui-panel').css({
            '-webkit-transition': '0s',
            '-moz-transition': '0s',
            '-ms-transition': '0s',
            '-o-transition': '0s'
          });
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
          obj.resize();
        }, 500);
      }
      return true;
    },
    toggle: function toggle(panel, immediate) {
      var p = this.get(panel);
      if (p === null) return false;
      if (p.hidden) return this.show(panel, immediate);else return this.hide(panel, immediate);
    },
    set: function set(panel, options) {
      var obj = this.get(panel, true);
      if (obj === null) return false;
      $.extend(this.panels[obj], options);
      if (typeof options['content'] != 'undefined') this.refresh(panel); // refresh only when content changed
      this.resize(); // resize is needed when panel size is changed
      return true;
    },
    get: function get(panel, returnIndex) {
      for (var p in this.panels) {
        if (this.panels[p].type == panel) {
          if (returnIndex === true) return p;else return this.panels[p];
        }
      }
      return null;
    },
    el: function el(panel) {
      var el = $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-content');
      if (el.length != 1) return null;
      return el[0];
    },
    hideToolbar: function hideToolbar(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      pan.show.toolbar = false;
      $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-toolbar').hide();
      this.resize();
    },
    showToolbar: function showToolbar(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      pan.show.toolbar = true;
      $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-toolbar').show();
      this.resize();
    },
    toggleToolbar: function toggleToolbar(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      if (pan.show.toolbar) this.hideToolbar(panel);else this.showToolbar(panel);
    },
    hideTabs: function hideTabs(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      pan.show.tabs = false;
      $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-tabs').hide();
      this.resize();
    },
    showTabs: function showTabs(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      pan.show.tabs = true;
      $('#layout_' + this.name + '_panel_' + panel + '> .w2ui-panel-tabs').show();
      this.resize();
    },
    toggleTabs: function toggleTabs(panel) {
      var pan = this.get(panel);
      if (!pan) return;
      if (pan.show.tabs) this.hideTabs(panel);else this.showTabs(panel);
    },
    render: function render(box) {
      var obj = this;
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      var time = new Date().getTime();
      // event before
      var eventData = obj.trigger({
        phase: 'before',
        type: 'render',
        target: obj.name,
        box: box
      });
      if (eventData.isCancelled === true) return;
      if (typeof box != 'undefined' && box !== null) {
        if ($(obj.box).find('#layout_' + obj.name + '_panel_main').length > 0) {
          $(obj.box).removeAttr('name').removeClass('w2ui-layout').html('');
        }
        obj.box = box;
      }
      if (!obj.box) return false;
      $(obj.box).attr('name', obj.name).addClass('w2ui-layout').html('<div></div>');
      if ($(obj.box).length > 0) $(obj.box)[0].style.cssText += obj.style;
      // create all panels
      for (var p1 in w2layout_panels) {
        p1 = w2layout_panels[p1];
        var pan = obj.get(p1);
        var html = '<div id="layout_' + obj.name + '_panel_' + p1 + '" class="w2ui-panel">' + '    <div class="w2ui-panel-title"></div>' + '    <div class="w2ui-panel-tabs"></div>' + '    <div class="w2ui-panel-toolbar"></div>' + '    <div class="w2ui-panel-content"></div>' + '</div>' + '<div id="layout_' + obj.name + '_resizer_' + p1 + '" class="w2ui-resizer"></div>';
        $(obj.box).find(' > div').append(html);
        // tabs are rendered in refresh()
      }
      $(obj.box).find(' > div').append('<div id="layout_' + obj.name + '_panel_css" style="position: absolute; top: 10000px;"></div');
      obj.refresh(); // if refresh is not called here, the layout will not be available right after initialization
      // process event
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
      // reinit events
      setTimeout(function () {
        // needed this timeout to allow browser to render first if there are tabs or toolbar
        initEvents();
        obj.resize();
      }, 0);
      return new Date().getTime() - time;
      function initEvents() {
        obj.tmp.events = {
          resize: function resize(event) {
            w2ui[obj.name].resize();
          },
          resizeStart: resizeStart,
          mouseMove: resizeMove,
          mouseUp: resizeStop
        };
        $(window).on('resize', obj.tmp.events.resize);
      }
      function resizeStart(type, evnt) {
        if (!obj.box) return;
        if (!evnt) evnt = window.event;
        if (!window.addEventListener) {
          window.document.attachEvent('onselectstart', function () {
            return false;
          });
        }
        $(document).off('mousemove', obj.tmp.events.mouseMove).on('mousemove', obj.tmp.events.mouseMove);
        $(document).off('mouseup', obj.tmp.events.mouseUp).on('mouseup', obj.tmp.events.mouseUp);
        obj.tmp.resize = {
          type: type,
          x: evnt.screenX,
          y: evnt.screenY,
          diff_x: 0,
          diff_y: 0,
          value: 0
        };
        // lock all panels
        for (var p1 in w2layout_panels) {
          p1 = w2layout_panels[p1];
          obj.lock(p1, {
            opacity: 0
          });
        }
        if (type == 'left' || type == 'right') {
          obj.tmp.resize.value = parseInt($('#layout_' + obj.name + '_resizer_' + type)[0].style.left);
        }
        if (type == 'top' || type == 'preview' || type == 'bottom') {
          obj.tmp.resize.value = parseInt($('#layout_' + obj.name + '_resizer_' + type)[0].style.top);
        }
      }
      function resizeStop(evnt) {
        if (!obj.box) return;
        if (!evnt) evnt = window.event;
        if (!window.addEventListener) {
          window.document.attachEvent('onselectstart', function () {
            return false;
          });
        }
        $(document).off('mousemove', obj.tmp.events.mouseMove);
        $(document).off('mouseup', obj.tmp.events.mouseUp);
        if (typeof obj.tmp.resize == 'undefined') return;
        // unlock all panels
        for (var p1 in w2layout_panels) {
          obj.unlock(w2layout_panels[p1]);
        }
        // set new size
        if (obj.tmp.diff_x !== 0 || obj.tmp.resize.diff_y !== 0) {
          // only recalculate if changed
          var ptop = obj.get('top');
          var pbottom = obj.get('bottom');
          var panel = obj.get(obj.tmp.resize.type);
          var height = parseInt($(obj.box).height());
          var width = parseInt($(obj.box).width());
          var str = String(panel.size);
          var ns, nd;
          switch (obj.tmp.resize.type) {
            case 'top':
              ns = parseInt(panel.sizeCalculated) + obj.tmp.resize.diff_y;
              nd = 0;
              break;
            case 'bottom':
              ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_y;
              nd = 0;
              break;
            case 'preview':
              ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_y;
              nd = (ptop && !ptop.hidden ? ptop.sizeCalculated : 0) + (pbottom && !pbottom.hidden ? pbottom.sizeCalculated : 0);
              break;
            case 'left':
              ns = parseInt(panel.sizeCalculated) + obj.tmp.resize.diff_x;
              nd = 0;
              break;
            case 'right':
              ns = parseInt(panel.sizeCalculated) - obj.tmp.resize.diff_x;
              nd = 0;
              break;
          }
          // set size
          if (str.substr(str.length - 1) == '%') {
            panel.size = Math.floor(ns * 100 / (panel.type == 'left' || panel.type == 'right' ? width : height - nd) * 100) / 100 + '%';
          } else {
            panel.size = ns;
          }
          obj.resize();
        }
        $('#layout_' + obj.name + '_resizer_' + obj.tmp.resize.type).removeClass('active');
        delete obj.tmp.resize;
      }
      function resizeMove(evnt) {
        if (!obj.box) return;
        if (!evnt) evnt = window.event;
        if (typeof obj.tmp.resize == 'undefined') return;
        var panel = obj.get(obj.tmp.resize.type);
        // event before
        var tmp = obj.tmp.resize;
        var eventData = obj.trigger({
          phase: 'before',
          type: 'resizing',
          target: obj.name,
          object: panel,
          originalEvent: evnt,
          panel: tmp ? tmp.type : 'all',
          diff_x: tmp ? tmp.diff_x : 0,
          diff_y: tmp ? tmp.diff_y : 0
        });
        if (eventData.isCancelled === true) return;
        var p = $('#layout_' + obj.name + '_resizer_' + tmp.type);
        var resize_x = evnt.screenX - tmp.x;
        var resize_y = evnt.screenY - tmp.y;
        var mainPanel = obj.get('main');
        if (!p.hasClass('active')) p.addClass('active');
        switch (tmp.type) {
          case 'left':
            if (panel.minSize - resize_x > panel.width) {
              resize_x = panel.minSize - panel.width;
            }
            if (panel.maxSize && panel.width + resize_x > panel.maxSize) {
              resize_x = panel.maxSize - panel.width;
            }
            if (mainPanel.minSize + resize_x > mainPanel.width) {
              resize_x = mainPanel.width - mainPanel.minSize;
            }
            break;
          case 'right':
            if (panel.minSize + resize_x > panel.width) {
              resize_x = panel.width - panel.minSize;
            }
            if (panel.maxSize && panel.width - resize_x > panel.maxSize) {
              resize_x = panel.width - panel.maxSize;
            }
            if (mainPanel.minSize - resize_x > mainPanel.width) {
              resize_x = mainPanel.minSize - mainPanel.width;
            }
            break;
          case 'top':
            if (panel.minSize - resize_y > panel.height) {
              resize_y = panel.minSize - panel.height;
            }
            if (panel.maxSize && panel.height + resize_y > panel.maxSize) {
              resize_y = panel.maxSize - panel.height;
            }
            if (mainPanel.minSize + resize_y > mainPanel.height) {
              resize_y = mainPanel.height - mainPanel.minSize;
            }
            break;
          case 'preview':
          case 'bottom':
            if (panel.minSize + resize_y > panel.height) {
              resize_y = panel.height - panel.minSize;
            }
            if (panel.maxSize && panel.height - resize_y > panel.maxSize) {
              resize_y = panel.height - panel.maxSize;
            }
            if (mainPanel.minSize - resize_y > mainPanel.height) {
              resize_y = mainPanel.minSize - mainPanel.height;
            }
            break;
        }
        tmp.diff_x = resize_x;
        tmp.diff_y = resize_y;
        switch (tmp.type) {
          case 'top':
          case 'preview':
          case 'bottom':
            tmp.diff_x = 0;
            if (p.length > 0) p[0].style.top = tmp.value + tmp.diff_y + 'px';
            break;
          case 'left':
          case 'right':
            tmp.diff_y = 0;
            if (p.length > 0) p[0].style.left = tmp.value + tmp.diff_x + 'px';
            break;
        }
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
    },
    refresh: function refresh(panel) {
      var obj = this;
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      if (typeof panel == 'undefined') panel = null;
      var time = new Date().getTime();
      // event before
      var eventData = obj.trigger({
        phase: 'before',
        type: 'refresh',
        target: typeof panel != 'undefined' ? panel : obj.name,
        object: obj.get(panel)
      });
      if (eventData.isCancelled === true) return;
      // obj.unlock(panel);
      if (typeof panel == 'string') {
        var p = obj.get(panel);
        if (p === null) return;
        var pname = '#layout_' + obj.name + '_panel_' + p.type;
        var rname = '#layout_' + obj.name + '_resizer_' + p.type;
        // apply properties to the panel
        $(pname).css({
          display: p.hidden ? 'none' : 'block'
        });
        if (p.resizable) $(rname).show();else $(rname).hide();
        // insert content
        if (_typeof(p.content) == 'object' && typeof p.content.render === 'function') {
          p.content.box = $(pname + '> .w2ui-panel-content')[0];
          setTimeout(function () {
            // need to remove unnecessary classes
            if ($(pname + '> .w2ui-panel-content').length > 0) {
              $(pname + '> .w2ui-panel-content').removeClass().removeAttr('name').off('selectstart') // needed if previous was grid
              .addClass('w2ui-panel-content').css('overflow', p.overflow)[0].style.cssText += ';' + p.style;
            }
            p.content.render(); // do not do .render(box);
          }, 1);
        } else {
          // need to remove unnecessary classes
          if ($(pname + '> .w2ui-panel-content').length > 0) {
            $(pname + '> .w2ui-panel-content').removeClass().removeAttr('name').off('selectstart') // needed if previous was grid
            .addClass('w2ui-panel-content').html(p.content).css('overflow', p.overflow)[0].style.cssText += ';' + p.style;
          }
        }
        // if there are tabs and/or toolbar - render it
        var tmp = $(obj.box).find(pname + '> .w2ui-panel-tabs');
        if (p.show.tabs) {
          if (tmp.find('[name=' + p.tabs.name + ']').length === 0 && p.tabs !== null) tmp.w2render(p.tabs);else p.tabs.refresh();
        } else {
          tmp.html('').removeClass('w2ui-tabs').hide();
        }
        tmp = $(obj.box).find(pname + '> .w2ui-panel-toolbar');
        if (p.show.toolbar) {
          if (tmp.find('[name=' + p.toolbar.name + ']').length === 0 && p.toolbar !== null) tmp.w2render(p.toolbar);else p.toolbar.refresh();
        } else {
          tmp.html('').removeClass('w2ui-toolbar').hide();
        }
        // show title
        tmp = $(obj.box).find(pname + '> .w2ui-panel-title');
        if (p.title) {
          tmp.html(p.title).show();
        } else {
          tmp.html('').hide();
        }
      } else {
        if ($('#layout_' + obj.name + '_panel_main').length == 0) {
          obj.render();
          return;
        }
        obj.resize();
        // refresh all of them
        for (var p1 in this.panels) {
          obj.refresh(this.panels[p1].type);
        }
      }
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    resize: function resize() {
      // if (window.getSelection) window.getSelection().removeAllRanges();    // clear selection
      if (!this.box) return false;
      var time = new Date().getTime();
      // event before
      var tmp = this.tmp.resize;
      var eventData = this.trigger({
        phase: 'before',
        type: 'resize',
        target: this.name,
        panel: tmp ? tmp.type : 'all',
        diff_x: tmp ? tmp.diff_x : 0,
        diff_y: tmp ? tmp.diff_y : 0
      });
      if (eventData.isCancelled === true) return;
      if (this.padding < 0) this.padding = 0;

      // layout itself
      var width = parseInt($(this.box).width());
      var height = parseInt($(this.box).height());
      $(this.box).find(' > div').css({
        width: width + 'px',
        height: height + 'px'
      });
      var obj = this;
      // panels
      var pmain = this.get('main');
      var pprev = this.get('preview');
      var pleft = this.get('left');
      var pright = this.get('right');
      var ptop = this.get('top');
      var pbottom = this.get('bottom');
      var smain = true; // main always on
      var sprev = pprev !== null && pprev.hidden !== true ? true : false;
      var sleft = pleft !== null && pleft.hidden !== true ? true : false;
      var sright = pright !== null && pright.hidden !== true ? true : false;
      var stop = ptop !== null && ptop.hidden !== true ? true : false;
      var sbottom = pbottom !== null && pbottom.hidden !== true ? true : false;
      var l, t, w, h, e;
      // calculate %
      for (var p in w2layout_panels) {
        p = w2layout_panels[p];
        if (p === 'main') continue;
        var tmp = this.get(p);
        if (!tmp) continue;
        var str = String(tmp.size || 0);
        if (str.substr(str.length - 1) == '%') {
          var tmph = height;
          if (tmp.type == 'preview') {
            tmph = tmph - (ptop && !ptop.hidden ? ptop.sizeCalculated : 0) - (pbottom && !pbottom.hidden ? pbottom.sizeCalculated : 0);
          }
          tmp.sizeCalculated = parseInt((tmp.type == 'left' || tmp.type == 'right' ? width : tmph) * parseFloat(tmp.size) / 100);
        } else {
          tmp.sizeCalculated = parseInt(tmp.size);
        }
        tmp.sizeCalculated = Math.max(tmp.sizeCalculated, parseInt(tmp.minSize));
      }
      // top if any
      if (ptop !== null && ptop.hidden !== true) {
        l = 0;
        t = 0;
        w = width;
        h = ptop.sizeCalculated;
        $('#layout_' + this.name + '_panel_top').css({
          'display': 'block',
          'left': l + 'px',
          'top': t + 'px',
          'width': w + 'px',
          'height': h + 'px'
        }).show();
        ptop.width = w;
        ptop.height = h;
        // resizer
        if (ptop.resizable) {
          t = ptop.sizeCalculated - (this.padding === 0 ? this.resizer : 0);
          h = this.resizer > this.padding ? this.resizer : this.padding;
          $('#layout_' + this.name + '_resizer_top').show().css({
            'display': 'block',
            'left': l + 'px',
            'top': t + 'px',
            'width': w + 'px',
            'height': h + 'px',
            'cursor': 'ns-resize'
          }).off('mousedown').on('mousedown', function (event) {
            // event before
            var eventData = obj.trigger({
              phase: 'before',
              type: 'resizerClick',
              target: 'top',
              originalEvent: event
            });
            if (eventData.isCancelled === true) return;
            // default action
            w2ui[obj.name].tmp.events.resizeStart('top', event);
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
            return false;
          });
        }
      } else {
        $('#layout_' + this.name + '_panel_top').hide();
      }
      // left if any
      if (pleft !== null && pleft.hidden !== true) {
        l = 0;
        t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
        w = pleft.sizeCalculated;
        h = height - (stop ? ptop.sizeCalculated + this.padding : 0) - (sbottom ? pbottom.sizeCalculated + this.padding : 0);
        e = $('#layout_' + this.name + '_panel_left');
        if (window.navigator.userAgent.indexOf('MSIE') != -1 && e.length > 0 && e[0].clientHeight < e[0].scrollHeight) w += 17; // IE hack
        e.css({
          'display': 'block',
          'left': l + 'px',
          'top': t + 'px',
          'width': w + 'px',
          'height': h + 'px'
        }).show();
        pleft.width = w;
        pleft.height = h;
        // resizer
        if (pleft.resizable) {
          l = pleft.sizeCalculated - (this.padding === 0 ? this.resizer : 0);
          w = this.resizer > this.padding ? this.resizer : this.padding;
          $('#layout_' + this.name + '_resizer_left').show().css({
            'display': 'block',
            'left': l + 'px',
            'top': t + 'px',
            'width': w + 'px',
            'height': h + 'px',
            'cursor': 'ew-resize'
          }).off('mousedown').on('mousedown', function (event) {
            // event before
            var eventData = obj.trigger({
              phase: 'before',
              type: 'resizerClick',
              target: 'left',
              originalEvent: event
            });
            if (eventData.isCancelled === true) return;
            // default action
            w2ui[obj.name].tmp.events.resizeStart('left', event);
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
            return false;
          });
        }
      } else {
        $('#layout_' + this.name + '_panel_left').hide();
        $('#layout_' + this.name + '_resizer_left').hide();
      }
      // right if any
      if (pright !== null && pright.hidden !== true) {
        l = width - pright.sizeCalculated;
        t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
        w = pright.sizeCalculated;
        h = height - (stop ? ptop.sizeCalculated + this.padding : 0) - (sbottom ? pbottom.sizeCalculated + this.padding : 0);
        $('#layout_' + this.name + '_panel_right').css({
          'display': 'block',
          'left': l + 'px',
          'top': t + 'px',
          'width': w + 'px',
          'height': h + 'px'
        }).show();
        pright.width = w;
        pright.height = h;
        // resizer
        if (pright.resizable) {
          l = l - this.padding;
          w = this.resizer > this.padding ? this.resizer : this.padding;
          $('#layout_' + this.name + '_resizer_right').show().css({
            'display': 'block',
            'left': l + 'px',
            'top': t + 'px',
            'width': w + 'px',
            'height': h + 'px',
            'cursor': 'ew-resize'
          }).off('mousedown').on('mousedown', function (event) {
            // event before
            var eventData = obj.trigger({
              phase: 'before',
              type: 'resizerClick',
              target: 'right',
              originalEvent: event
            });
            if (eventData.isCancelled === true) return;
            // default action
            w2ui[obj.name].tmp.events.resizeStart('right', event);
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
            return false;
          });
        }
      } else {
        $('#layout_' + this.name + '_panel_right').hide();
      }
      // bottom if any
      if (pbottom !== null && pbottom.hidden !== true) {
        l = 0;
        t = height - pbottom.sizeCalculated;
        w = width;
        h = pbottom.sizeCalculated;
        $('#layout_' + this.name + '_panel_bottom').css({
          'display': 'block',
          'left': l + 'px',
          'top': t + 'px',
          'width': w + 'px',
          'height': h + 'px'
        }).show();
        pbottom.width = w;
        pbottom.height = h;
        // resizer
        if (pbottom.resizable) {
          t = t - (this.padding === 0 ? 0 : this.padding);
          h = this.resizer > this.padding ? this.resizer : this.padding;
          $('#layout_' + this.name + '_resizer_bottom').show().css({
            'display': 'block',
            'left': l + 'px',
            'top': t + 'px',
            'width': w + 'px',
            'height': h + 'px',
            'cursor': 'ns-resize'
          }).off('mousedown').on('mousedown', function (event) {
            // event before
            var eventData = obj.trigger({
              phase: 'before',
              type: 'resizerClick',
              target: 'bottom',
              originalEvent: event
            });
            if (eventData.isCancelled === true) return;
            // default action
            w2ui[obj.name].tmp.events.resizeStart('bottom', event);
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
            return false;
          });
        }
      } else {
        $('#layout_' + this.name + '_panel_bottom').hide();
      }
      // main - always there
      l = 0 + (sleft ? pleft.sizeCalculated + this.padding : 0);
      t = 0 + (stop ? ptop.sizeCalculated + this.padding : 0);
      w = width - (sleft ? pleft.sizeCalculated + this.padding : 0) - (sright ? pright.sizeCalculated + this.padding : 0);
      h = height - (stop ? ptop.sizeCalculated + this.padding : 0) - (sbottom ? pbottom.sizeCalculated + this.padding : 0) - (sprev ? pprev.sizeCalculated + this.padding : 0);
      e = $('#layout_' + this.name + '_panel_main');
      if (window.navigator.userAgent.indexOf('MSIE') != -1 && e.length > 0 && e[0].clientHeight < e[0].scrollHeight) w += 17; // IE hack
      e.css({
        'display': 'block',
        'left': l + 'px',
        'top': t + 'px',
        'width': w + 'px',
        'height': h + 'px'
      });
      pmain.width = w;
      pmain.height = h;

      // preview if any
      if (pprev !== null && pprev.hidden !== true) {
        l = 0 + (sleft ? pleft.sizeCalculated + this.padding : 0);
        t = height - (sbottom ? pbottom.sizeCalculated + this.padding : 0) - pprev.sizeCalculated;
        w = width - (sleft ? pleft.sizeCalculated + this.padding : 0) - (sright ? pright.sizeCalculated + this.padding : 0);
        h = pprev.sizeCalculated;
        e = $('#layout_' + this.name + '_panel_preview');
        if (window.navigator.userAgent.indexOf('MSIE') != -1 && e.length > 0 && e[0].clientHeight < e[0].scrollHeight) w += 17; // IE hack
        e.css({
          'display': 'block',
          'left': l + 'px',
          'top': t + 'px',
          'width': w + 'px',
          'height': h + 'px'
        }).show();
        pprev.width = w;
        pprev.height = h;
        // resizer
        if (pprev.resizable) {
          t = t - (this.padding === 0 ? 0 : this.padding);
          h = this.resizer > this.padding ? this.resizer : this.padding;
          $('#layout_' + this.name + '_resizer_preview').show().css({
            'display': 'block',
            'left': l + 'px',
            'top': t + 'px',
            'width': w + 'px',
            'height': h + 'px',
            'cursor': 'ns-resize'
          }).off('mousedown').on('mousedown', function (event) {
            // event before
            var eventData = obj.trigger({
              phase: 'before',
              type: 'resizerClick',
              target: 'preview',
              originalEvent: event
            });
            if (eventData.isCancelled === true) return;
            // default action
            w2ui[obj.name].tmp.events.resizeStart('preview', event);
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
            return false;
          });
        }
      } else {
        $('#layout_' + this.name + '_panel_preview').hide();
      }

      // display tabs and toolbar if needed
      for (var p1 in w2layout_panels) {
        p1 = w2layout_panels[p1];
        var pan = this.get(p1);
        var tmp2 = '#layout_' + this.name + '_panel_' + p1 + ' > .w2ui-panel-';
        var tabHeight = 0;
        if (pan) {
          if (pan.title) {
            tabHeight += w2utils.getSize($(tmp2 + 'title').css({
              top: tabHeight + 'px',
              display: 'block'
            }), 'height');
          }
          if (pan.show.tabs) {
            if (pan.tabs !== null && w2ui[this.name + '_' + p1 + '_tabs']) w2ui[this.name + '_' + p1 + '_tabs'].resize();
            tabHeight += w2utils.getSize($(tmp2 + 'tabs').css({
              top: tabHeight + 'px',
              display: 'block'
            }), 'height');
          }
          if (pan.show.toolbar) {
            if (pan.toolbar !== null && w2ui[this.name + '_' + p1 + '_toolbar']) w2ui[this.name + '_' + p1 + '_toolbar'].resize();
            tabHeight += w2utils.getSize($(tmp2 + 'toolbar').css({
              top: tabHeight + 'px',
              display: 'block'
            }), 'height');
          }
        }
        $(tmp2 + 'content').css({
          display: 'block'
        }).css({
          top: tabHeight + 'px'
        });
      }
      // send resize to all objects
      clearTimeout(this._resize_timer);
      this._resize_timer = setTimeout(function () {
        for (var e in w2ui) {
          if (typeof w2ui[e].resize == 'function') {
            // sent to all none-layouts
            if (w2ui[e].panels == 'undefined') w2ui[e].resize();
            // only send to nested layouts
            var parent = $(w2ui[e].box).parents('.w2ui-layout');
            if (parent.length > 0 && parent.attr('name') == obj.name) w2ui[e].resize();
          }
        }
      }, 100);
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'destroy',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      if (typeof w2ui[this.name] == 'undefined') return false;
      // clean up
      if ($(this.box).find('#layout_' + this.name + '_panel_main').length > 0) {
        $(this.box).removeAttr('name').removeClass('w2ui-layout').html('');
      }
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      if (this.tmp.events && this.tmp.events.resize) $(window).off('resize', this.tmp.events.resize);
      return true;
    },
    lock: function lock(panel, msg, showSpinner) {
      if (w2layout_panels.indexOf(panel) == -1) {
        console.log('ERROR: First parameter needs to be the a valid panel name.');
        return;
      }
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = '#layout_' + this.name + '_panel_' + panel;
      w2utils.lock.apply(window, args);
    },
    unlock: function unlock(panel) {
      if (w2layout_panels.indexOf(panel) == -1) {
        console.log('ERROR: First parameter needs to be the a valid panel name.');
        return;
      }
      var nm = '#layout_' + this.name + '_panel_' + panel;
      w2utils.unlock(nm);
    }
  };
  $.extend(w2layout.prototype, w2utils.event);
  w2obj.layout = w2layout;
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2popup      - popup widget
*        - $().w2popup  - jQuery wrapper
*   - Dependencies: jQuery, w2utils
*
* == NICE TO HAVE ==
*   - transition should include title, body and buttons, not just body
*
************************************************************************/

var w2popup = {};
(function () {
  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2popup = function (method, options) {
    if (typeof method === 'undefined') {
      options = {};
      method = 'open';
    }
    if ($.isPlainObject(method)) {
      options = method;
      method = 'open';
    }
    method = method.toLowerCase();
    if (method === 'load' && typeof options === 'string') {
      options = $.extend({
        url: options
      }, arguments.length > 2 ? arguments[2] : {});
    }
    if (method === 'open' && options.url != null) method = 'load';
    options = options || {};
    // load options from markup
    var dlgOptions = {};
    if ($(this).length > 0) {
      if ($(this).find('div[rel=title], div[rel=body], div[rel=buttons]').length > 0) {
        if ($(this).find('div[rel=title]').length > 0) {
          dlgOptions['title'] = $(this).find('div[rel=title]').html();
        }
        if ($(this).find('div[rel=body]').length > 0) {
          dlgOptions['body'] = $(this).find('div[rel=body]').html();
          dlgOptions['style'] = $(this).find('div[rel=body]')[0].style.cssText;
        }
        if ($(this).find('div[rel=buttons]').length > 0) {
          dlgOptions['buttons'] = $(this).find('div[rel=buttons]').html();
        }
      } else {
        dlgOptions['title'] = '&nbsp;';
        dlgOptions['body'] = $(this).html();
      }
      if (parseInt($(this).css('width')) != 0) dlgOptions['width'] = parseInt($(this).css('width'));
      if (parseInt($(this).css('height')) != 0) dlgOptions['height'] = parseInt($(this).css('height'));
    }
    // show popup
    return w2popup[method]($.extend({}, dlgOptions, options));
  };

  // ====================================================
  // -- Implementation of core functionality (SINGELTON)

  w2popup = {
    defaults: {
      title: '',
      body: '',
      buttons: '',
      style: '',
      color: '#000',
      opacity: 0.4,
      speed: 0.3,
      modal: false,
      maximized: false,
      keyboard: true,
      // will close popup on esc if not modal
      width: 500,
      height: 300,
      showClose: true,
      showMax: false,
      transition: null
    },
    status: 'closed',
    // string that describes current status
    handlers: [],
    onOpen: null,
    onClose: null,
    onMax: null,
    onMin: null,
    onToggle: null,
    onKeydown: null,
    open: function open(options) {
      var obj = this;
      if (w2popup.status == 'closing') {
        setTimeout(function () {
          obj.open.call(obj, options);
        }, 100);
        return;
      }
      // get old options and merge them
      var old_options = $('#w2ui-popup').data('options');
      var options = $.extend({}, this.defaults, old_options, {
        title: '',
        body: '',
        buttons: ''
      }, options, {
        maximized: false
      });
      // need timer because popup might not be open
      setTimeout(function () {
        $('#w2ui-popup').data('options', options);
      }, 100);
      // if new - reset event handlers
      if ($('#w2ui-popup').length == 0) {
        w2popup.handlers = [];
        w2popup.onMax = null;
        w2popup.onMin = null;
        w2popup.onToggle = null;
        w2popup.onOpen = null;
        w2popup.onClose = null;
        w2popup.onKeydown = null;
      }
      if (options.onOpen) w2popup.onOpen = options.onOpen;
      if (options.onClose) w2popup.onClose = options.onClose;
      if (options.onMax) w2popup.onMax = options.onMax;
      if (options.onMin) w2popup.onMin = options.onMin;
      if (options.onToggle) w2popup.onToggle = options.onToggle;
      if (options.onKeydown) w2popup.onKeydown = options.onKeydown;
      if (window.innerHeight == undefined) {
        var width = document.documentElement.offsetWidth;
        var height = document.documentElement.offsetHeight;
        if (w2utils.engine === 'IE7') {
          width += 21;
          height += 4;
        }
      } else {
        var width = window.innerWidth;
        var height = window.innerHeight;
      }
      if (parseInt(width) - 10 < parseInt(options.width)) options.width = parseInt(width) - 10;
      if (parseInt(height) - 10 < parseInt(options.height)) options.height = parseInt(height) - 10;
      var top = parseInt((parseInt(height) - parseInt(options.height)) / 2 * 0.6);
      var left = parseInt((parseInt(width) - parseInt(options.width)) / 2);
      // check if message is already displayed
      if ($('#w2ui-popup').length == 0) {
        // trigger event
        var eventData = this.trigger({
          phase: 'before',
          type: 'open',
          target: 'popup',
          options: options,
          present: false
        });
        if (eventData.isCancelled === true) return;
        w2popup.status = 'opening';
        // output message
        w2popup.lockScreen(options);
        var btn = '';
        if (options.showClose) {
          btn += '<div class="w2ui-msg-button w2ui-msg-close" onmousedown="event.stopPropagation()" onclick="w2popup.close()">Close</div>';
        }
        if (options.showMax) {
          btn += '<div class="w2ui-msg-button w2ui-msg-max" onmousedown="event.stopPropagation()" onclick="w2popup.toggle()">Max</div>';
        }
        var msg = '<div id="w2ui-popup" class="w2ui-popup" style="opacity: 0; left: ' + left + 'px; top: ' + top + 'px;' + '     width: ' + parseInt(options.width) + 'px; height: ' + parseInt(options.height) + 'px; ' + '    -webkit-transform: scale(0.8); -moz-transform: scale(0.8); -ms-transform: scale(0.8); -o-transform: scale(0.8); "' + '>' + '   <div class="w2ui-msg-title" style="' + (options.title == '' ? 'display: none' : '') + '">' + btn + options.title + '</div>' + '   <div class="w2ui-box1" style="' + (options.title == '' ? 'top: 0px !important;' : '') + (options.buttons == '' ? 'bottom: 0px !important;' : '') + '">' + '       <div class="w2ui-msg-body' + (!options.title != '' ? ' w2ui-msg-no-title' : '') + (!options.buttons != '' ? ' w2ui-msg-no-buttons' : '') + '" style="' + options.style + '">' + options.body + '</div>' + '   </div>' + '   <div class="w2ui-box2" style="' + (options.title == '' ? 'top: 0px !important;' : '') + (options.buttons == '' ? 'bottom: 0px !important;' : '') + '">' + '       <div class="w2ui-msg-body' + (!options.title != '' ? ' w2ui-msg-no-title' : '') + (!options.buttons != '' ? ' w2ui-msg-no-buttons' : '') + '" style="' + options.style + '"></div>' + '       </div>' + '   <div class="w2ui-msg-buttons" style="' + (options.buttons == '' ? 'display: none' : '') + '">' + options.buttons + '</div>' + '</div>';
        $('body').append(msg);
        // allow element to render
        setTimeout(function () {
          $('#w2ui-popup .w2ui-box2').hide();
          $('#w2ui-popup').css({
            '-webkit-transition': options.speed + 's opacity, ' + options.speed + 's -webkit-transform',
            '-webkit-transform': 'scale(1)',
            '-moz-transition': options.speed + 's opacity, ' + options.speed + 's -moz-transform',
            '-moz-transform': 'scale(1)',
            '-ms-transition': options.speed + 's opacity, ' + options.speed + 's -ms-transform',
            '-ms-transform': 'scale(1)',
            '-o-transition': options.speed + 's opacity, ' + options.speed + 's -o-transform',
            '-o-transform': 'scale(1)',
            'opacity': '1'
          });
        }, 1);
        // clean transform
        setTimeout(function () {
          $('#w2ui-popup').css({
            '-webkit-transform': '',
            '-moz-transform': '',
            '-ms-transform': '',
            '-o-transform': ''
          });
          // event after
          w2popup.status = 'open';
          setTimeout(function () {
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
          }, 100);
        }, options.speed * 1000);
      } else {
        // trigger event
        var eventData = this.trigger({
          phase: 'before',
          type: 'open',
          target: 'popup',
          options: options,
          present: true
        });
        if (eventData.isCancelled === true) return;
        // check if size changed
        w2popup.status = 'opening';
        if (typeof old_options == 'undefined' || old_options['width'] != options['width'] || old_options['height'] != options['height']) {
          w2popup.resize(options.width, options.height);
        }
        if (typeof old_options != 'undefined') {
          options.prevSize = options.width + ':' + options.height;
          options.maximized = old_options.maximized;
        }
        // show new items
        var body = $('#w2ui-popup .w2ui-box2 > .w2ui-msg-body').html(options.body);
        if (body.length > 0) body[0].style.cssText = options.style;
        if (options.buttons != '') {
          $('#w2ui-popup .w2ui-msg-buttons').show().html(options.buttons);
          $('#w2ui-popup .w2ui-msg-body').removeClass('w2ui-msg-no-buttons');
          $('#w2ui-popup .w2ui-box1, #w2ui-popup .w2ui-box2').css('bottom', '');
        } else {
          $('#w2ui-popup .w2ui-msg-buttons').hide().html('');
          $('#w2ui-popup .w2ui-msg-body').addClass('w2ui-msg-no-buttons');
          $('#w2ui-popup .w2ui-box1, #w2ui-popup .w2ui-box2').css('bottom', '0px');
        }
        if (options.title != '') {
          $('#w2ui-popup .w2ui-msg-title').show().html((options.showClose ? '<div class="w2ui-msg-button w2ui-msg-close" onmousedown="event.stopPropagation()" onclick="w2popup.close()">Close</div>' : '') + (options.showMax ? '<div class="w2ui-msg-button w2ui-msg-max" onmousedown="event.stopPropagation()" onclick="w2popup.toggle()">Max</div>' : '') + options.title);
          $('#w2ui-popup .w2ui-msg-body').removeClass('w2ui-msg-no-title');
          $('#w2ui-popup .w2ui-box1, #w2ui-popup .w2ui-box2').css('top', '');
        } else {
          $('#w2ui-popup .w2ui-msg-title').hide().html('');
          $('#w2ui-popup .w2ui-msg-body').addClass('w2ui-msg-no-title');
          $('#w2ui-popup .w2ui-box1, #w2ui-popup .w2ui-box2').css('top', '0px');
        }
        // transition
        var div_old = $('#w2ui-popup .w2ui-box1')[0];
        var div_new = $('#w2ui-popup .w2ui-box2')[0];
        w2utils.transition(div_old, div_new, options.transition);
        div_new.className = 'w2ui-box1';
        div_old.className = 'w2ui-box2';
        $(div_new).addClass('w2ui-current-box');
        // remove max state
        $('#w2ui-popup').data('prev-size', null);
        // call event onChange
        setTimeout(function () {
          w2popup.status = 'open';
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        }, 100);
      }
      // save new options
      options._last_w2ui_name = w2utils.keyboard.active();
      w2utils.keyboard.active(null);
      // keyboard events
      if (options.keyboard) $(document).on('keydown', this.keydown);

      // initialize move
      var tmp = {
        resizing: false,
        mvMove: mvMove,
        mvStop: mvStop
      };
      $('#w2ui-popup .w2ui-msg-title').on('mousedown', function (event) {
        mvStart(event);
      });

      // handlers
      function mvStart(evnt) {
        if (!evnt) evnt = window.event;
        if (!window.addEventListener) {
          window.document.attachEvent('onselectstart', function () {
            return false;
          });
        }
        w2popup.status = 'moving';
        tmp.resizing = true;
        tmp.x = evnt.screenX;
        tmp.y = evnt.screenY;
        tmp.pos_x = $('#w2ui-popup').position().left;
        tmp.pos_y = $('#w2ui-popup').position().top;
        w2popup.lock({
          opacity: 0
        });
        $(document).on('mousemove', tmp.mvMove);
        $(document).on('mouseup', tmp.mvStop);
        if (evnt.stopPropagation) evnt.stopPropagation();else evnt.cancelBubble = true;
        if (evnt.preventDefault) evnt.preventDefault();else return false;
      }
      function mvMove(evnt) {
        if (tmp.resizing != true) return;
        if (!evnt) evnt = window.event;
        tmp.div_x = evnt.screenX - tmp.x;
        tmp.div_y = evnt.screenY - tmp.y;
        $('#w2ui-popup').css({
          '-webkit-transition': 'none',
          '-webkit-transform': 'translate3d(' + tmp.div_x + 'px, ' + tmp.div_y + 'px, 0px)',
          '-moz-transition': 'none',
          '-moz-transform': 'translate(' + tmp.div_x + 'px, ' + tmp.div_y + 'px)',
          '-ms-transition': 'none',
          '-ms-transform': 'translate(' + tmp.div_x + 'px, ' + tmp.div_y + 'px)',
          '-o-transition': 'none',
          '-o-transform': 'translate(' + tmp.div_x + 'px, ' + tmp.div_y + 'px)'
        });
      }
      function mvStop(evnt) {
        if (tmp.resizing != true) return;
        if (!evnt) evnt = window.event;
        w2popup.status = 'open';
        tmp.div_x = evnt.screenX - tmp.x;
        tmp.div_y = evnt.screenY - tmp.y;
        $('#w2ui-popup').css({
          'left': tmp.pos_x + tmp.div_x + 'px',
          'top': tmp.pos_y + tmp.div_y + 'px',
          '-webkit-transition': 'none',
          '-webkit-transform': 'translate3d(0px, 0px, 0px)',
          '-moz-transition': 'none',
          '-moz-transform': 'translate(0px, 0px)',
          '-ms-transition': 'none',
          '-ms-transform': 'translate(0px, 0px)',
          '-o-transition': 'none',
          '-o-transform': 'translate(0px, 0px)'
        });
        tmp.resizing = false;
        $(document).off('mousemove', tmp.mvMove);
        $(document).off('mouseup', tmp.mvStop);
        w2popup.unlock();
      }
      return this;
    },
    keydown: function keydown(event) {
      var options = $('#w2ui-popup').data('options');
      if (!options || !options.keyboard) return;
      // trigger event
      var eventData = w2popup.trigger({
        phase: 'before',
        type: 'keydown',
        target: 'popup',
        options: options,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default behavior
      switch (event.keyCode) {
        case 27:
          event.preventDefault();
          if ($('#w2ui-popup .w2ui-popup-message').length > 0) w2popup.message();else w2popup.close();
          break;
      }
      // event after
      w2popup.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    close: function close(options) {
      var obj = this;
      var options = $.extend({}, $('#w2ui-popup').data('options'), options);
      if ($('#w2ui-popup').length == 0) return;
      // trigger event
      var eventData = this.trigger({
        phase: 'before',
        type: 'close',
        target: 'popup',
        options: options
      });
      if (eventData.isCancelled === true) return;
      // default behavior
      w2popup.status = 'closing';
      $('#w2ui-popup').css({
        '-webkit-transition': options.speed + 's opacity, ' + options.speed + 's -webkit-transform',
        '-webkit-transform': 'scale(0.9)',
        '-moz-transition': options.speed + 's opacity, ' + options.speed + 's -moz-transform',
        '-moz-transform': 'scale(0.9)',
        '-ms-transition': options.speed + 's opacity, ' + options.speed + 's -ms-transform',
        '-ms-transform': 'scale(0.9)',
        '-o-transition': options.speed + 's opacity, ' + options.speed + 's -o-transform',
        '-o-transform': 'scale(0.9)',
        'opacity': '0'
      });
      w2popup.unlockScreen(options);
      setTimeout(function () {
        $('#w2ui-popup').remove();
        w2popup.status = 'closed';
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, options.speed * 1000);
      // restore active
      w2utils.keyboard.active(options._last_w2ui_name);
      // remove keyboard events
      if (options.keyboard) $(document).off('keydown', this.keydown);
    },
    toggle: function toggle() {
      var obj = this;
      var options = $('#w2ui-popup').data('options');
      // trigger event
      var eventData = this.trigger({
        phase: 'before',
        type: 'toggle',
        target: 'popup',
        options: options
      });
      if (eventData.isCancelled === true) return;
      // defatul action
      if (options.maximized === true) w2popup.min();else w2popup.max();
      // event after
      setTimeout(function () {
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, options.speed * 1000 + 50);
    },
    max: function max() {
      var obj = this;
      var options = $('#w2ui-popup').data('options');
      if (options.maximized === true) return;
      // trigger event
      var eventData = this.trigger({
        phase: 'before',
        type: 'max',
        target: 'popup',
        options: options
      });
      if (eventData.isCancelled === true) return;
      // default behavior
      w2popup.status = 'resizing';
      options.prevSize = $('#w2ui-popup').css('width') + ':' + $('#w2ui-popup').css('height');
      // do resize
      w2popup.resize(10000, 10000, function () {
        w2popup.status = 'open';
        options.maximized = true;
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      });
    },
    min: function min() {
      var obj = this;
      var options = $('#w2ui-popup').data('options');
      if (options.maximized !== true) return;
      var size = options.prevSize.split(':');
      // trigger event
      var eventData = this.trigger({
        phase: 'before',
        type: 'min',
        target: 'popup',
        options: options
      });
      if (eventData.isCancelled === true) return;
      // default behavior
      w2popup.status = 'resizing';
      // do resize
      w2popup.resize(size[0], size[1], function () {
        w2popup.status = 'open';
        options.maximized = false;
        options.prevSize = null;
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      });
    },
    get: function get() {
      return $('#w2ui-popup').data('options');
    },
    set: function set(options) {
      w2popup.open(options);
    },
    clear: function clear() {
      $('#w2ui-popup .w2ui-msg-title').html('');
      $('#w2ui-popup .w2ui-msg-body').html('');
      $('#w2ui-popup .w2ui-msg-buttons').html('');
    },
    reset: function reset() {
      w2popup.open(w2popup.defaults);
    },
    load: function load(options) {
      w2popup.status = 'loading';
      if (String(options.url) == 'undefined') {
        console.log('ERROR: The url parameter is empty.');
        return;
      }
      var tmp = String(options.url).split('#');
      var url = tmp[0];
      var selector = tmp[1];
      if (String(options) == 'undefined') options = {};
      // load url
      var html = $('#w2ui-popup').data(url);
      if (typeof html != 'undefined' && html != null) {
        popup(html, selector);
      } else {
        $.get(url, function (data, status, obj) {
          // should always be $.get as it is template
          popup(obj.responseText, selector);
          $('#w2ui-popup').data(url, obj.responseText); // remember for possible future purposes
        });
      }
      function popup(html, selector) {
        delete options.url;
        $('body').append('<div id="w2ui-tmp" style="display: none">' + html + '</div>');
        if (typeof selector != 'undefined' && $('#w2ui-tmp #' + selector).length > 0) {
          $('#w2ui-tmp #' + selector).w2popup(options);
        } else {
          $('#w2ui-tmp > div').w2popup(options);
        }
        // link styles
        if ($('#w2ui-tmp > style').length > 0) {
          var style = $('<div>').append($('#w2ui-tmp > style').clone()).html();
          if ($('#w2ui-popup #div-style').length == 0) {
            $('#w2ui-popup').append('<div id="div-style" style="position: absolute; left: -100; width: 1px"></div>');
          }
          $('#w2ui-popup #div-style').html(style);
        }
        $('#w2ui-tmp').remove();
      }
    },
    message: function message(options) {
      $().w2tag(); // hide all tags
      if (!options) options = {
        width: 200,
        height: 100
      };
      if (parseInt(options.width) < 10) options.width = 10;
      if (parseInt(options.height) < 10) options.height = 10;
      if (typeof options.hideOnClick == 'undefined') options.hideOnClick = false;
      var poptions = $('#w2ui-popup').data('options') || {};
      if (typeof options.width == 'undefined' || options.width > poptions.width - 10) options.width = poptions.width - 10;
      if (typeof options.height == 'undefined' || options.height > poptions.height - 40) options.height = poptions.height - 40; // title is 30px or so

      var head = $('#w2ui-popup .w2ui-msg-title');
      var pwidth = parseInt($('#w2ui-popup').width());
      var msgCount = $('#w2ui-popup .w2ui-popup-message').length;
      // remove message
      if ($.trim(options.html) == '') {
        $('#w2ui-popup #w2ui-message' + (msgCount - 1)).css('z-Index', 250);
        var options = $('#w2ui-popup #w2ui-message' + (msgCount - 1)).data('options') || {};
        $('#w2ui-popup #w2ui-message' + (msgCount - 1)).remove();
        if (typeof options.onClose == 'function') options.onClose();
        if (msgCount == 1) {
          w2popup.unlock();
        } else {
          $('#w2ui-popup #w2ui-message' + (msgCount - 2)).show();
        }
      } else {
        // hide previous messages
        $('#w2ui-popup .w2ui-popup-message').hide();
        // add message
        $('#w2ui-popup .w2ui-box1').before('<div id="w2ui-message' + msgCount + '" class="w2ui-popup-message" style="display: none; ' + (head.length == 0 ? 'top: 0px;' : 'top: ' + w2utils.getSize(head, 'height') + 'px;') + (typeof options.width != 'undefined' ? 'width: ' + options.width + 'px; left: ' + (pwidth - options.width) / 2 + 'px;' : 'left: 10px; right: 10px;') + (typeof options.height != 'undefined' ? 'height: ' + options.height + 'px;' : 'bottom: 6px;') + '-webkit-transition: .3s; -moz-transition: .3s; -ms-transition: .3s; -o-transition: .3s;"' + (options.hideOnClick === true ? 'onclick="w2popup.message();"' : '') + '>' + '</div>');
        $('#w2ui-popup #w2ui-message' + msgCount).data('options', options);
        var display = $('#w2ui-popup #w2ui-message' + msgCount).css('display');
        $('#w2ui-popup #w2ui-message' + msgCount).css({
          '-webkit-transform': display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)',
          '-moz-transform': display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)',
          '-ms-transform': display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)',
          '-o-transform': display == 'none' ? 'translateY(-' + options.height + 'px)' : 'translateY(0px)'
        });
        if (display == 'none') {
          $('#w2ui-popup #w2ui-message' + msgCount).show().html(options.html);
          // timer needs to animation
          setTimeout(function () {
            $('#w2ui-popup #w2ui-message' + msgCount).css({
              '-webkit-transform': display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)',
              '-moz-transform': display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)',
              '-ms-transform': display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)',
              '-o-transform': display == 'none' ? 'translateY(0px)' : 'translateY(-' + options.height + 'px)'
            });
          }, 1);
          // timer for lock
          setTimeout(function () {
            $('#w2ui-popup #w2ui-message' + msgCount).css({
              '-webkit-transition': '0s',
              '-moz-transition': '0s',
              '-ms-transition': '0s',
              '-o-transition': '0s',
              'z-Index': 1500
            }); // has to be on top of lock
            if (msgCount == 0) w2popup.lock();
            if (typeof options.onOpen == 'function') options.onOpen();
          }, 300);
        }
      }
    },
    lock: function lock(msg, showSpinner) {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift($('#w2ui-popup'));
      w2utils.lock.apply(window, args);
    },
    unlock: function unlock() {
      w2utils.unlock($('#w2ui-popup'));
    },
    // --- INTERNAL FUNCTIONS

    lockScreen: function lockScreen(options) {
      if ($('#w2ui-lock').length > 0) return false;
      if (typeof options == 'undefined') options = $('#w2ui-popup').data('options');
      if (typeof options == 'undefined') options = {};
      options = $.extend({}, w2popup.defaults, options);
      // show element
      $('body').append('<div id="w2ui-lock" ' + '    onmousewheel="if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true; if (event.preventDefault) event.preventDefault(); else return false;"' + '    style="position: ' + (w2utils.engine == 'IE5' ? 'absolute' : 'fixed') + '; z-Index: 1199; left: 0px; top: 0px; ' + '           padding: 0px; margin: 0px; background-color: ' + options.color + '; width: 100%; height: 100%; opacity: 0;"></div>');
      // lock screen
      setTimeout(function () {
        $('#w2ui-lock').css({
          '-webkit-transition': options.speed + 's opacity',
          '-moz-transition': options.speed + 's opacity',
          '-ms-transition': options.speed + 's opacity',
          '-o-transition': options.speed + 's opacity',
          'opacity': options.opacity
        });
      }, 1);
      // add events
      if (options.modal == true) {
        $('#w2ui-lock').on('mousedown', function () {
          $('#w2ui-lock').css({
            '-webkit-transition': '.1s',
            '-moz-transition': '.1s',
            '-ms-transition': '.1s',
            '-o-transition': '.1s',
            'opacity': '0.6'
          });
          // if (window.getSelection) window.getSelection().removeAllRanges();
        });
        $('#w2ui-lock').on('mouseup', function () {
          setTimeout(function () {
            $('#w2ui-lock').css({
              '-webkit-transition': '.1s',
              '-moz-transition': '.1s',
              '-ms-transition': '.1s',
              '-o-transition': '.1s',
              'opacity': options.opacity
            });
          }, 100);
          // if (window.getSelection) window.getSelection().removeAllRanges();
        });
      } else {
        $('#w2ui-lock').on('mouseup', function () {
          w2popup.close();
        });
      }
      return true;
    },
    unlockScreen: function unlockScreen(options) {
      if ($('#w2ui-lock').length == 0) return false;
      if (typeof options == 'undefined') options = $('#w2ui-popup').data('options');
      if (typeof options == 'undefined') options = {};
      options = $.extend({}, w2popup.defaults, options);
      $('#w2ui-lock').css({
        '-webkit-transition': options.speed + 's opacity',
        '-moz-transition': options.speed + 's opacity',
        '-ms-transition': options.speed + 's opacity',
        '-o-transition': options.speed + 's opacity',
        'opacity': 0
      });
      setTimeout(function () {
        $('#w2ui-lock').remove();
      }, options.speed * 1000);
      return true;
    },
    resize: function resize(width, height, callBack) {
      var options = $('#w2ui-popup').data('options');
      // calculate new position
      if (parseInt($(window).width()) - 10 < parseInt(width)) width = parseInt($(window).width()) - 10;
      if (parseInt($(window).height()) - 10 < parseInt(height)) height = parseInt($(window).height()) - 10;
      var top = (parseInt($(window).height()) - parseInt(height)) / 2 * 0.8;
      var left = (parseInt($(window).width()) - parseInt(width)) / 2;
      // resize there
      $('#w2ui-popup').css({
        '-webkit-transition': options.speed + 's width, ' + options.speed + 's height, ' + options.speed + 's left, ' + options.speed + 's top',
        '-moz-transition': options.speed + 's width, ' + options.speed + 's height, ' + options.speed + 's left, ' + options.speed + 's top',
        '-ms-transition': options.speed + 's width, ' + options.speed + 's height, ' + options.speed + 's left, ' + options.speed + 's top',
        '-o-transition': options.speed + 's width, ' + options.speed + 's height, ' + options.speed + 's left, ' + options.speed + 's top',
        'top': top,
        'left': left,
        'width': width,
        'height': height
      });
      setTimeout(function () {
        options.width = width;
        options.height = height;
        if (typeof callBack == 'function') callBack();
      }, options.speed * 1000 + 50); // give extra 50 ms
    }
  };

  // merge in event handling
  $.extend(w2popup, w2utils.event);
})();

// ============================================
// --- Common dialogs

var w2alert = function w2alert(msg, title, callBack) {
  if (title == null) title = w2utils.lang('Notification');
  if ($('#w2ui-popup').length > 0 && w2popup.status != 'closing') {
    w2popup.message({
      width: 400,
      height: 170,
      html: '<div style="position: absolute; top: 0px; left: 0px; right: 0px; bottom: 45px; overflow: auto">' + '        <div class="w2ui-centered" style="font-size: 13px;">' + msg + '</div>' + '</div>' + '<div style="position: absolute; bottom: 7px; left: 0px; right: 0px; text-align: center; padding: 5px">' + '        <button onclick="w2popup.message();" class="w2ui-popup-btn w2ui-btn">' + w2utils.lang('Ok') + '</button>' + '</div>',
      onClose: function onClose() {
        if (typeof callBack == 'function') callBack();
      }
    });
  } else {
    w2popup.open({
      width: 450,
      height: 220,
      showMax: false,
      showClose: false,
      title: title,
      body: '<div class="w2ui-centered" style="font-size: 13px;">' + msg + '</div>',
      buttons: '<button onclick="w2popup.close();" class="w2ui-popup-btn w2ui-btn">' + w2utils.lang('Ok') + '</button>',
      onClose: function onClose() {
        if (typeof callBack == 'function') callBack();
      }
    });
  }
};
var w2confirm = function w2confirm(msg, title, callBack) {
  var options = {};
  var defaults = {
    msg: '',
    title: w2utils.lang('Confirmation'),
    width: $('#w2ui-popup').length > 0 ? 400 : 450,
    height: $('#w2ui-popup').length > 0 ? 170 : 220,
    yes_text: 'Yes',
    yes_class: '',
    yes_style: '',
    yes_callBack: null,
    no_text: 'No',
    no_class: '',
    no_style: '',
    no_callBack: null,
    callBack: null
  };
  if (arguments.length == 1 && _typeof(msg) == 'object') {
    $.extend(options, defaults, msg);
  } else {
    if (typeof title == 'function') {
      $.extend(options, defaults, {
        msg: msg,
        callBack: title
      });
    } else {
      $.extend(options, defaults, {
        msg: msg,
        title: title,
        callBack: callBack
      });
    }
  }
  if ($('#w2ui-popup').length > 0 && w2popup.status != 'closing') {
    if (options.width > w2popup.get().width) options.width = w2popup.get().width;
    if (options.height > w2popup.get().height - 50) options.height = w2popup.get().height - 50;
    w2popup.message({
      width: options.width,
      height: options.height,
      html: '<div style="position: absolute; top: 0px; left: 0px; right: 0px; bottom: 40px; overflow: auto">' + '        <div class="w2ui-centered" style="font-size: 13px;">' + options.msg + '</div>' + '</div>' + '<div style="position: absolute; bottom: 7px; left: 0px; right: 0px; text-align: center; padding: 5px">' + '        <button id="Yes" class="w2ui-popup-btn w2ui-btn ' + options.yes_class + '" style="' + options.yes_style + '">' + w2utils.lang(options.yes_text) + '</button>' + '        <button id="No" class="w2ui-popup-btn w2ui-btn ' + options.no_class + '" style="' + options.no_style + '">' + w2utils.lang(options.no_text) + '</button>' + '</div>',
      onOpen: function onOpen() {
        $('#w2ui-popup .w2ui-popup-message .w2ui-btn').on('click', function (event) {
          w2popup.message();
          if (typeof options.callBack == 'function') options.callBack(event.target.id);
          if (event.target.id == 'Yes' && typeof options.yes_callBack == 'function') options.yes_callBack();
          if (event.target.id == 'No' && typeof options.no_callBack == 'function') options.no_callBack();
        });
      },
      onKeydown: function onKeydown(event) {
        switch (event.originalEvent.keyCode) {
          case 13:
            // enter
            if (typeof options.callBack == 'function') options.callBack('Yes');
            if (typeof options.yes_callBack == 'function') options.yes_callBack();
            w2popup.message();
            break;
          case 27:
            // esc
            if (typeof options.callBack == 'function') options.callBack('No');
            if (typeof options.no_callBack == 'function') options.no_callBack();
            w2popup.message();
            break;
        }
      }
    });
  } else {
    if (!w2utils.isInt(options.height)) options.height = options.height + 50;
    w2popup.open({
      width: options.width,
      height: options.height,
      title: options.title,
      modal: true,
      showClose: false,
      body: '<div class="w2ui-centered" style="font-size: 13px;">' + options.msg + '</div>',
      buttons: '<button id="Yes" class="w2ui-popup-btn w2ui-btn ' + options.yes_class + '" style="' + options.yes_style + '">' + w2utils.lang(options.yes_text) + '</button>' + '<button id="No" class="w2ui-popup-btn w2ui-btn ' + options.no_class + '" style="' + options.no_style + '">' + w2utils.lang(options.no_text) + '</button>',
      onOpen: function onOpen(event) {
        event.onComplete = function () {
          $('#w2ui-popup .w2ui-popup-btn').on('click', function (event) {
            w2popup.close();
            if (typeof options.callBack == 'function') options.callBack(event.target.id);
            if (event.target.id == 'Yes' && typeof options.yes_callBack == 'function') options.yes_callBack();
            if (event.target.id == 'No' && typeof options.no_callBack == 'function') options.no_callBack();
          });
        };
      },
      onKeydown: function onKeydown(event) {
        switch (event.originalEvent.keyCode) {
          case 13:
            // enter
            if (typeof options.callBack == 'function') options.callBack('Yes');
            if (typeof options.yes_callBack == 'function') options.yes_callBack();
            w2popup.close();
            break;
          case 27:
            // esc
            if (typeof options.callBack == 'function') options.callBack('No');
            if (typeof options.no_callBack == 'function') options.no_callBack();
            w2popup.close();
            break;
        }
      }
    });
  }
  return {
    yes: function yes(fun) {
      options.yes_callBack = fun;
      return this;
    },
    no: function no(fun) {
      options.no_callBack = fun;
      return this;
    }
  };
};
/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2tabs        - tabs widget
*        - $().w2tabs    - jQuery wrapper
*   - Dependencies: jQuery, w2utils
*
* == NICE TO HAVE ==
*   - on overflow display << >>
*
************************************************************************/

(function () {
  var w2tabs = function w2tabs(options) {
    this.box = null; // DOM Element that holds the element
    this.name = null; // unique name for w2ui
    this.active = null;
    this.tabs = [];
    this.routeData = {}; // data for dynamic routes
    this.right = '';
    this.style = '';
    this.onClick = null;
    this.onClose = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onResize = null;
    this.onDestroy = null;
    $.extend(this, {
      handlers: []
    });
    $.extend(true, this, w2obj.tabs, options);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2tabs = function (method) {
    if (_typeof(method) === 'object' || !method) {
      // check name parameter
      if (!w2utils.checkName(method, 'w2tabs')) return;
      // extend tabs
      var tabs = method.tabs || [];
      var object = new w2tabs(method);
      for (var i = 0; i < tabs.length; i++) {
        object.tabs[i] = $.extend({}, w2tabs.prototype.tab, tabs[i]);
      }
      if ($(this).length !== 0) {
        object.render($(this)[0]);
      }
      // register new object
      w2ui[object.name] = object;
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2tabs');
      return undefined;
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2tabs.prototype = {
    tab: {
      id: null,
      // command to be sent to all event handlers
      text: '',
      route: null,
      hidden: false,
      disabled: false,
      closable: false,
      hint: '',
      onClick: null,
      onRefresh: null,
      onClose: null
    },
    add: function add(tab) {
      return this.insert(null, tab);
    },
    insert: function insert(id, tab) {
      if (!$.isArray(tab)) tab = [tab];
      // assume it is array
      for (var i = 0; i < tab.length; i++) {
        // checks
        if (typeof tab[i].id === 'undefined') {
          console.log('ERROR: The parameter "id" is required but not supplied. (obj: ' + this.name + ')');
          return;
        }
        if (!w2utils.checkUniqueId(tab[i].id, this.tabs, 'tabs', this.name)) return;
        // add tab
        var newTab = $.extend({}, w2tabs.prototype.tab, tab[i]);
        if (id === null || typeof id === 'undefined') {
          this.tabs.push(newTab);
        } else {
          var middle = this.get(id, true);
          this.tabs = this.tabs.slice(0, middle).concat([newTab], this.tabs.slice(middle));
        }
        this.refresh(tab[i].id);
      }
    },
    remove: function remove() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        var tab = this.get(arguments[a]);
        if (!tab) return false;
        removed++;
        // remove from array
        this.tabs.splice(this.get(tab.id, true), 1);
        // remove from screen
        $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id)).remove();
      }
      return removed;
    },
    select: function select(id) {
      if (this.active == id || this.get(id) === null) return false;
      this.active = id;
      this.refresh();
      return true;
    },
    set: function set(id, tab) {
      var index = this.get(id, true);
      if (index === null) return false;
      $.extend(this.tabs[index], tab);
      this.refresh(id);
      return true;
    },
    get: function get(id, returnIndex) {
      if (arguments.length === 0) {
        var all = [];
        for (var i1 = 0; i1 < this.tabs.length; i1++) {
          if (this.tabs[i1].id != null) {
            all.push(this.tabs[i1].id);
          }
        }
        return all;
      } else {
        for (var i2 = 0; i2 < this.tabs.length; i2++) {
          if (this.tabs[i2].id == id) {
            // need to be == since id can be numeric
            return returnIndex === true ? i2 : this.tabs[i2];
          }
        }
      }
      return null;
    },
    show: function show() {
      var obj = this;
      var shown = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var tab = this.get(arguments[a]);
        if (!tab || tab.hidden === false) continue;
        shown++;
        tab.hidden = false;
        tmp.push(tab.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return shown;
    },
    hide: function hide() {
      var obj = this;
      var hidden = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var tab = this.get(arguments[a]);
        if (!tab || tab.hidden === true) continue;
        hidden++;
        tab.hidden = true;
        tmp.push(tab.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return hidden;
    },
    enable: function enable() {
      var obj = this;
      var enabled = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var tab = this.get(arguments[a]);
        if (!tab || tab.disabled === false) continue;
        enabled++;
        tab.disabled = false;
        tmp.push(tab.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return enabled;
    },
    disable: function disable() {
      var obj = this;
      var disabled = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var tab = this.get(arguments[a]);
        if (!tab || tab.disabled === true) continue;
        disabled++;
        tab.disabled = true;
        tmp.push(tab.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return disabled;
    },
    refresh: function refresh(id) {
      var time = new Date().getTime();
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'refresh',
        target: typeof id !== 'undefined' ? id : this.name,
        object: this.get(id)
      });
      if (eventData.isCancelled === true) return;
      if (typeof id === 'undefined') {
        // refresh all
        for (var i = 0; i < this.tabs.length; i++) this.refresh(this.tabs[i].id);
      } else {
        // create or refresh only one item
        var tab = this.get(id);
        if (tab === null) return false;
        if (typeof tab.caption !== 'undefined') tab.text = tab.caption;
        var jq_el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id));
        var tabHTML = (tab.closable ? '<div class="w2ui-tab-close" onclick="w2ui[\'' + this.name + '\'].animateClose(\'' + tab.id + '\', event);"></div>' : '') + '    <div class="w2ui-tab' + (this.active === tab.id ? ' active' : '') + (tab.closable ? ' closable' : '') + '" ' + '        title="' + (typeof tab.hint !== 'undefined' ? tab.hint : '') + '"' + '        onclick="w2ui[\'' + this.name + '\'].click(\'' + tab.id + '\', event);">' + tab.text + '</div>';
        if (jq_el.length === 0) {
          // does not exist - create it
          var addStyle = '';
          if (tab.hidden) {
            addStyle += 'display: none;';
          }
          if (tab.disabled) {
            addStyle += 'opacity: 0.2; -moz-opacity: 0.2; -webkit-opacity: 0.2; -o-opacity: 0.2; filter:alpha(opacity=20);';
          }
          var html = '<td id="tabs_' + this.name + '_tab_' + tab.id + '" style="' + addStyle + '" valign="middle">' + tabHTML + '</td>';
          if (this.get(id, true) !== this.tabs.length - 1 && $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true)) + 1].id)).length > 0) {
            $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true)) + 1].id)).before(html);
          } else {
            $(this.box).find('#tabs_' + this.name + '_right').before(html);
          }
        } else {
          // refresh
          jq_el.html(tabHTML);
          if (tab.hidden) {
            jq_el.css('display', 'none');
          } else {
            jq_el.css('display', '');
          }
          if (tab.disabled) {
            jq_el.css({
              'opacity': '0.2',
              '-moz-opacity': '0.2',
              '-webkit-opacity': '0.2',
              '-o-opacity': '0.2',
              'filter': 'alpha(opacity=20)'
            });
          } else {
            jq_el.css({
              'opacity': '1',
              '-moz-opacity': '1',
              '-webkit-opacity': '1',
              '-o-opacity': '1',
              'filter': 'alpha(opacity=100)'
            });
          }
        }
      }
      // right html
      $('#tabs_' + this.name + '_right').html(this.right);
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    render: function render(box) {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'render',
        target: this.name,
        box: box
      });
      if (eventData.isCancelled === true) return;
      // default action
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      if (typeof box !== 'undefined' && box !== null) {
        if ($(this.box).find('> table #tabs_' + this.name + '_right').length > 0) {
          $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-tabs').html('');
        }
        this.box = box;
      }
      if (!this.box) return false;
      // render all buttons
      var html = '<table cellspacing="0" cellpadding="1" width="100%">' + '    <tr><td width="100%" id="tabs_' + this.name + '_right" align="right">' + this.right + '</td></tr>' + '</table>';
      $(this.box).attr('name', this.name).addClass('w2ui-reset w2ui-tabs').html(html);
      if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      this.refresh();
      return new Date().getTime() - time;
    },
    resize: function resize() {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'resize',
        target: this.name
      });
      if (eventData.isCancelled === true) return;

      // intentionaly blank

      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'destroy',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      // clean up
      if ($(this.box).find('> table #tabs_' + this.name + '_right').length > 0) {
        $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-tabs').html('');
      }
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    // ===================================================
    // -- Internal Event Handlers

    click: function click(id, event) {
      var tab = this.get(id);
      if (tab === null || tab.disabled) return false;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'click',
        target: id,
        tab: tab,
        object: tab,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default action
      $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.active) + ' .w2ui-tab').removeClass('active');
      this.active = tab.id;
      // route processing
      if (tab.route) {
        var route = String('/' + tab.route).replace(/\/{2,}/g, '/');
        var info = w2utils.parseRoute(route);
        if (info.keys.length > 0) {
          for (var k = 0; k < info.keys.length; k++) {
            if (this.routeData[info.keys[k].name] == null) continue;
            route = route.replace(new RegExp(':' + info.keys[k].name, 'g'), this.routeData[info.keys[k].name]);
          }
        }
        setTimeout(function () {
          window.location.hash = route;
        }, 1);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      this.refresh(id);
    },
    animateClose: function animateClose(id, event) {
      var tab = this.get(id);
      if (tab === null || tab.disabled) return false;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'close',
        target: id,
        object: this.get(id),
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default action
      var obj = this;
      $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id)).css({
        '-webkit-transition': '.2s',
        '-moz-transition': '2s',
        '-ms-transition': '.2s',
        '-o-transition': '.2s',
        opacity: '0'
      });
      setTimeout(function () {
        var width = $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id)).width();
        $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id)).html('<div style="width: ' + width + 'px; -webkit-transition: .2s; -moz-transition: .2s; -ms-transition: .2s; -o-transition: .2s"></div>');
        setTimeout(function () {
          $(obj.box).find('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id)).find(':first-child').css({
            'width': '0px'
          });
        }, 50);
      }, 200);
      setTimeout(function () {
        obj.remove(id);
      }, 450);
      // event before
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      this.refresh();
    },
    animateInsert: function animateInsert(id, tab) {
      if (this.get(id) === null) return;
      if (!$.isPlainObject(tab)) return;
      // check for unique
      if (!w2utils.checkUniqueId(tab.id, this.tabs, 'tabs', this.name)) return;
      // insert simple div
      var jq_el = $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(tab.id));
      if (jq_el.length !== 0) return; // already exists
      // measure width
      if (typeof tab.caption !== 'undefined') tab.text = tab.caption;
      var tmp = '<div id="_tmp_tabs" class="w2ui-reset w2ui-tabs" style="position: absolute; top: -1000px;">' + '<table cellspacing="0" cellpadding="1" width="100%"><tr>' + '<td id="_tmp_simple_tab" style="" valign="middle">' + (tab.closable ? '<div class="w2ui-tab-close"></div>' : '') + '    <div class="w2ui-tab ' + (this.active === tab.id ? 'active' : '') + '">' + tab.text + '</div>' + '</td></tr></table>' + '</div>';
      $('body').append(tmp);
      // create dummy element
      var tabHTML = '<div style="width: 1px; -webkit-transition: 0.2s; -moz-transition: 0.2s; -ms-transition: 0.2s; -o-transition: 0.2s;">&nbsp;</div>';
      var addStyle = '';
      if (tab.hidden) {
        addStyle += 'display: none;';
      }
      if (tab.disabled) {
        addStyle += 'opacity: 0.2; -moz-opacity: 0.2; -webkit-opacity: 0.2; -o-opacity: 0.2; filter:alpha(opacity=20);';
      }
      var html = '<td id="tabs_' + this.name + '_tab_' + tab.id + '" style="' + addStyle + '" valign="middle">' + tabHTML + '</td>';
      if (this.get(id, true) !== this.tabs.length && $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true))].id)).length > 0) {
        $(this.box).find('#tabs_' + this.name + '_tab_' + w2utils.escapeId(this.tabs[parseInt(this.get(id, true))].id)).before(html);
      } else {
        $(this.box).find('#tabs_' + this.name + '_right').before(html);
      }
      // -- move
      var obj = this;
      setTimeout(function () {
        var width = $('#_tmp_simple_tab').width();
        $('#_tmp_tabs').remove();
        $('#tabs_' + obj.name + '_tab_' + w2utils.escapeId(tab.id) + ' > div').css('width', width + 'px');
      }, 1);
      setTimeout(function () {
        // insert for real
        obj.insert(id, tab);
      }, 200);
    }
  };
  $.extend(w2tabs.prototype, w2utils.event);
  w2obj.tabs = w2tabs;
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2toolbar        - toolbar widget
*        - $().w2toolbar    - jQuery wrapper
*   - Dependencies: jQuery, w2utils
*
* == NICE TO HAVE ==
*   - on overflow display << >>
*   - verticle toolbar
*
************************************************************************/

(function () {
  var w2toolbar = function w2toolbar(options) {
    this.box = null; // DOM Element that holds the element
    this.name = null; // unique name for w2ui
    this.routeData = {}; // data for dynamic routes
    this.items = [];
    this.right = ''; // HTML text on the right of toolbar
    this.onClick = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onResize = null;
    this.onDestroy = null;
    $.extend(true, this, w2obj.toolbar, options);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2toolbar = function (method) {
    if (_typeof(method) === 'object' || !method) {
      // check name parameter
      if (!w2utils.checkName(method, 'w2toolbar')) return;
      // extend items
      var items = method.items || [];
      var object = new w2toolbar(method);
      $.extend(object, {
        items: [],
        handlers: []
      });
      for (var i = 0; i < items.length; i++) {
        object.items[i] = $.extend({}, w2toolbar.prototype.item, items[i]);
      }
      if ($(this).length !== 0) {
        object.render($(this)[0]);
      }
      // register new object
      w2ui[object.name] = object;
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2toolbar');
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2toolbar.prototype = {
    item: {
      id: null,
      // command to be sent to all event handlers
      type: 'button',
      // button, check, radio, drop, menu, break, html, spacer
      text: '',
      route: null,
      // if not null, it is route to go
      html: '',
      img: null,
      icon: null,
      count: null,
      hidden: false,
      disabled: false,
      checked: false,
      // used for radio buttons
      arrow: true,
      // arrow down for drop/menu types
      hint: '',
      group: null,
      // used for radio buttons
      items: null,
      // for type menu it is an array of items in the menu
      overlay: {},
      onClick: null
    },
    add: function add(items) {
      this.insert(null, items);
    },
    insert: function insert(id, items) {
      if (!$.isArray(items)) items = [items];
      for (var o = 0; o < items.length; o++) {
        // checks
        if (typeof items[o].type === 'undefined') {
          console.log('ERROR: The parameter "type" is required but not supplied in w2toolbar.add() method.');
          return;
        }
        if ($.inArray(String(items[o].type), ['button', 'check', 'radio', 'drop', 'menu', 'break', 'html', 'spacer']) === -1) {
          console.log('ERROR: The parameter "type" should be one of the following [button, check, radio, drop, menu, break, html, spacer] ' + 'in w2toolbar.add() method.');
          return;
        }
        if (typeof items[o].id === 'undefined') {
          console.log('ERROR: The parameter "id" is required but not supplied in w2toolbar.add() method.');
          return;
        }
        if (!w2utils.checkUniqueId(items[o].id, this.items, 'toolbar items', this.name)) return;
        // add item
        var it = $.extend({}, w2toolbar.prototype.item, items[o]);
        if (id == null) {
          this.items.push(it);
        } else {
          var middle = this.get(id, true);
          this.items = this.items.slice(0, middle).concat([it], this.items.slice(middle));
        }
        this.refresh(it.id);
      }
    },
    remove: function remove() {
      var removed = 0;
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        removed++;
        // remove from screen
        $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(it.id)).remove();
        // remove from array
        var ind = this.get(it.id, true);
        if (ind) this.items.splice(ind, 1);
      }
      return removed;
    },
    set: function set(id, item) {
      var index = this.get(id, true);
      if (index === null) return false;
      $.extend(this.items[index], item);
      this.refresh(id);
      return true;
    },
    get: function get(id, returnIndex) {
      if (arguments.length === 0) {
        var all = [];
        for (var i1 = 0; i1 < this.items.length; i1++) if (this.items[i1].id !== null) all.push(this.items[i1].id);
        return all;
      }
      for (var i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].id === id) {
          if (returnIndex === true) return i2;else return this.items[i2];
        }
      }
      return null;
    },
    show: function show() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.hidden = false;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    hide: function hide() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.hidden = true;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    enable: function enable() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.disabled = false;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    disable: function disable() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.disabled = true;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    check: function check() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.checked = true;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    uncheck: function uncheck() {
      var obj = this;
      var items = 0;
      var tmp = [];
      for (var a = 0; a < arguments.length; a++) {
        var it = this.get(arguments[a]);
        if (!it) continue;
        items++;
        it.checked = false;
        tmp.push(it.id);
      }
      setTimeout(function () {
        for (var t in tmp) obj.refresh(tmp[t]);
      }, 15); // needs timeout 
      return items;
    },
    render: function render(box) {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'render',
        target: this.name,
        box: box
      });
      if (eventData.isCancelled === true) return;
      if (box != null) {
        if ($(this.box).find('> table #tb_' + this.name + '_right').length > 0) {
          $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-toolbar').html('');
        }
        this.box = box;
      }
      if (!this.box) return;
      // render all buttons
      var html = '<table cellspacing="0" cellpadding="0" width="100%">' + '<tr>';
      for (var i = 0; i < this.items.length; i++) {
        var it = this.items[i];
        if (it.id == null) it.id = "item_" + i;
        if (it === null) continue;
        if (it.type === 'spacer') {
          html += '<td width="100%" id="tb_' + this.name + '_item_' + it.id + '" align="right"></td>';
        } else {
          html += '<td id="tb_' + this.name + '_item_' + it.id + '" style="' + (it.hidden ? 'display: none' : '') + '" ' + '    class="' + (it.disabled ? 'disabled' : '') + '" valign="middle">' + this.getItemHTML(it) + '</td>';
        }
      }
      html += '<td width="100%" id="tb_' + this.name + '_right" align="right">' + this.right + '</td>';
      html += '</tr>' + '</table>';
      $(this.box).attr('name', this.name).addClass('w2ui-reset w2ui-toolbar').html(html);
      if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    refresh: function refresh(id) {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'refresh',
        target: typeof id !== 'undefined' ? id : this.name,
        item: this.get(id)
      });
      if (eventData.isCancelled === true) return;
      if (id == null) {
        // refresh all
        for (var i = 0; i < this.items.length; i++) {
          var it1 = this.items[i];
          if (it1.id == null) it1.id = "item_" + i;
          this.refresh(it1.id);
        }
      }
      // create or refresh only one item
      var it = this.get(id);
      if (it === null) return false;
      var el = $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(it.id));
      var html = this.getItemHTML(it);
      if (el.length === 0) {
        // does not exist - create it
        if (it.type === 'spacer') {
          html = '<td width="100%" id="tb_' + this.name + '_item_' + it.id + '" align="right"></td>';
        } else {
          html = '<td id="tb_' + this.name + '_item_' + it.id + '" style="' + (it.hidden ? 'display: none' : '') + '" ' + '    class="' + (it.disabled ? 'disabled' : '') + '" valign="middle">' + html + '</td>';
        }
        if (this.get(id, true) === this.items.length - 1) {
          $(this.box).find('#tb_' + this.name + '_right').before(html);
        } else {
          $(this.box).find('#tb_' + this.name + '_item_' + w2utils.escapeId(this.items[parseInt(this.get(id, true)) + 1].id)).before(html);
        }
      } else {
        // refresh
        el.html(html);
        if (it.hidden) {
          el.css('display', 'none');
        } else {
          el.css('display', '');
        }
        if (it.disabled) {
          el.addClass('disabled');
        } else {
          el.removeClass('disabled');
        }
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    resize: function resize() {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'resize',
        target: this.name
      });
      if (eventData.isCancelled === true) return;

      // intentionaly blank

      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'destroy',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      // clean up
      if ($(this.box).find('> table #tb_' + this.name + '_right').length > 0) {
        $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-toolbar').html('');
      }
      $(this.box).html('');
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    // ========================================
    // --- Internal Functions

    getItemHTML: function getItemHTML(item) {
      var html = '';
      if (typeof item.caption !== 'undefined') item.text = item.caption;
      if (typeof item.hint === 'undefined') item.hint = '';
      if (typeof item.text === 'undefined') item.text = '';
      switch (item.type) {
        case 'menu':
        case 'button':
        case 'check':
        case 'radio':
        case 'drop':
          var img = '<td>&nbsp;</td>';
          if (item.img) img = '<td><div class="w2ui-tb-image w2ui-icon ' + item.img + '"></div></td>';
          if (item.icon) img = '<td><div class="w2ui-tb-image"><span class="' + item.icon + '"></span></div></td>';
          html += '<table cellpadding="0" cellspacing="0" title="' + item.hint + '" class="w2ui-button ' + (item.checked ? 'checked' : '') + '" ' + '       onclick     = "var el=w2ui[\'' + this.name + '\']; if (el) el.click(\'' + item.id + '\', event);" ' + '       onmouseover = "' + (!item.disabled ? "$(this).addClass('over');" : "") + '"' + '       onmouseout  = "' + (!item.disabled ? "$(this).removeClass('over').removeClass('down');" : "") + '"' + '       onmousedown = "' + (!item.disabled ? "$(this).addClass('down');" : "") + '"' + '       onmouseup   = "' + (!item.disabled ? "$(this).removeClass('down');" : "") + '"' + '>' + '<tr><td>' + '  <table cellpadding="1" cellspacing="0">' + '  <tr>' + img + (item.text !== '' ? '<td class="w2ui-tb-caption" nowrap>' + item.text + '</td>' : '') + (item.count != null ? '<td class="w2ui-tb-count" nowrap><span>' + item.count + '</span></td>' : '') + ((item.type === 'drop' || item.type === 'menu') && item.arrow !== false ? '<td class="w2ui-tb-down" nowrap><div></div></td>' : '') + '  </tr></table>' + '</td></tr></table>';
          break;
        case 'break':
          html += '<table cellpadding="0" cellspacing="0"><tr>' + '    <td><div class="w2ui-break">&nbsp;</div></td>' + '</tr></table>';
          break;
        case 'html':
          html += '<table cellpadding="0" cellspacing="0"><tr>' + '    <td nowrap>' + item.html + '</td>' + '</tr></table>';
          break;
      }
      var newHTML = '';
      if (typeof item.onRender === 'function') newHTML = item.onRender.call(this, item.id, html);
      if (typeof this.onRender === 'function') newHTML = this.onRender(item.id, html);
      if (newHTML !== '' && newHTML != null) html = newHTML;
      return html;
    },
    menuClick: function menuClick(event) {
      var obj = this;
      if (event.item && !event.item.disabled) {
        // event before
        var eventData = this.trigger({
          phase: 'before',
          type: 'click',
          target: event.item.id + ':' + event.subItem.id,
          item: event.item,
          subItem: event.subItem,
          originalEvent: event.originalEvent
        });
        if (eventData.isCancelled === true) return;

        // route processing
        var it = event.subItem;
        if (it.route) {
          var route = String('/' + it.route).replace(/\/{2,}/g, '/');
          var info = w2utils.parseRoute(route);
          if (info.keys.length > 0) {
            for (var k = 0; k < info.keys.length; k++) {
              if (obj.routeData[info.keys[k].name] == null) continue;
              route = route.replace(new RegExp(':' + info.keys[k].name, 'g'), this.routeData[info.keys[k].name]);
            }
          }
          setTimeout(function () {
            window.location.hash = route;
          }, 1);
        }

        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
    },
    click: function click(id, event) {
      var obj = this;
      var it = this.get(id);
      if (it && !it.disabled) {
        // event before
        var eventData = this.trigger({
          phase: 'before',
          type: 'click',
          target: typeof id !== 'undefined' ? id : this.name,
          item: it,
          object: it,
          originalEvent: event
        });
        if (eventData.isCancelled === true) return;
        var btn = $('#tb_' + this.name + '_item_' + w2utils.escapeId(it.id) + ' table.w2ui-button');
        btn.removeClass('down');
        if (it.type === 'radio') {
          for (var i = 0; i < this.items.length; i++) {
            var itt = this.items[i];
            if (itt == null || itt.id === it.id || itt.type !== 'radio') continue;
            if (itt.group === it.group && itt.checked) {
              itt.checked = false;
              this.refresh(itt.id);
            }
          }
          it.checked = true;
          btn.addClass('checked');
        }
        if (it.type === 'drop' || it.type === 'menu') {
          if (it.checked) {
            // if it was already checked, second click will hide it
            it.checked = false;
          } else {
            // show overlay
            setTimeout(function () {
              var el = $('#tb_' + obj.name + '_item_' + w2utils.escapeId(it.id));
              if (!$.isPlainObject(it.overlay)) it.overlay = {};
              var left = (el.width() - 50) / 2;
              if (left > 19) left = 19;
              if (it.type === 'drop') {
                el.w2overlay(it.html, $.extend({
                  left: left,
                  top: 3
                }, it.overlay));
              }
              if (it.type === 'menu') {
                el.w2menu(it.items, $.extend({
                  left: left,
                  top: 3
                }, it.overlay, {
                  select: function select(event) {
                    obj.menuClick({
                      item: it,
                      subItem: event.item,
                      originalEvent: event.originalEvent
                    });
                    hideDrop();
                  }
                }));
              }
              // window.click to hide it
              $(document).on('click', hideDrop);
              function hideDrop() {
                $(document).off('click', hideDrop);
                it.checked = false;
                btn.removeClass('checked');
              }
            }, 1);
          }
        }
        if (it.type === 'check' || it.type === 'drop' || it.type === 'menu') {
          it.checked = !it.checked;
          if (it.checked) {
            btn.addClass('checked');
          } else {
            btn.removeClass('checked');
          }
        }
        // route processing
        if (it.route) {
          var route = String('/' + it.route).replace(/\/{2,}/g, '/');
          var info = w2utils.parseRoute(route);
          if (info.keys.length > 0) {
            for (var k = 0; k < info.keys.length; k++) {
              route = route.replace(new RegExp(':' + info.keys[k].name, 'g'), this.routeData[info.keys[k].name]);
            }
          }
          setTimeout(function () {
            window.location.hash = route;
          }, 1);
        }
        // event after
        this.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }
    }
  };
  $.extend(w2toolbar.prototype, w2utils.event);
  w2obj.toolbar = w2toolbar;
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2sidebar        - sidebar widget
*        - $().w2sidebar    - jQuery wrapper
*   - Dependencies: jQuery, w2utils
*
* == NICE TO HAVE ==
*   - return ids of all subitems
*   - add find() method to find nodes by a specific criteria (I want all nodes for exampe)
*   - dbl click should be like it is in grid (with timer not HTML dbl click event)
*   - reorder with grag and drop
*   - add route property that would navigate to a #route
*   - node.style is missleading - should be there to apply color for example
*
************************************************************************/

(function () {
  var w2sidebar = function w2sidebar(options) {
    this.name = null;
    this.box = null;
    this.sidebar = null;
    this.parent = null;
    this.nodes = []; // Sidebar child nodes
    this.menu = [];
    this.routeData = {}; // data for dynamic routes
    this.selected = null; // current selected node (readonly)
    this.img = null;
    this.icon = null;
    this.style = '';
    this.topHTML = '';
    this.bottomHTML = '';
    this.keyboard = true;
    this.onClick = null; // Fire when user click on Node Text
    this.onDblClick = null; // Fire when user dbl clicks
    this.onContextMenu = null;
    this.onMenuClick = null; // when context menu item selected
    this.onExpand = null; // Fire when node Expands
    this.onCollapse = null; // Fire when node Colapses
    this.onKeydown = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onResize = null;
    this.onDestroy = null;
    $.extend(true, this, w2obj.sidebar, options);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2sidebar = function (method) {
    if (_typeof(method) === 'object' || !method) {
      // check name parameter
      if (!w2utils.checkName(method, 'w2sidebar')) return;
      // extend items
      var nodes = method.nodes;
      var object = new w2sidebar(method);
      $.extend(object, {
        handlers: [],
        nodes: []
      });
      if (typeof nodes != 'undefined') {
        object.add(object, nodes);
      }
      if ($(this).length !== 0) {
        object.render($(this)[0]);
      }
      object.sidebar = object;
      // register new object
      w2ui[object.name] = object;
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2sidebar');
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2sidebar.prototype = {
    node: {
      id: null,
      text: '',
      count: null,
      img: null,
      icon: null,
      nodes: [],
      style: '',
      // additional style for subitems
      route: null,
      selected: false,
      expanded: false,
      hidden: false,
      disabled: false,
      group: false,
      // if true, it will build as a group
      groupShowHide: true,
      plus: false,
      // if true, plus will be shown even if there is no sub nodes
      // events
      onClick: null,
      onDblClick: null,
      onContextMenu: null,
      onExpand: null,
      onCollapse: null,
      // internal
      parent: null,
      // node object
      sidebar: null
    },
    add: function add(parent, nodes) {
      if (arguments.length == 1) {
        // need to be in reverse order
        nodes = arguments[0];
        parent = this;
      }
      if (typeof parent == 'string') parent = this.get(parent);
      return this.insert(parent, null, nodes);
    },
    insert: function insert(parent, before, nodes) {
      var txt, ind, tmp, node, nd;
      if (arguments.length == 2) {
        // need to be in reverse order
        nodes = arguments[1];
        before = arguments[0];
        ind = this.get(before);
        if (ind === null) {
          if (!$.isArray(nodes)) nodes = [nodes];
          txt = nodes[0].caption != null ? nodes[0].caption : nodes[0].text;
          console.log('ERROR: Cannot insert node "' + txt + '" because cannot find node "' + before + '" to insert before.');
          return null;
        }
        parent = this.get(before).parent;
      }
      if (typeof parent == 'string') parent = this.get(parent);
      if (!$.isArray(nodes)) nodes = [nodes];
      for (var o in nodes) {
        node = nodes[o];
        if (_typeof(node.id) == null) {
          txt = node.caption != null ? node.caption : node.text;
          console.log('ERROR: Cannot insert node "' + txt + '" because it has no id.');
          continue;
        }
        if (this.get(this, node.id) !== null) {
          txt = node.caption != null ? node.caption : node.text;
          console.log('ERROR: Cannot insert node with id=' + node.id + ' (text: ' + txt + ') because another node with the same id already exists.');
          continue;
        }
        tmp = $.extend({}, w2sidebar.prototype.node, node);
        tmp.sidebar = this;
        tmp.parent = parent;
        nd = tmp.nodes || [];
        tmp.nodes = []; // very important to re-init empty nodes array
        if (before === null) {
          // append to the end
          parent.nodes.push(tmp);
        } else {
          ind = this.get(parent, before, true);
          if (ind === null) {
            txt = node.caption != null ? node.caption : node.text;
            console.log('ERROR: Cannot insert node "' + txt + '" because cannot find node "' + before + '" to insert before.');
            return null;
          }
          parent.nodes.splice(ind, 0, tmp);
        }
        if (nd.length > 0) {
          this.insert(tmp, null, nd);
        }
      }
      this.refresh(parent.id);
      return tmp;
    },
    remove: function remove() {
      // multiple arguments
      var deleted = 0;
      var tmp;
      for (var a = 0; a < arguments.length; a++) {
        tmp = this.get(arguments[a]);
        if (tmp === null) continue;
        if (this.selected !== null && this.selected === tmp.id) {
          this.selected = null;
        }
        var ind = this.get(tmp.parent, arguments[a], true);
        if (ind === null) continue;
        if (tmp.parent.nodes[ind].selected) tmp.sidebar.unselect(tmp.id);
        tmp.parent.nodes.splice(ind, 1);
        deleted++;
      }
      if (deleted > 0 && arguments.length == 1) this.refresh(tmp.parent.id);else this.refresh();
      return deleted;
    },
    set: function set(parent, id, node) {
      if (arguments.length == 2) {
        // need to be in reverse order
        node = id;
        id = parent;
        parent = this;
      }
      // searches all nested nodes
      if (typeof parent == 'string') parent = this.get(parent);
      if (parent.nodes == null) return null;
      for (var i = 0; i < parent.nodes.length; i++) {
        if (parent.nodes[i].id === id) {
          // make sure nodes inserted correctly
          var nodes = node.nodes;
          $.extend(parent.nodes[i], node, {
            nodes: []
          });
          if (nodes != null) {
            this.add(parent.nodes[i], nodes);
          }
          this.refresh(id);
          return true;
        } else {
          var rv = this.set(parent.nodes[i], id, node);
          if (rv) return true;
        }
      }
      return false;
    },
    get: function get(parent, id, returnIndex) {
      // can be just called get(id) or get(id, true)
      if (arguments.length === 0) {
        var all = [];
        var tmp = this.find({});
        for (var t = 0; t < tmp.length; t++) {
          if (tmp[t].id != null) all.push(tmp[t].id);
        }
        return all;
      } else {
        if (arguments.length == 1 || arguments.length == 2 && id === true) {
          // need to be in reverse order
          returnIndex = id;
          id = parent;
          parent = this;
        }
        // searches all nested nodes
        if (typeof parent == 'string') parent = this.get(parent);
        if (parent.nodes == null) return null;
        for (var i = 0; i < parent.nodes.length; i++) {
          if (parent.nodes[i].id == id) {
            if (returnIndex === true) return i;else return parent.nodes[i];
          } else {
            var rv = this.get(parent.nodes[i], id, returnIndex);
            if (rv || rv === 0) return rv;
          }
        }
        return null;
      }
    },
    find: function find(parent, params, results) {
      // can be just called find({ selected: true })
      if (arguments.length == 1) {
        // need to be in reverse order
        params = parent;
        parent = this;
      }
      if (!results) results = [];
      // searches all nested nodes
      if (typeof parent == 'string') parent = this.get(parent);
      if (parent.nodes == null) return results;
      for (var i = 0; i < parent.nodes.length; i++) {
        var match = true;
        for (var prop in params) {
          if (parent.nodes[i][prop] != params[prop]) match = false;
        }
        if (match) results.push(parent.nodes[i]);
        if (parent.nodes[i].nodes.length > 0) results = this.find(parent.nodes[i], params, results);
      }
      return results;
    },
    hide: function hide() {
      // multiple arguments
      var hidden = 0;
      for (var a = 0; a < arguments.length; a++) {
        var tmp = this.get(arguments[a]);
        if (tmp === null) continue;
        tmp.hidden = true;
        hidden++;
      }
      if (arguments.length == 1) this.refresh(arguments[0]);else this.refresh();
      return hidden;
    },
    show: function show() {
      // multiple arguments
      var shown = 0;
      for (var a = 0; a < arguments.length; a++) {
        var tmp = this.get(arguments[a]);
        if (tmp === null) continue;
        tmp.hidden = false;
        shown++;
      }
      if (arguments.length == 1) this.refresh(arguments[0]);else this.refresh();
      return shown;
    },
    disable: function disable() {
      // multiple arguments
      var disabled = 0;
      for (var a = 0; a < arguments.length; a++) {
        var tmp = this.get(arguments[a]);
        if (tmp === null) continue;
        tmp.disabled = true;
        if (tmp.selected) this.unselect(tmp.id);
        disabled++;
      }
      if (arguments.length == 1) this.refresh(arguments[0]);else this.refresh();
      return disabled;
    },
    enable: function enable() {
      // multiple arguments
      var enabled = 0;
      for (var a = 0; a < arguments.length; a++) {
        var tmp = this.get(arguments[a]);
        if (tmp === null) continue;
        tmp.disabled = false;
        enabled++;
      }
      if (arguments.length == 1) this.refresh(arguments[0]);else this.refresh();
      return enabled;
    },
    select: function select(id) {
      var new_node = this.get(id);
      if (!new_node) return false;
      if (this.selected == id && new_node.selected) return false;
      this.unselect(this.selected);
      $(this.box).find('#node_' + w2utils.escapeId(id)).addClass('w2ui-selected').find('.w2ui-icon').addClass('w2ui-icon-selected');
      new_node.selected = true;
      this.selected = id;
      return true;
    },
    unselect: function unselect(id) {
      var current = this.get(id);
      if (!current) return false;
      current.selected = false;
      $(this.box).find('#node_' + w2utils.escapeId(id)).removeClass('w2ui-selected').find('.w2ui-icon').removeClass('w2ui-icon-selected');
      if (this.selected == id) this.selected = null;
      return true;
    },
    toggle: function toggle(id) {
      var nd = this.get(id);
      if (nd === null) return false;
      if (nd.plus) {
        this.set(id, {
          plus: false
        });
        this.expand(id);
        this.refresh(id);
        return;
      }
      if (nd.nodes.length === 0) return false;
      if (this.get(id).expanded) return this.collapse(id);else return this.expand(id);
    },
    collapse: function collapse(id) {
      var obj = this;
      var nd = this.get(id);
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'collapse',
        target: id,
        object: nd
      });
      if (eventData.isCancelled === true) return;
      // default action
      $(this.box).find('#node_' + w2utils.escapeId(id) + '_sub').slideUp(200);
      $(this.box).find('#node_' + w2utils.escapeId(id) + ' .w2ui-node-dots:first-child').html('<div class="w2ui-expand">+</div>');
      nd.expanded = false;
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      setTimeout(function () {
        obj.refresh(id);
      }, 200);
      return true;
    },
    collapseAll: function collapseAll(parent) {
      if (typeof parent == 'undefined') parent = this;
      if (typeof parent == 'string') parent = this.get(parent);
      if (parent.nodes == null) return false;
      for (var i = 0; i < parent.nodes.length; i++) {
        if (parent.nodes[i].expanded === true) parent.nodes[i].expanded = false;
        if (parent.nodes[i].nodes && parent.nodes[i].nodes.length > 0) this.collapseAll(parent.nodes[i]);
      }
      this.refresh(parent.id);
      return true;
    },
    expand: function expand(id) {
      var obj = this;
      var nd = this.get(id);
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'expand',
        target: id,
        object: nd
      });
      if (eventData.isCancelled === true) return;
      // default action
      $(this.box).find('#node_' + w2utils.escapeId(id) + '_sub').slideDown(200);
      $(this.box).find('#node_' + w2utils.escapeId(id) + ' .w2ui-node-dots:first-child').html('<div class="w2ui-expand">-</div>');
      nd.expanded = true;
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      setTimeout(function () {
        obj.refresh(id);
      }, 200);
      return true;
    },
    expandAll: function expandAll(parent) {
      if (typeof parent == 'undefined') parent = this;
      if (typeof parent == 'string') parent = this.get(parent);
      if (parent.nodes == null) return false;
      for (var i = 0; i < parent.nodes.length; i++) {
        if (parent.nodes[i].expanded === false) parent.nodes[i].expanded = true;
        if (parent.nodes[i].nodes && parent.nodes[i].nodes.length > 0) this.expandAll(parent.nodes[i]);
      }
      this.refresh(parent.id);
    },
    expandParents: function expandParents(id) {
      var node = this.get(id);
      if (node === null) return false;
      if (node.parent) {
        node.parent.expanded = true;
        this.expandParents(node.parent.id);
      }
      this.refresh(id);
      return true;
    },
    click: function click(id, event) {
      var obj = this;
      var nd = this.get(id);
      if (nd === null) return;
      if (nd.disabled || nd.group) return; // should click event if already selected
      // unselect all previsously
      $(obj.box).find('.w2ui-node.w2ui-selected').each(function (index, el) {
        var oldID = $(el).attr('id').replace('node_', '');
        var oldNode = obj.get(oldID);
        if (oldNode != null) oldNode.selected = false;
        $(el).removeClass('w2ui-selected').find('.w2ui-icon').removeClass('w2ui-icon-selected');
      });
      // select new one
      var newNode = $(obj.box).find('#node_' + w2utils.escapeId(id));
      var oldNode = $(obj.box).find('#node_' + w2utils.escapeId(obj.selected));
      newNode.addClass('w2ui-selected').find('.w2ui-icon').addClass('w2ui-icon-selected');
      // need timeout to allow rendering
      setTimeout(function () {
        // event before
        var eventData = obj.trigger({
          phase: 'before',
          type: 'click',
          target: id,
          originalEvent: event,
          node: nd,
          object: nd
        });
        if (eventData.isCancelled === true) {
          // restore selection
          newNode.removeClass('w2ui-selected').find('.w2ui-icon').removeClass('w2ui-icon-selected');
          oldNode.addClass('w2ui-selected').find('.w2ui-icon').addClass('w2ui-icon-selected');
          return;
        }
        // default action
        if (oldNode !== null) oldNode.selected = false;
        obj.get(id).selected = true;
        obj.selected = id;
        // route processing
        if (nd.route) {
          var route = String('/' + nd.route).replace(/\/{2,}/g, '/');
          var info = w2utils.parseRoute(route);
          if (info.keys.length > 0) {
            for (var k = 0; k < info.keys.length; k++) {
              if (obj.routeData[info.keys[k].name] == null) continue;
              route = route.replace(new RegExp(':' + info.keys[k].name, 'g'), obj.routeData[info.keys[k].name]);
            }
          }
          setTimeout(function () {
            window.location.hash = route;
          }, 1);
        }
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, 1);
    },
    keydown: function keydown(event) {
      var obj = this;
      var nd = obj.get(obj.selected);
      if (!nd || obj.keyboard !== true) return;
      // trigger event
      var eventData = obj.trigger({
        phase: 'before',
        type: 'keydown',
        target: obj.name,
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default behaviour
      if (event.keyCode == 13 || event.keyCode == 32) {
        // enter or space
        if (nd.nodes.length > 0) obj.toggle(obj.selected);
      }
      if (event.keyCode == 37) {
        // left
        if (nd.nodes.length > 0 && nd.expanded) {
          obj.collapse(obj.selected);
        } else {
          selectNode(nd.parent);
          if (!nd.parent.group) obj.collapse(nd.parent.id);
        }
      }
      if (event.keyCode == 39) {
        // right
        if ((nd.nodes.length > 0 || nd.plus) && !nd.expanded) obj.expand(obj.selected);
      }
      if (event.keyCode == 38) {
        // up
        selectNode(neighbor(nd, prev));
      }
      if (event.keyCode == 40) {
        // down
        selectNode(neighbor(nd, next));
      }
      // cancel event if needed
      if ($.inArray(event.keyCode, [13, 32, 37, 38, 39, 40]) != -1) {
        if (event.preventDefault) event.preventDefault();
        if (event.stopPropagation) event.stopPropagation();
      }
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
      function selectNode(node, event) {
        if (node !== null && !node.hidden && !node.disabled && !node.group) {
          obj.click(node.id, event);
          setTimeout(function () {
            obj.scrollIntoView();
          }, 50);
        }
      }
      function neighbor(node, neighborFunc) {
        node = neighborFunc(node);
        while (node !== null && (node.hidden || node.disabled)) {
          if (node.group) break;else node = neighborFunc(node);
        }
        return node;
      }
      function next(node, noSubs) {
        if (node === null) return null;
        var parent = node.parent;
        var ind = obj.get(node.id, true);
        var nextNode = null;
        // jump inside
        if (node.expanded && node.nodes.length > 0 && noSubs !== true) {
          var t = node.nodes[0];
          if (t.hidden || t.disabled || t.group) nextNode = next(t);else nextNode = t;
        } else {
          if (parent && ind + 1 < parent.nodes.length) {
            nextNode = parent.nodes[ind + 1];
          } else {
            nextNode = next(parent, true); // jump to the parent
          }
        }
        if (nextNode !== null && (nextNode.hidden || nextNode.disabled || nextNode.group)) nextNode = next(nextNode);
        return nextNode;
      }
      function prev(node) {
        if (node === null) return null;
        var parent = node.parent;
        var ind = obj.get(node.id, true);
        var prevNode = ind > 0 ? lastChild(parent.nodes[ind - 1]) : parent;
        if (prevNode !== null && (prevNode.hidden || prevNode.disabled || prevNode.group)) prevNode = prev(prevNode);
        return prevNode;
      }
      function lastChild(node) {
        if (node.expanded && node.nodes.length > 0) {
          var t = node.nodes[node.nodes.length - 1];
          if (t.hidden || t.disabled || t.group) return prev(t);else return lastChild(t);
        }
        return node;
      }
    },
    scrollIntoView: function scrollIntoView(id) {
      if (typeof id == 'undefined') id = this.selected;
      var nd = this.get(id);
      if (nd === null) return;
      var body = $(this.box).find('.w2ui-sidebar-div');
      var item = $(this.box).find('#node_' + w2utils.escapeId(id));
      var offset = item.offset().top - body.offset().top;
      if (offset + item.height() > body.height()) {
        body.animate({
          'scrollTop': body.scrollTop() + body.height() / 1.3
        }, 250, 'linear');
      }
      if (offset <= 0) {
        body.animate({
          'scrollTop': body.scrollTop() - body.height() / 1.3
        }, 250, 'linear');
      }
    },
    dblClick: function dblClick(id, event) {
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      var nd = this.get(id);
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'dblClick',
        target: id,
        originalEvent: event,
        object: nd
      });
      if (eventData.isCancelled === true) return;
      // default action
      this.toggle(id);
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    contextMenu: function contextMenu(id, event) {
      var obj = this;
      var nd = obj.get(id);
      if (id != obj.selected) obj.click(id);
      // need timeout to allow click to finish first
      setTimeout(function () {
        // event before
        var eventData = obj.trigger({
          phase: 'before',
          type: 'contextMenu',
          target: id,
          originalEvent: event,
          object: nd
        });
        if (eventData.isCancelled === true) return;
        // default action
        if (nd.group || nd.disabled) return;
        if (obj.menu.length > 0) {
          $(obj.box).find('#node_' + w2utils.escapeId(id)).w2menu(obj.menu, {
            left: (event ? event.offsetX || event.pageX : 50) - 25,
            onSelect: function onSelect(event) {
              obj.menuClick(id, parseInt(event.index), event.originalEvent);
            }
          });
        }
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, 150); // need timer 150 for FF
    },
    menuClick: function menuClick(itemId, index, event) {
      var obj = this;
      // event before
      var eventData = obj.trigger({
        phase: 'before',
        type: 'menuClick',
        target: itemId,
        originalEvent: event,
        menuIndex: index,
        menuItem: obj.menu[index]
      });
      if (eventData.isCancelled === true) return;
      // default action
      // -- empty
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    render: function render(box) {
      var time = new Date().getTime();
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'render',
        target: this.name,
        box: box
      });
      if (eventData.isCancelled === true) return;
      // default action
      if (typeof box != 'undefined' && box !== null) {
        if ($(this.box).find('> div > div.w2ui-sidebar-div').length > 0) {
          $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-sidebar').html('');
        }
        this.box = box;
      }
      if (!this.box) return;
      $(this.box).attr('name', this.name).addClass('w2ui-reset w2ui-sidebar').html('<div>' + '<div class="w2ui-sidebar-top"></div>' + '<div class="w2ui-sidebar-div"></div>' + '<div class="w2ui-sidebar-bottom"></div>' + '</div>');
      $(this.box).find('> div').css({
        width: $(this.box).width() + 'px',
        height: $(this.box).height() + 'px'
      });
      if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;
      // adjust top and bottom
      if (this.topHTML !== '') {
        $(this.box).find('.w2ui-sidebar-top').html(this.topHTML);
        $(this.box).find('.w2ui-sidebar-div').css('top', $(this.box).find('.w2ui-sidebar-top').height() + 'px');
      }
      if (this.bottomHTML !== '') {
        $(this.box).find('.w2ui-sidebar-bottom').html(this.bottomHTML);
        $(this.box).find('.w2ui-sidebar-div').css('bottom', $(this.box).find('.w2ui-sidebar-bottom').height() + 'px');
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      // ---
      this.refresh();
      return new Date().getTime() - time;
    },
    refresh: function refresh(id) {
      var time = new Date().getTime();
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'refresh',
        target: typeof id != 'undefined' ? id : this.name
      });
      if (eventData.isCancelled === true) return;
      // adjust top and bottom
      if (this.topHTML !== '') {
        $(this.box).find('.w2ui-sidebar-top').html(this.topHTML);
        $(this.box).find('.w2ui-sidebar-div').css('top', $(this.box).find('.w2ui-sidebar-top').height() + 'px');
      }
      if (this.bottomHTML !== '') {
        $(this.box).find('.w2ui-sidebar-bottom').html(this.bottomHTML);
        $(this.box).find('.w2ui-sidebar-div').css('bottom', $(this.box).find('.w2ui-sidebar-bottom').height() + 'px');
      }
      // default action
      $(this.box).find('> div').css({
        width: $(this.box).width() + 'px',
        height: $(this.box).height() + 'px'
      });
      var obj = this;
      var node, nd;
      var nm;
      if (typeof id == 'undefined') {
        node = this;
        nm = '.w2ui-sidebar-div';
      } else {
        node = this.get(id);
        if (node === null) return;
        nm = '#node_' + w2utils.escapeId(node.id) + '_sub';
      }
      var nodeHTML;
      if (node !== this) {
        var tmp = '#node_' + w2utils.escapeId(node.id);
        nodeHTML = getNodeHTML(node);
        $(this.box).find(tmp).before('<div id="sidebar_' + this.name + '_tmp"></div>');
        $(this.box).find(tmp).remove();
        $(this.box).find(nm).remove();
        $('#sidebar_' + this.name + '_tmp').before(nodeHTML);
        $('#sidebar_' + this.name + '_tmp').remove();
      }
      // refresh sub nodes
      $(this.box).find(nm).html('');
      for (var i = 0; i < node.nodes.length; i++) {
        nd = node.nodes[i];
        nodeHTML = getNodeHTML(nd);
        $(this.box).find(nm).append(nodeHTML);
        if (nd.nodes.length !== 0) {
          this.refresh(nd.id);
        }
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
      function getNodeHTML(nd) {
        var html = '';
        var img = nd.img;
        if (img === null) img = this.img;
        var icon = nd.icon;
        if (icon === null) icon = this.icon;
        // -- find out level
        var tmp = nd.parent;
        var level = 0;
        while (tmp && tmp.parent !== null) {
          if (tmp.group) level--;
          tmp = tmp.parent;
          level++;
        }
        if (typeof nd.caption != 'undefined') nd.text = nd.caption;
        if (nd.group) {
          html = '<div class="w2ui-node-group"  id="node_' + nd.id + '"' + '        onclick="w2ui[\'' + obj.name + '\'].toggle(\'' + nd.id + '\')"' + '        onmouseout="$(this).find(\'span:nth-child(1)\').css(\'color\', \'transparent\')" ' + '        onmouseover="$(this).find(\'span:nth-child(1)\').css(\'color\', \'inherit\')">' + (nd.groupShowHide ? '<span>' + (!nd.hidden && nd.expanded ? w2utils.lang('Hide') : w2utils.lang('Show')) + '</span>' : '<span></span>') + '    <span>' + nd.text + '</span>' + '</div>' + '<div class="w2ui-node-sub" id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden && nd.expanded ? '' : 'display: none;') + '"></div>';
        } else {
          if (nd.selected && !nd.disabled) obj.selected = nd.id;
          tmp = '';
          if (img) tmp = '<div class="w2ui-node-image w2ui-icon ' + img + (nd.selected && !nd.disabled ? " w2ui-icon-selected" : "") + '"></div>';
          if (icon) tmp = '<div class="w2ui-node-image"><span class="' + icon + '"></span></div>';
          html = '<div class="w2ui-node ' + (nd.selected ? 'w2ui-selected' : '') + ' ' + (nd.disabled ? 'w2ui-disabled' : '') + '" id="node_' + nd.id + '" style="' + (nd.hidden ? 'display: none;' : '') + '"' + '    ondblclick="w2ui[\'' + obj.name + '\'].dblClick(\'' + nd.id + '\', event);"' + '    oncontextmenu="w2ui[\'' + obj.name + '\'].contextMenu(\'' + nd.id + '\', event); ' + '        if (event.preventDefault) event.preventDefault();"' + '    onClick="w2ui[\'' + obj.name + '\'].click(\'' + nd.id + '\', event); ">' + '<table cellpadding="0" cellspacing="0" style="margin-left:' + level * 18 + 'px; padding-right:' + level * 18 + 'px"><tr>' + '<td class="w2ui-node-dots" nowrap onclick="w2ui[\'' + obj.name + '\'].toggle(\'' + nd.id + '\'); ' + '        if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;">' + '    <div class="w2ui-expand">' + (nd.nodes.length > 0 ? nd.expanded ? '-' : '+' : nd.plus ? '+' : '') + '</div>' + '</td>' + '<td class="w2ui-node-data" nowrap>' + tmp + (nd.count || nd.count === 0 ? '<div class="w2ui-node-count">' + nd.count + '</div>' : '') + '<div class="w2ui-node-caption">' + nd.text + '</div>' + '</td>' + '</tr></table>' + '</div>' + '<div class="w2ui-node-sub" id="node_' + nd.id + '_sub" style="' + nd.style + ';' + (!nd.hidden && nd.expanded ? '' : 'display: none;') + '"></div>';
        }
        return html;
      }
    },
    resize: function resize() {
      var time = new Date().getTime();
      // if (window.getSelection) window.getSelection().removeAllRanges(); // clear selection
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'resize',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      // default action
      $(this.box).css('overflow', 'hidden'); // container should have no overflow
      //$(this.box).find('.w2ui-sidebar-div').css('overflow', 'hidden');
      $(this.box).find('> div').css({
        width: $(this.box).width() + 'px',
        height: $(this.box).height() + 'px'
      });
      //$(this.box).find('.w2ui-sidebar-div').css('overflow', 'auto');
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return new Date().getTime() - time;
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'destroy',
        target: this.name
      });
      if (eventData.isCancelled === true) return;
      // clean up
      if ($(this.box).find('> div > div.w2ui-sidebar-div').length > 0) {
        $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-sidebar').html('');
      }
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    lock: function lock(msg, showSpinner) {
      var box = $(this.box).find('> div:first-child');
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift(box);
      w2utils.lock.apply(window, args);
    },
    unlock: function unlock() {
      w2utils.unlock(this.box);
    }
  };
  $.extend(w2sidebar.prototype, w2utils.event);
  w2obj.sidebar = w2sidebar;
})();

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2field        - various field controls
*        - $().w2field    - jQuery wrapper
*   - Dependencies: jQuery, w2utils
*
* == NICE TO HAVE ==
*   - upload (regular files)
*   - BUG with prefix/postfix and arrows (test in different contexts)
*   - prefix and suffix are slow (100ms or so)
*   - multiple date selection
*   - month selection, year selections
*   - arrows no longer work (for int)
*   - form to support custom types
*   - bug: if input is hidden and then enum is applied, then when it becomes visible, it will be 110px
*
************************************************************************/

(function ($) {
  var w2field = function w2field(options) {
    // public properties
    this.el = null;
    this.helpers = {}; // object or helper elements
    this.type = options.type || 'text';
    this.options = $.extend(true, {}, options);
    this.onSearch = options.onSearch || null;
    this.onRequest = options.onRequest || null;
    this.onLoad = options.onLoad || null;
    this.onError = options.onError || null;
    this.onClick = options.onClick || null;
    this.onAdd = options.onAdd || null;
    this.onNew = options.onNew || null;
    this.onRemove = options.onRemove || null;
    this.onMouseOver = options.onMouseOver || null;
    this.onMouseOut = options.onMouseOut || null;
    this.onIconClick = options.onIconClick || null;
    this.tmp = {}; // temp object
    // clean up some options
    delete this.options.type;
    delete this.options.onSearch;
    delete this.options.onRequest;
    delete this.options.onLoad;
    delete this.options.onError;
    delete this.options.onClick;
    delete this.options.onMouseOver;
    delete this.options.onMouseOut;
    delete this.options.onIconClick;
    // extend with defaults
    $.extend(true, this, w2obj.field);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2field = function (method, options) {
    // call direct
    if (this.length == 0) {
      var pr = w2field.prototype;
      if (pr[method]) {
        return pr[method].apply(pr, Array.prototype.slice.call(arguments, 1));
      }
    } else {
      // if without arguments - return the object
      if (arguments.length == 0) {
        var obj = $(this).data('w2field');
        return obj;
      }
      if (typeof method == 'string' && _typeof(options) == 'object') {
        method = $.extend(true, {}, options, {
          type: method
        });
      }
      if (typeof method == 'string' && typeof options == 'undefined') {
        method = {
          type: method
        };
      }
      method.type = String(method.type).toLowerCase();
      return this.each(function (index, el) {
        var obj = $(el).data('w2field');
        // if object is not defined, define it
        if (typeof obj == 'undefined') {
          var obj = new w2field(method);
          $.extend(obj, {
            handlers: []
          });
          if (el) obj.el = $(el)[0];
          obj.init();
          $(el).data('w2field', obj);
          return obj;
        } else {
          // fully re-init
          obj.clear();
          if (method.type == 'clear') return;
          var obj = new w2field(method);
          $.extend(obj, {
            handlers: []
          });
          if (el) obj.el = $(el)[0];
          obj.init();
          $(el).data('w2field', obj);
          return obj;
        }
        return null;
      });
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  /*     To add custom types
      $().w2field('addType', 'myType', function (options) {
          $(this.el).on('keypress', function (event) {
              if (event.metaKey || event.ctrlKey || event.altKey
                  || (event.charCode != event.keyCode && event.keyCode > 0)) return;
              var ch = String.fromCharCode(event.charCode);
              if (ch != 'a' && ch != 'b' && ch != 'c') {
                  if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
                  return false;
              }
          });
          $(this.el).on('blur', function (event)  { // keyCode & charCode differ in FireFox
              var ch = this.value;
              if (ch != 'a' && ch != 'b' && ch != 'c') {
                  $(this).w2tag(w2utils.lang("Not a single charecter from the set of 'abc'"));
              }
          });
      });
  */

  w2field.prototype = {
    custom: {},
    // map of custom types

    pallete: [['000000', '444444', '666666', '999999', 'CCCCCC', 'EEEEEE', 'F3F3F3', 'FFFFFF'], ['FF011B', 'FF9838', 'FFFD59', '01FD55', '00FFFE', '0424F3', '9B24F4', 'FF21F5'], ['F4CCCC', 'FCE5CD', 'FFF2CC', 'D9EAD3', 'D0E0E3', 'CFE2F3', 'D9D1E9', 'EAD1DC'], ['EA9899', 'F9CB9C', 'FEE599', 'B6D7A8', 'A2C4C9', '9FC5E8', 'B4A7D6', 'D5A6BD'], ['E06666', 'F6B26B', 'FED966', '93C47D', '76A5AF', '6FA8DC', '8E7CC3', 'C27BA0'], ['CC0814', 'E69138', 'F1C232', '6AA84F', '45818E', '3D85C6', '674EA7', 'A54D79'], ['99050C', 'B45F17', 'BF901F', '37761D', '124F5C', '0A5394', '351C75', '741B47'], ['660205', '783F0B', '7F6011', '274E12', '0C343D', '063762', '20124D', '4C1030']],
    addType: function addType(type, handler) {
      type = String(type).toLowerCase();
      this.custom[type] = handler;
      return true;
    },
    removeType: function removeType(type) {
      type = String(type).toLowerCase();
      if (!this.custom[type]) return false;
      delete this.custom[type];
      return true;
    },
    init: function init() {
      var obj = this;
      var options = this.options;
      var defaults;

      // Custom Types
      if (typeof this.custom[this.type] == 'function') {
        this.custom[this.type].call(this, options);
        return;
      }
      // only for INPUT or TEXTAREA
      if (['INPUT', 'TEXTAREA'].indexOf(this.el.tagName) == -1) {
        console.log('ERROR: w2field could only be applied to INPUT or TEXTAREA.', this.el);
        return;
      }
      switch (this.type) {
        case 'text':
        case 'int':
        case 'float':
        case 'money':
        case 'currency':
        case 'percent':
        case 'alphanumeric':
        case 'hex':
          defaults = {
            min: null,
            max: null,
            step: 1,
            placeholder: '',
            autoFormat: true,
            currencyPrefix: w2utils.settings.currencyPrefix,
            currencySuffix: w2utils.settings.currencySuffix,
            currencyPrecision: w2utils.settings.currencyPrecision,
            decimalSymbol: w2utils.settings.decimalSymbol,
            groupSymbol: w2utils.settings.groupSymbol,
            arrows: false,
            keyboard: true,
            precision: null,
            silent: true,
            prefix: '',
            suffix: ''
          };
          this.options = $.extend(true, {}, defaults, options);
          options = this.options; // since object is re-created, need to re-assign
          options.numberRE = new RegExp('[' + options.groupSymbol + ']', 'g');
          options.moneyRE = new RegExp('[' + options.currencyPrefix + options.currencySuffix + options.groupSymbol + ']', 'g');
          options.percentRE = new RegExp('[' + options.groupSymbol + '%]', 'g');
          // no keyboard support needed
          if (['text', 'alphanumeric', 'hex'].indexOf(this.type) != -1) {
            options.arrows = false;
            options.keyboard = false;
          }
          this.addPrefix(); // only will add if needed
          this.addSuffix();
          if ($(this.el).attr('placeholder') && options.placeholder == '') options.placeholder = $(this.el).attr('placeholder');
          $(this.el).attr('placeholder', options.placeholder);
          break;
        case 'color':
          defaults = {
            prefix: '#',
            suffix: '<div style="width: ' + (parseInt($(this.el).css('font-size')) || 12) + 'px">&nbsp;</div>',
            placeholder: '',
            arrows: false,
            keyboard: false
          };
          $.extend(options, defaults);
          this.addPrefix(); // only will add if needed
          this.addSuffix(); // only will add if needed
          // additional checks
          $(this.el).attr('maxlength', 6);
          if ($(this.el).val() != '') setTimeout(function () {
            $(obj.el).change();
          }, 1);
          if ($(this.el).attr('placeholder') && options.placeholder == '') options.placeholder = $(this.el).attr('placeholder');
          $(this.el).attr('placeholder', options.placeholder);
          break;
        case 'date':
          defaults = {
            format: w2utils.settings.date_format,
            // date format
            placeholder: '',
            keyboard: true,
            silent: true,
            start: '',
            // string or jquery object
            end: '',
            // string or jquery object
            blocked: {},
            // { '4/11/2011': 'yes' }
            colored: {} // { '4/11/2011': 'red:white' }
          };
          this.options = $.extend(true, {}, defaults, options);
          options = this.options; // since object is re-created, need to re-assign
          if ($(this.el).attr('placeholder') && options.placeholder == '') options.placeholder = $(this.el).attr('placeholder');
          $(this.el).attr('placeholder', options.placeholder ? options.placeholder : options.format);
          break;
        case 'time':
          defaults = {
            format: w2utils.settings.time_format,
            placeholder: '',
            keyboard: true,
            silent: true,
            start: '',
            end: ''
          };
          this.options = $.extend(true, {}, defaults, options);
          options = this.options; // since object is re-created, need to re-assign
          if ($(this.el).attr('placeholder') && options.placeholder == '') options.placeholder = $(this.el).attr('placeholder');
          $(this.el).attr('placeholder', options.placeholder ? options.placeholder : options.format == 'h12' ? 'hh:mi pm' : 'hh:mi');
          break;
        case 'datetime':
          break;
        case 'list':
        case 'combo':
          defaults = {
            items: [],
            selected: {},
            placeholder: '',
            url: null,
            // url to pull data from
            postData: {},
            minLength: 1,
            cacheMax: 250,
            maxDropHeight: 350,
            // max height for drop down menu
            match: 'begins',
            // ['contains', 'is', 'begins', 'ends']
            silent: true,
            icon: null,
            iconStyle: '',
            onSearch: null,
            // when search needs to be performed
            onRequest: null,
            // when request is submitted
            onLoad: null,
            // when data is received
            onError: null,
            // when data fails to load due to server error or other failure modes
            onIconClick: null,
            renderDrop: null,
            // render function for drop down item
            prefix: '',
            suffix: '',
            openOnFocus: false,
            // if to show overlay onclick or when typing
            markSearch: false
          };
          options.items = this.normMenu(options.items); // need to be first
          if (this.type == 'list') {
            // defaults.search = (options.items && options.items.length >= 10 ? true : false);
            defaults.openOnFocus = true;
            defaults.suffix = '<div class="arrow-down" style="margin-top: ' + (parseInt($(this.el).height()) - 6) / 2 + 'px;"></div>';
            $(this.el).addClass('w2ui-select');
            // if simple value - look it up
            if (!$.isPlainObject(options.selected)) {
              for (var i in options.items) {
                var item = options.items[i];
                if (item && item.id == options.selected) {
                  options.selected = $.extend(true, {}, item);
                  break;
                }
              }
            }
          }
          options = $.extend({}, defaults, options, {
            align: 'both',
            // same width as control
            altRows: true // alternate row color
          });
          this.options = options;
          if (!$.isPlainObject(options.selected)) options.selected = {};
          $(this.el).data('selected', options.selected);
          if (options.url) this.request(0);
          if (this.type == 'list') this.addFocus();
          this.addPrefix();
          this.addSuffix();
          setTimeout(function () {
            obj.refresh();
          }, 10); // need this for icon refresh
          if ($(this.el).attr('placeholder') && options.placeholder == '') options.placeholder = $(this.el).attr('placeholder');
          $(this.el).attr('placeholder', options.placeholder).attr('autocomplete', 'off');
          if (typeof options.selected.text != 'undefined') $(this.el).val(options.selected.text);
          break;
        case 'enum':
          defaults = {
            items: [],
            selected: [],
            placeholder: '',
            max: 0,
            // max number of selected items, 0 - unlim
            url: null,
            // not implemented
            postData: {},
            minLength: 1,
            cacheMax: 250,
            maxWidth: 250,
            // max width for a single item
            maxHeight: 350,
            // max height for input control to grow
            maxDropHeight: 350,
            // max height for drop down menu
            match: 'contains',
            // ['contains', 'is', 'begins', 'ends']
            silent: true,
            openOnFocus: false,
            // if to show overlay onclick or when typing
            markSearch: true,
            renderDrop: null,
            // render function for drop down item
            renderItem: null,
            // render selected item
            style: '',
            // style for container div
            onSearch: null,
            // when search needs to be performed
            onRequest: null,
            // when request is submitted
            onLoad: null,
            // when data is received
            onError: null,
            // when data fails to load due to server error or other failure modes
            onClick: null,
            // when an item is clicked
            onAdd: null,
            // when an item is added
            onNew: null,
            // when new item should be added
            onRemove: null,
            // when an item is removed
            onMouseOver: null,
            // when an item is mouse over
            onMouseOut: null // when an item is mouse out
          };
          options = $.extend({}, defaults, options, {
            align: 'both',
            // same width as control
            suffix: '',
            altRows: true // alternate row color
          });
          options.items = this.normMenu(options.items);
          options.selected = this.normMenu(options.selected);
          this.options = options;
          if (!$.isArray(options.selected)) options.selected = [];
          $(this.el).data('selected', options.selected);
          if (options.url) this.request(0);
          this.addSuffix();
          this.addMulti();
          break;
        case 'file':
          defaults = {
            selected: [],
            placeholder: w2utils.lang('Attach files by dragging and dropping or Click to Select'),
            max: 0,
            maxSize: 0,
            // max size of all files, 0 - unlim
            maxFileSize: 0,
            // max size of a single file, 0 -unlim
            maxWidth: 250,
            // max width for a single item
            maxHeight: 350,
            // max height for input control to grow
            maxDropHeight: 350,
            // max height for drop down menu
            silent: true,
            renderItem: null,
            // render selected item
            style: '',
            // style for container div
            onClick: null,
            // when an item is clicked
            onAdd: null,
            // when an item is added
            onRemove: null,
            // when an item is removed
            onMouseOver: null,
            // when an item is mouse over
            onMouseOut: null // when an item is mouse out
          };
          options = $.extend({}, defaults, options, {
            align: 'both',
            // same width as control
            altRows: true // alternate row color
          });
          this.options = options;
          if (!$.isArray(options.selected)) options.selected = [];
          $(this.el).data('selected', options.selected);
          if ($(this.el).attr('placeholder')) options.placeholder = $(this.el).attr('placeholder');
          this.addMulti();
          break;
      }
      // attach events
      this.tmp = {
        onChange: function onChange(event) {
          obj.change.call(obj, event);
        },
        onClick: function onClick(event) {
          obj.click.call(obj, event);
        },
        onFocus: function onFocus(event) {
          obj.focus.call(obj, event);
        },
        onBlur: function onBlur(event) {
          obj.blur.call(obj, event);
        },
        onKeydown: function onKeydown(event) {
          obj.keyDown.call(obj, event);
        },
        onKeyup: function onKeyup(event) {
          obj.keyUp.call(obj, event);
        },
        onKeypress: function onKeypress(event) {
          obj.keyPress.call(obj, event);
        }
      };
      $(this.el).addClass('w2field').data('w2field', this).on('change', this.tmp.onChange).on('click', this.tmp.onClick) // ignore click because it messes overlays
      .on('focus', this.tmp.onFocus).on('blur', this.tmp.onBlur).on('keydown', this.tmp.onKeydown).on('keyup', this.tmp.onKeyup).on('keypress', this.tmp.onKeypress).css({
        'box-sizing': 'border-box',
        '-webkit-box-sizing': 'border-box',
        '-moz-box-sizing': 'border-box',
        '-ms-box-sizing': 'border-box',
        '-o-box-sizing': 'border-box'
      });
      // format initial value
      this.change($.Event('change'));
    },
    clear: function clear() {
      var obj = this;
      var options = this.options;
      // if money then clear value
      if (['money', 'currency'].indexOf(this.type) != -1) {
        $(this.el).val($(this.el).val().replace(options.moneyRE, ''));
      }
      if (this.type == 'percent') {
        $(this.el).val($(this.el).val().replace(/%/g, ''));
      }
      if (this.type == 'color') {
        $(this.el).removeAttr('maxlength');
      }
      if (this.type == 'list') {
        $(this.el).removeClass('w2ui-select');
      }
      if (['date', 'time'].indexOf(this.type) != -1) {
        if ($(this.el).attr('placeholder') == options.format) $(this.el).attr('placeholder', '');
      }
      this.type = 'clear';
      var tmp = $(this.el).data('tmp');
      if (!this.tmp) return;
      // restore paddings
      if (typeof tmp != 'undefined') {
        if (tmp && tmp['old-padding-left']) $(this.el).css('padding-left', tmp['old-padding-left']);
        if (tmp && tmp['old-padding-right']) $(this.el).css('padding-right', tmp['old-padding-right']);
      }
      // remove events and data
      $(this.el).val(this.clean($(this.el).val())).removeClass('w2field').removeData() // removes all attached data
      .off('change', this.tmp.onChange).off('click', this.tmp.onClick).off('focus', this.tmp.onFocus).off('blur', this.tmp.onBlur).off('keydown', this.tmp.onKeydown).off('keyup', this.tmp.onKeyup).off('keypress', this.tmp.onKeypress);
      // remove helpers
      for (var h in this.helpers) $(this.helpers[h]).remove();
      this.helpers = {};
    },
    refresh: function refresh() {
      var obj = this;
      var options = this.options;
      var selected = $(this.el).data('selected');
      var time = new Date().getTime();
      // enum
      if (['list'].indexOf(this.type) != -1) {
        $(obj.el).parent().css('white-space', 'nowrap'); // needs this for arrow alway to appear on the right side
        // hide focus and show text
        if (obj.helpers.prefix) obj.helpers.prefix.hide();
        setTimeout(function () {
          if (!obj.helpers.focus) return;
          // if empty show no icon
          if (!$.isEmptyObject(selected) && options.icon) {
            options.prefix = '<span class="w2ui-icon ' + options.icon + '"style="cursor: pointer; font-size: 14px;' + ' display: inline-block; margin-top: -1px; color: #7F98AD;' + options.iconStyle + '">' + '</span>';
            obj.addPrefix();
          } else {
            options.prefix = '';
            obj.addPrefix();
          }
          // focus helpder
          var focus = obj.helpers.focus.find('input');
          if ($(focus).val() == '') {
            $(focus).css('opacity', 0).prev().css('opacity', 0);
            $(obj.el).val(selected && selected.text != null ? selected.text : '');
            $(obj.el).attr('placeholder', options.placeholder || '');
          } else {
            $(focus).css('opacity', 1).prev().css('opacity', 1);
            $(obj.el).val('');
            $(obj.el).removeAttr('placeholder');
            setTimeout(function () {
              if (obj.helpers.prefix) obj.helpers.prefix.hide();
              var tmp = 'position: absolute; opacity: 0; margin: 4px 0px 0px 2px; background-position: left !important;';
              if (options.icon) {
                $(focus).css('margin-left', '17px');
                $(obj.helpers.focus).find('.icon-search').attr('style', tmp + 'width: 11px !important; display: block; opacity: 1');
              } else {
                $(focus).css('margin-left', '0px');
                $(obj.helpers.focus).find('.icon-search').attr('style', tmp + 'width: 0px !important; display: none; opacity: 0');
              }
            }, 1);
          }
          // if readonly or disabled
          if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) {
            setTimeout(function () {
              $(obj.helpers.prefix).css('opacity', '0.6');
              $(obj.helpers.suffix).css('opacity', '0.6');
            }, 1);
          } else {
            setTimeout(function () {
              $(obj.helpers.prefix).css('opacity', '1');
              $(obj.helpers.suffix).css('opacity', '1');
            }, 1);
          }
        }, 1);
      }
      if (['enum', 'file'].indexOf(this.type) != -1) {
        var html = '';
        for (var s in selected) {
          var it = selected[s];
          var ren = '';
          if (typeof options.renderItem == 'function') {
            ren = options.renderItem(it, s, '<div class="w2ui-list-remove" title="' + w2utils.lang('Remove') + '" index="' + s + '">&nbsp;&nbsp;</div>');
          } else {
            ren = '<div class="w2ui-list-remove" title="' + w2utils.lang('Remove') + '" index="' + s + '">&nbsp;&nbsp;</div>' + (obj.type == 'enum' ? it.text : it.name + '<span class="file-size"> - ' + w2utils.size(it.size) + '</span>');
          }
          html += '<li index="' + s + '" style="max-width: ' + parseInt(options.maxWidth) + 'px; ' + (it.style ? it.style : '') + '">' + ren + '</li>';
        }
        var div = obj.helpers.multi;
        var ul = div.find('ul');
        div.attr('style', div.attr('style') + ';' + options.style);
        if ($(obj.el).prop('readonly') || $(obj.el).prop('disabled')) {
          div.addClass('w2ui-readonly');
          div.css('pointer-events', 'none').find('li').css('opacity', '0.6');
          $(obj.helpers.multi).find('input').prop('readonly', true);
        } else {
          div.removeClass('w2ui-readonly');
          div.css('pointer-events', 'auto').find('li').css('opacity', '1');
          $(obj.helpers.multi).find('input').prop('readonly', false);
        }
        // celan
        div.find('.w2ui-enum-placeholder').remove();
        ul.find('li').not('li.nomouse').remove();
        // add new list
        if (html != '') {
          ul.prepend(html);
        } else if (typeof options.placeholder != 'undefined') {
          var style = 'padding-top: ' + $(this.el).css('padding-top') + ';' + 'padding-left: ' + $(this.el).css('padding-left') + '; ' + 'box-sizing: ' + $(this.el).css('box-sizing') + '; ' + 'line-height: ' + $(this.el).css('line-height') + '; ' + 'font-size: ' + $(this.el).css('font-size') + '; ' + 'font-family: ' + $(this.el).css('font-family') + '; ';
          div.prepend('<div class="w2ui-enum-placeholder" style="' + style + '">' + options.placeholder + '</div>');
        }
        // ITEMS events
        div.find('li').data('mouse', 'out').on('click', function (event) {
          var item = selected[$(event.target).attr('index')];
          if ($(event.target).hasClass('nomouse')) return;
          event.stopPropagation();
          // trigger event
          var eventData = obj.trigger({
            phase: 'before',
            type: 'click',
            target: obj.el,
            originalEvent: event.originalEvent,
            item: item
          });
          if (eventData.isCancelled === true) return;
          // default behavior
          if ($(event.target).hasClass('w2ui-list-remove')) {
            if ($(obj.el).attr('readonly') || $(obj.el).attr('disabled')) return;
            // trigger event
            var eventData = obj.trigger({
              phase: 'before',
              type: 'remove',
              target: obj.el,
              originalEvent: event.originalEvent,
              item: item
            });
            if (eventData.isCancelled === true) return;
            // default behavior
            $().w2overlay();
            selected.splice($(event.target).attr('index'), 1);
            $(obj.el).trigger('change');
            $(event.target).parent().fadeOut('fast');
            setTimeout(function () {
              obj.refresh();
              // event after
              obj.trigger($.extend(eventData, {
                phase: 'after'
              }));
            }, 300);
          }
          if (obj.type == 'file' && !$(event.target).hasClass('w2ui-list-remove')) {
            var preview = '';
            if (/image/i.test(item.type)) {
              // image
              preview = '<div style="padding: 3px;">' + '    <img src="' + (item.content ? 'data:' + item.type + ';base64,' + item.content : '') + '" style="max-width: 300px;" ' + '        onload="var w = $(this).width(); var h = $(this).height(); ' + '            if (w < 300 & h < 300) return; ' + '            if (w >= h && w > 300) $(this).width(300);' + '            if (w < h && h > 300) $(this).height(300);"' + '        onerror="this.style.display = \'none\'"' + '    >' + '</div>';
            }
            var td1 = 'style="padding: 3px; text-align: right; color: #777;"';
            var td2 = 'style="padding: 3px"';
            preview += '<div style="padding: 8px;">' + '    <table cellpadding="2">' + '    <tr><td ' + td1 + '>' + w2utils.lang('Name') + ':</td><td ' + td2 + '>' + item.name + '</td></tr>' + '    <tr><td ' + td1 + '>' + w2utils.lang('Size') + ':</td><td ' + td2 + '>' + w2utils.size(item.size) + '</td></tr>' + '    <tr><td ' + td1 + '>' + w2utils.lang('Type') + ':</td><td ' + td2 + '>' + '        <span style="width: 200px; display: block-inline; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">' + item.type + '</span>' + '    </td></tr>' + '    <tr><td ' + td1 + '>' + w2utils.lang('Modified') + ':</td><td ' + td2 + '>' + w2utils.date(item.modified) + '</td></tr>' + '    </table>' + '</div>';
            $(event.target).w2overlay(preview);
          }
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        }).on('mouseover', function (event) {
          var tmp = event.target;
          if (tmp.tagName != 'LI') tmp = tmp.parentNode;
          if ($(tmp).hasClass('nomouse')) return;
          if ($(tmp).data('mouse') == 'out') {
            var item = selected[$(tmp).attr('index')];
            // trigger event
            var eventData = obj.trigger({
              phase: 'before',
              type: 'mouseOver',
              target: obj.el,
              originalEvent: event.originalEvent,
              item: item
            });
            if (eventData.isCancelled === true) return;
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
          }
          $(tmp).data('mouse', 'over');
        }).on('mouseout', function (event) {
          var tmp = event.target;
          if (tmp.tagName != 'LI') tmp = tmp.parentNode;
          if ($(tmp).hasClass('nomouse')) return;
          $(tmp).data('mouse', 'leaving');
          setTimeout(function () {
            if ($(tmp).data('mouse') == 'leaving') {
              $(tmp).data('mouse', 'out');
              var item = selected[$(tmp).attr('index')];
              // trigger event
              var eventData = obj.trigger({
                phase: 'before',
                type: 'f',
                target: obj.el,
                originalEvent: event.originalEvent,
                item: item
              });
              if (eventData.isCancelled === true) return;
              // event after
              obj.trigger($.extend(eventData, {
                phase: 'after'
              }));
            }
          }, 0);
        });
        // adjust height
        $(this.el).height('auto');
        var cntHeight = $(div).find('> div').height() + w2utils.getSize(div, '+height') * 2;
        if (cntHeight < 26) cntHeight = 26;
        if (cntHeight > options.maxHeight) cntHeight = options.maxHeight;
        if (div.length > 0) div[0].scrollTop = 1000;
        var inpHeight = w2utils.getSize($(this.el), 'height') - 2;
        if (inpHeight > cntHeight) cntHeight = inpHeight;
        $(div).css({
          'height': cntHeight + 'px',
          overflow: cntHeight == options.maxHeight ? 'auto' : 'hidden'
        });
        if (cntHeight < options.maxHeight) $(div).prop('scrollTop', 0);
        $(this.el).css({
          'height': cntHeight + 2 + 'px'
        });
      }
      return new Date().getTime() - time;
    },
    reset: function reset() {
      var obj = this;
      var type = this.type;
      this.clear();
      this.type = type;
      this.init();
    },
    clean: function clean(val) {
      var options = this.options;
      val = String(val).trim();
      // clean
      if (['int', 'float', 'money', 'currency', 'percent'].indexOf(this.type) != -1) {
        if (typeof val == 'string') val = val.replace(options.decimalSymbol, '.');
        if (options.autoFormat && ['money', 'currency'].indexOf(this.type) != -1) val = String(val).replace(options.moneyRE, '');
        if (options.autoFormat && this.type == 'percent') val = String(val).replace(options.percentRE, '');
        if (options.autoFormat && ['int', 'float'].indexOf(this.type) != -1) val = String(val).replace(options.numberRE, '');
        if (parseFloat(val) == val) {
          if (options.min !== null && val < options.min) {
            val = options.min;
            $(this.el).val(options.min);
          }
          if (options.max !== null && val > options.max) {
            val = options.max;
            $(this.el).val(options.max);
          }
        }
        if (val !== '' && w2utils.isFloat(val)) val = Number(val);else val = '';
      }
      return val;
    },
    format: function format(val) {
      var options = this.options;
      // autoformat numbers or money
      if (options.autoFormat && val != '') {
        switch (this.type) {
          case 'money':
          case 'currency':
            val = w2utils.formatNumber(Number(val).toFixed(options.currencyPrecision), options.groupSymbol);
            if (val != '') val = options.currencyPrefix + val + options.currencySuffix;
            break;
          case 'percent':
            val = w2utils.formatNumber(options.precision ? Number(val).toFixed(options.precision) : val, options.groupSymbol);
            if (val != '') val += '%';
            break;
          case 'float':
            val = w2utils.formatNumber(options.precision ? Number(val).toFixed(options.precision) : val, options.groupSymbol);
            break;
          case 'int':
            val = w2utils.formatNumber(val, options.groupSymbol);
            break;
        }
      }
      return val;
    },
    change: function change(event) {
      var obj = this;
      var options = obj.options;
      // numeric
      if (['int', 'float', 'money', 'currency', 'percent'].indexOf(this.type) != -1) {
        // check max/min
        var val = $(this.el).val();
        var new_val = this.format(this.clean($(this.el).val()));
        // if was modified
        if (val != '' && val != new_val) {
          $(this.el).val(new_val).change();
          // cancel event
          event.stopPropagation();
          event.preventDefault();
          return false;
        }
      }
      // color
      if (this.type == 'color') {
        var color = '#' + $(this.el).val();
        if ($(this.el).val().length != 6 && $(this.el).val().length != 3) color = '';
        $(this.el).next().find('div').css('background-color', color);
        if ($(obj.el).is(':focus')) this.updateOverlay();
      }
      // list, enum
      if (['list', 'enum', 'file'].indexOf(this.type) != -1) {
        obj.refresh();
        // need time out to show icon indent properly
        setTimeout(function () {
          obj.refresh();
        }, 5);
      }
      // date, time
      if (['date', 'time'].indexOf(this.type) != -1) {
        // convert linux timestamps
        var tmp = parseInt(obj.el.value);
        if (w2utils.isInt(obj.el.value) && tmp > 3000) {
          if (this.type == 'time') $(obj.el).val(w2utils.formatTime(new Date(tmp), options.format)).change();
          if (this.type == 'date') $(obj.el).val(w2utils.formatDate(new Date(tmp), options.format)).change();
        }
      }
    },
    click: function click(event) {
      event.stopPropagation();
      // lists
      if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
        if (!$(this.el).is(':focus')) this.focus(event);
      }
      // other fields with drops
      if (['date', 'time', 'color'].indexOf(this.type) != -1) {
        this.updateOverlay();
      }
    },
    focus: function focus(event) {
      var obj = this;
      var options = this.options;
      // color, date, time
      if (['color', 'date', 'time'].indexOf(obj.type) !== -1) {
        if ($(obj.el).attr('readonly') || $(obj.el).attr('disabled')) return;
        if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
        setTimeout(function () {
          obj.updateOverlay();
        }, 150);
      }
      // menu
      if (['list', 'combo', 'enum'].indexOf(obj.type) != -1) {
        if ($(obj.el).attr('readonly') || $(obj.el).attr('disabled')) return;
        if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
        setTimeout(function () {
          if (obj.type == 'list' && $(obj.el).is(':focus')) {
            $(obj.helpers.focus).find('input').focus();
            return;
          }
          obj.search();
          setTimeout(function () {
            obj.updateOverlay();
          }, 1);
        }, 1);
      }
      // file
      if (obj.type == 'file') {
        $(obj.helpers.multi).css({
          'outline': 'auto 5px #7DB4F3',
          'outline-offset': '-2px'
        });
      }
    },
    blur: function blur(event) {
      var obj = this;
      var options = obj.options;
      var val = $(obj.el).val().trim();
      // hide overlay
      if (['color', 'date', 'time', 'list', 'combo', 'enum'].indexOf(obj.type) != -1) {
        if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
      }
      if (['int', 'float', 'money', 'currency', 'percent'].indexOf(obj.type) != -1) {
        if (val !== '' && !obj.checkType(val)) {
          $(obj.el).val('').change();
          if (options.silent === false) {
            $(obj.el).w2tag('Not a valid number');
            setTimeout(function () {
              $(obj.el).w2tag('');
            }, 3000);
          }
        }
      }
      // date or time
      if (['date', 'time'].indexOf(obj.type) != -1) {
        // check if in range
        if (val !== '' && !obj.inRange(obj.el.value)) {
          $(obj.el).val('').removeData('selected').change();
          if (options.silent === false) {
            $(obj.el).w2tag('Not in range');
            setTimeout(function () {
              $(obj.el).w2tag('');
            }, 3000);
          }
        } else {
          if (obj.type == 'date' && val !== '' && !w2utils.isDate(obj.el.value, options.format)) {
            $(obj.el).val('').removeData('selected').change();
            if (options.silent === false) {
              $(obj.el).w2tag('Not a valid date');
              setTimeout(function () {
                $(obj.el).w2tag('');
              }, 3000);
            }
          }
          if (obj.type == 'time' && val !== '' && !w2utils.isTime(obj.el.value)) {
            $(obj.el).val('').removeData('selected').change();
            if (options.silent === false) {
              $(obj.el).w2tag('Not a valid time');
              setTimeout(function () {
                $(obj.el).w2tag('');
              }, 3000);
            }
          }
        }
      }
      // clear search input
      if (obj.type == 'enum') {
        $(obj.helpers.multi).find('input').val('').width(20);
      }
      // file
      if (obj.type == 'file') {
        $(obj.helpers.multi).css({
          'outline': 'none'
        });
      }
    },
    keyPress: function keyPress(event) {
      var obj = this;
      var options = obj.options;
      // ignore wrong pressed key
      if (['int', 'float', 'money', 'currency', 'percent', 'hex', 'color', 'alphanumeric'].indexOf(obj.type) != -1) {
        // keyCode & charCode differ in FireFox
        if (event.metaKey || event.ctrlKey || event.altKey || event.charCode != event.keyCode && event.keyCode > 0) return;
        var ch = String.fromCharCode(event.charCode);
        if (!obj.checkType(ch, true) && event.keyCode != 13) {
          event.preventDefault();
          if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
          return false;
        }
      }
      // update date popup
      if (['date', 'time'].indexOf(obj.type) != -1) {
        setTimeout(function () {
          obj.updateOverlay();
        }, 1);
      }
    },
    keyDown: function keyDown(event, extra) {
      var obj = this;
      var options = obj.options;
      var key = event.keyCode || extra && extra.keyCode;
      // numeric
      if (['int', 'float', 'money', 'currency', 'percent'].indexOf(obj.type) != -1) {
        if (!options.keyboard || $(obj.el).attr('readonly')) return;
        var cancel = false;
        var val = parseFloat($(obj.el).val().replace(options.moneyRE, '')) || 0;
        var inc = options.step;
        if (event.ctrlKey || event.metaKey) inc = 10;
        switch (key) {
          case 38:
            // up
            if (event.shiftKey) break; // no action if shift key is pressed
            $(obj.el).val(val + inc <= options.max || options.max === null ? Number((val + inc).toFixed(12)) : options.max).change();
            cancel = true;
            break;
          case 40:
            // down
            if (event.shiftKey) break; // no action if shift key is pressed
            $(obj.el).val(val - inc >= options.min || options.min === null ? Number((val - inc).toFixed(12)) : options.min).change();
            cancel = true;
            break;
        }
        if (cancel) {
          event.preventDefault();
          setTimeout(function () {
            // set cursor to the end
            obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
          }, 0);
        }
      }
      // date
      if (obj.type == 'date') {
        if (!options.keyboard || $(obj.el).attr('readonly')) return;
        var cancel = false;
        var daymil = 24 * 60 * 60 * 1000;
        var inc = 1;
        if (event.ctrlKey || event.metaKey) inc = 10;
        var dt = w2utils.isDate($(obj.el).val(), options.format, true);
        if (!dt) {
          dt = new Date();
          daymil = 0;
        }
        switch (key) {
          case 38:
            // up
            if (event.shiftKey) break; // no action if shift key is pressed
            var newDT = w2utils.formatDate(dt.getTime() + daymil, options.format);
            if (inc == 10) newDT = w2utils.formatDate(new Date(dt.getFullYear(), dt.getMonth() + 1, dt.getDate()), options.format);
            $(obj.el).val(newDT).change();
            cancel = true;
            break;
          case 40:
            // down
            if (event.shiftKey) break; // no action if shift key is pressed
            var newDT = w2utils.formatDate(dt.getTime() - daymil, options.format);
            if (inc == 10) newDT = w2utils.formatDate(new Date(dt.getFullYear(), dt.getMonth() - 1, dt.getDate()), options.format);
            $(obj.el).val(newDT).change();
            cancel = true;
            break;
        }
        if (cancel) {
          event.preventDefault();
          setTimeout(function () {
            // set cursor to the end
            obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
            obj.updateOverlay();
          }, 0);
        }
      }
      // time
      if (obj.type == 'time') {
        if (!options.keyboard || $(obj.el).attr('readonly')) return;
        var cancel = false;
        var inc = event.ctrlKey || event.metaKey ? 60 : 1;
        var val = $(obj.el).val();
        var time = obj.toMin(val) || obj.toMin(new Date().getHours() + ':' + (new Date().getMinutes() - 1));
        switch (key) {
          case 38:
            // up
            if (event.shiftKey) break; // no action if shift key is pressed
            time += inc;
            cancel = true;
            break;
          case 40:
            // down
            if (event.shiftKey) break; // no action if shift key is pressed
            time -= inc;
            cancel = true;
            break;
        }
        if (cancel) {
          $(obj.el).val(obj.fromMin(time)).change();
          event.preventDefault();
          setTimeout(function () {
            // set cursor to the end
            obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
          }, 0);
        }
      }
      // color
      if (obj.type == 'color') {
        if ($(obj.el).attr('readonly')) return;
        // paste
        if (event.keyCode == 86 && (event.ctrlKey || event.metaKey)) {
          $(obj.el).prop('maxlength', 7);
          setTimeout(function () {
            var val = $(obj).val();
            if (val.substr(0, 1) == '#') val = val.substr(1);
            if (!w2utils.isHex(val)) val = '';
            $(obj).val(val).prop('maxlength', 6).change();
          }, 20);
        }
        if ((event.ctrlKey || event.metaKey) && !event.shiftKey) {
          if (typeof obj.tmp.cind1 == 'undefined') {
            obj.tmp.cind1 = -1;
            obj.tmp.cind2 = -1;
          } else {
            switch (key) {
              case 38:
                // up
                obj.tmp.cind1--;
                break;
              case 40:
                // down
                obj.tmp.cind1++;
                break;
              case 39:
                // right
                obj.tmp.cind2++;
                break;
              case 37:
                // left
                obj.tmp.cind2--;
                break;
            }
            if (obj.tmp.cind1 < 0) obj.tmp.cind1 = 0;
            if (obj.tmp.cind1 > this.pallete.length - 1) obj.tmp.cind1 = this.pallete.length - 1;
            if (obj.tmp.cind2 < 0) obj.tmp.cind2 = 0;
            if (obj.tmp.cind2 > this.pallete[0].length - 1) obj.tmp.cind2 = this.pallete[0].length - 1;
          }
          if ([37, 38, 39, 40].indexOf(key) != -1) {
            $(obj.el).val(this.pallete[obj.tmp.cind1][obj.tmp.cind2]).change();
            event.preventDefault();
          }
        }
      }
      // list/select/combo
      if (['list', 'combo', 'enum'].indexOf(obj.type) != -1) {
        if ($(obj.el).attr('readonly')) return;
        var cancel = false;
        var selected = $(obj.el).data('selected');
        var focus = $(obj.helpers.focus).find('input');
        if (obj.type == 'list') {
          if ([37, 38, 39, 40].indexOf(key) == -1) obj.refresh(); // arrows
        }
        // apply arrows
        switch (key) {
          case 27:
            // escape
            if (obj.type == 'list') {
              if ($(focus).val() != '') $(focus).val('');
              event.stopPropagation(); // escape in field should not close popup
            }
            break;
          case 37: // left
          case 39:
            // right
            // cancel = true;
            break;
          case 13:
            // enter
            if ($('#w2ui-overlay').length == 0) break; // no action if overlay not open
            var item = options.items[options.index];
            var multi = $(obj.helpers.multi).find('input');
            if (obj.type == 'enum') {
              if (item != null) {
                // trigger event
                var eventData = obj.trigger({
                  phase: 'before',
                  type: 'add',
                  target: obj.el,
                  originalEvent: event.originalEvent,
                  item: item
                });
                if (eventData.isCancelled === true) return;
                item = eventData.item; // need to reassign because it could be recreated by user
                // default behavior
                if (selected.length >= options.max && options.max > 0) selected.pop();
                delete item.hidden;
                delete obj.tmp.force_open;
                selected.push(item);
                $(obj.el).change();
                multi.val('').width(20);
                obj.refresh();
                // event after
                obj.trigger($.extend(eventData, {
                  phase: 'after'
                }));
              } else {
                // trigger event
                item = {
                  id: multi.val(),
                  text: multi.val()
                };
                var eventData = obj.trigger({
                  phase: 'before',
                  type: 'new',
                  target: obj.el,
                  originalEvent: event.originalEvent,
                  item: item
                });
                if (eventData.isCancelled === true) return;
                item = eventData.item; // need to reassign because it could be recreated by user
                // default behavior
                if (typeof obj.onNew == 'function') {
                  if (selected.length >= options.max && options.max > 0) selected.pop();
                  delete obj.tmp.force_open;
                  selected.push(item);
                  $(obj.el).change();
                  multi.val('').width(20);
                  obj.refresh();
                }
                // event after
                obj.trigger($.extend(eventData, {
                  phase: 'after'
                }));
              }
            } else {
              if (item) $(obj.el).data('selected', item).val(item.text).change();
              if ($(obj.el).val() == '' && $(obj.el).data('selected')) $(obj.el).removeData('selected').val('').change();
              if (obj.type == 'list') {
                focus.val('');
                obj.refresh();
              }
              // hide overlay
              obj.tmp.force_hide = true;
            }
            break;
          case 8: // backspace
          case 46:
            // delete
            if (obj.type == 'enum' && key == 8) {
              if ($(obj.helpers.multi).find('input').val() == '' && selected.length > 0) {
                var item = selected[selected.length - 1];
                // trigger event
                var eventData = obj.trigger({
                  phase: 'before',
                  type: 'remove',
                  target: obj.el,
                  originalEvent: event.originalEvent,
                  item: item
                });
                if (eventData.isCancelled === true) return;
                // default behavior
                selected.pop();
                $(obj.el).trigger('change');
                obj.refresh();
                // event after
                obj.trigger($.extend(eventData, {
                  phase: 'after'
                }));
              }
            }
            if (obj.type == 'list' && $(focus).val() == '') {
              $(obj.el).data('selected', {}).change();
              obj.refresh();
            }
            break;
          case 38:
            // up
            options.index = w2utils.isInt(options.index) ? parseInt(options.index) : 0;
            options.index--;
            while (options.index > 0 && options.items[options.index].hidden) options.index--;
            if (options.index == 0 && options.items[options.index].hidden) {
              while (options.items[options.index] && options.items[options.index].hidden) options.index++;
            }
            cancel = true;
            break;
          case 40:
            // down
            options.index = w2utils.isInt(options.index) ? parseInt(options.index) : -1;
            options.index++;
            while (options.index < options.items.length - 1 && options.items[options.index].hidden) options.index++;
            if (options.index == options.items.length - 1 && options.items[options.index].hidden) {
              while (options.items[options.index] && options.items[options.index].hidden) options.index--;
            }
            // show overlay if not shown
            var input = obj.el;
            if (['enum'].indexOf(obj.type) != -1) input = obj.helpers.multi.find('input');
            if ($(input).val() == '' && $('#w2ui-overlay').length == 0) {
              obj.tmp.force_open = true;
            } else {
              cancel = true;
            }
            break;
        }
        if (cancel) {
          if (options.index < 0) options.index = 0;
          if (options.index >= options.items.length) options.index = options.items.length - 1;
          obj.updateOverlay();
          // cancel event
          event.preventDefault();
          setTimeout(function () {
            // set cursor to the end
            if (obj.type == 'enum') {
              var tmp = obj.helpers.multi.find('input').get(0);
              tmp.setSelectionRange(tmp.value.length, tmp.value.length);
            } else if (obj.type == 'list') {
              var tmp = obj.helpers.focus.find('input').get(0);
              tmp.setSelectionRange(tmp.value.length, tmp.value.length);
            } else {
              obj.el.setSelectionRange(obj.el.value.length, obj.el.value.length);
            }
          }, 0);
          return;
        }
        // expand input
        if (obj.type == 'enum') {
          var input = obj.helpers.multi.find('input');
          var search = input.val();
          input.width((search.length + 2) * 8 + 'px');
        }
      }
    },
    keyUp: function keyUp(event) {
      if (this.type == 'color') {
        if (event.keyCode == 86 && (event.ctrlKey || event.metaKey)) $(this).prop('maxlength', 6);
      }
      if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
        // need to be here for ipad compatibility
        if ([16, 17, 18, 20, 37, 39, 91].indexOf(event.keyCode) == -1) {
          // no refreah on crtl, shift, left/right arrows, etc
          if (!this.tmp.force_hide) this.request();
          var input = $(this.helpers.focus).find('input');
          if (input.val().length == 1) this.refresh();
          this.search();
        }
      }
    },
    clearCache: function clearCache() {
      var options = this.options;
      options.items = [];
      this.tmp.xhr_loading = false;
      this.tmp.xhr_search = '';
      this.tmp.xhr_total = -1;
      this.search();
    },
    request: function request(interval) {
      var obj = this;
      var options = this.options;
      var search = $(obj.el).val() || '';
      // if no url - do nothing
      if (!options.url) return;
      // --
      if (obj.type == 'enum') {
        var tmp = $(obj.helpers.multi).find('input');
        if (tmp.length == 0) search = '';else search = tmp.val();
      }
      if (obj.type == 'list') {
        var tmp = $(obj.helpers.focus).find('input');
        if (tmp.length == 0) search = '';else search = tmp.val();
      }
      if (options.minLength != 0 && search.length < options.minLength) {
        options.items = []; // need to empty the list
        this.updateOverlay();
        return;
      }
      if (typeof interval == 'undefined') interval = 350;
      if (typeof obj.tmp.xhr_search == 'undefined') obj.tmp.xhr_search = '';
      if (typeof obj.tmp.xhr_total == 'undefined') obj.tmp.xhr_total = -1;
      // check if need to search
      if (options.url && $(obj.el).prop('readonly') != true && (options.items.length === 0 && obj.tmp.xhr_total !== 0 || obj.tmp.xhr_total == options.cacheMax && search.length > obj.tmp.xhr_search.length || search.length >= obj.tmp.xhr_search.length && search.substr(0, obj.tmp.xhr_search.length) != obj.tmp.xhr_search || search.length < obj.tmp.xhr_search.length)) {
        // empty list
        obj.tmp.xhr_loading = true;
        obj.search();
        // timeout
        clearTimeout(obj.tmp.timeout);
        obj.tmp.timeout = setTimeout(function () {
          // trigger event
          var url = options.url;
          var postData = {
            search: search,
            max: options.cacheMax
          };
          $.extend(postData, options.postData);
          var eventData = obj.trigger({
            phase: 'before',
            type: 'request',
            target: obj.el,
            url: url,
            postData: postData
          });
          if (eventData.isCancelled === true) return;
          url = eventData.url;
          postData = eventData.postData;
          // console.log('REMOTE SEARCH:', search);
          if (obj.tmp.xhr) obj.tmp.xhr.abort();
          var ajaxOptions = {
            type: 'GET',
            url: url,
            data: postData,
            dataType: 'JSON' // expected from server
          };
          if (w2utils.settings.dataType == 'JSON') {
            ajaxOptions.type = 'POST';
            ajaxOptions.data = JSON.stringify(ajaxOptions.data);
            ajaxOptions.contentType = 'application/json';
          }
          obj.tmp.xhr = $.ajax(ajaxOptions).done(function (data, status, xhr) {
            // trigger event
            var eventData2 = obj.trigger({
              phase: 'before',
              type: 'load',
              target: obj.el,
              search: postData.search,
              data: data,
              xhr: xhr
            });
            if (eventData2.isCancelled === true) return;
            // default behavior
            data = eventData2.data;
            if (typeof data == 'string') data = JSON.parse(data);
            if (data.status != 'success') {
              console.log('ERROR: server did not return proper structure. It should return', {
                status: 'success',
                items: [{
                  id: 1,
                  text: 'item'
                }]
              });
              return;
            }
            // remove all extra items if more then needed for cache
            if (data.items.length > options.cacheMax) data.items.splice(options.cacheMax, 100000);
            // remember stats
            obj.tmp.xhr_loading = false;
            obj.tmp.xhr_search = search;
            obj.tmp.xhr_total = data.items.length;
            options.items = obj.normMenu(data.items);
            if (search == '' && data.items.length == 0) obj.tmp.emptySet = true;else obj.tmp.emptySet = false;
            obj.search();
            // console.log('-->', 'retrieved:', obj.tmp.xhr_total);
            // event after
            obj.trigger($.extend(eventData2, {
              phase: 'after'
            }));
          }).fail(function (xhr, status, error) {
            // trigger event
            var errorObj = {
              status: status,
              error: error,
              rawResponseText: xhr.responseText
            };
            var eventData2 = obj.trigger({
              phase: 'before',
              type: 'error',
              target: obj.el,
              search: search,
              error: errorObj,
              xhr: xhr
            });
            if (eventData2.isCancelled === true) return;
            // default behavior
            if (status != 'abort') {
              var data;
              try {
                data = $.parseJSON(xhr.responseText);
              } catch (e) {}
              console.log('ERROR: Server communication failed.', '\n   EXPECTED:', {
                status: 'success',
                items: [{
                  id: 1,
                  text: 'item'
                }]
              }, '\n         OR:', {
                status: 'error',
                message: 'error message'
              }, '\n   RECEIVED:', _typeof(data) == 'object' ? data : xhr.responseText);
            }
            // reset stats
            obj.clearCache();
            // event after
            obj.trigger($.extend(eventData2, {
              phase: 'after'
            }));
          });
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        }, interval);
      }
    },
    search: function search() {
      var obj = this;
      var options = this.options;
      var search = $(obj.el).val();
      var target = obj.el;
      var ids = [];
      var selected = $(obj.el).data('selected');
      if (obj.type == 'enum') {
        target = $(obj.helpers.multi).find('input');
        search = target.val();
        for (var s in selected) {
          if (selected[s]) ids.push(selected[s].id);
        }
      }
      if (obj.type == 'list') {
        target = $(obj.helpers.focus).find('input');
        search = target.val();
        for (var s in selected) {
          if (selected[s]) ids.push(selected[s].id);
        }
      }
      // trigger event
      var eventData = obj.trigger({
        phase: 'before',
        type: 'search',
        target: target,
        search: search
      });
      if (eventData.isCancelled === true) return;
      if (obj.tmp.xhr_loading !== true) {
        var shown = 0;
        for (var i in options.items) {
          var item = options.items[i];
          var prefix = '';
          var suffix = '';
          if (['is', 'begins'].indexOf(options.match) != -1) prefix = '^';
          if (['is', 'ends'].indexOf(options.match) != -1) suffix = '$';
          try {
            var re = new RegExp(prefix + search + suffix, 'i');
            if (re.test(item.text) || item.text == '...') item.hidden = false;else item.hidden = true;
          } catch (e) {}
          // do not show selected items
          if (obj.type == 'enum' && $.inArray(item.id, ids) != -1) item.hidden = true;
          if (item.hidden !== true) shown++;
        }
        if (obj.type != 'combo') {
          // don't preselect first for combo
          options.index = 0;
          while (options.items[options.index] && options.items[options.index].hidden) options.index++;
        } else {
          options.index = -1;
        }
        if (shown <= 0) options.index = -1;
        options.spinner = false;
        obj.updateOverlay();
        setTimeout(function () {
          var html = $('#w2ui-overlay').html() || '';
          if (options.markSearch && html.indexOf('$.fn.w2menuHandler') != -1) {
            // do not highlight when no items
            $('#w2ui-overlay').w2marker(search);
          }
        }, 1);
      } else {
        options.items.splice(0, options.cacheMax);
        options.spinner = true;
        obj.updateOverlay();
      }
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    updateOverlay: function updateOverlay() {
      var obj = this;
      var options = this.options;
      // color
      if (this.type == 'color') {
        if ($(obj.el).attr('readonly')) return;
        if ($('#w2ui-overlay').length == 0) {
          $(obj.el).w2overlay(obj.getColorHTML());
        } else {
          $('#w2ui-overlay').html(obj.getColorHTML());
        }
        // bind events
        $('#w2ui-overlay .color').on('mousedown', function (event) {
          var color = $(event.originalEvent.target).attr('name');
          var index = $(event.originalEvent.target).attr('index').split(':');
          obj.tmp.cind1 = index[0];
          obj.tmp.cind2 = index[1];
          $(obj.el).val(color).change();
          $(this).html('&#149;');
        }).on('mouseup', function () {
          setTimeout(function () {
            if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
          }, 10);
        });
      }
      // date
      if (this.type == 'date') {
        if ($(obj.el).attr('readonly')) return;
        if ($('#w2ui-overlay').length == 0) {
          $(obj.el).w2overlay('<div class="w2ui-reset w2ui-calendar" onclick="event.stopPropagation();"></div>', {
            css: {
              "background-color": "#f5f5f5"
            }
          });
        }
        var month, year;
        var dt = w2utils.isDate($(obj.el).val(), obj.options.format, true);
        if (dt) {
          month = dt.getMonth() + 1;
          year = dt.getFullYear();
        }
        (function refreshCalendar(month, year) {
          $('#w2ui-overlay > div > div').html(obj.getMonthHTML(month, year));
          $('#w2ui-overlay .w2ui-calendar-title').on('mousedown', function () {
            if ($(this).next().hasClass('w2ui-calendar-jump')) {
              $(this).next().remove();
            } else {
              var selYear, selMonth;
              $(this).after('<div class="w2ui-calendar-jump" style=""></div>');
              $(this).next().hide().html(obj.getYearHTML()).fadeIn(200);
              setTimeout(function () {
                $('#w2ui-overlay .w2ui-calendar-jump').find('.w2ui-jump-month, .w2ui-jump-year').on('click', function () {
                  if ($(this).hasClass('w2ui-jump-month')) {
                    $(this).parent().find('.w2ui-jump-month').removeClass('selected');
                    $(this).addClass('selected');
                    selMonth = $(this).attr('name');
                  }
                  if ($(this).hasClass('w2ui-jump-year')) {
                    $(this).parent().find('.w2ui-jump-year').removeClass('selected');
                    $(this).addClass('selected');
                    selYear = $(this).attr('name');
                  }
                  if (selYear != null && selMonth != null) {
                    $('#w2ui-overlay .w2ui-calendar-jump').fadeOut(100);
                    setTimeout(function () {
                      refreshCalendar(parseInt(selMonth) + 1, selYear);
                    }, 100);
                  }
                });
                $('#w2ui-overlay .w2ui-calendar-jump >:last-child').prop('scrollTop', 2000);
              }, 1);
            }
          });
          $('#w2ui-overlay .w2ui-date').on('mousedown', function () {
            var day = $(this).attr('date');
            $(obj.el).val(day).change();
            $(this).css({
              'background-color': '#B6D5FB',
              'border-color': '#aaa'
            });
          }).on('mouseup', function () {
            setTimeout(function () {
              if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
            }, 10);
          });
          $('#w2ui-overlay .previous').on('mousedown', function () {
            var tmp = obj.options.current.split('/');
            tmp[0] = parseInt(tmp[0]) - 1;
            refreshCalendar(tmp[0], tmp[1]);
          });
          $('#w2ui-overlay .next').on('mousedown', function () {
            var tmp = obj.options.current.split('/');
            tmp[0] = parseInt(tmp[0]) + 1;
            refreshCalendar(tmp[0], tmp[1]);
          });
        })(month, year);
      }
      // date
      if (this.type == 'time') {
        if ($(obj.el).attr('readonly')) return;
        if ($('#w2ui-overlay').length == 0) {
          $(obj.el).w2overlay('<div class="w2ui-reset w2ui-calendar-time" onclick="event.stopPropagation();"></div>', {
            css: {
              "background-color": "#fff"
            }
          });
        }
        var h24 = this.options.format == 'h24' ? true : false;
        $('#w2ui-overlay > div').html(obj.getHourHTML());
        $('#w2ui-overlay .w2ui-time').on('mousedown', function (event) {
          $(this).css({
            'background-color': '#B6D5FB',
            'border-color': '#aaa'
          });
          var hour = $(this).attr('hour');
          $(obj.el).val((hour > 12 && !h24 ? hour - 12 : hour) + ':00' + (!h24 ? hour < 12 ? ' am' : ' pm' : '')).change();
        }).on('mouseup', function () {
          var hour = $(this).attr('hour');
          if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
          $(obj.el).w2overlay('<div class="w2ui-reset w2ui-calendar-time"></div>', {
            css: {
              "background-color": "#fff"
            }
          });
          $('#w2ui-overlay > div').html(obj.getMinHTML(hour));
          $('#w2ui-overlay .w2ui-time').on('mousedown', function () {
            $(this).css({
              'background-color': '#B6D5FB',
              'border-color': '#aaa'
            });
            var min = $(this).attr('min');
            $(obj.el).val((hour > 12 && !h24 ? hour - 12 : hour) + ':' + (min < 10 ? 0 : '') + min + (!h24 ? hour < 12 ? ' am' : ' pm' : '')).change();
          }).on('mouseup', function () {
            setTimeout(function () {
              if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay').removeData('keepOpen')[0].hide();
            }, 10);
          });
        });
      }
      // list
      if (['list', 'combo', 'enum'].indexOf(this.type) != -1) {
        var el = this.el;
        var input = this.el;
        if (this.type == 'enum') {
          el = $(this.helpers.multi);
          input = $(el).find('input');
        }
        if (this.type == 'list') {
          input = $(this.helpers.focus).find('input');
        }
        if ($(input).is(':focus')) {
          if (options.openOnFocus === false && $(input).val() == '' && obj.tmp.force_open !== true) {
            $().w2overlay();
            return;
          }
          if (obj.tmp.force_hide) {
            $().w2overlay();
            setTimeout(function () {
              delete obj.tmp.force_hide;
            }, 1);
            return;
          }
          if ($(input).val() != '') delete obj.tmp.force_open;
          if ($('#w2ui-overlay').length == 0) options.index = 0;
          var msgNoItems = w2utils.lang('No matches');
          if (options.url != null && $(input).val().length < options.minLength && obj.tmp.emptySet !== true) msgNoItems = options.minLength + ' ' + w2utils.lang('letters or more...');
          if (options.url != null && $(input).val() == '' && obj.tmp.emptySet !== true) msgNoItems = w2utils.lang('Type to search....');
          $(el).w2menu('refresh', $.extend(true, {}, options, {
            search: false,
            render: options.renderDrop,
            maxHeight: options.maxDropHeight,
            msgNoItems: msgNoItems,
            // selected with mouse
            onSelect: function onSelect(event) {
              if (obj.type == 'enum') {
                var selected = $(obj.el).data('selected');
                if (event.item) {
                  // trigger event
                  var eventData = obj.trigger({
                    phase: 'before',
                    type: 'add',
                    target: obj.el,
                    originalEvent: event.originalEvent,
                    item: event.item
                  });
                  if (eventData.isCancelled === true) return;
                  // default behavior
                  if (selected.length >= options.max && options.max > 0) selected.pop();
                  delete event.item.hidden;
                  selected.push(event.item);
                  $(obj.el).data('selected', selected).change();
                  $(obj.helpers.multi).find('input').val('').width(20);
                  obj.refresh();
                  if ($("#w2ui-overlay").length > 0) $('#w2ui-overlay')[0].hide();
                  // event after
                  obj.trigger($.extend(eventData, {
                    phase: 'after'
                  }));
                }
              } else {
                $(obj.el).data('selected', event.item).val(event.item.text).change();
                if (obj.helpers.focus) obj.helpers.focus.find('input').val('');
              }
            }
          }));
        }
      }
    },
    inRange: function inRange(str) {
      var inRange = false;
      if (this.type == 'date') {
        var dt = w2utils.isDate(str, this.options.format, true);
        if (dt) {
          // enable range
          if (this.options.start || this.options.end) {
            var st = typeof this.options.start == 'string' ? this.options.start : $(this.options.start).val();
            var en = typeof this.options.end == 'string' ? this.options.end : $(this.options.end).val();
            var start = w2utils.isDate(st, this.options.format, true);
            var end = w2utils.isDate(en, this.options.format, true);
            var current = new Date(dt);
            if (!start) start = current;
            if (!end) end = current;
            if (current >= start && current <= end) inRange = true;
          } else {
            inRange = true;
          }
          // block predefined dates
          if (this.options.blocked && $.inArray(str, this.options.blocked) != -1) inRange = false;
        }
      }
      if (this.type == 'time') {
        if (this.options.start || this.options.end) {
          var tm = this.toMin(str);
          var tm1 = this.toMin(this.options.start);
          var tm2 = this.toMin(this.options.end);
          if (!tm1) tm1 = tm;
          if (!tm2) tm2 = tm;
          if (tm >= tm1 && tm <= tm2) inRange = true;
        } else {
          inRange = true;
        }
      }
      return inRange;
    },
    /*
    *  INTERNAL FUNCTIONS
    */

    checkType: function checkType(ch, loose) {
      var obj = this;
      switch (obj.type) {
        case 'int':
          if (loose && ['-', obj.options.groupSymbol].indexOf(ch) != -1) return true;
          return w2utils.isInt(ch.replace(obj.options.numberRE, ''));
        case 'percent':
          ch = ch.replace(/%/g, '');
        case 'float':
          if (loose && ['-', w2utils.settings.decimalSymbol, obj.options.groupSymbol].indexOf(ch) != -1) return true;
          return w2utils.isFloat(ch.replace(obj.options.numberRE, ''));
        case 'money':
        case 'currency':
          if (loose && ['-', obj.options.decimalSymbol, obj.options.groupSymbol, obj.options.currencyPrefix, obj.options.currencySuffix].indexOf(ch) != -1) return true;
          return w2utils.isFloat(ch.replace(obj.options.moneyRE, ''));
        case 'hex':
        case 'color':
          return w2utils.isHex(ch);
        case 'alphanumeric':
          return w2utils.isAlphaNumeric(ch);
      }
      return true;
    },
    addPrefix: function addPrefix() {
      var obj = this;
      setTimeout(function () {
        if (obj.type === 'clear') return;
        var helper;
        var tmp = $(obj.el).data('tmp') || {};
        if (tmp['old-padding-left']) $(obj.el).css('padding-left', tmp['old-padding-left']);
        tmp['old-padding-left'] = $(obj.el).css('padding-left');
        $(obj.el).data('tmp', tmp);
        // remove if already displaed
        if (obj.helpers.prefix) $(obj.helpers.prefix).remove();
        if (obj.options.prefix !== '') {
          // add fresh
          $(obj.el).before('<div class="w2ui-field-helper">' + obj.options.prefix + '</div>');
          helper = $(obj.el).prev();
          helper.css({
            'color': $(obj.el).css('color'),
            'font-family': $(obj.el).css('font-family'),
            'font-size': $(obj.el).css('font-size'),
            'padding-top': $(obj.el).css('padding-top'),
            'padding-bottom': $(obj.el).css('padding-bottom'),
            'padding-left': $(obj.el).css('padding-left'),
            'padding-right': 0,
            'margin-top': parseInt($(obj.el).css('margin-top'), 10) + 2 + 'px',
            'margin-bottom': parseInt($(obj.el).css('margin-bottom'), 10) + 1 + 'px',
            'margin-left': $(obj.el).css('margin-left'),
            'margin-right': 0
          }).on('click', function (event) {
            if (obj.options.icon && typeof obj.onIconClick == 'function') {
              // event before
              var eventData = obj.trigger({
                phase: 'before',
                type: 'iconClick',
                target: obj.el,
                el: $(this).find('span.w2ui-icon')[0]
              });
              if (eventData.isCancelled === true) return;

              // intentionally empty

              // event after
              obj.trigger($.extend(eventData, {
                phase: 'after'
              }));
            } else {
              if (obj.type == 'list') {
                $(obj.helpers.focus).find('input').focus();
              } else {
                $(obj.el).focus();
              }
            }
          });
          $(obj.el).css('padding-left', helper.width() + parseInt($(obj.el).css('padding-left'), 10) + 'px');
          // remember helper
          obj.helpers.prefix = helper;
        }
      }, 1);
    },
    addSuffix: function addSuffix() {
      var obj = this;
      var helper, pr;
      setTimeout(function () {
        if (obj.type === 'clear') return;
        var tmp = $(obj.el).data('tmp') || {};
        if (tmp['old-padding-right']) $(obj.el).css('padding-right', tmp['old-padding-right']);
        tmp['old-padding-right'] = $(obj.el).css('padding-right');
        $(obj.el).data('tmp', tmp);
        pr = parseInt($(obj.el).css('padding-right'), 10);
        if (obj.options.arrows) {
          // remove if already displaed
          if (obj.helpers.arrows) $(obj.helpers.arrows).remove();
          // add fresh
          $(obj.el).after('<div class="w2ui-field-helper" style="border: 1px solid transparent">&nbsp;' + '    <div class="w2ui-field-up" type="up">' + '        <div class="arrow-up" type="up"></div>' + '    </div>' + '    <div class="w2ui-field-down" type="down">' + '        <div class="arrow-down" type="down"></div>' + '    </div>' + '</div>');
          var height = w2utils.getSize(obj.el, 'height');
          helper = $(obj.el).next();
          helper.css({
            'color': $(obj.el).css('color'),
            'font-family': $(obj.el).css('font-family'),
            'font-size': $(obj.el).css('font-size'),
            'height': $(obj.el).height() + parseInt($(obj.el).css('padding-top'), 10) + parseInt($(obj.el).css('padding-bottom'), 10) + 'px',
            'padding': 0,
            'margin-top': parseInt($(obj.el).css('margin-top'), 10) + 1 + 'px',
            'margin-bottom': 0,
            'border-left': '1px solid silver'
          }).css('margin-left', '-' + (helper.width() + parseInt($(obj.el).css('margin-right'), 10) + 12) + 'px').on('mousedown', function (event) {
            $('body').on('mouseup', tmp);
            $('body').data('_field_update_timer', setTimeout(update, 700));
            update(false);
            // timer function
            function tmp() {
              clearTimeout($('body').data('_field_update_timer'));
              $('body').off('mouseup', tmp);
            }
            // update function
            function update(notimer) {
              $(obj.el).focus();
              obj.keyDown($.Event("keydown"), {
                keyCode: $(event.target).attr('type') == 'up' ? 38 : 40
              });
              if (notimer !== false) $('body').data('_field_update_timer', setTimeout(update, 60));
            }
          });
          pr += helper.width() + 12;
          $(obj.el).css('padding-right', pr + 'px');
          // remember helper
          obj.helpers.arrows = helper;
        }
        if (obj.options.suffix !== '') {
          // remove if already displaed
          if (obj.helpers.suffix) $(obj.helpers.suffix).remove();
          // add fresh
          $(obj.el).after('<div class="w2ui-field-helper">' + obj.options.suffix + '</div>');
          helper = $(obj.el).next();
          helper.css({
            'color': $(obj.el).css('color'),
            'font-family': $(obj.el).css('font-family'),
            'font-size': $(obj.el).css('font-size'),
            'padding-top': $(obj.el).css('padding-top'),
            'padding-bottom': $(obj.el).css('padding-bottom'),
            'padding-left': '3px',
            'padding-right': $(obj.el).css('padding-right'),
            'margin-top': parseInt($(obj.el).css('margin-top'), 10) + 2 + 'px',
            'margin-bottom': parseInt($(obj.el).css('margin-bottom'), 10) + 1 + 'px'
          }).on('click', function (event) {
            if (obj.type == 'list') {
              $(obj.helpers.focus).find('input').focus();
            } else {
              $(obj.el).focus();
            }
          });
          helper.css('margin-left', '-' + (w2utils.getSize(helper, 'width') + parseInt($(obj.el).css('margin-right'), 10) + 2) + 'px');
          pr += helper.width() + 3;
          $(obj.el).css('padding-right', pr + 'px');
          // remember helper
          obj.helpers.suffix = helper;
        }
      }, 1);
    },
    addFocus: function addFocus() {
      var obj = this;
      var options = this.options;
      var width = 0; // 11 - show search icon, 0 do not show
      // clean up & init
      $(obj.helpers.focus).remove();
      // remember original tabindex
      var tabIndex = $(obj.el).attr('tabIndex');
      if (tabIndex && tabIndex != -1) obj.el._tabIndex = tabIndex;
      if (obj.el._tabIndex) tabIndex = obj.el._tabIndex;
      // build helper
      var html = '<div class="w2ui-field-helper">' + '    <div class="w2ui-icon icon-search" style="display: none"></div>' + '    <input type="text" autocomplete="off" tabindex="' + tabIndex + '">' + '<div>';
      $(obj.el).attr('tabindex', -1).before(html);
      var helper = $(obj.el).prev();
      obj.helpers.focus = helper;
      helper.css({
        width: $(obj.el).width(),
        "margin-top": $(obj.el).css('margin-top'),
        "margin-left": parseInt($(obj.el).css('margin-left')) + parseInt($(obj.el).css('padding-left')) + 'px',
        "margin-bottom": $(obj.el).css('margin-bottom'),
        "margin-right": $(obj.el).css('margin-right')
      }).find('input').css({
        cursor: 'default',
        width: '100%',
        outline: 'none',
        opacity: 1,
        margin: 0,
        border: '1px solid transparent',
        padding: $(obj.el).css('padding-top'),
        "padding-left": 0,
        "margin-left": width > 0 ? width + 6 : 0,
        "background-color": 'transparent'
      });
      // INPUT events
      helper.find('input').on('click', function (event) {
        if ($('#w2ui-overlay').length == 0) obj.focus(event);
        event.stopPropagation();
      }).on('focus', function (event) {
        $(obj.el).css({
          'outline': 'auto 5px #7DB4F3',
          'outline-offset': '-2px'
        });
        $(this).val('');
        $(obj.el).triggerHandler('focus');
        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
      }).on('blur', function (event) {
        $(obj.el).css('outline', 'none');
        $(this).val('');
        obj.refresh();
        $(obj.el).triggerHandler('blur');
        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
      }).on('keyup', function (event) {
        obj.keyUp(event);
      }).on('keydown', function (event) {
        obj.keyDown(event);
      }).on('keypress', function (event) {
        obj.keyPress(event);
      });
      // MAIN div
      helper.on('click', function (event) {
        $(this).find('input').focus();
      });
      obj.refresh();
    },
    addMulti: function addMulti() {
      var obj = this;
      var options = this.options;
      // clean up & init
      $(obj.helpers.multi).remove();
      // build helper
      var html = '';
      var margin = 'margin-top     : 0px; ' + 'margin-bottom  : 0px; ' + 'margin-left    : ' + $(obj.el).css('margin-left') + '; ' + 'margin-right   : ' + $(obj.el).css('margin-right') + '; ' + 'width          : ' + (w2utils.getSize(obj.el, 'width') - parseInt($(obj.el).css('margin-left'), 10) - parseInt($(obj.el).css('margin-right'), 10)) + 'px;';
      if (obj.type == 'enum') {
        html = '<div class="w2ui-field-helper w2ui-list" style="' + margin + '; box-sizing: border-box">' + '    <div style="padding: 0px; margin: 0px; margin-right: 20px; display: inline-block">' + '    <ul>' + '        <li style="padding-left: 0px; padding-right: 0px" class="nomouse">' + '            <input type="text" style="width: 20px" autocomplete="off" ' + ($(obj.el).attr('readonly') ? 'readonly' : '') + '>' + '        </li>' + '    </ul>' + '    </div>' + '</div>';
      }
      if (obj.type == 'file') {
        html = '<div class="w2ui-field-helper w2ui-list" style="' + margin + '; box-sizing: border-box">' + '    <div style="padding: 0px; margin: 0px; margin-right: 20px; display: inline-block">' + '    <ul><li style="padding-left: 0px; padding-right: 0px" class="nomouse"></li></ul>' + '    <input class="file-input" type="file" name="attachment" multiple style="display: none" tabindex="-1">' + '    </div>' + '</div>';
      }
      $(obj.el).before(html).css({
        'background-color': 'transparent',
        'border-color': 'transparent'
      });
      var div = $(obj.el).prev();
      obj.helpers.multi = div;
      if (obj.type == 'enum') {
        $(obj.el).attr('tabindex', -1);
        // INPUT events
        div.find('input').on('click', function (event) {
          if ($('#w2ui-overlay').length == 0) obj.focus(event);
          $(obj.el).triggerHandler('click');
        }).on('focus', function (event) {
          $(div).css({
            'outline': 'auto 5px #7DB4F3',
            'outline-offset': '-2px'
          });
          $(obj.el).triggerHandler('focus');
          if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
        }).on('blur', function (event) {
          $(div).css('outline', 'none');
          $(obj.el).triggerHandler('blur');
          if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
        }).on('keyup', function (event) {
          obj.keyUp(event);
        }).on('keydown', function (event) {
          obj.keyDown(event);
        }).on('keypress', function (event) {
          div.find('.w2ui-enum-placeholder').remove();
          obj.keyPress(event);
        });
        // MAIN div
        div.on('click', function (event) {
          $(this).find('input').focus();
        });
      }
      if (obj.type == 'file') {
        $(obj.el).css('outline', 'none');
        div.on('click', function (event) {
          $(obj.el).focus();
          if ($(obj.el).attr('readonly')) return;
          obj.blur(event);
          div.find('input').click();
        }).on('dragenter', function (event) {
          if ($(obj.el).attr('readonly')) return;
          $(div).addClass('w2ui-file-dragover');
        }).on('dragleave', function (event) {
          if ($(obj.el).attr('readonly')) return;
          var tmp = $(event.target).parents('.w2ui-field-helper');
          if (tmp.length == 0) $(div).removeClass('w2ui-file-dragover');
        }).on('drop', function (event) {
          if ($(obj.el).attr('readonly')) return;
          $(div).removeClass('w2ui-file-dragover');
          var files = event.originalEvent.dataTransfer.files;
          for (var i = 0, l = files.length; i < l; i++) obj.addFile.call(obj, files[i]);
          // cancel to stop browser behaviour
          event.preventDefault();
          event.stopPropagation();
        }).on('dragover', function (event) {
          // cancel to stop browser behaviour
          event.preventDefault();
          event.stopPropagation();
        });
        div.find('input').on('click', function (event) {
          event.stopPropagation();
        }).on('change', function () {
          if (typeof this.files !== "undefined") {
            for (var i = 0, l = this.files.length; i < l; i++) {
              obj.addFile.call(obj, this.files[i]);
            }
          }
        });
      }
      obj.refresh();
    },
    addFile: function addFile(file) {
      var obj = this;
      var options = this.options;
      var selected = $(obj.el).data('selected');
      var newItem = {
        name: file.name,
        type: file.type,
        modified: file.lastModifiedDate,
        size: file.size,
        content: null
      };
      var size = 0;
      var cnt = 0;
      var err;
      for (var s in selected) {
        // check for dups
        if (selected[s].name == file.name && selected[s].size == file.size) return;
        size += selected[s].size;
        cnt++;
      }
      // trigger event
      var eventData = obj.trigger({
        phase: 'before',
        type: 'add',
        target: obj.el,
        file: newItem,
        total: cnt,
        totalSize: size
      });
      if (eventData.isCancelled === true) return;
      // check params
      if (options.maxFileSize !== 0 && newItem.size > options.maxFileSize) {
        err = 'Maximum file size is ' + w2utils.size(options.maxFileSize);
        if (options.silent === false) $(obj.el).w2tag(err);
        console.log('ERROR: ' + err);
        return;
      }
      if (options.maxSize !== 0 && size + newItem.size > options.maxSize) {
        err = 'Maximum total size is ' + w2utils.size(options.maxSize);
        if (options.silent === false) $(obj.el).w2tag(err);
        console.log('ERROR: ' + err);
        return;
      }
      if (options.max !== 0 && cnt >= options.max) {
        err = 'Maximum number of files is ' + options.max;
        if (options.silent === false) $(obj.el).w2tag(err);
        console.log('ERROR: ' + err);
        return;
      }
      selected.push(newItem);
      // read file as base64
      if (typeof FileReader !== "undefined") {
        var reader = new FileReader();
        // need a closure
        reader.onload = function () {
          return function (event) {
            var fl = event.target.result;
            var ind = fl.indexOf(',');
            newItem.content = fl.substr(ind + 1);
            obj.refresh();
            $(obj.el).trigger('change');
            // event after
            obj.trigger($.extend(eventData, {
              phase: 'after'
            }));
          };
        }();
        reader.readAsDataURL(file);
      } else {
        obj.refresh();
        $(obj.el).trigger('change');
      }
    },
    normMenu: function normMenu(menu) {
      if ($.isArray(menu)) {
        for (var m = 0; m < menu.length; m++) {
          if (typeof menu[m] == 'string') {
            menu[m] = {
              id: menu[m],
              text: menu[m]
            };
          } else {
            if (typeof menu[m].text != 'undefined' && typeof menu[m].id == 'undefined') menu[m].id = menu[m].text;
            if (typeof menu[m].text == 'undefined' && typeof menu[m].id != 'undefined') menu[m].text = menu[m].id;
            if (typeof menu[m].caption != 'undefined') menu[m].text = menu[m].caption;
          }
        }
        return menu;
      } else if (_typeof(menu) == 'object') {
        var tmp = [];
        for (var m in menu) tmp.push({
          id: m,
          text: menu[m]
        });
        return tmp;
      }
    },
    getColorHTML: function getColorHTML() {
      var html = '<div class="w2ui-color">' + '<table cellspacing="5">';
      for (var i = 0; i < 8; i++) {
        html += '<tr>';
        for (var j = 0; j < 8; j++) {
          html += '<td>' + '    <div class="color" style="background-color: #' + this.pallete[i][j] + ';" name="' + this.pallete[i][j] + '" index="' + i + ':' + j + '">' + '        ' + ($(this.el).val() == this.pallete[i][j] ? '&#149;' : '&nbsp;') + '    </div>' + '</td>';
        }
        html += '</tr>';
        if (i < 2) html += '<tr><td style="height: 8px" colspan="8"></td></tr>';
      }
      html += '</table></div>';
      return html;
    },
    getMonthHTML: function getMonthHTML(month, year) {
      var td = new Date();
      var months = w2utils.settings.fullmonths;
      var days = w2utils.settings.fulldays;
      var daysCount = ['31', '28', '31', '30', '31', '30', '31', '31', '30', '31', '30', '31'];
      var today = td.getFullYear() + '/' + (Number(td.getMonth()) + 1) + '/' + td.getDate();
      // normalize date
      year = w2utils.isInt(year) ? parseInt(year) : td.getFullYear();
      month = w2utils.isInt(month) ? parseInt(month) : td.getMonth() + 1;
      if (month > 12) {
        month -= 12;
        year++;
      }
      if (month < 1 || month === 0) {
        month += 12;
        year--;
      }
      if (year / 4 == Math.floor(year / 4)) {
        daysCount[1] = '29';
      } else {
        daysCount[1] = '28';
      }
      this.options.current = month + '/' + year;

      // start with the required date
      td = new Date(year, month - 1, 1);
      var weekDay = td.getDay();
      var tabDays = w2utils.settings.shortdays;
      var dayTitle = '';
      for (var i = 0, len = tabDays.length; i < len; i++) {
        dayTitle += '<td>' + tabDays[i] + '</td>';
      }
      var html = '<div class="w2ui-calendar-title title">' + '    <div class="w2ui-calendar-previous previous"> <div></div> </div>' + '    <div class="w2ui-calendar-next next"> <div></div> </div> ' + months[month - 1] + ', ' + year + '</div>' + '<table class="w2ui-calendar-days" cellspacing="0">' + '    <tr class="w2ui-day-title">' + dayTitle + '</tr>' + '    <tr>';
      var day = 1;
      for (var ci = 1; ci < 43; ci++) {
        if (weekDay === 0 && ci == 1) {
          for (var ti = 0; ti < 6; ti++) html += '<td class="w2ui-day-empty">&nbsp;</td>';
          ci += 6;
        } else {
          if (ci < weekDay || day > daysCount[month - 1]) {
            html += '<td class="w2ui-day-empty">&nbsp;</td>';
            if (ci % 7 === 0) html += '</tr><tr>';
            continue;
          }
        }
        var dt = year + '/' + month + '/' + day;
        var className = '';
        if (ci % 7 == 6) className = ' w2ui-saturday';
        if (ci % 7 === 0) className = ' w2ui-sunday';
        if (dt == today) className += ' w2ui-today';
        var dspDay = day;
        var col = '';
        var bgcol = '';
        var tmp_dt = w2utils.formatDate(dt, this.options.format);
        if (this.options.colored && this.options.colored[tmp_dt] !== undefined) {
          // if there is predefined colors for dates
          tmp = this.options.colored[tmp_dt].split(':');
          bgcol = 'background-color: ' + tmp[0] + ';';
          col = 'color: ' + tmp[1] + ';';
        }
        html += '<td class="' + (this.inRange(tmp_dt) ? 'w2ui-date ' : 'w2ui-blocked') + className + '" style="' + col + bgcol + '" date="' + tmp_dt + '">' + dspDay + '</td>';
        if (ci % 7 === 0 || weekDay === 0 && ci == 1) html += '</tr><tr>';
        day++;
      }
      html += '</tr></table>';
      return html;
    },
    getYearHTML: function getYearHTML() {
      var months = w2utils.settings.shortmonths;
      var mhtml = '';
      var yhtml = '';
      for (var m in months) {
        mhtml += '<div class="w2ui-jump-month" name="' + m + '">' + months[m] + '</div>';
      }
      for (var y = 1950; y <= 2020; y++) {
        yhtml += '<div class="w2ui-jump-year" name="' + y + '">' + y + '</div>';
      }
      return '<div>' + mhtml + '</div><div>' + yhtml + '</div>';
    },
    getHourHTML: function getHourHTML() {
      var tmp = [];
      var h24 = this.options.format == 'h24' ? true : false;
      for (var a = 0; a < 24; a++) {
        var time = (a >= 12 && !h24 ? a - 12 : a) + ':00' + (!h24 ? a < 12 ? ' am' : ' pm' : '');
        if (a == 12 && !h24) time = '12:00 pm';
        if (!tmp[Math.floor(a / 8)]) tmp[Math.floor(a / 8)] = '';
        var tm1 = this.fromMin(this.toMin(time));
        var tm2 = this.fromMin(this.toMin(time) + 59);
        tmp[Math.floor(a / 8)] += '<div class="' + (this.inRange(tm1) || this.inRange(tm2) ? 'w2ui-time ' : 'w2ui-blocked') + '" hour="' + a + '">' + time + '</div>';
      }
      var html = '<div class="w2ui-calendar-time"><table><tr>' + '    <td>' + tmp[0] + '</td>' + '    <td>' + tmp[1] + '</td>' + '    <td>' + tmp[2] + '</td>' + '</tr></table></div>';
      return html;
    },
    getMinHTML: function getMinHTML(hour) {
      if (typeof hour == 'undefined') hour = 0;
      var h24 = this.options.format == 'h24' ? true : false;
      var tmp = [];
      for (var a = 0; a < 60; a += 5) {
        var time = (hour > 12 && !h24 ? hour - 12 : hour) + ':' + (a < 10 ? 0 : '') + a + ' ' + (!h24 ? hour < 12 ? 'am' : 'pm' : '');
        var ind = a < 20 ? 0 : a < 40 ? 1 : 2;
        if (!tmp[ind]) tmp[ind] = '';
        tmp[ind] += '<div class="' + (this.inRange(time) ? 'w2ui-time ' : 'w2ui-blocked') + '" min="' + a + '">' + time + '</div>';
      }
      var html = '<div class="w2ui-calendar-time"><table><tr>' + '    <td>' + tmp[0] + '</td>' + '    <td>' + tmp[1] + '</td>' + '    <td>' + tmp[2] + '</td>' + '</tr></table></div>';
      return html;
    },
    toMin: function toMin(str) {
      if (typeof str != 'string') return null;
      var tmp = str.split(':');
      if (tmp.length == 2) {
        tmp[0] = parseInt(tmp[0]);
        tmp[1] = parseInt(tmp[1]);
        if (str.indexOf('pm') != -1 && tmp[0] != 12) tmp[0] += 12;
      } else {
        return null;
      }
      return tmp[0] * 60 + tmp[1];
    },
    fromMin: function fromMin(time) {
      var ret = '';
      if (time >= 24 * 60) time = time % (24 * 60);
      if (time < 0) time = 24 * 60 + time;
      var hour = Math.floor(time / 60);
      var min = (time % 60 < 10 ? '0' : '') + time % 60;
      if (this.options.format.indexOf('h24') != -1) {
        ret = hour + ':' + min;
      } else {
        ret = (hour <= 12 ? hour : hour - 12) + ':' + min + ' ' + (hour >= 12 ? 'pm' : 'am');
      }
      return ret;
    }
  };
  $.extend(w2field.prototype, w2utils.event);
  w2obj.field = w2field;
})(jQuery);

/************************************************************************
*   Library: Web 2.0 UI for jQuery (using prototypical inheritance)
*   - Following objects defined
*        - w2form      - form widget
*        - $().w2form  - jQuery wrapper
*   - Dependencies: jQuery, w2utils, w2fields, w2tabs, w2toolbar, w2alert
*
* == NICE TO HAVE ==
*   - refresh(field) - would refresh only one field
*   - include delta on save
*   - create an example how to do cascadic dropdown
*   - form should read <select> <options> into items
*   - two way data bindings
*   - verify validation of fields
*   - when field is blank, set record.field = null
*   - show/hide a field
*   - added getChanges() - not complete
*
************************************************************************/

(function () {
  var w2form = function w2form(options) {
    // public properties
    this.name = null;
    this.header = '';
    this.box = null; // HTML element that hold this element
    this.url = '';
    this.routeData = {}; // data for dynamic routes
    this.formURL = ''; // url where to get form HTML
    this.formHTML = ''; // form HTML (might be loaded from the url)
    this.page = 0; // current page
    this.recid = 0; // can be null or 0
    this.fields = [];
    this.actions = {};
    this.record = {};
    this.original = {};
    this.postData = {};
    this.toolbar = {}; // if not empty, then it is toolbar
    this.tabs = {}; // if not empty, then it is tabs object

    this.style = '';
    this.focus = 0; // focus first or other element
    this.msgNotJSON = w2utils.lang('Return data is not in JSON format.');
    this.msgAJAXerror = w2utils.lang('AJAX error. See console for more details.');
    this.msgRefresh = w2utils.lang('Refreshing...');
    this.msgSaving = w2utils.lang('Saving...');

    // events
    this.onRequest = null;
    this.onLoad = null;
    this.onValidate = null;
    this.onSubmit = null;
    this.onSave = null;
    this.onChange = null;
    this.onRender = null;
    this.onRefresh = null;
    this.onResize = null;
    this.onDestroy = null;
    this.onAction = null;
    this.onToolbar = null;
    this.onError = null;

    // internal
    this.isGenerated = false;
    this.last = {
      xhr: null // jquery xhr requests
    };
    $.extend(true, this, w2obj.form, options);
  };

  // ====================================================
  // -- Registers as a jQuery plugin

  $.fn.w2form = function (method) {
    if (_typeof(method) === 'object' || !method) {
      var obj = this;
      // check name parameter
      if (!w2utils.checkName(method, 'w2form')) return;
      // remember items
      var record = method.record;
      var original = method.original;
      var fields = method.fields;
      var toolbar = method.toolbar;
      var tabs = method.tabs;
      // extend items
      var object = new w2form(method);
      $.extend(object, {
        record: {},
        original: {},
        fields: [],
        tabs: {},
        toolbar: {},
        handlers: []
      });
      if ($.isArray(tabs)) {
        $.extend(true, object.tabs, {
          tabs: []
        });
        for (var t in tabs) {
          var tmp = tabs[t];
          if (_typeof(tmp) === 'object') object.tabs.tabs.push(tmp);else object.tabs.tabs.push({
            id: tmp,
            caption: tmp
          });
        }
      } else {
        $.extend(true, object.tabs, tabs);
      }
      $.extend(true, object.toolbar, toolbar);
      // reassign variables
      for (var p in fields) {
        var field = $.extend(true, {}, fields[p]);
        if (typeof field.name == 'undefined' && typeof field.field != 'undefined') field.name = field.field;
        if (typeof field.field == 'undefined' && typeof field.name != 'undefined') field.field = field.name;
        object.fields[p] = field;
      }
      for (var p in record) {
        if ($.isPlainObject(record[p])) {
          object.record[p] = $.extend(true, {}, record[p]);
        } else {
          object.record[p] = record[p];
        }
      }
      for (var p in original) {
        if ($.isPlainObject(original[p])) {
          object.original[p] = $.extend(true, {}, original[p]);
        } else {
          object.original[p] = original[p];
        }
      }
      if (obj.length > 0) object.box = obj[0];
      // render if necessary
      if (object.formURL != '') {
        $.get(object.formURL, function (data) {
          // should always be $.get as it is template
          object.formHTML = data;
          object.isGenerated = true;
          if ($(object.box).length != 0 || data.length != 0) {
            $(object.box).html(data);
            object.render(object.box);
          }
        });
      } else if (object.formHTML != '') {
        // it is already loaded into formHTML
      } else if ($(this).length != 0 && $.trim($(this).html()) != '') {
        object.formHTML = $(this).html();
      } else {
        // try to generate it
        object.formHTML = object.generateHTML();
      }
      // register new object
      w2ui[object.name] = object;
      // render if not loaded from url
      if (object.formURL == '') {
        if (String(object.formHTML).indexOf('w2ui-page') == -1) {
          object.formHTML = '<div class="w2ui-page page-0">' + object.formHTML + '</div>';
        }
        $(object.box).html(object.formHTML);
        object.isGenerated = true;
        object.render(object.box);
      }
      return object;
    } else if (w2ui[$(this).attr('name')]) {
      var obj = w2ui[$(this).attr('name')];
      obj[method].apply(obj, Array.prototype.slice.call(arguments, 1));
      return this;
    } else {
      console.log('ERROR: Method ' + method + ' does not exist on jQuery.w2form');
    }
  };

  // ====================================================
  // -- Implementation of core functionality

  w2form.prototype = {
    get: function get(field, returnIndex) {
      if (arguments.length === 0) {
        var all = [];
        for (var f1 in this.fields) {
          if (this.fields[f1].name != null) all.push(this.fields[f1].name);
        }
        return all;
      } else {
        for (var f2 in this.fields) {
          if (this.fields[f2].name == field) {
            if (returnIndex === true) return f2;else return this.fields[f2];
          }
        }
        return null;
      }
    },
    set: function set(field, obj) {
      for (var f in this.fields) {
        if (this.fields[f].name == field) {
          $.extend(this.fields[f], obj);
          this.refresh();
          return true;
        }
      }
      return false;
    },
    reload: function reload(callBack) {
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url && this.recid != 0) {
        // this.clear();
        this.request(callBack);
      } else {
        // this.refresh(); // no need to refresh
        if (typeof callBack == 'function') callBack();
      }
    },
    clear: function clear() {
      this.recid = 0;
      this.record = {};
      $().w2tag();
      this.refresh();
    },
    error: function error(msg) {
      var obj = this;
      // let the management of the error outside of the grid
      var eventData = this.trigger({
        target: this.name,
        type: 'error',
        message: msg,
        xhr: this.last.xhr
      });
      if (eventData.isCancelled === true) {
        if (typeof callBack == 'function') callBack();
        return;
      }
      // need a time out because message might be already up)
      setTimeout(function () {
        w2alert(msg, 'Error');
      }, 1);
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    validate: function validate(showErrors) {
      if (typeof showErrors == 'undefined') showErrors = true;
      $().w2tag(); // hide all tags before validating
      // validate before saving
      var errors = [];
      for (var f in this.fields) {
        var field = this.fields[f];
        if (this.record[field.name] == null) this.record[field.name] = '';
        switch (field.type) {
          case 'int':
            if (this.record[field.name] && !w2utils.isInt(this.record[field.name])) {
              errors.push({
                field: field,
                error: w2utils.lang('Not an integer')
              });
            }
            break;
          case 'float':
            if (this.record[field.name] && !w2utils.isFloat(this.record[field.name])) {
              errors.push({
                field: field,
                error: w2utils.lang('Not a float')
              });
            }
            break;
          case 'money':
            if (this.record[field.name] && !w2utils.isMoney(this.record[field.name])) {
              errors.push({
                field: field,
                error: w2utils.lang('Not in money format')
              });
            }
            break;
          case 'color':
          case 'hex':
            if (this.record[field.name] && !w2utils.isHex(this.record[field.name])) {
              errors.push({
                field: field,
                error: w2utils.lang('Not a hex number')
              });
            }
            break;
          case 'email':
            if (this.record[field.name] && !w2utils.isEmail(this.record[field.name])) {
              errors.push({
                field: field,
                error: w2utils.lang('Not a valid email')
              });
            }
            break;
          case 'checkbox':
            // convert true/false
            if (this.record[field.name] == true) this.record[field.name] = 1;else this.record[field.name] = 0;
            break;
          case 'date':
            // format date before submit
            if (!field.options.format) field.options.format = w2utils.settings.date_format;
            if (this.record[field.name] && !w2utils.isDate(this.record[field.name], field.options.format)) {
              errors.push({
                field: field,
                error: w2utils.lang('Not a valid date') + ': ' + field.options.format
              });
            } else {}
            break;
          case 'list':
          case 'combo':
            break;
          case 'enum':
            break;
        }
        // === check required - if field is '0' it should be considered not empty
        var val = this.record[field.name];
        if (field.required && (val === '' || $.isArray(val) && val.length == 0 || $.isPlainObject(val) && $.isEmptyObject(val))) {
          errors.push({
            field: field,
            error: w2utils.lang('Required field')
          });
        }
        if (field.equalto && this.record[field.name] != this.record[field.equalto]) {
          errors.push({
            field: field,
            error: w2utils.lang('Field should be equal to ') + field.equalto
          });
        }
      }
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'validate',
        errors: errors
      });
      if (eventData.isCancelled === true) return;
      // show error
      if (showErrors) for (var e in eventData.errors) {
        var err = eventData.errors[e];
        if (err.field.type == 'radio') {
          // for radio and checkboxes
          $($(err.field.el).parents('div')[0]).w2tag(err.error, {
            "class": 'w2ui-error'
          });
        } else if (['enum', 'file'].indexOf(err.field.type) != -1) {
          (function (err) {
            setTimeout(function () {
              var fld = $(err.field.el).data('w2field').helpers.multi;
              $(err.field.el).w2tag(err.error);
              $(fld).addClass('w2ui-error');
            }, 1);
          })(err);
        } else {
          $(err.field.el).w2tag(err.error, {
            "class": 'w2ui-error'
          });
        }
        this["goto"](errors[0].field.page);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      return errors;
    },
    getChanges: function getChanges() {
      var differ = function differ(record, original, result) {
        for (var i in record) {
          if (_typeof(record[i]) == "object") {
            result[i] = differ(record[i], original[i] || {}, {});
            if (!result[i] || $.isEmptyObject(result[i])) delete result[i];
          } else if (record[i] != original[i]) {
            result[i] = record[i];
          }
        }
        return result;
      };
      return differ(this.record, this.original, {});
    },
    request: function request(postData, callBack) {
      // if (1) param then it is call back if (2) then postData and callBack
      var obj = this;
      // check for multiple params
      if (typeof postData == 'function') {
        callBack = postData;
        postData = null;
      }
      if (typeof postData == 'undefined' || postData == null) postData = {};
      if (!this.url || _typeof(this.url) == 'object' && !this.url.get) return;
      if (this.recid == null || typeof this.recid == 'undefined') this.recid = 0;
      // build parameters list
      var params = {};
      // add list params
      params['cmd'] = 'get-record';
      params['recid'] = this.recid;
      // append other params
      $.extend(params, this.postData);
      $.extend(params, postData);
      // event before
      var eventData = this.trigger({
        phase: 'before',
        type: 'request',
        target: this.name,
        url: this.url,
        postData: params
      });
      if (eventData.isCancelled === true) {
        if (typeof callBack == 'function') callBack({
          status: 'error',
          message: 'Request aborted.'
        });
        return;
      }
      // default action
      this.record = {};
      this.original = {};
      // call server to get data
      this.lock(this.msgRefresh);
      var url = eventData.url;
      if (_typeof(eventData.url) == 'object' && eventData.url.get) url = eventData.url.get;
      if (this.last.xhr) try {
        this.last.xhr.abort();
      } catch (e) {}
      ;
      // process url with routeData
      if (!$.isEmptyObject(obj.routeData)) {
        var info = w2utils.parseRoute(url);
        if (info.keys.length > 0) {
          for (var k = 0; k < info.keys.length; k++) {
            if (obj.routeData[info.keys[k].name] == null) continue;
            url = url.replace(new RegExp(':' + info.keys[k].name, 'g'), obj.routeData[info.keys[k].name]);
          }
        }
      }
      var ajaxOptions = {
        type: 'POST',
        url: url,
        data: eventData.postData,
        dataType: 'text' // expected from server
      };
      if (w2utils.settings.dataType == 'HTTP') {
        ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
      }
      if (w2utils.settings.dataType == 'RESTFULL') {
        ajaxOptions.type = 'GET';
        ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
      }
      if (w2utils.settings.dataType == 'JSON') {
        ajaxOptions.type = 'POST';
        ajaxOptions.data = JSON.stringify(ajaxOptions.data);
        ajaxOptions.contentType = 'application/json';
      }
      this.last.xhr = $.ajax(ajaxOptions).done(function (data, status, xhr) {
        obj.unlock();
        // event before
        var eventData = obj.trigger({
          phase: 'before',
          target: obj.name,
          type: 'load',
          xhr: xhr
        });
        if (eventData.isCancelled === true) {
          if (typeof callBack == 'function') callBack({
            status: 'error',
            message: 'Request aborted.'
          });
          return;
        }
        // parse server response
        var data;
        var responseText = obj.last.xhr.responseText;
        if (status != 'error') {
          // default action
          if (typeof responseText != 'undefined' && responseText != '') {
            // check if the onLoad handler has not already parsed the data
            if (_typeof(responseText) == "object") {
              data = responseText;
            } else {
              // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
              //
              // TODO: avoid (potentially malicious) code injection from the response.
              try {
                eval('data = ' + responseText);
              } catch (e) {}
            }
            if (typeof data == 'undefined') {
              data = {
                status: 'error',
                message: obj.msgNotJSON,
                responseText: responseText
              };
            }
            if (data['status'] == 'error') {
              obj.error(data['message']);
            } else {
              obj.record = $.extend({}, data.record);
              obj.original = $.extend({}, data.record);
            }
          }
        } else {
          obj.error('AJAX Error ' + xhr.status + ': ' + xhr.statusText);
          data = {
            status: 'error',
            message: obj.msgAJAXerror,
            responseText: responseText
          };
        }
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
        obj.refresh();
        // call back
        if (typeof callBack == 'function') callBack(data);
      }).fail(function (xhr, status, error) {
        // trigger event
        var errorObj = {
          status: status,
          error: error,
          rawResponseText: xhr.responseText
        };
        var eventData2 = obj.trigger({
          phase: 'before',
          type: 'error',
          error: errorObj,
          xhr: xhr
        });
        if (eventData2.isCancelled === true) return;
        // default behavior
        if (status != 'abort') {
          var data;
          try {
            data = $.parseJSON(xhr.responseText);
          } catch (e) {}
          console.log('ERROR: Server communication failed.', '\n   EXPECTED:', {
            status: 'success',
            items: [{
              id: 1,
              text: 'item'
            }]
          }, '\n         OR:', {
            status: 'error',
            message: 'error message'
          }, '\n   RECEIVED:', _typeof(data) == 'object' ? data : xhr.responseText);
        }
        // event after
        obj.trigger($.extend(eventData2, {
          phase: 'after'
        }));
      });
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    submit: function submit(postData, callBack) {
      return this.save(postData, callBack);
    },
    save: function save(postData, callBack) {
      var obj = this;
      $(this.box).find(':focus').change(); // trigger onchange
      // check for multiple params
      if (typeof postData == 'function') {
        callBack = postData;
        postData = null;
      }
      // validation
      var errors = obj.validate(true);
      if (errors.length !== 0) return;
      // submit save
      if (typeof postData == 'undefined' || postData == null) postData = {};
      if (!obj.url || _typeof(obj.url) == 'object' && !obj.url.save) {
        console.log("ERROR: Form cannot be saved because no url is defined.");
        return;
      }
      obj.lock(obj.msgSaving + ' <span id="' + obj.name + '_progress"></span>');
      // need timer to allow to lock
      setTimeout(function () {
        // build parameters list
        var params = {};
        // add list params
        params['cmd'] = 'save-record';
        params['recid'] = obj.recid;
        // append other params
        $.extend(params, obj.postData);
        $.extend(params, postData);
        params.record = $.extend(true, {}, obj.record);
        // event before
        var eventData = obj.trigger({
          phase: 'before',
          type: 'submit',
          target: obj.name,
          url: obj.url,
          postData: params
        });
        if (eventData.isCancelled === true) return;
        // default action
        var url = eventData.url;
        if (_typeof(eventData.url) == 'object' && eventData.url.save) url = eventData.url.save;
        if (obj.last.xhr) try {
          obj.last.xhr.abort();
        } catch (e) {}
        ;
        // process url with routeData
        if (!$.isEmptyObject(obj.routeData)) {
          var info = w2utils.parseRoute(url);
          if (info.keys.length > 0) {
            for (var k = 0; k < info.keys.length; k++) {
              if (obj.routeData[info.keys[k].name] == null) continue;
              url = url.replace(new RegExp(':' + info.keys[k].name, 'g'), obj.routeData[info.keys[k].name]);
            }
          }
        }
        var ajaxOptions = {
          type: 'POST',
          url: url,
          data: eventData.postData,
          dataType: 'text',
          // expected from server
          xhr: function xhr() {
            var xhr = new window.XMLHttpRequest();
            // upload
            xhr.upload.addEventListener("progress", function (evt) {
              if (evt.lengthComputable) {
                var percent = Math.round(evt.loaded / evt.total * 100);
                $('#' + obj.name + '_progress').text('' + percent + '%');
              }
            }, false);
            return xhr;
          }
        };
        if (w2utils.settings.dataType == 'HTTP') {
          ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
        }
        if (w2utils.settings.dataType == 'RESTFULL') {
          if (obj.recid != 0) ajaxOptions.type = 'PUT';
          ajaxOptions.data = String($.param(ajaxOptions.data, false)).replace(/%5B/g, '[').replace(/%5D/g, ']');
        }
        if (w2utils.settings.dataType == 'JSON') {
          ajaxOptions.type = 'POST';
          ajaxOptions.data = JSON.stringify(ajaxOptions.data);
          ajaxOptions.contentType = 'application/json';
        }
        obj.last.xhr = $.ajax(ajaxOptions).done(function (data, status, xhr) {
          obj.unlock();
          // event before
          var eventData = obj.trigger({
            phase: 'before',
            target: obj.name,
            type: 'save',
            xhr: xhr,
            status: status
          });
          if (eventData.isCancelled === true) return;
          // parse server response
          var data;
          var responseText = xhr.responseText;
          if (status != 'error') {
            // default action
            if (typeof responseText != 'undefined' && responseText != '') {
              // check if the onLoad handler has not already parsed the data
              if (_typeof(responseText) == "object") {
                data = responseText;
              } else {
                // $.parseJSON or $.getJSON did not work because those expect perfect JSON data - where everything is in double quotes
                //
                // TODO: avoid (potentially malicious) code injection from the response.
                try {
                  eval('data = ' + responseText);
                } catch (e) {}
              }
              if (typeof data == 'undefined') {
                data = {
                  status: 'error',
                  message: obj.msgNotJSON,
                  responseText: responseText
                };
              }
              if (data['status'] == 'error') {
                obj.error(data['message']);
              } else {
                obj.original = $.extend({}, obj.record);
              }
            }
          } else {
            obj.error('AJAX Error ' + xhr.status + ': ' + xhr.statusText);
            data = {
              status: 'error',
              message: obj.msgAJAXerror,
              responseText: responseText
            };
          }
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
          obj.refresh();
          // call back
          if (data.status == 'success' && typeof callBack == 'function') callBack(data);
        }).fail(function (xhr, status, error) {
          // trigger event
          var errorObj = {
            status: status,
            error: error,
            rawResponseText: xhr.responseText
          };
          var eventData2 = obj.trigger({
            phase: 'before',
            type: 'error',
            error: errorObj,
            xhr: xhr
          });
          if (eventData2.isCancelled === true) return;
          // default behavior
          console.log('ERROR: server communication failed. The server should return', {
            status: 'success'
          }, 'OR', {
            status: 'error',
            message: 'error message'
          }, ', instead the AJAX request produced this: ', errorObj);
          // event after
          obj.trigger($.extend(eventData2, {
            phase: 'after'
          }));
        });
        // event after
        obj.trigger($.extend(eventData, {
          phase: 'after'
        }));
      }, 50);
    },
    lock: function lock(msg, showSpinner) {
      var box = $(this.box).find('> div:first-child');
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift(box);
      w2utils.lock.apply(window, args);
    },
    unlock: function unlock() {
      var obj = this;
      setTimeout(function () {
        w2utils.unlock(obj.box);
      }, 25); // needed timer so if server fast, it will not flash
    },
    "goto": function goto(page) {
      if (typeof page != 'undefined') this.page = page;
      // if it was auto size, resize it
      if ($(this.box).data('auto-size') === true) $(this.box).height(0);
      this.refresh();
    },
    generateHTML: function generateHTML() {
      var pages = []; // array for each page
      var group = '';
      var page;
      for (var f in this.fields) {
        var html = '';
        var field = this.fields[f];
        if (typeof field.html == 'undefined') field.html = {};
        field.html = $.extend(true, {
          caption: '',
          span: 6,
          attr: '',
          text: '',
          page: 0
        }, field.html);
        if (typeof page == 'undefined') page = field.html.page;
        if (field.html.caption == '') field.html.caption = field.name;
        var input = '<input name="' + field.name + '" type="text" ' + field.html.attr + '/>';
        if (field.type === 'pass' || field.type === 'password') {
          input = '<input name="' + field.name + '" type = "password" ' + field.html.attr + '/>';
        }
        if (field.type == 'checkbox') input = '<input name="' + field.name + '" type="checkbox" ' + field.html.attr + '/>';
        if (field.type == 'textarea') input = '<textarea name="' + field.name + '" ' + field.html.attr + '></textarea>';
        if (field.type == 'toggle') input = '<input name="' + field.name + '" type="checkbox" ' + field.html.attr + ' class="w2ui-toggle"/><div><div></div></div>';
        if (field.html.group) {
          if (group != '') html += '\n   </div>';
          html += '\n   <div class="w2ui-group-title">' + field.html.group + '</div>\n   <div class="w2ui-group">';
          group = field.html.group;
        }
        if (field.html.page != page && group != '') {
          pages[pages.length - 1] += '\n   </div>';
          group = '';
        }
        html += '\n      <div class="w2ui-field ' + (typeof field.html.span != 'undefined' ? 'w2ui-span' + field.html.span : '') + '">' + '\n         <label>' + w2utils.lang(field.html.caption) + '</label>' + '\n         <div>' + input + w2utils.lang(field.html.text) + '</div>' + '\n      </div>';
        if (typeof pages[field.html.page] == 'undefined') pages[field.html.page] = '';
        pages[field.html.page] += html;
        page = field.html.page;
      }
      if (group != '') pages[pages.length - 1] += '\n   </div>';
      if (this.tabs.tabs) {
        for (var i = 0; i < this.tabs.tabs.length; i++) if (typeof pages[i] == 'undefined') pages[i] = '';
      }
      for (var p in pages) pages[p] = '<div class="w2ui-page page-' + p + '">' + pages[p] + '\n</div>';
      // buttons if any
      var buttons = '';
      if (!$.isEmptyObject(this.actions)) {
        var addClass = '';
        buttons += '\n<div class="w2ui-buttons">';
        for (var a in this.actions) {
          if (['save', 'update', 'create'].indexOf(a.toLowerCase()) != -1) addClass = 'w2ui-btn-green';else addClass = '';
          buttons += '\n    <button name="' + a + '" class="w2ui-btn ' + addClass + '">' + w2utils.lang(a) + '</button>';
        }
        buttons += '\n</div>';
      }
      return pages.join('') + buttons;
    },
    action: function action(_action, event) {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: _action,
        type: 'action',
        originalEvent: event
      });
      if (eventData.isCancelled === true) return;
      // default actions
      if (typeof this.actions[_action] == 'function') {
        this.actions[_action].call(this, event);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
    },
    resize: function resize() {
      var obj = this;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'resize'
      });
      if (eventData.isCancelled === true) return;
      // default behaviour
      var main = $(this.box).find('> div');
      var header = $(this.box).find('> div .w2ui-form-header');
      var toolbar = $(this.box).find('> div .w2ui-form-toolbar');
      var tabs = $(this.box).find('> div .w2ui-form-tabs');
      var page = $(this.box).find('> div .w2ui-page');
      var cpage = $(this.box).find('> div .w2ui-page.page-' + this.page);
      var dpage = $(this.box).find('> div .w2ui-page.page-' + this.page + ' > div');
      var buttons = $(this.box).find('> div .w2ui-buttons');
      // if no height, calculate it
      resizeElements();
      if (parseInt($(this.box).height()) == 0 || $(this.box).data('auto-size') === true) {
        $(this.box).height((header.length > 0 ? w2utils.getSize(header, 'height') : 0) + (_typeof(this.tabs) === 'object' && $.isArray(this.tabs.tabs) && this.tabs.tabs.length > 0 ? w2utils.getSize(tabs, 'height') : 0) + (_typeof(this.toolbar) == 'object' && $.isArray(this.toolbar.items) && this.toolbar.items.length > 0 ? w2utils.getSize(toolbar, 'height') : 0) + (page.length > 0 ? w2utils.getSize(dpage, 'height') + w2utils.getSize(cpage, '+height') + 12 : 0) + (
        // why 12 ???
        buttons.length > 0 ? w2utils.getSize(buttons, 'height') : 0));
        $(this.box).data('auto-size', true);
      }
      resizeElements();
      // event after
      obj.trigger($.extend(eventData, {
        phase: 'after'
      }));
      function resizeElements() {
        // resize elements
        main.width($(obj.box).width()).height($(obj.box).height());
        toolbar.css('top', obj.header != '' ? w2utils.getSize(header, 'height') : 0);
        tabs.css('top', (obj.header != '' ? w2utils.getSize(header, 'height') : 0) + (_typeof(obj.toolbar) == 'object' && $.isArray(obj.toolbar.items) && obj.toolbar.items.length > 0 ? w2utils.getSize(toolbar, 'height') : 0));
        page.css('top', (obj.header != '' ? w2utils.getSize(header, 'height') : 0) + (_typeof(obj.toolbar) == 'object' && $.isArray(obj.toolbar.items) && obj.toolbar.items.length > 0 ? w2utils.getSize(toolbar, 'height') + 5 : 0) + (_typeof(obj.tabs) === 'object' && $.isArray(obj.tabs.tabs) && obj.tabs.tabs.length > 0 ? w2utils.getSize(tabs, 'height') + 5 : 0));
        page.css('bottom', buttons.length > 0 ? w2utils.getSize(buttons, 'height') : 0);
      }
    },
    refresh: function refresh() {
      var time = new Date().getTime();
      var obj = this;
      if (!this.box) return;
      if (!this.isGenerated || typeof $(this.box).html() == 'undefined') return;
      // update what page field belongs
      $(this.box).find('input, textarea, select').each(function (index, el) {
        var name = typeof $(el).attr('name') != 'undefined' ? $(el).attr('name') : $(el).attr('id');
        var field = obj.get(name);
        if (field) {
          // find page
          var div = $(el).parents('.w2ui-page');
          if (div.length > 0) {
            for (var i = 0; i < 100; i++) {
              if (div.hasClass('page-' + i)) {
                field.page = i;
                break;
              }
            }
          }
        }
      });
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'refresh',
        page: this.page
      });
      if (eventData.isCancelled === true) return;
      // default action
      $(this.box).find('.w2ui-page').hide();
      $(this.box).find('.w2ui-page.page-' + this.page).show();
      $(this.box).find('.w2ui-form-header').html(this.header);
      // refresh tabs if needed
      if (_typeof(this.tabs) === 'object' && $.isArray(this.tabs.tabs) && this.tabs.tabs.length > 0) {
        $('#form_' + this.name + '_tabs').show();
        this.tabs.active = this.tabs.tabs[this.page].id;
        this.tabs.refresh();
      } else {
        $('#form_' + this.name + '_tabs').hide();
      }
      // refresh tabs if needed
      if (_typeof(this.toolbar) == 'object' && $.isArray(this.toolbar.items) && this.toolbar.items.length > 0) {
        $('#form_' + this.name + '_toolbar').show();
        this.toolbar.refresh();
      } else {
        $('#form_' + this.name + '_toolbar').hide();
      }
      // refresh values of all fields
      for (var f in this.fields) {
        var field = this.fields[f];
        if (typeof field.name == 'undefined' && typeof field.field != 'undefined') field.name = field.field;
        if (typeof field.field == 'undefined' && typeof field.name != 'undefined') field.field = field.name;
        field.$el = $(this.box).find('[name="' + String(field.name).replace(/\\/g, '\\\\') + '"]');
        field.el = field.$el[0];
        if (typeof field.el == 'undefined') {
          console.log('ERROR: Cannot associate field "' + field.name + '" with html control. Make sure html control exists with the same name.');
          //return;
        }
        if (field.el) field.el.id = field.name;
        var tmp = $(field).data('w2field');
        if (tmp) tmp.clear();
        $(field.$el).off('change').on('change', function () {
          var value_new = this.value;
          var value_previous = obj.record[this.name] ? obj.record[this.name] : '';
          var field = obj.get(this.name);
          if (['list', 'enum', 'file'].indexOf(field.type) != -1 && $(this).data('selected')) {
            var nv = $(this).data('selected');
            var cv = obj.record[this.name];
            if ($.isArray(nv)) {
              value_new = [];
              for (var i in nv) value_new[i] = $.extend(true, {}, nv[i]); // clone array
            }
            if ($.isPlainObject(nv)) {
              value_new = $.extend(true, {}, nv); // clone object
            }
            if ($.isArray(cv)) {
              value_previous = [];
              for (var i in cv) value_previous[i] = $.extend(true, {}, cv[i]); // clone array
            }
            if ($.isPlainObject(cv)) {
              value_previous = $.extend(true, {}, cv); // clone object
            }
          }
          if (['toggle', 'checkbox'].indexOf(field.type) != -1) {
            value_new = $(this).prop('checked') ? true : false;
          }
          // clean extra chars
          if (['int', 'float', 'percent', 'money', 'currency'].indexOf(field.type) != -1) {
            value_new = $(this).data('w2field').clean(value_new);
          }
          if (value_new === value_previous) return;
          // event before
          var eventData = obj.trigger({
            phase: 'before',
            target: this.name,
            type: 'change',
            value_new: value_new,
            value_previous: value_previous
          });
          if (eventData.isCancelled === true) {
            $(this).val(obj.record[this.name]); // return previous value
            return;
          }
          // default action
          var val = this.value;
          if (this.type == 'select') val = this.value;
          if (this.type == 'checkbox') val = this.checked ? true : false;
          if (this.type == 'radio') {
            field.$el.each(function (index, el) {
              if (el.checked) val = el.value;
            });
          }
          if (['int', 'float', 'percent', 'money', 'currency', 'list', 'combo', 'enum', 'file', 'toggle'].indexOf(field.type) != -1) {
            val = value_new;
          }
          if (['enum', 'file'].indexOf(field.type) != -1) {
            if (val.length > 0) {
              var fld = $(field.el).data('w2field').helpers.multi;
              $(fld).removeClass('w2ui-error');
            }
          }
          obj.record[this.name] = val;
          // event after
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        });
        if (field.required) {
          $(field.el).parent().parent().addClass('w2ui-required');
        } else {
          $(field.el).parent().parent().removeClass('w2ui-required');
        }
      }
      // attach actions on buttons
      $(this.box).find('button, input[type=button]').each(function (index, el) {
        $(el).off('click').on('click', function (event) {
          var action = this.value;
          if (this.id) action = this.id;
          if (this.name) action = this.name;
          obj.action(action, event);
        });
      });
      // init controls with record
      for (var f in this.fields) {
        var field = this.fields[f];
        var value = typeof this.record[field.name] != 'undefined' ? this.record[field.name] : '';
        if (!field.el) continue;
        field.type = String(field.type).toLowerCase();
        if (!field.options) field.options = {};
        switch (field.type) {
          case 'text':
          case 'textarea':
          case 'email':
          case 'pass':
          case 'password':
            field.el.value = value;
            break;
          case 'int':
          case 'float':
          case 'money':
          case 'currency':
          case 'percent':
          case 'hex':
          case 'alphanumeric':
          case 'color':
          case 'date':
          case 'time':
            field.el.value = value;
            $(field.el).w2field($.extend({}, field.options, {
              type: field.type
            }));
            break;
          case 'toggle':
            if (w2utils.isFloat(value)) value = parseFloat(value);
            $(field.el).prop('checked', value ? true : false);
            this.record[field.name] = value ? 1 : 0;
            break;
          // enums
          case 'list':
          case 'combo':
            if (field.type == 'list') {
              var tmp_value = $.isPlainObject(value) ? value.id : value;
              // normalized options
              var items = field.options.items;
              if ($.isArray(items) && items.length > 0 && !$.isPlainObject(items[0])) {
                field.options.items = w2obj.field.prototype.normMenu(items);
              }
              // find value from items
              for (var i in field.options.items) {
                var item = field.options.items[i];
                if (item.id == tmp_value) {
                  value = $.extend(true, {}, item);
                  obj.record[field.name] = value;
                  break;
                }
              }
            } else if (field.type == 'combo' && !$.isPlainObject(value)) {
              field.el.value = value;
            } else if ($.isPlainObject(value) && typeof value.text != 'undefined') {
              field.el.value = value.text;
            } else {
              field.el.value = '';
            }
            if (!$.isPlainObject(value)) value = {};
            $(field.el).w2field($.extend({}, field.options, {
              type: field.type,
              selected: value
            }));
            break;
          case 'enum':
          case 'file':
            if (!$.isArray(value)) value = [];
            $(field.el).w2field($.extend({}, field.options, {
              type: field.type,
              selected: value
            }));
            break;

          // standard HTML
          case 'select':
            // generate options
            var items = field.options.items;
            if (typeof items != 'undefined' && items.length > 0) {
              items = w2obj.field.prototype.normMenu(items);
              $(field.el).html('');
              for (var it in items) {
                $(field.el).append('<option value="' + items[it].id + '">' + items[it].text + '</option');
              }
            }
            $(field.el).val(value);
            break;
          case 'radio':
            $(field.$el).prop('checked', false).each(function (index, el) {
              if ($(el).val() == value) $(el).prop('checked', true);
            });
            break;
          case 'checkbox':
            $(field.el).prop('checked', value ? true : false);
            break;
          default:
            $(field.el).w2field($.extend({}, field.options, {
              type: field.type
            }));
            break;
        }
      }
      // wrap pages in div
      var tmp = $(this.box).find('.w2ui-page');
      for (var i = 0; i < tmp.length; i++) {
        if ($(tmp[i]).find('> *').length > 1) $(tmp[i]).wrapInner('<div></div>');
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      this.resize();
      return new Date().getTime() - time;
    },
    render: function render(box) {
      var time = new Date().getTime();
      var obj = this;
      if (_typeof(box) == 'object') {
        // remove from previous box
        if ($(this.box).find('#form_' + this.name + '_tabs').length > 0) {
          $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-form').html('');
        }
        this.box = box;
      }
      if (!this.isGenerated) return;
      if (!this.box) return;
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'render',
        box: typeof box != 'undefined' ? box : this.box
      });
      if (eventData.isCancelled === true) return;
      // default actions
      if ($.isEmptyObject(this.original) && !$.isEmptyObject(this.record)) {
        this.original = $.extend(true, {}, this.record);
      }
      var html = '<div>' + (this.header != '' ? '<div class="w2ui-form-header">' + this.header + '</div>' : '') + '    <div id="form_' + this.name + '_toolbar" class="w2ui-form-toolbar"></div>' + '    <div id="form_' + this.name + '_tabs" class="w2ui-form-tabs"></div>' + this.formHTML + '</div>';
      $(this.box).attr('name', this.name).addClass('w2ui-reset w2ui-form').html(html);
      if ($(this.box).length > 0) $(this.box)[0].style.cssText += this.style;

      // init toolbar regardless it is defined or not
      if (typeof this.toolbar.render !== 'function') {
        this.toolbar = $().w2toolbar($.extend({}, this.toolbar, {
          name: this.name + '_toolbar',
          owner: this
        }));
        this.toolbar.on('click', function (event) {
          var eventData = obj.trigger({
            phase: 'before',
            type: 'toolbar',
            target: event.target,
            originalEvent: event
          });
          if (eventData.isCancelled === true) return;
          // no default action
          obj.trigger($.extend(eventData, {
            phase: 'after'
          }));
        });
      }
      if (_typeof(this.toolbar) == 'object' && typeof this.toolbar.render == 'function') {
        this.toolbar.render($('#form_' + this.name + '_toolbar')[0]);
      }
      // init tabs regardless it is defined or not
      if (typeof this.tabs.render !== 'function') {
        this.tabs = $().w2tabs($.extend({}, this.tabs, {
          name: this.name + '_tabs',
          owner: this
        }));
        this.tabs.on('click', function (event) {
          obj["goto"](this.get(event.target, true));
        });
      }
      if (_typeof(this.tabs) == 'object' && typeof this.tabs.render == 'function') {
        this.tabs.render($('#form_' + this.name + '_tabs')[0]);
      }
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      // after render actions
      this.resize();
      var url = _typeof(this.url) != 'object' ? this.url : this.url.get;
      if (url && this.recid != 0) {
        this.request();
      } else {
        this.refresh();
      }
      // attach to resize event
      if ($('.w2ui-layout').length == 0) {
        // if there is layout, it will send a resize event
        this.tmp_resize = function (event) {
          w2ui[obj.name].resize();
        };
        $(window).off('resize', 'body').on('resize', 'body', this.tmp_resize);
      }
      setTimeout(function () {
        obj.resize();
        obj.refresh();
      }, 150); // need timer because resize is on timer
      // focus on load
      function focusEl() {
        var inputs = $(obj.box).find('input, select, textarea');
        if (inputs.length > obj.focus) inputs[obj.focus].focus();
      }
      if (this.focus >= 0) setTimeout(focusEl, 500); // need timeout to allow form to render
      return new Date().getTime() - time;
    },
    destroy: function destroy() {
      // event before
      var eventData = this.trigger({
        phase: 'before',
        target: this.name,
        type: 'destroy'
      });
      if (eventData.isCancelled === true) return;
      // clean up
      if (_typeof(this.toolbar) == 'object' && this.toolbar.destroy) this.toolbar.destroy();
      if (_typeof(this.tabs) == 'object' && this.tabs.destroy) this.tabs.destroy();
      if ($(this.box).find('#form_' + this.name + '_tabs').length > 0) {
        $(this.box).removeAttr('name').removeClass('w2ui-reset w2ui-form').html('');
      }
      delete w2ui[this.name];
      // event after
      this.trigger($.extend(eventData, {
        phase: 'after'
      }));
      $(window).off('resize', 'body');
    }
  };
  $.extend(w2form.prototype, w2utils.event);
  w2obj.form = w2form;
})();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/src/jquery.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var g;

// This works in non-strict mode
g = function () {
  return this;
}();
try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};
    module.paths = [];
    // module.parent = undefined by default
    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }
  return module;
};

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var window = __webpack_require__(/*! global/window */ "./node_modules/global/window.js");
var once = __webpack_require__(/*! once */ "./node_modules/xhr/node_modules/once/once.js");
var parseHeaders = __webpack_require__(/*! parse-headers */ "./node_modules/parse-headers/parse-headers.js");
var messages = {
  "0": "Internal XMLHttpRequest Error",
  "4": "4xx Client Error",
  "5": "5xx Server Error"
};
var XHR = window.XMLHttpRequest || noop;
var XDR = "withCredentials" in new XHR() ? XHR : window.XDomainRequest;
module.exports = createXHR;
function createXHR(options, callback) {
  if (typeof options === "string") {
    options = {
      uri: options
    };
  }
  options = options || {};
  callback = once(callback);
  var xhr = options.xhr || null;
  if (!xhr) {
    if (options.cors || options.useXDR) {
      xhr = new XDR();
    } else {
      xhr = new XHR();
    }
  }
  var uri = xhr.url = options.uri || options.url;
  var method = xhr.method = options.method || "GET";
  var body = options.body || options.data;
  var headers = xhr.headers = options.headers || {};
  var sync = !!options.sync;
  var isJson = false;
  var key;
  var load = options.response ? loadResponse : loadXhr;
  if ("json" in options) {
    isJson = true;
    headers["Accept"] = "application/json";
    if (method !== "GET" && method !== "HEAD") {
      headers["Content-Type"] = "application/json";
      body = JSON.stringify(options.json);
    }
  }
  xhr.onreadystatechange = readystatechange;
  xhr.onload = load;
  xhr.onerror = error;
  // IE9 must have onprogress be set to a unique function.
  xhr.onprogress = function () {
    // IE must die
  };
  // hate IE
  xhr.ontimeout = noop;
  xhr.open(method, uri, !sync);
  //backward compatibility
  if (options.withCredentials || options.cors && options.withCredentials !== false) {
    xhr.withCredentials = true;
  }

  // Cannot set timeout with sync request
  if (!sync) {
    xhr.timeout = "timeout" in options ? options.timeout : 5000;
  }
  if (xhr.setRequestHeader) {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (options.headers) {
    throw new Error("Headers cannot be set on an XDomainRequest object");
  }
  if ("responseType" in options) {
    xhr.responseType = options.responseType;
  }
  if ("beforeSend" in options && typeof options.beforeSend === "function") {
    options.beforeSend(xhr);
  }
  xhr.send(body);
  return xhr;
  function readystatechange() {
    if (xhr.readyState === 4) {
      load();
    }
  }
  function getBody() {
    // Chrome with requestType=blob throws errors arround when even testing access to responseText
    var body = null;
    if (xhr.response) {
      body = xhr.response;
    } else if (xhr.responseType === 'text' || !xhr.responseType) {
      body = xhr.responseText || xhr.responseXML;
    }
    if (isJson) {
      try {
        body = JSON.parse(body);
      } catch (e) {}
    }
    return body;
  }
  function getStatusCode() {
    return xhr.status === 1223 ? 204 : xhr.status;
  }

  // if we're getting a none-ok statusCode, build & return an error
  function errorFromStatusCode(status, body) {
    var error = null;
    if (status === 0 || status >= 400 && status < 600) {
      var message = (typeof body === "string" ? body : false) || messages[String(status).charAt(0)];
      error = new Error(message);
      error.statusCode = status;
    }
    return error;
  }

  // will load the data & process the response in a special response object
  function loadResponse() {
    var status = getStatusCode();
    var body = getBody();
    var error = errorFromStatusCode(status, body);
    var response = {
      body: body,
      statusCode: status,
      statusText: xhr.statusText,
      raw: xhr
    };
    if (xhr.getAllResponseHeaders) {
      //remember xhr can in fact be XDR for CORS in IE
      response.headers = parseHeaders(xhr.getAllResponseHeaders());
    } else {
      response.headers = {};
    }
    callback(error, response, response.body);
  }

  // will load the data and add some response properties to the source xhr
  // and then respond with that
  function loadXhr() {
    var status = getStatusCode();
    var error = errorFromStatusCode(status);
    xhr.status = xhr.statusCode = status;
    xhr.body = getBody();
    xhr.headers = parseHeaders(xhr.getAllResponseHeaders());
    callback(error, xhr, xhr.body);
  }
  function error(evt) {
    callback(evt, xhr);
  }
}
function noop() {}

/***/ }),

/***/ "./node_modules/xhr/node_modules/once/once.js":
/*!****************************************************!*\
  !*** ./node_modules/xhr/node_modules/once/once.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = once;
once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function value() {
      return once(this);
    },
    configurable: true
  });
});
function once(fn) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    return fn.apply(this, arguments);
  };
}

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}

/***/ })

/******/ });
//# sourceMappingURL=application-95ca484a9d266310e628.js.map